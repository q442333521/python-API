This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.repomixignore
01-safe_base_test.py
01-start-home.bat
com_port.txt
example_client.py
headless_commander_fixed.py
headless_commander_patched.py
headless_commander.py
headless_commander.py.backup_1757427986
headless_commander.py.backup_wN_1757428702
LICENSE
linux_serial_patch.py
parol6_controller.py
parol6_ik_fix.py
PAROL6_ROBOT.py
PAROL6_ROBOT.py.backup_1757427986
python quick_fix.py
README_FIXED.md
README.md
replace_ikine_LMS.py
repomix.config.json
robot_api.py
run_headless_complete_fix.py
run_headless_fixed.py
run_headless_linux.py
run_minimal.py
run_parol6_fixed.py
run_patched.py
safe_home_client.py
smooth_motion.py
smooth_motion.py.backup_1757427986
smooth_motion.py.backup_wN_1757428702
start_parol6.sh
STATUS_REPORT.md
test_basic.py
test_script.py
test_serial.py
test_smooth_motion.py
test/æµ‹è¯•å‘ç°çš„é—®é¢˜æ€»ç»“
test/å¯ç”¨apiæµ‹è¯•.py
test/ä½ è¿åŠ¨å­¦æ±‚è§£å™¨æµ‹è¯•.py
test/ä¸€é”®ç§»åŠ¨åˆ°å®‰å…¨ä½ç½®.py
test/all-test.py
test/base01.py
test/base02.py
test/emergency_stop_cli.py
test/requirements.txt
test/testik.py
test/wnå¿«é€Ÿä¿®å¤è„šæœ¬.py
```

# Files

## File: .repomixignore
````
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
````

## File: 01-start-home.bat
````
call "C:\Users\q4423\miniconda3\Scripts\activate.bat" parol
python D:\Onedrive\p\09-PAROL6-python-API\headless_commander.py
````

## File: repomix.config.json
````json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "api.md",
    "style": "markdown",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
````

## File: test/æµ‹è¯•å‘ç°çš„é—®é¢˜æ€»ç»“
````
é€šè¿‡è¿™ä¸€ç³»åˆ—çš„æµ‹è¯•ï¼Œæˆ‘ä»¬å‘ç°äº†é—®é¢˜å¹¶è¿›è¡Œäº†ä¿®å¤ã€‚è®©æˆ‘æ€»ç»“ä¸€ä¸‹ï¼š

## ğŸ“Š **æµ‹è¯•å‘ç°çš„é—®é¢˜æ€»ç»“**

### âœ… **å·²ç¡®è®¤å¯ç”¨çš„API**
```python
# çŠ¶æ€æŸ¥è¯¢API - 100%å¯ç”¨
- get_robot_joint_angles()      # è·å–å…³èŠ‚è§’åº¦
- get_robot_pose()              # è·å–ä½å§¿
- get_robot_joint_speeds()      # è·å–å…³èŠ‚é€Ÿåº¦
- get_robot_status()            # è·å–ç»¼åˆçŠ¶æ€
- is_robot_stopped()            # æ£€æŸ¥åœæ­¢çŠ¶æ€

# å…³èŠ‚æ§åˆ¶API - 100%å¯ç”¨  
- home_robot()                  # æœºå™¨äººå½’é›¶
- jog_robot_joint()            # å•å…³èŠ‚ç‚¹åŠ¨
- jog_multiple_joints()        # å¤šå…³èŠ‚ç‚¹åŠ¨

# å¤¹å…·æ§åˆ¶API - éƒ¨åˆ†å¯ç”¨
- control_pneumatic_gripper()   # æ°”åŠ¨å¤¹å…·æ§åˆ¶
- control_electric_gripper()    # ç”µåŠ¨å¤¹å…·ï¼ˆéœ€æ›´é•¿ç­‰å¾…æ—¶é—´ï¼‰

# ç³»ç»Ÿæ§åˆ¶API - éƒ¨åˆ†å¯ç”¨
- stop_robot_movement()         # åœæ­¢è¿åŠ¨
- delay_robot()                # å»¶è¿Ÿå‘½ä»¤
```

### âŒ **å‘ç°çš„ä¸»è¦é—®é¢˜**

#### 1. **é€†è¿åŠ¨å­¦æ±‚è§£å™¨é—®é¢˜** 
```bash
# åŸå§‹é”™è¯¯
'DHRobot' object has no attribute 'ikine_LMS'

# ç¬¬ä¸€æ¬¡ä¿®å¤ï¼šikine_LMS -> ikine_LM
# æ–°é”™è¯¯  
IKMixin.ikine_LM() got an unexpected keyword argument 'wN'
```

#### 2. **å®‰å…¨ä½ç½®é—®é¢˜**
```bash
# æœºå™¨äººä½ç½®ä¸åœ¨å®‰å…¨å·¥ä½œç©ºé—´
âš ï¸ å½“å‰ä½ç½®å¯èƒ½ä¸å®‰å…¨ï¼Œè¯·æ‰‹åŠ¨ç§»åŠ¨åˆ°å®‰å…¨ä½ç½®
```

#### 3. **å‚æ•°è¶…é™é—®é¢˜**
```bash
# å…³èŠ‚è§’åº¦è¶…å‡ºé™åˆ¶
VALIDATION FAILED: Target for Joint 3 (90.0 deg) is out of range
```

## ğŸ”§ **å·²å®Œæˆçš„ä¿®æ”¹**

### 1. **æ–‡ä»¶æ›¿æ¢ä¿®æ”¹**
```python
# åœ¨ä»¥ä¸‹æ–‡ä»¶ä¸­è¿›è¡Œæ›¿æ¢ï¼š
- headless_commander.py
- PAROL6_ROBOT.py  
- smooth_motion.py

# æ›¿æ¢å†…å®¹ï¼š
ikine_LMS -> ikine_LM
```

### 2. **åˆ›å»ºçš„å·¥å…·ç¨‹åº**
```python
- api_test_fixed.py           # APIåŠŸèƒ½æµ‹è¯•ç¨‹åº
- safe_position_mover.py      # å®‰å…¨ä½ç½®ç§»åŠ¨ç¨‹åº  
- quick_safe_move.py          # å¿«é€Ÿå®‰å…¨ç§»åŠ¨
- fix_ikine_parameters.py     # å‚æ•°ä¿®å¤ç¨‹åº
- quick_fix_wN.py            # å¿«é€Ÿå‚æ•°ä¿®å¤
```

## ğŸ¯ **éœ€è¦è¿›è¡Œçš„ä¿®æ”¹**

### 1. **ç«‹å³éœ€è¦ä¿®å¤**

#### A. ä¿®å¤ `wN` å‚æ•°é—®é¢˜
```python
# åœ¨æ‰€æœ‰æ–‡ä»¶ä¸­æ‰¾åˆ°å¹¶ä¿®å¤ï¼š
# é”™è¯¯ç”¨æ³•ï¼š
sol = robot.ikine_LM(T, q0=q0, wN=None)
sol = robot.ikine_LM(T, q0=q0, wN=np.eye(6))

# æ­£ç¡®ç”¨æ³•ï¼š
sol = robot.ikine_LM(T, q0=q0)
sol = robot.ikine_LM(T, q0=q0, ilimit=100, slimit=100)
```

#### B. ç§»åŠ¨åˆ°å®‰å…¨ä½ç½®
```python
# ä½¿ç”¨æˆ‘ä»¬åˆ›å»ºçš„ç¨‹åºï¼š
python safe_position_mover.py
# æˆ–
python quick_safe_move.py
```

### 2. **éœ€è¦ç³»ç»Ÿæ€§ä¿®æ”¹çš„æ–‡ä»¶**

#### A. `headless_commander.py`
```python
# éœ€è¦ä¿®æ”¹çš„å†…å®¹ï¼š
1. åˆ é™¤æ‰€æœ‰ ikine_LM è°ƒç”¨ä¸­çš„ wN å‚æ•°
2. å¯èƒ½éœ€è¦è°ƒæ•´ IK æ±‚è§£çš„è¶…æ—¶å’Œå®¹å·®å‚æ•°
3. æ£€æŸ¥å…³èŠ‚é™åˆ¶éªŒè¯é€»è¾‘
```

#### B. `smooth_motion.py`
```python
# éœ€è¦ä¿®æ”¹çš„å†…å®¹ï¼š
1. ä¿®å¤æ‰€æœ‰å¹³æ»‘è¿åŠ¨å‡½æ•°ä¸­çš„ ikine_LM è°ƒç”¨
2. åˆ é™¤ wN å‚æ•°
3. å¯èƒ½éœ€è¦è°ƒæ•´è½¨è¿¹ç”Ÿæˆçš„å‚æ•°
4. ä¿®å¤é™¤é›¶é”™è¯¯ï¼ˆRuntimeWarning: invalid value encountered in divideï¼‰
```

#### C. `PAROL6_ROBOT.py`
```python
# éœ€è¦ä¿®æ”¹çš„å†…å®¹ï¼š
1. æ£€æŸ¥æœºå™¨äººè¿åŠ¨å­¦æ¨¡å‹å®šä¹‰
2. ç¡®ä¿å…³èŠ‚é™åˆ¶æ­£ç¡®è®¾ç½®
3. ä¿®å¤ä»»ä½• ikine_LM å‚æ•°é—®é¢˜
```

### 3. **å»ºè®®çš„æ”¹è¿›**

#### A. å‚æ•°é…ç½®æ–‡ä»¶
```python
# åˆ›å»º config.py
JOINT_LIMITS = {
    0: (-170, 170),   # Base
    1: (-135, 0),     # Shoulder  
    2: (0, 180),      # Elbow
    3: (-180, 180),   # Wrist1
    4: (-120, 120),   # Wrist2  
    5: (-360, 360),   # Wrist3
}

SAFE_POSITIONS = {
    "home": [0, -90, 180, 0, 0, 180],
    "center": [0, -60, 150, 0, 30, 180],
}

IK_PARAMETERS = {
    "ilimit": 100,     # æœ€å¤§è¿­ä»£æ¬¡æ•°
    "slimit": 100,     # æœç´¢é™åˆ¶
    "tol": 1e-6,       # æ”¶æ•›å®¹å·®
}
```

#### B. é”™è¯¯å¤„ç†æ”¹è¿›
```python
# åœ¨æ‰€æœ‰ ikine_LM è°ƒç”¨å‘¨å›´æ·»åŠ ï¼š
try:
    sol = robot.ikine_LM(T, q0=q0, **IK_PARAMETERS)
    if not sol.success:
        print(f"IK failed: {sol.reason}")
        return None
except Exception as e:
    print(f"IK error: {e}")
    return None
```

## ğŸ“‹ **å®Œæ•´ä¿®å¤è®¡åˆ’**

### æ­¥éª¤1ï¼šå‚æ•°ä¿®å¤ï¼ˆç«‹å³æ‰§è¡Œï¼‰
```bash
python fix_ikine_parameters.py  # æˆ– python quick_fix_wN.py
```

### æ­¥éª¤2ï¼šç§»åŠ¨åˆ°å®‰å…¨ä½ç½®
```bash  
python safe_position_mover.py
```

### æ­¥éª¤3ï¼šé‡å¯æœåŠ¡å™¨
```bash
python headless_commander.py
```

### æ­¥éª¤4ï¼šéªŒè¯ä¿®å¤æ•ˆæœ
```bash
python safe_api_test.py
```

### æ­¥éª¤5ï¼šå¦‚æœä»æœ‰é—®é¢˜ï¼Œæ‰‹åŠ¨æ£€æŸ¥
```python
# æ£€æŸ¥è¿™äº›æ–‡ä»¶ä¸­çš„æ‰€æœ‰ ikine_LM è°ƒç”¨ï¼š
grep -n "ikine_LM" headless_commander.py
grep -n "ikine_LM" smooth_motion.py  
grep -n "ikine_LM" PAROL6_ROBOT.py

# ç¡®ä¿å‚æ•°æ ¼å¼æ­£ç¡®ï¼š
robot.ikine_LM(T, q0=q0)                    # âœ… æ­£ç¡®
robot.ikine_LM(T, q0=q0, ilimit=100)       # âœ… æ­£ç¡®
robot.ikine_LM(T, q0=q0, wN=None)          # âŒ é”™è¯¯
```

## ğŸ¯ **é¢„æœŸç»“æœ**

å®Œæˆæ‰€æœ‰ä¿®å¤åï¼Œåº”è¯¥çœ‹åˆ°ï¼š
```
âœ… move_robot_pose: æˆåŠŸ
âœ… move_robot_cartesian: æˆåŠŸ
âœ… jog_cartesian: æˆåŠŸ  
âœ… smooth_circle: æˆåŠŸ
âœ… smooth_arc_center: æˆåŠŸ
âœ… smooth_spline: æˆåŠŸ
âœ… smooth_helix: æˆåŠŸ

ğŸ“Š æˆåŠŸç‡: 90%+
```

**å…³é”®æ˜¯å…ˆä¿®å¤ `wN` å‚æ•°é—®é¢˜ï¼Œè¿™æ˜¯å½“å‰é˜»æ­¢æ‰€æœ‰ä½å§¿ç›¸å…³APIå·¥ä½œçš„æ ¹æœ¬åŸå› ï¼**
````

## File: test/å¯ç”¨apiæµ‹è¯•.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 API ä¿®å¤ç‰ˆæµ‹è¯•ç¨‹åº
æ ¹æ®å®é™…é”™è¯¯åˆ†æä¿®å¤çš„ç‰ˆæœ¬
"""
import sys
import os

# è·å–å½“å‰æ–‡ä»¶çš„ç»å¯¹è·¯å¾„
current_dir = os.path.dirname(os.path.abspath(__file__))

# è·å–çˆ¶ç›®å½•è·¯å¾„
parent_dir = os.path.dirname(current_dir)

# å°†çˆ¶ç›®å½•æ·»åŠ åˆ°æ¨¡å—æœç´¢è·¯å¾„ä¸­
sys.path.append(parent_dir)

# ç°åœ¨å¯ä»¥å¯¼å…¥çˆ¶ç›®å½•ä¸­çš„æ¨¡å—
from robot_api import *
import time

import time
import traceback
from robot_api import *

class PAROL6FixedTester:
    def __init__(self):
        """åˆå§‹åŒ–ä¿®å¤ç‰ˆæµ‹è¯•å™¨"""
        self.test_results = {}
        self.test_count = 0
        self.passed_count = 0
        self.failed_count = 0
        self.skipped_count = 0
        
        # åŠ¨æ€è·å–å½“å‰ä½ç½®ä½œä¸ºå®‰å…¨åŸºå‡†
        self.current_pose = None
        self.current_joints = None
        self.safe_joint_limits = {
            0: (-170, 170),   # Base: Â±170Â°
            1: (-135, 0),     # Shoulder: -135Â° to 0Â°  
            2: (0, 180),      # Elbow: 0Â° to 180Â°
            3: (-180, 180),   # Wrist1: Â±180Â°
            4: (-120, 120),   # Wrist2: Â±120Â°
            5: (-360, 360),   # Wrist3: Â±360Â°
        }
        
        print("ğŸ”§ PAROL6 ä¿®å¤ç‰ˆAPIæµ‹è¯•å™¨")
        print("ğŸ“‹ ä¿®å¤å†…å®¹:")
        print("   âœ… ä½¿ç”¨å½“å‰ä½ç½®ä½œä¸ºå®‰å…¨åŸºå‡†")
        print("   âœ… é¿å…é€†è¿åŠ¨å­¦é—®é¢˜çš„API")
        print("   âœ… åˆç†çš„å…³èŠ‚è§’åº¦é™åˆ¶")
        print("   âœ… æ”¹è¿›è¶…æ—¶å¤„ç†")

    def initialize_safe_positions(self):
        """åˆå§‹åŒ–å®‰å…¨ä½ç½®"""
        try:
            self.current_pose = get_robot_pose()
            self.current_joints = get_robot_joint_angles()
            
            if self.current_pose:
                print(f"ğŸ“ å½“å‰ä½å§¿: {[round(p, 2) for p in self.current_pose]}")
            if self.current_joints:
                print(f"ğŸ”§ å½“å‰å…³èŠ‚: {[round(a, 2) for a in self.current_joints]}")
                
            return self.current_pose is not None and self.current_joints is not None
        except Exception as e:
            print(f"âŒ åˆå§‹åŒ–å¤±è´¥: {e}")
            return False

    def is_joint_angle_safe(self, joint_index, angle):
        """æ£€æŸ¥å…³èŠ‚è§’åº¦æ˜¯å¦å®‰å…¨"""
        if joint_index in self.safe_joint_limits:
            min_angle, max_angle = self.safe_joint_limits[joint_index]
            return min_angle <= angle <= max_angle
        return False

    def get_safe_joint_angles(self):
        """è·å–åŸºäºå½“å‰ä½ç½®çš„å®‰å…¨å…³èŠ‚è§’åº¦"""
        if not self.current_joints:
            return None
        
        safe_joints = self.current_joints.copy()
        
        # åªå¯¹åº•åº§åšå°å¹…è°ƒæ•´ï¼ˆæœ€å®‰å…¨ï¼‰
        if self.is_joint_angle_safe(0, safe_joints[0] + 10):
            safe_joints[0] += 10
        elif self.is_joint_angle_safe(0, safe_joints[0] - 10):
            safe_joints[0] -= 10
        
        return safe_joints

    def get_safe_pose_offset(self, offset_x=0, offset_y=0, offset_z=0):
        """è·å–åŸºäºå½“å‰ä½ç½®çš„å®‰å…¨ä½å§¿åç§»"""
        if not self.current_pose:
            return None
        
        safe_pose = self.current_pose.copy()
        safe_pose[0] += offset_x  # Xè½´åç§»
        safe_pose[1] += offset_y  # Yè½´åç§»  
        safe_pose[2] += offset_z  # Zè½´åç§»
        
        return safe_pose

    def log_test(self, test_name, result, details=""):
        """è®°å½•æµ‹è¯•ç»“æœ"""
        self.test_count += 1
        status = "âœ… é€šè¿‡" if result == "PASS" else "âŒ å¤±è´¥" if result == "FAIL" else "â­ï¸ è·³è¿‡"
        
        if result == "PASS":
            self.passed_count += 1
        elif result == "FAIL":
            self.failed_count += 1
        else:
            self.skipped_count += 1
            
        self.test_results[test_name] = {"status": result, "details": details}
        print(f"{status} {test_name}: {details}")

    def safe_execute(self, func, *args, **kwargs):
        """å®‰å…¨æ‰§è¡Œå‡½æ•°"""
        try:
            result = func(*args, **kwargs)
            return result, None
        except Exception as e:
            return None, str(e)

    def wait_for_command_complete(self, result, timeout=10.0):
        """ç­‰å¾…å‘½ä»¤å®Œæˆï¼ˆæ”¹è¿›ç‰ˆï¼‰"""
        if not result or not isinstance(result, dict):
            return False
            
        command_id = result.get('command_id')
        if not command_id:
            return result.get('status') == 'COMPLETED'
        
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                status = check_command_status(command_id)
                if status and status.get('completed'):
                    return status.get('status') == 'COMPLETED'
                time.sleep(0.2)
            except:
                pass
                
        return False

    # ================================
    # ä¿®å¤åçš„æµ‹è¯•å‡½æ•°
    # ================================
    
    def test_working_apis(self):
        """æµ‹è¯•ç¡®è®¤å¯ç”¨çš„API"""
        print("\n" + "="*50)
        print("âœ… æµ‹è¯•å·²éªŒè¯å¯ç”¨çš„API")
        print("="*50)
        
        # 1. çŠ¶æ€æŸ¥è¯¢API - å…¨éƒ¨å¯ç”¨
        apis_to_test = [
            ("get_robot_joint_angles", get_robot_joint_angles, []),
            ("get_robot_pose", get_robot_pose, []),
            ("get_robot_joint_speeds", get_robot_joint_speeds, []),
            ("get_electric_gripper_status", get_electric_gripper_status, []),
            ("get_robot_pose_matrix", get_robot_pose_matrix, []),
            ("is_robot_stopped", is_robot_stopped, []),
            ("get_robot_status", get_robot_status, []),
        ]
        
        for name, func, args in apis_to_test:
            result, error = self.safe_execute(func, *args)
            if result is not None:
                self.log_test(name, "PASS", f"ç»“æœç±»å‹: {type(result)}")
            else:
                self.log_test(name, "FAIL", f"é”™è¯¯: {error}")

    def test_joint_movement_apis(self):
        """æµ‹è¯•å…³èŠ‚ç§»åŠ¨APIï¼ˆä½¿ç”¨å®‰å…¨è§’åº¦ï¼‰"""
        print("\n" + "="*50)
        print("ğŸ”§ æµ‹è¯•å…³èŠ‚ç§»åŠ¨APIï¼ˆå®‰å…¨ç‰ˆï¼‰")
        print("="*50)
        
        # 1. å•å…³èŠ‚ç‚¹åŠ¨ï¼ˆå·²éªŒè¯å¯ç”¨ï¼‰
        if input("æµ‹è¯•å•å…³èŠ‚ç‚¹åŠ¨ï¼ˆåº•åº§Â±2Â°ï¼‰? (y/N): ").lower() == 'y':
            for direction, joint_idx in [("æ­£å‘", 0), ("åå‘", 6)]:
                result, error = self.safe_execute(
                    jog_robot_joint,
                    joint_index=joint_idx,
                    speed_percentage=10,
                    distance_deg=2.0,
                    wait_for_ack=True,
                    timeout=10.0
                )
                
                if result and self.wait_for_command_complete(result, 10):
                    self.log_test(f"jog_robot_joint_{direction}", "PASS", f"åº•åº§{direction}ç‚¹åŠ¨2Â°æˆåŠŸ")
                else:
                    self.log_test(f"jog_robot_joint_{direction}", "FAIL", f"å¤±è´¥: {error or result}")
                
                time.sleep(1)
        else:
            self.log_test("jog_robot_joint", "SKIP", "ç”¨æˆ·è·³è¿‡")
        
        # 2. å¤šå…³èŠ‚ç‚¹åŠ¨ï¼ˆå·²éªŒè¯å¯ç”¨ï¼‰
        if input("æµ‹è¯•å¤šå…³èŠ‚åŒæ—¶ç‚¹åŠ¨? (y/N): ").lower() == 'y':
            result, error = self.safe_execute(
                jog_multiple_joints,
                joints=[0, 1],  # åº•åº§å’Œè‚©éƒ¨
                speeds=[8, 8],  # é™ä½é€Ÿåº¦
                duration=1.5,   # å¢åŠ æ—¶é—´
                wait_for_ack=True,
                timeout=10.0
            )
            
            if result and self.wait_for_command_complete(result, 10):
                self.log_test("jog_multiple_joints", "PASS", "å¤šå…³èŠ‚ç‚¹åŠ¨æˆåŠŸ")
            else:
                self.log_test("jog_multiple_joints", "FAIL", f"å¤±è´¥: {error or result}")
            
            time.sleep(1)
        else:
            self.log_test("jog_multiple_joints", "SKIP", "ç”¨æˆ·è·³è¿‡")
        
        # 3. å®‰å…¨å…³èŠ‚ç§»åŠ¨ï¼ˆä¿®å¤è§’åº¦èŒƒå›´ï¼‰
        if input("æµ‹è¯•å®‰å…¨å…³èŠ‚ç§»åŠ¨? (y/N): ").lower() == 'y':
            safe_joints = self.get_safe_joint_angles()
            if safe_joints:
                print(f"ä½¿ç”¨å®‰å…¨å…³èŠ‚è§’åº¦: {[round(a, 2) for a in safe_joints]}")
                result, error = self.safe_execute(
                    move_robot_joints,
                    safe_joints,
                    speed_percentage=15,  # å¾ˆæ…¢çš„é€Ÿåº¦
                    wait_for_ack=True,
                    timeout=15.0
                )
                
                if result and self.wait_for_command_complete(result, 15):
                    self.log_test("move_robot_joints_safe", "PASS", "å®‰å…¨å…³èŠ‚ç§»åŠ¨æˆåŠŸ")
                else:
                    self.log_test("move_robot_joints_safe", "FAIL", f"å¤±è´¥: {error or result}")
            else:
                self.log_test("move_robot_joints_safe", "FAIL", "æ— æ³•ç¡®å®šå®‰å…¨è§’åº¦")
        else:
            self.log_test("move_robot_joints_safe", "SKIP", "ç”¨æˆ·è·³è¿‡")

    def test_gripper_apis_fixed(self):
        """æµ‹è¯•å¤¹å…·APIï¼ˆä¿®å¤è¶…æ—¶é—®é¢˜ï¼‰"""
        print("\n" + "="*50)
        print("ğŸ¤ æµ‹è¯•å¤¹å…·APIï¼ˆä¿®å¤ç‰ˆï¼‰")
        print("="*50)
        
        # 1. æ°”åŠ¨å¤¹å…·ï¼ˆå·²éªŒè¯å¯ç”¨ï¼‰
        if input("æµ‹è¯•æ°”åŠ¨å¤¹å…·? (y/N): ").lower() == 'y':
            for action in ['open', 'close']:
                result, error = self.safe_execute(
                    control_pneumatic_gripper,
                    action=action,
                    port=1,
                    wait_for_ack=True,
                    timeout=5.0
                )
                
                if result and self.wait_for_command_complete(result, 5):
                    self.log_test(f"pneumatic_gripper_{action}", "PASS", f"æ°”åŠ¨å¤¹å…·{action}æˆåŠŸ")
                else:
                    self.log_test(f"pneumatic_gripper_{action}", "FAIL", f"å¤±è´¥: {error or result}")
                
                time.sleep(1)
        else:
            self.log_test("pneumatic_gripper", "SKIP", "ç”¨æˆ·è·³è¿‡")
        
        # 2. ç”µåŠ¨å¤¹å…·ï¼ˆå¢åŠ ç­‰å¾…æ—¶é—´ï¼‰
        if input("æµ‹è¯•ç”µåŠ¨å¤¹å…·ï¼ˆéœ€è¦æ›´é•¿æ—¶é—´ï¼‰? (y/N): ").lower() == 'y':
            print("å¼€å§‹ç”µåŠ¨å¤¹å…·æ ¡å‡†ï¼ˆè¯·ç­‰å¾…...ï¼‰")
            result, error = self.safe_execute(
                control_electric_gripper,
                action='calibrate',
                wait_for_ack=True,
                timeout=30.0  # å¢åŠ åˆ°30ç§’
            )
            
            if result:
                # ç­‰å¾…æ ¡å‡†å®Œæˆ
                time.sleep(5)  # é¢å¤–ç­‰å¾…æ—¶é—´
                if self.wait_for_command_complete(result, 30):
                    self.log_test("electric_gripper_calibrate", "PASS", "ç”µåŠ¨å¤¹å…·æ ¡å‡†æˆåŠŸ")
                    
                    # æµ‹è¯•ç§»åŠ¨
                    print("æµ‹è¯•ç”µåŠ¨å¤¹å…·ç§»åŠ¨...")
                    result2, error2 = self.safe_execute(
                        control_electric_gripper,
                        action='move',
                        position=150,
                        speed=80,
                        wait_for_ack=True,
                        timeout=15.0
                    )
                    
                    if result2 and self.wait_for_command_complete(result2, 15):
                        self.log_test("electric_gripper_move", "PASS", "ç”µåŠ¨å¤¹å…·ç§»åŠ¨æˆåŠŸ")
                    else:
                        self.log_test("electric_gripper_move", "FAIL", f"ç§»åŠ¨å¤±è´¥: {error2 or result2}")
                else:
                    self.log_test("electric_gripper_calibrate", "FAIL", "æ ¡å‡†è¶…æ—¶")
            else:
                self.log_test("electric_gripper_calibrate", "FAIL", f"æ ¡å‡†å¤±è´¥: {error}")
        else:
            self.log_test("electric_gripper", "SKIP", "ç”¨æˆ·è·³è¿‡")

    def test_system_apis_fixed(self):
        """æµ‹è¯•ç³»ç»ŸAPIï¼ˆä¿®å¤ç‰ˆï¼‰"""
        print("\n" + "="*50)
        print("âš™ï¸ æµ‹è¯•ç³»ç»ŸAPIï¼ˆä¿®å¤ç‰ˆï¼‰")
        print("="*50)
        
        # 1. å»¶è¿Ÿå‘½ä»¤ï¼ˆä¿®å¤åˆ¤æ–­é€»è¾‘ï¼‰
        print("æµ‹è¯•å»¶è¿Ÿå‘½ä»¤ï¼ˆ3ç§’ï¼‰...")
        start_time = time.time()
        result, error = self.safe_execute(
            delay_robot, 
            duration=3.0, 
            wait_for_ack=True, 
            timeout=10.0
        )
        
        if result:
            # ç­‰å¾…å»¶è¿Ÿå®Œæˆ
            completed = self.wait_for_command_complete(result, 10)
            elapsed = time.time() - start_time
            
            if completed and 2.8 <= elapsed <= 3.5:
                self.log_test("delay_robot", "PASS", f"å»¶è¿Ÿ{elapsed:.1f}ç§’æˆåŠŸ")
            else:
                self.log_test("delay_robot", "FAIL", f"å»¶è¿Ÿå¼‚å¸¸ï¼Œç”¨æ—¶{elapsed:.1f}ç§’ï¼Œå®ŒæˆçŠ¶æ€: {completed}")
        else:
            self.log_test("delay_robot", "FAIL", f"å»¶è¿Ÿå¤±è´¥: {error}")
        
        # 2. åœæ­¢å‘½ä»¤ï¼ˆå·²éªŒè¯å¯ç”¨ï¼‰
        result, error = self.safe_execute(stop_robot_movement, wait_for_ack=True)
        if result and self.wait_for_command_complete(result, 5):
            self.log_test("stop_robot_movement", "PASS", "åœæ­¢å‘½ä»¤æˆåŠŸ")
        else:
            self.log_test("stop_robot_movement", "FAIL", f"å¤±è´¥: {error or result}")

    def test_problematic_apis_analysis(self):
        """åˆ†ææœ‰é—®é¢˜çš„API"""
        print("\n" + "="*50)
        print("ğŸ”¬ æœ‰é—®é¢˜çš„APIåˆ†æ")
        print("="*50)
        
        problematic_apis = {
            "move_robot_pose": "é€†è¿åŠ¨å­¦æ±‚è§£å™¨ç¼ºå¤±(ikine_LMS)",
            "move_robot_cartesian": "é€†è¿åŠ¨å­¦æ±‚è§£å™¨ç¼ºå¤±(ikine_LMS)", 
            "jog_cartesian": "é€†è¿åŠ¨å­¦æ±‚è§£å™¨ç¼ºå¤±(ikine_LMS)",
            "smooth_circle": "é€†è¿åŠ¨å­¦æ±‚è§£å™¨ç¼ºå¤±(ikine_LMS)",
            "smooth_arc_center": "é€†è¿åŠ¨å­¦æ±‚è§£å™¨ç¼ºå¤±(ikine_LMS)",
            "smooth_arc_parametric": "æ•°æ®ç±»å‹è½¬æ¢é—®é¢˜(tolist)",
            "smooth_spline": "é€†è¿åŠ¨å­¦æ±‚è§£å™¨ç¼ºå¤±(ikine_LMS)",
            "smooth_helix": "é€†è¿åŠ¨å­¦æ±‚è§£å™¨ç¼ºå¤±(ikine_LMS)",
        }
        
        print("âŒ æ— æ³•ä½¿ç”¨çš„APIåŠåŸå› :")
        for api, reason in problematic_apis.items():
            print(f"   â€¢ {api}: {reason}")
            self.log_test(api, "FAIL", f"å·²çŸ¥é—®é¢˜: {reason}")
        
        print("\nğŸ’¡ è§£å†³å»ºè®®:")
        print("   1. æ£€æŸ¥roboticstoolboxç‰ˆæœ¬å…¼å®¹æ€§")
        print("   2. æ›´æ–°PAROLæœºå™¨äººé…ç½®æ–‡ä»¶") 
        print("   3. ä½¿ç”¨alternativeé€†è¿åŠ¨å­¦æ±‚è§£å™¨")
        print("   4. è”ç³»å¼€å‘è€…è·å–ä¿®å¤ç‰ˆæœ¬")

    def run_fixed_tests(self):
        """è¿è¡Œä¿®å¤ç‰ˆæµ‹è¯•"""
        print("ğŸš€ å¼€å§‹ä¿®å¤ç‰ˆAPIæµ‹è¯•")
        
        # åˆå§‹åŒ–å®‰å…¨ä½ç½®
        if not self.initialize_safe_positions():
            print("âŒ æ— æ³•åˆå§‹åŒ–ï¼Œé€€å‡ºæµ‹è¯•")
            return
        
        start_time = time.time()
        
        try:
            # 1. æµ‹è¯•å¯ç”¨API
            self.test_working_apis()
            
            # 2. æµ‹è¯•å…³èŠ‚ç§»åŠ¨ï¼ˆä¿®å¤ç‰ˆï¼‰
            self.test_joint_movement_apis()
            
            # 3. æµ‹è¯•å¤¹å…·ï¼ˆä¿®å¤ç‰ˆï¼‰
            self.test_gripper_apis_fixed()
            
            # 4. æµ‹è¯•ç³»ç»ŸAPIï¼ˆä¿®å¤ç‰ˆï¼‰
            self.test_system_apis_fixed()
            
            # 5. åˆ†ææœ‰é—®é¢˜çš„API
            self.test_problematic_apis_analysis()
            
        except KeyboardInterrupt:
            print("\nğŸ›‘ æµ‹è¯•è¢«ç”¨æˆ·ä¸­æ–­")
        except Exception as e:
            print(f"\nâŒ æµ‹è¯•é”™è¯¯: {e}")
            traceback.print_exc()
        finally:
            self.generate_fixed_report(time.time() - start_time)

    def generate_fixed_report(self, total_time):
        """ç”Ÿæˆä¿®å¤ç‰ˆæŠ¥å‘Š"""
        print("\n" + "="*60)
        print("ğŸ“Š PAROL6 API ä¿®å¤ç‰ˆæµ‹è¯•æŠ¥å‘Š")
        print("="*60)
        
        print(f"ğŸ• æ€»æµ‹è¯•æ—¶é—´: {total_time:.1f}ç§’")
        print(f"ğŸ“ˆ æµ‹è¯•ç»Ÿè®¡:")
        print(f"   æ€»æµ‹è¯•æ•°: {self.test_count}")
        print(f"   âœ… é€šè¿‡: {self.passed_count}")
        print(f"   âŒ å¤±è´¥: {self.failed_count}")
        print(f"   â­ï¸ è·³è¿‡: {self.skipped_count}")
        
        working_count = self.passed_count + self.skipped_count
        if self.test_count > 0:
            working_rate = (working_count / self.test_count) * 100
            print(f"   ğŸ“Š å¯ç”¨ç‡: {working_rate:.1f}%")
        
        print(f"\nâœ… ç¡®è®¤å¯ç”¨çš„APIç±»åˆ«:")
        print(f"   â€¢ çŠ¶æ€æŸ¥è¯¢API: 100%å¯ç”¨")
        print(f"   â€¢ å•å…³èŠ‚ç‚¹åŠ¨: 100%å¯ç”¨") 
        print(f"   â€¢ å¤šå…³èŠ‚ç‚¹åŠ¨: 100%å¯ç”¨")
        print(f"   â€¢ æ°”åŠ¨å¤¹å…·æ§åˆ¶: 100%å¯ç”¨")
        print(f"   â€¢ ç³»ç»Ÿæ§åˆ¶: éƒ¨åˆ†å¯ç”¨")
        
        print(f"\nâŒ éœ€è¦ä¿®å¤çš„APIç±»åˆ«:")
        print(f"   â€¢ ä½å§¿ç§»åŠ¨: éœ€è¦ä¿®å¤é€†è¿åŠ¨å­¦")
        print(f"   â€¢ ç¬›å¡å°”ç§»åŠ¨: éœ€è¦ä¿®å¤é€†è¿åŠ¨å­¦")
        print(f"   â€¢ å¹³æ»‘è¿åŠ¨: éœ€è¦ä¿®å¤é€†è¿åŠ¨å­¦")
        print(f"   â€¢ ç”µåŠ¨å¤¹å…·: éœ€è¦æ›´é•¿ç­‰å¾…æ—¶é—´")
        
        print("="*60)

def main():
    """ä¸»ç¨‹åº"""
    print("ğŸ”§ PAROL6 API ä¿®å¤ç‰ˆæµ‹è¯•ç¨‹åº")
    print("åŸºäºé”™è¯¯åˆ†æçš„æ”¹è¿›ç‰ˆæœ¬")
    
    tester = PAROL6FixedTester()
    
    if input("\nç¡®è®¤å¼€å§‹ä¿®å¤ç‰ˆæµ‹è¯•? (y/N): ").lower() == 'y':
        tester.run_fixed_tests()
    else:
        print("âŒ ç”¨æˆ·å–æ¶ˆæµ‹è¯•")

if __name__ == "__main__":
    main()
````

## File: test/ä½ è¿åŠ¨å­¦æ±‚è§£å™¨æµ‹è¯•.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 ä¿®å¤åAPIå®‰å…¨æµ‹è¯•ç¨‹åº
ä¸“é—¨æµ‹è¯•ä¿®å¤åçš„ä½å§¿å’Œå¹³æ»‘è¿åŠ¨API
"""
import sys
import os

# è·å–å½“å‰æ–‡ä»¶çš„ç»å¯¹è·¯å¾„
current_dir = os.path.dirname(os.path.abspath(__file__))

# è·å–çˆ¶ç›®å½•è·¯å¾„
parent_dir = os.path.dirname(current_dir)

# å°†çˆ¶ç›®å½•æ·»åŠ åˆ°æ¨¡å—æœç´¢è·¯å¾„ä¸­
sys.path.append(parent_dir)

# ç°åœ¨å¯ä»¥å¯¼å…¥çˆ¶ç›®å½•ä¸­çš„æ¨¡å—
from robot_api import *
import time
import numpy as np
from robot_api import *

class SafeAPITester:
    def __init__(self):
        """åˆå§‹åŒ–å®‰å…¨æµ‹è¯•å™¨"""
        self.current_pose = None
        self.current_joints = None
        self.safe_workspace_center = None
        self.test_results = {}
        
        print("ğŸ›¡ï¸ PAROL6 ä¿®å¤åAPIå®‰å…¨æµ‹è¯•å™¨")
        print("ä¸“é—¨æµ‹è¯•ä½å§¿ç§»åŠ¨å’Œå¹³æ»‘è¿åŠ¨API")

    def initialize_safe_baseline(self):
        """åˆå§‹åŒ–å®‰å…¨åŸºçº¿"""
        print("\nğŸ“Š åˆå§‹åŒ–å®‰å…¨æµ‹è¯•åŸºçº¿")
        print("-" * 40)
        
        try:
            # è·å–å½“å‰çŠ¶æ€
            self.current_pose = get_robot_pose()
            self.current_joints = get_robot_joint_angles()
            
            if not self.current_pose or not self.current_joints:
                print("âŒ æ— æ³•è·å–æœºå™¨äººå½“å‰çŠ¶æ€")
                return False
            
            print(f"ğŸ“ å½“å‰ä½å§¿: {[round(p, 2) for p in self.current_pose]}")
            print(f"ğŸ”§ å½“å‰å…³èŠ‚: {[round(a, 2) for a in self.current_joints]}")
            
            # è®¾ç½®å®‰å…¨å·¥ä½œç©ºé—´ä¸­å¿ƒï¼ˆä½¿ç”¨å½“å‰ä½ç½®ï¼‰
            self.safe_workspace_center = self.current_pose[:3].copy()  # åªå–XYZ
            print(f"ğŸ¯ å®‰å…¨å·¥ä½œç©ºé—´ä¸­å¿ƒ: {[round(p, 2) for p in self.safe_workspace_center]}")
            
            # æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦å®‰å…¨
            if self.is_pose_safe(self.current_pose):
                print("âœ… å½“å‰ä½ç½®å®‰å…¨ï¼Œå¯ä»¥å¼€å§‹æµ‹è¯•")
                return True
            else:
                print("âš ï¸ å½“å‰ä½ç½®å¯èƒ½ä¸å®‰å…¨ï¼Œè¯·æ‰‹åŠ¨ç§»åŠ¨åˆ°å®‰å…¨ä½ç½®")
                return False
                
        except Exception as e:
            print(f"âŒ åˆå§‹åŒ–å¤±è´¥: {e}")
            return False

    def is_pose_safe(self, pose):
        """æ£€æŸ¥ä½å§¿æ˜¯å¦å®‰å…¨"""
        if not pose or len(pose) < 3:
            return False
        
        x, y, z = pose[:3]
        
        # åŸºæœ¬å®‰å…¨æ£€æŸ¥ï¼ˆæ ¹æ®PAROL6å·¥ä½œç©ºé—´è°ƒæ•´ï¼‰
        if (50 <= x <= 400 and 
            -300 <= y <= 300 and 
            50 <= z <= 400):
            return True
        
        return False

    def create_safe_target_pose(self, offset_x=0, offset_y=0, offset_z=0):
        """åˆ›å»ºå®‰å…¨çš„ç›®æ ‡ä½å§¿"""
        if not self.current_pose:
            return None
        
        target_pose = self.current_pose.copy()
        target_pose[0] += offset_x
        target_pose[1] += offset_y
        target_pose[2] += offset_z
        
        # æ£€æŸ¥ç›®æ ‡æ˜¯å¦å®‰å…¨
        if self.is_pose_safe(target_pose):
            return target_pose
        else:
            print(f"âš ï¸ ç›®æ ‡ä½å§¿ä¸å®‰å…¨: {[round(p, 2) for p in target_pose]}")
            return None

    def wait_for_completion(self, result, timeout=15):
        """ç­‰å¾…å‘½ä»¤å®Œæˆ"""
        if not result or not isinstance(result, dict):
            return False, "æ— æ•ˆç»“æœ"
        
        command_id = result.get('command_id')
        if not command_id:
            status = result.get('status')
            return status == 'COMPLETED', f"çŠ¶æ€: {status}"
        
        start_time = time.time()
        last_status = None
        
        while time.time() - start_time < timeout:
            try:
                status_info = check_command_status(command_id)
                if status_info:
                    current_status = status_info.get('status')
                    if current_status != last_status:
                        print(f"   çŠ¶æ€æ›´æ–°: {current_status}")
                        last_status = current_status
                    
                    if status_info.get('completed'):
                        final_status = status_info.get('status')
                        return final_status == 'COMPLETED', f"æœ€ç»ˆçŠ¶æ€: {final_status}"
                
                time.sleep(0.3)
            except Exception as e:
                print(f"   çŠ¶æ€æ£€æŸ¥å¼‚å¸¸: {e}")
                
        return False, "è¶…æ—¶"

    def log_test_result(self, api_name, success, details=""):
        """è®°å½•æµ‹è¯•ç»“æœ"""
        self.test_results[api_name] = {
            'success': success,
            'details': details,
            'timestamp': time.time()
        }
        
        status = "âœ… æˆåŠŸ" if success else "âŒ å¤±è´¥"
        print(f"{status} {api_name}: {details}")

    def test_move_robot_pose(self):
        """æµ‹è¯• move_robot_pose"""
        print("\nğŸ¤– æµ‹è¯• move_robot_pose")
        print("-" * 30)
        
        # åˆ›å»ºå®‰å…¨çš„å°å¹…ç§»åŠ¨ç›®æ ‡
        target_pose = self.create_safe_target_pose(offset_x=10, offset_z=5)
        
        if not target_pose:
            self.log_test_result("move_robot_pose", False, "æ— æ³•åˆ›å»ºå®‰å…¨ç›®æ ‡ä½å§¿")
            return
        
        print(f"ğŸ¯ ç›®æ ‡ä½å§¿: {[round(p, 2) for p in target_pose]}")
        
        try:
            result = move_robot_pose(
                target_pose,
                speed_percentage=5,  # éå¸¸æ…¢çš„é€Ÿåº¦
                wait_for_ack=True,
                timeout=20
            )
            
            success, details = self.wait_for_completion(result, timeout=20)
            self.log_test_result("move_robot_pose", success, details)
            
            if success:
                time.sleep(1)  # ç­‰å¾…ç¨³å®š
                
        except Exception as e:
            self.log_test_result("move_robot_pose", False, f"å¼‚å¸¸: {e}")

    def test_move_robot_cartesian(self):
        """æµ‹è¯• move_robot_cartesian"""
        print("\nğŸ“ æµ‹è¯• move_robot_cartesian")
        print("-" * 30)
        
        target_pose = self.create_safe_target_pose(offset_y=8, offset_z=-3)
        
        if not target_pose:
            self.log_test_result("move_robot_cartesian", False, "æ— æ³•åˆ›å»ºå®‰å…¨ç›®æ ‡ä½å§¿")
            return
        
        print(f"ğŸ¯ ç›´çº¿ç§»åŠ¨ç›®æ ‡: {[round(p, 2) for p in target_pose]}")
        
        try:
            result = move_robot_cartesian(
                target_pose,
                speed_percentage=5,  # éå¸¸æ…¢çš„é€Ÿåº¦
                wait_for_ack=True,
                timeout=20
            )
            
            success, details = self.wait_for_completion(result, timeout=20)
            self.log_test_result("move_robot_cartesian", success, details)
            
            if success:
                time.sleep(1)
                
        except Exception as e:
            self.log_test_result("move_robot_cartesian", False, f"å¼‚å¸¸: {e}")

    def test_jog_cartesian(self):
        """æµ‹è¯• jog_cartesian"""
        print("\nğŸ•¹ï¸ æµ‹è¯• jog_cartesian")
        print("-" * 30)
        
        # æµ‹è¯•å¤šä¸ªè½´å‘çš„å°å¹…ç‚¹åŠ¨
        test_axes = [
            ('X+', 'Xè½´æ­£å‘'),
            ('Y+', 'Yè½´æ­£å‘'), 
            ('Z+', 'Zè½´æ­£å‘'),
            ('Z-', 'Zè½´è´Ÿå‘')
        ]
        
        for axis, desc in test_axes:
            print(f"ğŸ® æµ‹è¯• {desc} ç‚¹åŠ¨...")
            
            try:
                result = jog_cartesian(
                    frame='WRF',  # ä¸–ç•Œåæ ‡ç³»
                    axis=axis,
                    speed_percentage=8,  # å¾ˆæ…¢çš„é€Ÿåº¦
                    duration=1.0,  # çŸ­æ—¶é—´
                    wait_for_ack=True,
                    timeout=10
                )
                
                success, details = self.wait_for_completion(result, timeout=10)
                self.log_test_result(f"jog_cartesian_{axis}", success, details)
                
                if success:
                    time.sleep(0.5)  # çŸ­æš‚åœé¡¿
                else:
                    break  # å¦‚æœå¤±è´¥ï¼Œåœæ­¢åç»­æµ‹è¯•
                    
            except Exception as e:
                self.log_test_result(f"jog_cartesian_{axis}", False, f"å¼‚å¸¸: {e}")
                break

    def test_smooth_circle(self):
        """æµ‹è¯• smooth_circle"""
        print("\nâ­• æµ‹è¯• smooth_circle")
        print("-" * 30)
        
        if not self.safe_workspace_center:
            self.log_test_result("smooth_circle", False, "æ— å®‰å…¨å·¥ä½œç©ºé—´ä¸­å¿ƒ")
            return
        
        # åœ¨å½“å‰ä½ç½®é™„è¿‘ç”»å°åœ†
        center = self.safe_workspace_center.copy()
        radius = 8  # å¾ˆå°çš„åŠå¾„
        
        print(f"ğŸ¯ åœ†å¿ƒ: {[round(c, 2) for c in center]}, åŠå¾„: {radius}mm")
        
        try:
            result = smooth_circle(
                center=center,
                radius=radius,
                plane='XY',
                frame='WRF',
                duration=8.0,  # è¾ƒé•¿æ—¶é—´ï¼Œæ…¢é€Ÿæ‰§è¡Œ
                wait_for_ack=True,
                timeout=15
            )
            
            success, details = self.wait_for_completion(result, timeout=15)
            self.log_test_result("smooth_circle", success, details)
            
            if success:
                time.sleep(1)
                
        except Exception as e:
            self.log_test_result("smooth_circle", False, f"å¼‚å¸¸: {e}")

    def test_smooth_arc_center(self):
        """æµ‹è¯• smooth_arc_center"""
        print("\nğŸŒ™ æµ‹è¯• smooth_arc_center")
        print("-" * 30)
        
        if not self.current_pose or not self.safe_workspace_center:
            self.log_test_result("smooth_arc_center", False, "ç¼ºå°‘åŸºå‡†ä½ç½®")
            return
        
        # åˆ›å»ºå¼§å½¢è·¯å¾„
        center = self.safe_workspace_center.copy()
        end_pose = self.current_pose.copy()
        end_pose[0] += 15  # Xæ–¹å‘åç§»
        end_pose[1] += 10  # Yæ–¹å‘åç§»
        
        if not self.is_pose_safe(end_pose):
            self.log_test_result("smooth_arc_center", False, "å¼§å½¢ç»ˆç‚¹ä¸å®‰å…¨")
            return
        
        print(f"ğŸ¯ å¼§å½¢: ä¸­å¿ƒ{[round(c, 2) for c in center]} -> ç»ˆç‚¹{[round(p, 2) for p in end_pose[:3]]}")
        
        try:
            result = smooth_arc_center(
                end_pose=end_pose,
                center=center,
                frame='WRF',
                duration=6.0,
                wait_for_ack=True,
                timeout=12
            )
            
            success, details = self.wait_for_completion(result, timeout=12)
            self.log_test_result("smooth_arc_center", success, details)
            
            if success:
                time.sleep(1)
                
        except Exception as e:
            self.log_test_result("smooth_arc_center", False, f"å¼‚å¸¸: {e}")

    def test_smooth_spline(self):
        """æµ‹è¯• smooth_spline"""
        print("\nğŸŒŠ æµ‹è¯• smooth_spline")
        print("-" * 30)
        
        if not self.current_pose:
            self.log_test_result("smooth_spline", False, "æ— å½“å‰ä½å§¿")
            return
        
        # åˆ›å»ºæ ·æ¡è·¯å¾„çš„è·¯å¾„ç‚¹
        waypoints = []
        
        # èµ·å§‹ç‚¹ï¼ˆå½“å‰ä½ç½®å°å¹…åç§»ï¼‰
        wp1 = self.create_safe_target_pose(offset_x=5, offset_y=5)
        wp2 = self.create_safe_target_pose(offset_x=10, offset_y=-5)  
        wp3 = self.create_safe_target_pose(offset_x=15, offset_y=0)
        
        if not all([wp1, wp2, wp3]):
            self.log_test_result("smooth_spline", False, "æ— æ³•åˆ›å»ºå®‰å…¨è·¯å¾„ç‚¹")
            return
        
        waypoints = [wp1, wp2, wp3]
        print(f"ğŸ¯ æ ·æ¡è·¯å¾„: {len(waypoints)} ä¸ªè·¯å¾„ç‚¹")
        
        try:
            result = smooth_spline(
                waypoints=waypoints,
                frame='WRF',
                duration=8.0,  # è¾ƒé•¿æ—¶é—´
                wait_for_ack=True,
                timeout=15
            )
            
            success, details = self.wait_for_completion(result, timeout=15)
            self.log_test_result("smooth_spline", success, details)
            
            if success:
                time.sleep(1)
                
        except Exception as e:
            self.log_test_result("smooth_spline", False, f"å¼‚å¸¸: {e}")

    def test_smooth_helix(self):
        """æµ‹è¯• smooth_helix"""
        print("\nğŸŒ€ æµ‹è¯• smooth_helix")
        print("-" * 30)
        
        if not self.safe_workspace_center:
            self.log_test_result("smooth_helix", False, "æ— å®‰å…¨å·¥ä½œç©ºé—´ä¸­å¿ƒ")
            return
        
        # å°èºæ—‹å‚æ•°
        center = self.safe_workspace_center.copy()
        center[2] -= 10  # ç¨å¾®é™ä½ä¸­å¿ƒé«˜åº¦
        radius = 6
        pitch = 5  # èºè·
        height = 15  # æ€»é«˜åº¦
        
        print(f"ğŸ¯ èºæ—‹: ä¸­å¿ƒ{[round(c, 2) for c in center]}, r={radius}mm, h={height}mm")
        
        try:
            result = smooth_helix(
                center=center,
                radius=radius,
                pitch=pitch,
                height=height,
                frame='WRF',
                duration=10.0,  # æ›´é•¿æ—¶é—´
                wait_for_ack=True,
                timeout=18
            )
            
            success, details = self.wait_for_completion(result, timeout=18)
            self.log_test_result("smooth_helix", success, details)
            
            if success:
                time.sleep(1)
                
        except Exception as e:
            self.log_test_result("smooth_helix", False, f"å¼‚å¸¸: {e}")

    def run_all_tests(self):
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        print("ğŸš€ å¼€å§‹ä¿®å¤åAPIå®Œæ•´æµ‹è¯•")
        print("=" * 50)
        
        # åˆå§‹åŒ–
        if not self.initialize_safe_baseline():
            print("âŒ åˆå§‹åŒ–å¤±è´¥ï¼Œæ— æ³•ç»§ç»­æµ‹è¯•")
            return
        
        print("\nâš ï¸ å®‰å…¨æé†’:")
        print("â€¢ æµ‹è¯•å°†ä½¿ç”¨å¾ˆå°çš„ç§»åŠ¨è·ç¦»å’Œå¾ˆæ…¢çš„é€Ÿåº¦")
        print("â€¢ ç¡®ä¿æœºå™¨äººå‘¨å›´å®‰å…¨æ— éšœç¢")
        print("â€¢ æ€¥åœæŒ‰é’®éšæ—¶å¯ç”¨")
        
        if input("\nç¡®è®¤å¼€å§‹æµ‹è¯•? (y/N): ").lower() != 'y':
            print("âŒ ç”¨æˆ·å–æ¶ˆæµ‹è¯•")
            return
        
        start_time = time.time()
        
        try:
            # ä¾æ¬¡æµ‹è¯•æ¯ä¸ªAPI
            test_functions = [
                ("move_robot_pose", self.test_move_robot_pose),
                ("move_robot_cartesian", self.test_move_robot_cartesian), 
                ("jog_cartesian", self.test_jog_cartesian),
                ("smooth_circle", self.test_smooth_circle),
                ("smooth_arc_center", self.test_smooth_arc_center),
                ("smooth_spline", self.test_smooth_spline),
                ("smooth_helix", self.test_smooth_helix),
            ]
            
            for api_name, test_func in test_functions:
                print(f"\n{'='*20} {api_name.upper()} {'='*20}")
                
                if input(f"æµ‹è¯• {api_name}? (Y/n/s=è·³è¿‡å…¨éƒ¨): ").lower() in ['n', 's']:
                    if input("è·³è¿‡å…¨éƒ¨å‰©ä½™æµ‹è¯•? (y/N): ").lower() == 'y':
                        break
                    continue
                
                test_func()
                
                # æµ‹è¯•é—´çŸ­æš‚ä¼‘æ¯
                time.sleep(1)
                
        except KeyboardInterrupt:
            print("\nğŸ›‘ æµ‹è¯•è¢«ç”¨æˆ·ä¸­æ–­")
        except Exception as e:
            print(f"\nâŒ æµ‹è¯•å¼‚å¸¸: {e}")
        finally:
            self.generate_test_report(time.time() - start_time)

    def generate_test_report(self, total_time):
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        print("\n" + "=" * 60)
        print("ğŸ“Š ä¿®å¤åAPIæµ‹è¯•æŠ¥å‘Š")
        print("=" * 60)
        
        successful_apis = []
        failed_apis = []
        
        for api_name, result in self.test_results.items():
            if result['success']:
                successful_apis.append(api_name)
            else:
                failed_apis.append((api_name, result['details']))
        
        print(f"ğŸ• æ€»æµ‹è¯•æ—¶é—´: {total_time:.1f}ç§’")
        print(f"ğŸ“ˆ æµ‹è¯•ç»Ÿè®¡:")
        print(f"   æ€»æµ‹è¯•API: {len(self.test_results)}")
        print(f"   âœ… æˆåŠŸ: {len(successful_apis)}")
        print(f"   âŒ å¤±è´¥: {len(failed_apis)}")
        
        if self.test_results:
            success_rate = len(successful_apis) / len(self.test_results) * 100
            print(f"   ğŸ“Š æˆåŠŸç‡: {success_rate:.1f}%")
        
        if successful_apis:
            print(f"\nâœ… æˆåŠŸçš„API:")
            for api in successful_apis:
                print(f"   â€¢ {api}")
        
        if failed_apis:
            print(f"\nâŒ å¤±è´¥çš„API:")
            for api, details in failed_apis:
                print(f"   â€¢ {api}: {details}")
        
        print(f"\nğŸ’¡ æ€»ç»“:")
        if len(successful_apis) >= 5:
            print("   ğŸ‰ å¤§éƒ¨åˆ†APIä¿®å¤æˆåŠŸï¼")
        elif len(successful_apis) >= 2:
            print("   ğŸ‘ éƒ¨åˆ†APIä¿®å¤æˆåŠŸï¼Œè¿˜éœ€è¿›ä¸€æ­¥è°ƒæ•´")
        else:
            print("   ğŸ”§ ä»éœ€è¦æ›´å¤šä¿®å¤å·¥ä½œ")
        
        print("=" * 60)

def main():
    """ä¸»ç¨‹åº"""
    print("ğŸ›¡ï¸ PAROL6 ä¿®å¤åAPIå®‰å…¨æµ‹è¯•ç¨‹åº")
    print("ä¸“é—¨æµ‹è¯•ikine_LMä¿®å¤åçš„APIåŠŸèƒ½")
    
    tester = SafeAPITester()
    tester.run_all_tests()

if __name__ == "__main__":
    main()
````

## File: test/ä¸€é”®ç§»åŠ¨åˆ°å®‰å…¨ä½ç½®.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 å¿«é€Ÿå®‰å…¨ç§»åŠ¨è„šæœ¬
ä¸€é”®ç§»åŠ¨åˆ°æœ€å®‰å…¨çš„ä½ç½®
"""
import sys
import os

# è·å–å½“å‰æ–‡ä»¶çš„ç»å¯¹è·¯å¾„
current_dir = os.path.dirname(os.path.abspath(__file__))

# è·å–çˆ¶ç›®å½•è·¯å¾„
parent_dir = os.path.dirname(current_dir)

# å°†çˆ¶ç›®å½•æ·»åŠ åˆ°æ¨¡å—æœç´¢è·¯å¾„ä¸­
sys.path.append(parent_dir)

# ç°åœ¨å¯ä»¥å¯¼å…¥çˆ¶ç›®å½•ä¸­çš„æ¨¡å—
from robot_api import *
import time
from robot_api import *

def quick_safe_move():
    """å¿«é€Ÿç§»åŠ¨åˆ°å®‰å…¨ä½ç½®"""
    print("ğŸš€ PAROL6 å¿«é€Ÿå®‰å…¨ç§»åŠ¨")
    print("=" * 30)
    
    # è·å–å½“å‰çŠ¶æ€
    try:
        current_pose = get_robot_pose()
        current_joints = get_robot_joint_angles()
        
        if not current_pose or not current_joints:
            print("âŒ æ— æ³•è·å–æœºå™¨äººçŠ¶æ€")
            return False
        
        print(f"ğŸ“ å½“å‰ä½å§¿: {[round(p, 2) for p in current_pose]}")
        print(f"ğŸ”§ å½“å‰å…³èŠ‚: {[round(a, 2) for a in current_joints]}")
        
    except Exception as e:
        print(f"âŒ è·å–çŠ¶æ€å¤±è´¥: {e}")
        return False
    
    # å®šä¹‰æœ€å®‰å…¨çš„ä½ç½®ï¼ˆå·¥ä½œç©ºé—´ä¸­å¿ƒï¼Œä¸­ç­‰é«˜åº¦ï¼‰
    safe_joints = [0, -60, 150, 0, 30, 180]
    print(f"\nğŸ¯ ç›®æ ‡å®‰å…¨ä½ç½®: {safe_joints}")
    
    # ç¡®è®¤ç§»åŠ¨
    if input("ç¡®è®¤ç§»åŠ¨åˆ°å®‰å…¨ä½ç½®? (y/N): ").lower() != 'y':
        print("âŒ ç”¨æˆ·å–æ¶ˆ")
        return False
    
    try:
        print("ğŸš€ å¼€å§‹ç§»åŠ¨...")
        
        result = move_robot_joints(
            safe_joints,
            speed_percentage=8,  # æ…¢é€Ÿ
            wait_for_ack=True,
            timeout=20.0
        )
        
        if result:
            print("â³ ç­‰å¾…ç§»åŠ¨å®Œæˆ...")
            
            # ç­‰å¾…å®Œæˆ
            start_time = time.time()
            while time.time() - start_time < 20:
                try:
                    if result.get('command_id'):
                        status = check_command_status(result['command_id'])
                        if status and status.get('completed'):
                            if status.get('status') == 'COMPLETED':
                                print("âœ… ç§»åŠ¨åˆ°å®‰å…¨ä½ç½®æˆåŠŸï¼")
                                
                                # æ˜¾ç¤ºæ–°ä½ç½®
                                time.sleep(1)
                                new_pose = get_robot_pose()
                                new_joints = get_robot_joint_angles()
                                if new_pose and new_joints:
                                    print(f"ğŸ“ æ–°ä½å§¿: {[round(p, 2) for p in new_pose]}")
                                    print(f"ğŸ”§ æ–°å…³èŠ‚: {[round(a, 2) for a in new_joints]}")
                                
                                return True
                            else:
                                print(f"âŒ ç§»åŠ¨å¤±è´¥: {status.get('status')}")
                                return False
                    elif result.get('status') == 'COMPLETED':
                        print("âœ… ç§»åŠ¨å®Œæˆï¼")
                        return True
                    
                    time.sleep(0.5)
                except:
                    pass
            
            print("âš ï¸ ç§»åŠ¨å¯èƒ½è¶…æ—¶")
            return False
        else:
            print("âŒ ç§»åŠ¨å‘½ä»¤å¤±è´¥")
            return False
            
    except Exception as e:
        print(f"âŒ ç§»åŠ¨å¼‚å¸¸: {e}")
        return False

if __name__ == "__main__":
    if quick_safe_move():
        print("\nğŸ‰ ç°åœ¨å¯ä»¥è¿è¡ŒAPIæµ‹è¯•ç¨‹åºäº†ï¼")
        print("è¿è¡Œ: python safe_api_test.py")
    else:
        print("\nâŒ ç§»åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœºå™¨äººçŠ¶æ€")
````

## File: test/emergency_stop_cli.py
````python
#!/usr/bin/env python3
"""
PAROL6å¿«é€Ÿæ€¥åœå‘½ä»¤è¡Œå·¥å…·
"""
import sys
sys.path.append('09-PAROL6-python-API')

try:
    from robot_api import stop_robot_movement
    import rclpy
    from std_msgs.msg import String, Bool
    
    def emergency_stop():
        print("æ‰§è¡Œæ€¥åœ...")
        
        # 1. APIç›´æ¥åœæ­¢
        try:
            result = stop_robot_movement(wait_for_ack=True, timeout=3)
            if result:
                print("âœ… APIæ€¥åœæˆåŠŸ")
            else:
                print("âŒ APIæ€¥åœå¤±è´¥")
        except Exception as e:
            print(f"âŒ APIæ€¥åœå¼‚å¸¸: {e}")
        
        # 2. ROSæ€¥åœ
        try:
            rclpy.init()
            node = rclpy.create_node('emergency_stop_cli')
            
            emergency_pub = node.create_publisher(Bool, '/parol6/emergency_stop', 10)
            cmd_pub = node.create_publisher(String, '/parol6/api_command', 10)
            
            # å‘å¸ƒæ€¥åœä¿¡å·
            emergency_msg = Bool()
            emergency_msg.data = True
            emergency_pub.publish(emergency_msg)
            
            cmd_msg = String()
            cmd_msg.data = 'emergency_stop'
            cmd_pub.publish(cmd_msg)
            
            print("âœ… ROSæ€¥åœä¿¡å·å·²å‘é€")
            
            node.destroy_node()
            rclpy.shutdown()
            
        except Exception as e:
            print(f"âŒ ROSæ€¥åœå¼‚å¸¸: {e}")
    
    if __name__ == "__main__":
        emergency_stop()
        
except ImportError as e:
    print(f"å¯¼å…¥å¤±è´¥: {e}")
    print("è¯·ç¡®ä¿PAROL6 APIå’ŒROS2ç¯å¢ƒæ­£ç¡®é…ç½®")
````

## File: test/requirements.txt
````
# requirements.txt  â€”â€” PAROL6-python-API ç¯å¢ƒ
numpy==1.23.4
scipy==1.11.4

# æœºå™¨äººç›¸å…³
roboticstoolbox-python==1.0.3
spatialmath-python==1.0.5

# ä¸²å£é€šä¿¡
pyserial>=3.5

# é”®ç›˜äº‹ä»¶ç›‘å¬ï¼ˆheadless_commander.py ç”¨åˆ°ï¼‰
keyboard>=0.13.5

# Windows ä¸‹ç”¨äºè®¡æ—¶çš„åŒ…ï¼ˆå¦‚æœä»£ç é‡ŒçœŸçš„ import oclock æ‰éœ€è¦ï¼‰
# oclock

# å…¶ä»–å·¥å…·åº“ï¼ˆæ ¹æ® PAROL6 READMEï¼Œè‹¥ç”¨ get_robot_poseï¼‰
# å¦‚æœè¦ä½¿ç”¨ get_robot_pose() è¿˜éœ€å®‰è£… numpy, spatialmath å·²åŒ…å«
````

## File: test/wnå¿«é€Ÿä¿®å¤è„šæœ¬.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å¿«é€Ÿä¿®å¤ ikine_LM wN å‚æ•°é—®é¢˜
"""

import os
import re
import shutil
import time

def quick_fix_wN_parameter():
    """å¿«é€Ÿä¿®å¤ wN å‚æ•°é—®é¢˜"""
    print("ğŸš€ å¿«é€Ÿä¿®å¤ ikine_LM wN å‚æ•°é—®é¢˜")
    print("="*40)
    
    files = ["headless_commander.py", "PAROL6_ROBOT.py", "smooth_motion.py"]
    
    for filename in files:
        if not os.path.exists(filename):
            print(f"âš ï¸ {filename}: æ–‡ä»¶ä¸å­˜åœ¨")
            continue
        
        try:
            # è¯»å–æ–‡ä»¶
            with open(filename, 'r', encoding='utf-8') as f:
                content = f.read()
            
            original_content = content
            
            # æ£€æŸ¥æ˜¯å¦æœ‰é—®é¢˜
            if 'wN' not in content:
                print(f"âœ… {filename}: æ— éœ€ä¿®å¤")
                continue
            
            # å¤‡ä»½
            backup = f"{filename}.backup_wN_{int(time.time())}"
            shutil.copy2(filename, backup)
            
            # ä¿®å¤æ‰€æœ‰ wN å‚æ•°ç›¸å…³é—®é¢˜
            fixes = [
                # åˆ é™¤ wN=xxx å‚æ•°
                (r',\s*wN\s*=[^,)]*', ''),
                (r'wN\s*=[^,)]*,\s*', ''),
                # åˆ é™¤å•ç‹¬çš„ wN å‚æ•°
                (r',\s*wN\s*,', ','),
                (r'\(\s*wN\s*,', '('),
                (r',\s*wN\s*\)', ')'),
            ]
            
            fixes_applied = 0
            for pattern, replacement in fixes:
                if re.search(pattern, content):
                    content = re.sub(pattern, replacement, content)
                    fixes_applied += 1
            
            # æ¸…ç†å¤šä½™çš„é€—å·
            content = re.sub(r',\s*,', ',', content)
            content = re.sub(r'\(\s*,', '(', content)
            content = re.sub(r',\s*\)', ')', content)
            
            # å†™å…¥ä¿®å¤åçš„å†…å®¹
            if content != original_content:
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                print(f"âœ… {filename}: ä¿®å¤å®Œæˆï¼Œå¤‡ä»½åˆ° {backup}")
                
                # æ˜¾ç¤ºä¿®å¤çš„å†…å®¹
                lines = content.split('\n')
                for i, line in enumerate(lines, 1):
                    if 'ikine_LM' in line:
                        print(f"   è¡Œ {i}: {line.strip()}")
            else:
                print(f"ğŸ“„ {filename}: æœªå‘ç°å…·ä½“é—®é¢˜")
                os.remove(backup)  # åˆ é™¤ä¸å¿…è¦çš„å¤‡ä»½
                
        except Exception as e:
            print(f"âŒ {filename}: ä¿®å¤å¤±è´¥ - {e}")
    
    print("\nğŸ‰ å¿«é€Ÿä¿®å¤å®Œæˆï¼")
    print("ğŸ“‹ ä¸‹ä¸€æ­¥:")
    print("1. é‡å¯ headless_commander.py")  
    print("2. è¿è¡Œ API æµ‹è¯•")

if __name__ == "__main__":
    if input("ç¡®è®¤æ‰§è¡Œ wN å‚æ•°å¿«é€Ÿä¿®å¤? (y/N): ").lower() == 'y':
        quick_fix_wN_parameter()
    else:
        print("âŒ å–æ¶ˆä¿®å¤")
````

## File: 01-safe_base_test.py
````python
# safe_base_test.py
import time
from robot_api import (
    connect, disconnect, is_connected,
    clear_queue, stop_robot, get_state,
    move_robot_joints, home_robot  # è‹¥æœ‰ home_joint å¯æ”¹ç”¨å®ƒ
)

DEG2RAD = 3.141592653589793 / 180.0

def main():
    # 1) è¿æ¥
    connect()  # è‹¥ä½ çš„å®ç°éœ€è¦IP/ç«¯å£ï¼Œæ”¹æˆ connect("192.168.x.x", 5001)
    assert is_connected(), "è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ headless_commander æ˜¯å¦å·²è¿è¡Œ"

    # 2) å®‰å…¨ï¼šè½¯åœ + æ¸…é˜Ÿåˆ—ï¼ˆå¦‚å‡½æ•°ä¸å­˜åœ¨å¯æ³¨é‡Šï¼‰
    try: stop_robot()
    except: pass
    try: clear_queue()
    except: pass

    # 3) è¯»å–å½“å‰å…³èŠ‚è§’ï¼ˆå¼§åº¦ï¼‰
    st = get_state()  # æœŸå¾…è¿”å›æœ‰ joints åˆ—è¡¨ï¼Œå•ä½é€šå¸¸ä¸ºåº¦æˆ–å¼§åº¦ï¼Œè§†å®ç°è€Œå®š
    joints = list(st["joints"] if isinstance(st, dict) else st.joints)

    # 4) åªæ”¹ J1ï¼ˆbaseï¼‰ä¸€ç‚¹ç‚¹ï¼š+5Â°
    # å¦‚æœ get_state è¿”å›çš„æ˜¯åº¦ï¼Œè¯·å»æ‰ *DEG2RADï¼›å¦‚æœæ˜¯å¼§åº¦ï¼Œä¿ç•™å¦‚ä¸‹ï¼š
    target = joints[:]
    target[0] = target[0] + 5.0 * DEG2RAD  # åŸºåº§ +5Â°

    print("å‡†å¤‡ä»¥ 5% é€Ÿåº¦ç¼“æ…¢è½¬åŠ¨åŸºåº§ +5Â° ...")
    move_robot_joints(
        target,
        speed_percentage=5,       # å¾ˆæ…¢
        wait_for_ack=True,        # ç­‰ç¡®è®¤
        non_blocking=False        # é˜»å¡åˆ°å®Œæˆï¼ˆæ›´å®‰å…¨ï¼‰
    )

    time.sleep(0.5)
    print("åŸºåº§å°è§’åº¦åŠ¨ä½œå®Œæˆã€‚å¼€å§‹å› Homeï¼ˆä½é€Ÿï¼‰...")
    # è‹¥æœ‰æŒ‰å…³èŠ‚å›é›¶APIï¼Œå¯æ›¿æ¢ä¸º home_joint(joint_index=0, speed_percentage=5, wait_for_ack=True)
    home_robot(speed_percentage=5, wait_for_ack=True, timeout=120)

    disconnect()
    print("å®Œæˆã€‚")

if __name__ == "__main__":
    main()
````

## File: com_port.txt
````
COM3
````

## File: example_client.py
````python
# safe_home_client.py
import time
from robot_api import (
    connect, disconnect, is_connected,
    stop_robot, clear_queue, home_robot, get_state
)

def main():
    # 1) è¿æ¥ï¼ˆå¦‚æœ robot_api éœ€è¦ IP/ç«¯å£ï¼Œæ›¿æ¢ connect(host, port) ç‰ˆæœ¬ï¼‰
    connect()
    assert is_connected(), "è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ headless_commander æ˜¯å¦åœ¨è¿è¡Œ"

    # 2) å®‰å…¨ï¼šåœæ­¢å¹¶æ¸…é˜Ÿåˆ—
    try:
        stop_robot()    # æŸäº›å®ç°æ˜¯è½¯åœï¼›è‹¥æ— è¯¥å‡½æ•°å¯å¿½ç•¥
    except Exception:
        pass
    try:
        clear_queue()
    except Exception:
        pass

    # 3) è¯»å–å½“å‰çŠ¶æ€å¹¶æ‰“å°ï¼ˆç¡®è®¤æœªåœ¨è¿åŠ¨ï¼‰
    try:
        s = get_state()
        print("å½“å‰çŠ¶æ€ï¼š", s)
    except Exception as e:
        print("è¯»å–çŠ¶æ€å¤±è´¥ï¼Œä¸å½±å“ Homeï¼š", e)

    # 4) ä½é€Ÿ Homeï¼ˆå…³é”®ï¼ï¼‰
    print("å¼€å§‹ä½é€Ÿ Home ...")
    home_robot(speed_percentage=10, wait_for_ack=True, timeout=120)

    # 5) ç­‰å¾…ç¨³å®š
    time.sleep(1.0)
    print("Home æŒ‡ä»¤å®Œæˆã€‚å†æ¬¡è¯»å–çŠ¶æ€ï¼š")
    try:
        s2 = get_state()
        print("çŠ¶æ€ï¼š", s2)
    except Exception:
        pass

    # 6) æ–­å¼€
    disconnect()
    print("å®Œæˆ")

if __name__ == "__main__":
    main()
````

## File: headless_commander_fixed.py
````python
#!/usr/bin/env python3
"""
Fixed version of headless_commander.py with Linux serial port support
"""
import sys
import os
import platform

# Add serial port initialization for Linux
def initialize_serial():
    import serial
    import serial.tools.list_ports
    
    my_os = platform.system()
    ser = None
    
    if my_os == "Windows":
        # Try to read the COM port from a file
        try:
            with open("com_port.txt", "r") as f:
                com_port_str = f.read().strip()
                ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
                print(f"Connected to saved COM port: {com_port_str}")
        except (FileNotFoundError, serial.SerialException):
            # If the file doesn't exist or the port is invalid, ask the user
            while True:
                try:
                    com_port = input("Enter the COM port (e.g., COM9): ")
                    ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                    print(f"Successfully connected to {com_port}")
                    # Save the successful port to the file
                    with open("com_port.txt", "w") as f:
                        f.write(com_port)
                    break
                except serial.SerialException:
                    print(f"Could not open port {com_port}. Please try again.")
    else:
        # Linux/Mac system
        # Try to read the serial port from a file
        try:
            with open("com_port.txt", "r") as f:
                com_port_str = f.read().strip()
                ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
                print(f"Connected to saved serial port: {com_port_str}")
        except (FileNotFoundError, serial.SerialException):
            # If the file doesn't exist or the port is invalid, try default ports
            default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
            for port in default_ports:
                try:
                    ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                    print(f"Successfully connected to {port}")
                    # Save the successful port to the file
                    with open("com_port.txt", "w") as f:
                        f.write(port)
                    break
                except serial.SerialException:
                    continue
            
            if ser is None:
                print("Could not find any available serial ports. Available ports:")
                ports = serial.tools.list_ports.comports()
                for port in ports:
                    print(f"  {port.device}")
                
                while True:
                    try:
                        com_port = input("Enter the serial port (e.g., /dev/ttyACM0): ")
                        ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                        print(f"Successfully connected to {com_port}")
                        # Save the successful port to the file
                        with open("com_port.txt", "w") as f:
                            f.write(com_port)
                        break
                    except serial.SerialException:
                        print(f"Could not open port {com_port}. Please try again.")
    
    return ser

# Now run the original script with our serial initialization
if __name__ == "__main__":
    import subprocess
    
    # First initialize the serial port
    ser = initialize_serial()
    if ser:
        print(f"Serial port successfully initialized: {ser.port}")
        ser.close()  # Close it, let the main script handle it
    
    # Now we need to patch the original script
    print("Patching original script...")
````

## File: headless_commander_patched.py
````python
'''
A full fledged "API" for the PAROL6 robot. To use this, you should pair it with the "robot_api.py" where you can import commands
from said file and use them anywhere within your code. This Python script will handle sending and performing all the commands
to the PAROL6 robot, as well as E-Stop functionality and safety limitations.

To run this program, you must use the "experimental-kinematics" branch of the "PAROL-commander-software" on GitHub
which can be found through this link: https://github.com/PCrnjak/PAROL-commander-software/tree/experimental_kinematics.
You must also save these files into the following folder: "Project Files\PAROL-commander-software\GUI\files".
'''

# * If you press estop robot will stop and you need to enable it by pressing e

from roboticstoolbox import DHRobot, RevoluteDH, ERobot, ELink, ETS, trapezoidal, quintic
import roboticstoolbox as rp
from math import pi, sin, cos
import numpy as np
from oclock import Timer, loop, interactiveloop
import time
import socket
from spatialmath import SE3
import select
import serial
import platform
import os
import re
import logging
import struct
import keyboard
from typing import Optional, Tuple
from spatialmath.base import trinterp
from collections import namedtuple, deque
import GUI.files.PAROL6_ROBOT as PAROL6_ROBOT
from smooth_motion import CircularMotion, SplineMotion, MotionBlender

# Set interval
INTERVAL_S = 0.01
prev_time = 0

logging.basicConfig(level = logging.DEBUG,
    format='%(asctime)s.%(msecs)03d %(levelname)s:\t%(message)s',
    datefmt='%H:%M:%S'
)
logging.disable(logging.DEBUG)



my_os = platform.system()

# Initialize serial port based on OS
ser = None
com_port_str = None

if my_os == "Windows":
    # Windows serial port initialization
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved COM port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        while True:
            try:
                com_port = input("Enter the COM port (e.g., COM9): ")
                ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                com_port_str = com_port
                print(f"Successfully connected to {com_port}")
                with open("com_port.txt", "w") as f:
                    f.write(com_port)
                break
            except serial.SerialException:
                print(f"Could not open port {com_port}. Please try again.")

else:  # Linux/Mac
    # Linux serial port initialization
    print("ğŸ”§ Initializing serial port for Linux/Mac...")
    
    # Try to read saved port
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            if os.path.exists(com_port_str):
                ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
                print(f"âœ… Connected to saved port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException) as e:
        print(f"âš ï¸ Could not connect to saved port: {e}")
        ser = None
    
    # If not connected, try default ports
    if ser is None:
        default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
        for port in default_ports:
            if os.path.exists(port):
                try:
                    ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                    com_port_str = port
                    print(f"âœ… Connected to {port}")
                    with open("com_port.txt", "w") as f:
                        f.write(port)
                    break
                except serial.SerialException as e:
                    print(f"âŒ Failed to connect to {port}: {e}")
    
    # If still not connected, list available ports
    if ser is None:
        print("\nğŸ“¡ Available serial ports:")
        ports = serial.tools.list_ports.comports()
        for port in ports:
            print(f"  â€¢ {port.device} - {port.description}")
        
        # Try to connect to the first available ACM/USB port
        for port in ports:
            if "ACM" in port.device or "USB" in port.device:
                try:
                    ser = serial.Serial(port=port.device, baudrate=3000000, timeout=0)
                    com_port_str = port.device
                    print(f"âœ… Connected to {port.device}")
                    with open("com_port.txt", "w") as f:
                        f.write(port.device)
                    break
                except Exception:
                    pass
        
        if ser is None:
            print("\nâŒ Could not connect to any serial port!")
            print("Please check:")
            print("1. Robot is connected and powered on")
            print("2. User has permission (sudo usermod -a -G dialout $USER)")
            print("3. No other program is using the serial port")
            sys.exit(1)

print(f"ğŸ“¡ Using serial port: {com_port_str}")
print(f"âš¡ Baudrate: 3000000")
print("ğŸ¤– PAROL6 Headless Commander Ready\n")

# in big endian machines, first byte of binary representation of the multibyte data-type is stored first. 
int_to_3_bytes = struct.Struct('>I').pack # BIG endian order

# data for output string (data that is being sent to the robot)
#######################################################################################
#######################################################################################
start_bytes =  [0xff,0xff,0xff] 
start_bytes = bytes(start_bytes)

end_bytes =  [0x01,0x02] 
end_bytes = bytes(end_bytes)


# data for input string (Data that is being sent by the robot)
#######################################################################################
#######################################################################################
input_byte = 0 # Here save incoming bytes from serial

start_cond1_byte = bytes([0xff])
start_cond2_byte = bytes([0xff])
start_cond3_byte = bytes([0xff])

end_cond1_byte = bytes([0x01])
end_cond2_byte = bytes([0x02])

start_cond1 = 0 #Flag if start_cond1_byte is received
start_cond2 = 0 #Flag if start_cond2_byte is received
start_cond3 = 0 #Flag if start_cond3_byte is received

good_start = 0 #Flag if we got all 3 start condition bytes
data_len = 0 #Length of the data after -3 start condition bytes and length byte, so -4 bytes

data_buffer = [None]*255 #Here save all data after data length byte
data_counter = 0 #Data counter for incoming bytes; compared to data length to see if we have correct length
#######################################################################################
#######################################################################################
prev_positions = [0,0,0,0,0,0]
prev_speed = [0,0,0,0,0,0]
robot_pose = [0,0,0,0,0,0] #np.array([0,0,0,0,0,0])
#######################################################################################
#######################################################################################

# --- Wrapper class to make integers mutable when passed to functions ---
class CommandValue:
    def __init__(self, value):
        self.value = value

#######################################################################################
#######################################################################################
Position_out = [1,11,111,1111,11111,10]
Speed_out = [2,21,22,23,24,25]
Command_out = CommandValue(255)
Affected_joint_out = [1,1,1,1,1,1,1,1]
InOut_out = [0,0,0,0,0,0,0,0]
Timeout_out = 0
#Positon,speed,current,command,mode,ID
Gripper_data_out = [1,1,1,1,0,0]
#######################################################################################
#######################################################################################
# Data sent from robot to PC
Position_in = [31,32,33,34,35,36]
Speed_in = [41,42,43,44,45,46]
Homed_in = [0,0,0,0,0,0,0,0]
InOut_in = [1,1,1,1,1,1,1,1]
Temperature_error_in = [1,1,1,1,1,1,1,1]
Position_error_in = [1,1,1,1,1,1,1,1]
Timeout_error = 0
# how much time passed between 2 sent commands (2byte value, last 2 digits are decimal so max value is 655.35ms?)
Timing_data_in = [0]
XTR_data =   0

# --- State variables for program execution ---
Robot_mode = "Dummy"  # Start in an idle state
Program_step = 0      # Which line of the program to run
Command_step = 0      # The current step within a single command
Command_len = 0       # The total steps for the current command
ik_error = 0          # Flag for inverse kinematics errors
error_state = 0       # General error flag
program_running = False # A flag to start and stop the program

# This will be your "program"
command_list = []

#ID,Position,speed,current,status,obj_detection
Gripper_data_in = [1,1,1,1,1,1] 

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179Â° and 181Â° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    
    Parameters
    ----------
    robot : DHRobot
        Robot model
    q : array_like
        Joint configuration
    strict_tol : float
        Strict tolerance away from singularities (default: 1e-10)
    loose_tol : float
        Loose tolerance near singularities (1e-7)
        
    Returns
    -------
    float
        Adaptive tolerance value
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    
    Parameters
    ----------
    q_seed : array_like
        Current joint configuration in radians
        
    Returns
    -------
    float
        Configuration-dependent maximum reach threshold
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90Â°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 | None = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities:
    - Near singularities: looser tolerance for easier convergence
    - Away from singularities: stricter tolerance for precise solutions
    If necessary, recursively subdivide the motion until ikine_LMS converges
    on every segment. Finally check that solution respects joint limits. From experimentation,
    jogging with lower tolerances often produces q_paths that do not differ from current_q,
    essentially freezing the robot.

    Parameters
    ----------
    robot : DHRobot
        Robot model
    target_pose : SE3
        Target pose to reach
    current_q : array_like
        Current joint configuration
    current_pose : SE3, optional
        Current pose (computed if None)
    max_depth : int, optional
        Maximum subdivision depth (default: 8)
    ilimit : int, optional
        Maximum iterations for IK solver (default: 100)

    Returns
    -------
    IKResult
        success  - True/False
        q_path   - (mxn) array of the final joint configuration 
        iterations, residual  - aggregated diagnostics
        tolerance_used - which tolerance was used
        violations - joint limit violations (if any)
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # â”€â”€ inner recursive solverâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            # print(f"current_reach:{current_reach:.3f}, max_reach_threshold:{max_reach_threshold:.3f}")
            if not is_recovery and target_reach > max_reach_threshold:
                print(f"Target reach limit exceeded: {target_reach:.3f} > {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LMS(Tb, q0=q_seed, ilimit=ilimit, tol=tol, wN=damping)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # â”€â”€ kick-off with adaptive tolerance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    # Check if solution respects joint limits
    target_q = path[-1] if len(path) != 0 else None
    solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
    if ok and solution_valid:
        return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
    else:
        return IKResult(False, None, its, resid, adaptive_tol, violations)

#Setup IP address and Simulator port
ip = "127.0.0.1" #Loopback address
port = 5001
# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((ip, port))
print(f'Start listening to {ip}:{port}')

def Unpack_data(data_buffer_list, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):

    Joints = []
    Speed = []

    for i in range(0,18, 3):
        variable = data_buffer_list[i:i+3]
        Joints.append(variable)

    for i in range(18,36, 3):
        variable = data_buffer_list[i:i+3]
        Speed.append(variable)


    for i in range(6):
        var =  b'\x00' + b''.join(Joints[i])
        Position_in[i] = Fuse_3_bytes(var)
        var =  b'\x00' + b''.join(Speed[i])
        Speed_in[i] = Fuse_3_bytes(var)

    Homed = data_buffer_list[36]
    IO_var = data_buffer_list[37]
    temp_error = data_buffer_list[38]
    position_error = data_buffer_list[39]
    timing_data = data_buffer_list[40:42]
    Timeout_error_var = data_buffer_list[42]
    xtr2 = data_buffer_list[43]
    device_ID = data_buffer_list[44]
    Gripper_position = data_buffer_list[45:47]
    Gripper_speed = data_buffer_list[47:49]
    Gripper_current = data_buffer_list[49:51]
    Status = data_buffer_list[51]
    # The original object_detection byte at index 52 is ignored as it is not reliable.
    CRC_byte = data_buffer_list[53]
    endy_byte1 = data_buffer_list[54]
    endy_byte2 = data_buffer_list[55]

    # ... (Code for Homed, IO_var, temp_error, etc. remains the same) ...

    temp = Split_2_bitfield(int.from_bytes(Homed,"big"))
    for i in range(8):
        Homed_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(IO_var,"big"))
    for i in range(8):
        InOut_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(temp_error,"big"))
    for i in range(8):
        Temperature_error_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(position_error,"big"))
    for i in range(8):
        Position_error_in[i] = temp[i]

    var = b'\x00' + b'\x00' + b''.join(timing_data)
    Timing_data_in[0] = Fuse_3_bytes(var)
    Timeout_error = int.from_bytes(Timeout_error_var,"big")
    XTR_data = int.from_bytes(xtr2,"big")

    # --- Gripper Data Unpacking ---
    Gripper_data_in[0] = int.from_bytes(device_ID,"big")

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_position)
    Gripper_data_in[1] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_speed)
    Gripper_data_in[2] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_current)
    Gripper_data_in[3] = Fuse_2_bytes(var)

    # --- Start of Corrected Logic ---
    # This section now mirrors the working logic from GUI_PAROL_latest.py
    
    # 1. Store the raw status byte (from index 51)
    status_byte = int.from_bytes(Status,"big")
    Gripper_data_in[4] = status_byte

    # 2. Split the status byte into a list of 8 individual bits
    status_bits = Split_2_bitfield(status_byte)
    
    # 3. Combine the 3rd and 4th bits (at indices 2 and 3) to get the true object detection status
    # This creates a 2-bit number (0-3) which represents the full state.
    object_detection_status = (status_bits[2] << 1) | status_bits[3]
    Gripper_data_in[5] = object_detection_status
    # --- End of Corrected Logic ---

def Pack_data(Position_out,Speed_out,Command_out,Affected_joint_out,InOut_out,Timeout_out,Gripper_data_out):

    # Len is defined by all bytes EXCEPT start bytes and len
    # Start bytes = 3
    len = 52 #1
    Position = [Position_out[0],Position_out[1],Position_out[2],Position_out[3],Position_out[4],Position_out[5]]  #18
    Speed = [Speed_out[0], Speed_out[1], Speed_out[2], Speed_out[3], Speed_out[4], Speed_out[5],] #18
    Command = Command_out#1
    Affected_joint = Affected_joint_out
    InOut = InOut_out #1
    Timeout = Timeout_out #1
    Gripper_data = Gripper_data_out #9
    CRC_byte = 228 #1
    # End bytes = 2


    test_list = []
    #print(test_list)

    #x = bytes(start_bytes)
    test_list.append((start_bytes))
    
    test_list.append(bytes([len]))


    # Position data
    for i in range(6):
        position_split = Split_2_3_bytes(Position[i])
        test_list.append(position_split[1:4])

    # Speed data
    for i in range(6):
        speed_split = Split_2_3_bytes(Speed[i])
        test_list.append(speed_split[1:4])

    # Command data
    test_list.append(bytes([Command]))

    # Affected joint data
    Affected_list = Fuse_bitfield_2_bytearray(Affected_joint[:])
    test_list.append(Affected_list)

    # Inputs outputs data
    InOut_list = Fuse_bitfield_2_bytearray(InOut[:])
    test_list.append(InOut_list)

    # Timeout data
    test_list.append(bytes([Timeout]))

    # Gripper position
    Gripper_position = Split_2_3_bytes(Gripper_data[0])
    test_list.append(Gripper_position[2:4])

    # Gripper speed
    Gripper_speed = Split_2_3_bytes(Gripper_data[1])
    test_list.append(Gripper_speed[2:4])

    # Gripper current
    Gripper_current = Split_2_3_bytes(Gripper_data[2])
    test_list.append(Gripper_current[2:4])  

    # Gripper command
    test_list.append(bytes([Gripper_data[3]]))
    # Gripper mode
    test_list.append(bytes([Gripper_data[4]]))
    
    # ==========================================================
    # === FIX: Make sure calibrate is a one-shot command      ====
    # ==========================================================
    # If the mode was set to calibrate (1) or clear_error (2), reset it
    # back to normal (0) for the next cycle. This prevents an endless loop.
    if Gripper_data_out[4] == 1 or Gripper_data_out[4] == 2:
        Gripper_data_out[4] = 0
    # ==========================================================
    
    # Gripper ID
    test_list.append(bytes([Gripper_data[5]]))
 
    # CRC byte
    test_list.append(bytes([CRC_byte]))

    # END bytes
    test_list.append((end_bytes))
    
    #print(test_list)
    return test_list

def Get_data(Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):
    global input_byte 

    global start_cond1_byte 
    global start_cond2_byte 
    global start_cond3_byte 

    global end_cond1_byte 
    global end_cond2_byte 

    global start_cond1 
    global start_cond2 
    global start_cond3 

    global good_start 
    global data_len 

    global data_buffer 
    global data_counter

    while (ser.inWaiting() > 0):
        input_byte = ser.read()

        #UNCOMMENT THIS TO GET ALL DATA FROM THE ROBOT PRINTED
        #print(input_byte) 

        # When data len is received start is good and after that put all data in receive buffer
        # Data len is ALL data after it; that includes input buffer, end bytes and CRC
        if (good_start != 1):
            # All start bytes are good and next byte is data len
            if (start_cond1 == 1 and start_cond2 == 1 and start_cond3 == 1):
                good_start = 1
                data_len = input_byte
                data_len = struct.unpack('B', data_len)[0]
                logging.debug("data len we got from robot packet= ")
                logging.debug(input_byte)
                logging.debug("good start for DATA that we received at PC")
            # Third start byte is good
            if (input_byte == start_cond3_byte and start_cond2 == 1 and start_cond1 == 1):
                start_cond3 = 1
                #print("good cond 3 PC")
            #Third start byte is bad, reset all flags
            elif (start_cond2 == 1 and start_cond1 == 1):
                #print("bad cond 3 PC")
                start_cond1 = 0
                start_cond2 = 0
            # Second start byte is good
            if (input_byte == start_cond2_byte and start_cond1 == 1):
                start_cond2 = 1
                #print("good cond 2 PC ")
            #Second start byte is bad, reset all flags   
            elif (start_cond1 == 1):
                #print("Bad cond 2 PC")
                start_cond1 = 0
            # First start byte is good
            if (input_byte == start_cond1_byte):
                start_cond1 = 1
                #print("good cond 1 PC")
        else:
            # Here data goes after good  start
            data_buffer[data_counter] = input_byte
            if (data_counter == data_len - 1):

                logging.debug("Data len PC")
                logging.debug(data_len)
                logging.debug("End bytes are:")
                logging.debug(data_buffer[data_len -1])
                logging.debug(data_buffer[data_len -2])

                # Here if last 2 bytes are end condition bytes we process the data 
                if (data_buffer[data_len -1] == end_cond2_byte and data_buffer[data_len - 2] == end_cond1_byte):

                    logging.debug("GOOD END CONDITION PC")
                    logging.debug("I UNPACKED RAW DATA RECEIVED FROM THE ROBOT")
                    Unpack_data(data_buffer, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
                    XTR_data,Gripper_data_in)
                    logging.debug("DATA UNPACK FINISHED")
                    # ako su dobri izraÄunaj crc
                    # if crc dobar raspakiraj podatke
                    # ako je dobar paket je dobar i spremi ga u nove variable!
                
                # Print every byte
                #print("podaci u data bufferu su:")
                #for i in range(data_len):
                    #print(data_buffer[i])

                good_start = 0
                start_cond1 = 0
                start_cond3 = 0
                start_cond2 = 0
                data_len = 0
                data_counter = 0
            else:
                data_counter = data_counter + 1

# Split data to 3 bytes 
def Split_2_3_bytes(var_in):
    y = int_to_3_bytes(var_in & 0xFFFFFF) # converts my int value to bytes array
    return y

# Splits byte to bitfield list
def Split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]

# Fuses 3 bytes to 1 signed int
def Fuse_3_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<23:
        value -= 1<<24

    return value

# Fuses 2 bytes to 1 signed int
def Fuse_2_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<15:
        value -= 1<<16

    return value

# Fuse bitfield list to byte
def Fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Check if there is element 1 in the list. 
# If yes return its index, if no element is 1 return -1
def check_elements(lst):
    for i, element in enumerate(lst):
        if element == 1:
            return i
    return -1  # Return -1 if no element is 1

def quintic_scaling(s: float) -> float:
    """
    Calculates a smooth 0-to-1 scaling factor for progress 's'
    using a quintic polynomial, ensuring smooth start/end accelerations.
    """
    return 6 * (s**5) - 15 * (s**4) + 10 * (s**3)

#########################################################################
# Robot Commands Start Here
#########################################################################

class HomeCommand:
    """
    A non-blocking command that tells the robot to perform its internal homing sequence.
    This version uses a state machine to allow re-homing even if the robot is already homed.
    """
    def __init__(self):
        self.is_valid = True
        self.is_finished = False
        # State machine: START -> WAIT_FOR_UNHOMED -> WAIT_FOR_HOMED -> FINISHED
        self.state = "START"
        # Counter to send the home command for multiple cycles
        self.start_cmd_counter = 10  # Send command 100 for 10 cycles (0.1s)
        # Safety timeout (20 seconds at 0.01s interval)
        self.timeout_counter = 2000
        print("Initializing Home command...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Manages the homing command and monitors for completion using a state machine.
        """
        if self.is_finished:
            return True

        # --- State: START ---
        # On the first few executions, continuously send the 'home' (100) command.
        if self.state == "START":
            print(f"  -> Sending home signal (100)... Countdown: {self.start_cmd_counter}")
            Command_out.value = 100
            self.start_cmd_counter -= 1
            if self.start_cmd_counter <= 0:
                # Once sent for enough cycles, move to the next state
                self.state = "WAITING_FOR_UNHOMED"
            return False

        # --- State: WAITING_FOR_UNHOMED ---
        # The robot's firmware should reset the homed status. We wait to see that happen.
        # During this time, we send 'idle' (255) to let the robot's controller take over.
        if self.state == "WAITING_FOR_UNHOMED":
            Command_out.value = 255
            # Check if at least one joint has started homing (is no longer homed)
            if any(h == 0 for h in Homed_in[:6]):
                print("  -> Homing sequence initiated by robot.")
                self.state = "WAITING_FOR_HOMED"
            # Check for timeout
            self.timeout_counter -= 1
            if self.timeout_counter <= 0:
                print("  -> ERROR: Timeout waiting for robot to start homing sequence.")
                self.is_finished = True
            return self.is_finished

        # --- State: WAITING_FOR_HOMED ---
        # Now we wait for all joints to report that they are homed (all flags are 1).
        if self.state == "WAITING_FOR_HOMED":
            Command_out.value = 255
            # Check if all joints have finished homing
            if all(h == 1 for h in Homed_in[:6]):
                print("Homing sequence complete. All joints reported home.")
                self.is_finished = True
                Speed_out[:] = [0] * 6 # Ensure robot is stopped

        return self.is_finished

class JogCommand:
    """
    A non-blocking command to jog a joint for a specific duration or distance.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joint, speed_percentage=None, duration=None, distance_deg=None):
        """
        Initializes and validates the jog command. This is the SETUP phase.
        """
        self.is_valid = False
        self.is_finished = False
        self.mode = None
        self.command_step = 0

        # --- 1. Parameter Validation and Mode Selection ---
        if duration and distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Distance {distance_deg} deg, Duration {duration}s.")
        elif duration:
            self.mode = 'time'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Duration {duration}s.")
        elif distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Distance {distance_deg} deg.")
        else:
            print("Error: JogCommand requires either 'duration', 'distance_deg', or both.")
            return

        # --- 2. Store parameters for deferred calculation ---
        self.joint = joint
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.distance_deg = distance_deg

        # --- These will be calculated later ---
        self.direction = 1
        self.joint_index = 0
        self.speed_out = 0
        self.command_len = 0
        self.target_position = 0

        self.is_valid = True # Mark as valid for now; preparation step will confirm.


    def prepare_for_execution(self, current_position_in):
        """Pre-computes speeds and target positions using live data."""
        print(f"  -> Preparing for Jog command...")

        # Determine direction and joint index
        self.direction = 1 if 0 <= self.joint <= 5 else -1
        self.joint_index = self.joint if self.direction == 1 else self.joint - 6
        
        distance_steps = 0
        if self.distance_deg:
            distance_steps = int(PAROL6_ROBOT.DEG2STEPS(abs(self.distance_deg), self.joint_index))
            # --- MOVED LOGIC: Calculate target using the LIVE position ---
            self.target_position = current_position_in[self.joint_index] + (distance_steps * self.direction)
            
            min_limit, max_limit = PAROL6_ROBOT.Joint_limits_steps[self.joint_index]
            if not (min_limit <= self.target_position <= max_limit):
                print(f"  -> VALIDATION FAILED: Target position {self.target_position} is out of joint limits ({min_limit}, {max_limit}).")
                self.is_valid = False
                return

        # Calculate speed and duration
        speed_steps_per_sec = 0
        if self.mode == 'distance' and self.duration:
            speed_steps_per_sec = int(distance_steps / self.duration) if self.duration > 0 else 0
            max_joint_speed = PAROL6_ROBOT.Joint_max_speed[self.joint_index]
            if speed_steps_per_sec > max_joint_speed:
                print(f"  -> VALIDATION FAILED: Required speed ({speed_steps_per_sec} steps/s) exceeds joint's max speed ({max_joint_speed} steps/s).")
                self.is_valid = False
                return
        else:
            if self.speed_percentage is None:
                print("Error: 'speed_percentage' must be provided if not calculating automatically.")
                self.is_valid = False
                return
            speed_steps_per_sec = int(np.interp(abs(self.speed_percentage), [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[self.joint_index] * 2]))

        self.speed_out = speed_steps_per_sec * self.direction
        self.command_len = int(self.duration / INTERVAL_S) if self.duration else float('inf')
        print("  -> Jog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        stop_reason = None
        current_pos = Position_in[self.joint_index]

        if self.mode == 'time':
            if self.command_step >= self.command_len:
                stop_reason = "Timed jog finished."
        elif self.mode == 'distance':
            if (self.direction == 1 and current_pos >= self.target_position) or \
               (self.direction == -1 and current_pos <= self.target_position):
                stop_reason = "Distance jog finished."
        
        if not stop_reason:
            if (self.direction == 1 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][1]) or \
               (self.direction == -1 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][0]):
                stop_reason = f"Limit reached on joint {self.joint_index + 1}."

        if stop_reason:
            print(stop_reason)
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            Speed_out[:] = [0] * 6
            Speed_out[self.joint_index] = self.speed_out
            Command_out.value = 123
            self.command_step += 1
            return False
        
class MultiJogCommand:
    """
    A non-blocking command to jog multiple joints simultaneously for a specific duration.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joints, speed_percentages, duration):
        """
        Initializes and validates the multi-jog command.
        """
        self.is_valid = False
        self.is_finished = False
        self.command_step = 0

        # --- 1. Parameter Validation ---
        if not isinstance(joints, list) or not isinstance(speed_percentages, list):
            print("Error: MultiJogCommand requires 'joints' and 'speed_percentages' to be lists.")
            return

        if len(joints) != len(speed_percentages):
            print("Error: The number of joints must match the number of speed percentages.")
            return

        if not duration or duration <= 0:
            print("Error: MultiJogCommand requires a positive 'duration'.")
            return

        # ==========================================================
        # === NEW: Check for conflicting joint commands          ===
        # ==========================================================
        base_joints = set()
        for joint in joints:
            # Normalize the joint index to its base (0-5)
            base_joint = joint % 6
            # If the base joint is already in our set, it's a conflict.
            if base_joint in base_joints:
                print(f"  -> VALIDATION FAILED: Conflicting commands for Joint {base_joint + 1} (e.g., J1+ and J1-).")
                self.is_valid = False
                return
            base_joints.add(base_joint)
        # ==========================================================

        print(f"Initializing MultiJog for joints {joints} with speeds {speed_percentages}% for {duration}s.")

        # --- 2. Store parameters ---
        self.joints = joints
        self.speed_percentages = speed_percentages
        self.duration = duration
        self.command_len = int(self.duration / INTERVAL_S)

        # --- This will be calculated in the prepare step ---
        self.speeds_out = [0] * 6

        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Pre-computes the speeds for each joint."""
        print(f"  -> Preparing for MultiJog command...")

        for i, joint in enumerate(self.joints):
            # Determine direction and joint index (0-5 for positive, 6-11 for negative)
            direction = 1 if 0 <= joint <= 5 else -1
            joint_index = joint if direction == 1 else joint - 6
            speed_percentage = self.speed_percentages[i]

            # Check for joint index validity
            if not (0 <= joint_index < 6):
                print(f"  -> VALIDATION FAILED: Invalid joint index {joint_index}.")
                self.is_valid = False
                return

            # Calculate speed in steps/sec
            speed_steps_per_sec = int(np.interp(speed_percentage, [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[joint_index]]))
            self.speeds_out[joint_index] = speed_steps_per_sec * direction

        print("  -> MultiJog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        # Stop if the duration has elapsed
        if self.command_step >= self.command_len:
            print("Timed multi-jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            # Continuously check for joint limits during the jog
            for i in range(6):
                if self.speeds_out[i] != 0:
                    current_pos = Position_in[i]
                    # Hitting positive limit while moving positively
                    if self.speeds_out[i] > 0 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[i][1]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True
                    # Hitting negative limit while moving negatively
                    elif self.speeds_out[i] < 0 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[i][0]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True

            # If no limits are hit, apply the speeds
            Speed_out[:] = self.speeds_out
            Command_out.value = 123 # Jog command
            self.command_step += 1
            return False # Command is still running
        
# This dictionary maps descriptive axis names to movement vectors, which is cleaner.
# Format: ([x, y, z], [rx, ry, rz])
AXIS_MAP = {
    'X+': ([1, 0, 0], [0, 0, 0]), 'X-': ([-1, 0, 0], [0, 0, 0]),
    'Y+': ([0, 1, 0], [0, 0, 0]), 'Y-': ([0, -1, 0], [0, 0, 0]),
    'Z+': ([0, 0, 1], [0, 0, 0]), 'Z-': ([0, 0, -1], [0, 0, 0]),
    'RX+': ([0, 0, 0], [1, 0, 0]), 'RX-': ([0, 0, 0], [-1, 0, 0]),
    'RY+': ([0, 0, 0], [0, 1, 0]), 'RY-': ([0, 0, 0], [0, -1, 0]),
    'RZ+': ([0, 0, 0], [0, 0, 1]), 'RZ-': ([0, 0, 0], [0, 0, -1]),
}

class CartesianJogCommand:
    """
    A non-blocking command to jog the robot's end-effector in Cartesian space.
    This is the final, refactored version using clean, standard spatial math
    operations now that the core unit bug has been fixed.
    """
    def __init__(self, frame, axis, speed_percentage=50, duration=1.5, **kwargs):
        """
        Initializes and validates the Cartesian jog command.
        """
        self.is_valid = False
        self.is_finished = False
        print(f"Initializing CartesianJog: Frame {frame}, Axis {axis}...")

        if axis not in AXIS_MAP:
            print(f"  -> VALIDATION FAILED: Invalid axis '{axis}'.")
            return
        
        # Store all necessary parameters for use in execute_step
        self.frame = frame
        self.axis_vectors = AXIS_MAP[axis]
        self.is_rotation = any(self.axis_vectors[1])
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.end_time = time.time() + self.duration
        
        self.is_valid = True
        print("  -> Command is valid and ready.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Check for completion ---
        if time.time() >= self.end_time:
            print("Cartesian jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- B. Calculate Target Pose using clean vector math ---
        Command_out.value = 123 # Set jog command
        
        q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        T_current = PAROL6_ROBOT.robot.fkine(q_current)

        if not isinstance(T_current, SE3):
            return False # Wait for valid pose data

        # Calculate speed and displacement for this cycle
        linear_speed_ms = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min_JOG, PAROL6_ROBOT.Cartesian_linear_velocity_max_JOG]))
        angular_speed_degs = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max]))

        delta_linear = linear_speed_ms * INTERVAL_S
        delta_angular_rad = np.deg2rad(angular_speed_degs * INTERVAL_S)

        # Create the small incremental transformation (delta_pose)
        trans_vec = np.array(self.axis_vectors[0]) * delta_linear
        rot_vec = np.array(self.axis_vectors[1]) * delta_angular_rad
        delta_pose = SE3.Rt(SE3.Eul(rot_vec).R, trans_vec)

        # Apply the transformation in the correct reference frame
        if self.frame == 'WRF':
            # Pre-multiply to apply the change in the World Reference Frame
            target_pose = delta_pose * T_current
        else: # TRF
            # Post-multiply to apply the change in the Tool Reference Frame
            target_pose = T_current * delta_pose
        
        # --- C. Solve IK and Calculate Velocities ---
        var = solve_ik_with_adaptive_tol_subdivision(PAROL6_ROBOT.robot, target_pose, q_current, jogging=True)

        if var.success:
            q_velocities = (var.q - q_current) / INTERVAL_S
            for i in range(6):
                Speed_out[i] = int(PAROL6_ROBOT.SPEED_RAD2STEP(q_velocities[i], i))
        else:
            print("IK Warning: Could not find solution for jog step. Stopping.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- D. Speed Scaling ---
        max_scale_factor = 1.0
        for i in range(6):
            if abs(Speed_out[i]) > PAROL6_ROBOT.Joint_max_speed[i]:
                scale = abs(Speed_out[i]) / PAROL6_ROBOT.Joint_max_speed[i]
                if scale > max_scale_factor:
                    max_scale_factor = scale
        
        if max_scale_factor > 1.0:
            for i in range(6):
                Speed_out[i] = int(Speed_out[i] / max_scale_factor)

        return False # Command is still running

class MovePoseCommand:
    """
    A non-blocking command to move the robot to a specific Cartesian pose.
    The movement itself is a joint-space interpolation.
    """
    def __init__(self, pose, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = True  # Assume valid; preparation step will confirm.
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MovePose to {pose}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.pose = pose
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

    """
        Initializes, validates, and pre-computes the trajectory for a move-to-pose command.

        Args:
            pose (list): A list of 6 values [x, y, z, r, p, y] for the target pose.
                         Positions are in mm, rotations are in degrees.
            duration (float, optional): The total time for the movement in seconds.
            velocity_percent (float, optional): The target velocity as a percentage (0-100).
            accel_percent (float, optional): The target acceleration as a percentage (0-100).
            trajectory_type (str, optional): The type of trajectory ('poly' or 'trap').
        """
    
    def prepare_for_execution(self, current_position_in):
        """Calculates the full trajectory just-in-time before execution."""
        print(f"  -> Preparing trajectory for MovePose to {self.pose}...")

        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pose = SE3(self.pose[0] / 1000.0, self.pose[1] / 1000.0, self.pose[2] / 1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')
        
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_pose, initial_pos_rad, ilimit=100)

        if not ik_solution.success:
            print("  -> VALIDATION FAILED: Inverse kinematics failed at execution time.")
            self.is_valid = False
            return

        target_pos_rad = ik_solution.q

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])

                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue
                    
                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)
            
                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                self.is_valid = False
                return

        else:
            print("  -> Using conservative values for MovePose.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveJointCommand:
    """
    A non-blocking command to move the robot's joints to a specific configuration.
    It pre-calculates the entire trajectory upon initialization.
    """
    def __init__(self, target_angles, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = False  # Will be set to True after basic validation
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MoveJoint to {target_angles}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.target_angles = target_angles
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

        # --- Perform only state-independent validation ---
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])
        for i in range(6):
            min_rad, max_rad = PAROL6_ROBOT.Joint_limits_radian[i]
            if not (min_rad <= target_pos_rad[i] <= max_rad):
                print(f"  -> VALIDATION FAILED: Target for Joint {i+1} ({self.target_angles[i]} deg) is out of range.")
                return
        
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Calculates the trajectory just before execution begins."""
        print(f"  -> Preparing trajectory for MoveJoint to {self.target_angles}...")
        
        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])
                
                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue

                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)

                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                print(f"  -> Please check Joint_min/max_speed and Joint_min/max_acc values in PAROL6_ROBOT.py.")
                self.is_valid = False
                return
        
        else:
            print("  -> Using conservative values for MoveJoint.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveCartCommand:
    """
    A non-blocking command to move the robot's end-effector in a straight line
    in Cartesian space, completing the move in an exact duration.

    It works by:
    1. Pre-validating the final target pose.
    2. Interpolating the pose in Cartesian space in real-time.
    3. Solving Inverse Kinematics for each intermediate step to ensure path validity.
    """
    def __init__(self, pose, duration=None, velocity_percent=None):
        self.is_valid = False
        self.is_finished = False

        # --- MODIFICATION: Validate that at least one timing parameter is given ---
        if duration is None and velocity_percent is None:
            print("  -> VALIDATION FAILED: MoveCartCommand requires either 'duration' or 'velocity_percent'.")
            return
        if duration is not None and velocity_percent is not None:
            print("  -> INFO: Both duration and velocity_percent provided. Using duration.")
            self.velocity_percent = None # Prioritize duration
        else:
            self.velocity_percent = velocity_percent

        # --- Store parameters and set placeholders ---
        self.duration = duration
        self.pose = pose
        self.start_time = None
        self.initial_pose = None
        self.target_pose = None
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Captures the initial state and validates the path just before execution."""
        print(f"  -> Preparing for MoveCart to {self.pose}...")
        
        # --- MOVED LOGIC: Capture initial state from live data ---
        initial_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        self.initial_pose = PAROL6_ROBOT.robot.fkine(initial_q_rad)
        self.target_pose = SE3(self.pose[0]/1000.0, self.pose[1]/1000.0, self.pose[2]/1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')

        print("  -> Pre-validating final target pose...")
        ik_check = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, self.target_pose, initial_q_rad
        )

        if not ik_check.success:
            print("  -> VALIDATION FAILED: The final target pose is unreachable.")
            if ik_check.violations:
                print(f"     Reason: Solution violates joint limits: {ik_check.violations}")
            self.is_valid = False # Mark as invalid if path fails
            return

        # --- NEW BLOCK: Calculate duration from velocity if needed ---
        if self.velocity_percent is not None:
            print(f"  -> Calculating duration for {self.velocity_percent}% speed...")
            # Calculate the total distance for translation and rotation
            linear_distance = np.linalg.norm(self.target_pose.t - self.initial_pose.t)
            angular_distance_rad = self.initial_pose.angdist(self.target_pose)

            # Interpolate the target speeds from percentages, assuming constants exist in PAROL6_ROBOT
            target_linear_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min, PAROL6_ROBOT.Cartesian_linear_velocity_max])
            target_angular_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max])
            target_angular_speed_rad = np.deg2rad(target_angular_speed)

            # Calculate time required for each component of the movement
            time_linear = linear_distance / target_linear_speed if target_linear_speed > 0 else 0
            time_angular = angular_distance_rad / target_angular_speed_rad if target_angular_speed_rad > 0 else 0

            # The total duration is the longer of the two times to ensure synchronization
            calculated_duration = max(time_linear, time_angular)

            if calculated_duration <= 0:
                print("  -> INFO: MoveCart has zero duration. Marking as finished.")
                self.is_finished = True
                self.is_valid = True # It's valid, just already done.
                return

            self.duration = calculated_duration
            print(f"  -> Calculated MoveCart duration: {self.duration:.2f}s")

        print("  -> Command is valid and ready for execution.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        if self.start_time is None:
            self.start_time = time.time()

        elapsed_time = time.time() - self.start_time
        s = min(elapsed_time / self.duration, 1.0)
        s_scaled = quintic_scaling(s)

        current_target_pose = self.initial_pose.interp(self.target_pose, s_scaled)

        current_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, current_target_pose, current_q_rad
        )

        if not ik_solution.success:
            print("  -> ERROR: MoveCart failed. An intermediate point on the path is unreachable.")
            if ik_solution.violations:
                 print(f"     Reason: Path violates joint limits: {ik_solution.violations}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        current_pos_rad = ik_solution.q

        # --- MODIFIED BLOCK ---
        # Send only the target position and let the firmware's P-controller handle speed.
        Position_out[:] = [int(PAROL6_ROBOT.RAD2STEPS(p, i)) for i, p in enumerate(current_pos_rad)]
        Speed_out[:] = [0] * 6 # Set feed-forward velocity to zero for smooth P-control.
        Command_out.value = 156
        # --- END MODIFIED BLOCK ---

        if s >= 1.0:
            print(f"MoveCart finished in ~{elapsed_time:.2f}s.")
            self.is_finished = True
            # The main loop will handle holding the final position.

        return self.is_finished
        
class GripperCommand:
    """
    A single, unified, non-blocking command to control all gripper functions.
    It internally selects the correct logic (position-based waiting, timed delay,
    or instantaneous) based on the specified action.
    """
    def __init__(self, gripper_type, action=None, position=100, speed=100, current=500, output_port=1):
        """
        Initializes the Gripper command and configures its internal state machine
        based on the requested action.
        """
        self.is_valid = True
        self.is_finished = False
        self.gripper_type = gripper_type.lower()
        self.action = action.lower() if action else 'move'
        self.state = "START"
        self.timeout_counter = 1000 # 10-second safety timeout for all waiting states

        # --- Configure based on Gripper Type and Action ---
        if self.gripper_type == 'electric':
            if self.action == 'move':
                self.target_position = position
                self.speed = speed
                self.current = current
                if not (0 <= position <= 255 and 0 <= speed <= 255 and 100 <= current <= 1000):
                    self.is_valid = False
            elif self.action == 'calibrate':
                self.wait_counter = 200 # 2-second fixed delay for calibration
            else:
                self.is_valid = False # Invalid action

        elif self.gripper_type == 'pneumatic':
            if self.action not in ['open', 'close']:
                self.is_valid = False
            self.state_to_set = 1 if self.action == 'open' else 0
            self.port_index = 2 if output_port == 1 else 3
        else:
            self.is_valid = False

        if not self.is_valid:
            print(f"  -> VALIDATION FAILED for GripperCommand with action: '{self.action}'")

    def execute_step(self, Gripper_data_out, InOut_out, Gripper_data_in, InOut_in, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        self.timeout_counter -= 1
        if self.timeout_counter <= 0:
            print(f"  -> ERROR: Gripper command timed out in state {self.state}.")
            self.is_finished = True
            return True

        # --- Pneumatic Logic (Instantaneous) ---
        if self.gripper_type == 'pneumatic':
            InOut_out[self.port_index] = self.state_to_set
            print("  -> Pneumatic gripper command sent.")
            self.is_finished = True
            return True

        # --- Electric Gripper Logic ---
        if self.gripper_type == 'electric':
            # On the first run, transition to the correct state for the action
            if self.state == "START":
                if self.action == 'calibrate':
                    self.state = "SEND_CALIBRATE"
                else: # 'move'
                    self.state = "WAIT_FOR_POSITION"
            
            # --- Calibrate Logic (Timed Delay) ---
            if self.state == "SEND_CALIBRATE":
                print("  -> Sending one-shot calibrate command...")
                Gripper_data_out[4] = 1 # Set mode to calibrate
                self.state = "WAITING_CALIBRATION"
                return False

            if self.state == "WAITING_CALIBRATION":
                self.wait_counter -= 1
                if self.wait_counter <= 0:
                    print("  -> Calibration delay finished.")
                    Gripper_data_out[4] = 0 # Reset to operation mode
                    self.is_finished = True
                    return True
                return False

            # --- Move Logic (Position-Based) ---
            if self.state == "WAIT_FOR_POSITION":
                # Persistently send the move command
                Gripper_data_out[0], Gripper_data_out[1], Gripper_data_out[2] = self.target_position, self.speed, self.current
                Gripper_data_out[4] = 0 # Operation mode
                bitfield = [1, 1, not InOut_in[4], 1, 0, 0, 0, 0]
                fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                Gripper_data_out[3] = int(fused.hex(), 16)

                # Check for completion
                current_position = Gripper_data_in[1]
                if abs(current_position - self.target_position) <= 5:
                    print(f"  -> Gripper move complete.")
                    self.is_finished = True
                    # Set command back to idle
                    bitfield = [1, 0, not InOut_in[4], 1, 0, 0, 0, 0]
                    fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                    Gripper_data_out[3] = int(fused.hex(), 16)
                    return True
                return False
        
        return self.is_finished

class DelayCommand:
    """
    A non-blocking command that pauses execution for a specified duration.
    During the delay, it ensures the robot remains idle by sending the
    appropriate commands.
    """
    def __init__(self, duration):
        """
        Initializes and validates the Delay command.

        Args:
            duration (float): The delay time in seconds.
        """
        self.is_valid = False
        self.is_finished = False

        # --- 1. Parameter Validation ---
        if not isinstance(duration, (int, float)) or duration <= 0:
            print(f"  -> VALIDATION FAILED: Delay duration must be a positive number, but got {duration}.")
            return

        print(f"Initializing Delay for {duration} seconds...")
        
        self.duration = duration
        self.end_time = None  # Will be set in prepare_for_execution
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Set the end time when the command actually starts."""
        self.end_time = time.time() + self.duration
        print(f"  -> Delay starting for {self.duration} seconds...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Checks if the delay duration has passed and keeps the robot idle.
        This method is called on every loop cycle (~0.01s).
        """
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Keep the robot idle during the delay ---
        Command_out.value = 255  # Set command to idle
        Speed_out[:] = [0] * 6   # Set all speeds to zero

        # --- B. Check for completion ---
        if self.end_time and time.time() >= self.end_time:
            print(f"Delay finished after {self.duration} seconds.")
            self.is_finished = True
        
        return self.is_finished
    
#########################################################################
# Smooth Motion Commands Start Here
#########################################################################
    
class BaseSmoothMotionCommand:
    """
    Base class for all smooth motion commands with proper error tracking.
    """
    
    def __init__(self, description="smooth motion"):
        self.description = description
        self.trajectory = None
        self.trajectory_command = None
        self.transition_command = None
        self.is_valid = True
        self.is_finished = False
        self.specified_start_pose = None
        self.transition_complete = False
        self.trajectory_prepared = False
        self.error_state = False
        self.error_message = ""
        self.trajectory_generated = False  # NEW: Track if trajectory is generated
        
    def create_transition_command(self, current_pose, target_pose):
        """Create a MovePose command for smooth transition to start position."""
        pos_error = np.linalg.norm(
            np.array(target_pose[:3]) - np.array(current_pose[:3])
        )
        
        # Lower threshold to 2mm for more aggressive transition generation
        if pos_error < 2.0:  # Changed from 5.0mm to 2.0mm
            print(f"  -> Already near start position (error: {pos_error:.1f}mm)")
            return None
        
        print(f"  -> Creating smooth transition to start ({pos_error:.1f}mm away)")
        
        # Calculate transition speed based on distance
        # Slower for short distances, faster for long distances
        if pos_error < 10:
            transition_speed = 20.0  # mm/s for short distances
        elif pos_error < 30:
            transition_speed = 30.0  # mm/s for medium distances
        else:
            transition_speed = 40.0  # mm/s for long distances
        
        transition_duration = max(pos_error / transition_speed, 0.5)  # Minimum 0.5s
        
        transition_cmd = MovePoseCommand(
            pose=target_pose,
            duration=transition_duration
        )
        
        return transition_cmd
    
    def get_current_pose_from_position(self, position_in):
        """Convert current position to pose [x,y,z,rx,ry,rz]"""
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(position_in)])
        current_pose_se3 = PAROL6_ROBOT.robot.fkine(current_q)
        
        current_xyz = current_pose_se3.t * 1000  # Convert to mm
        current_rpy = current_pose_se3.rpy(unit='deg', order='xyz')
        return np.concatenate([current_xyz, current_rpy]).tolist()
        
    def prepare_for_execution(self, current_position_in):
        """Minimal preparation - just check if we need a transition."""
        print(f"  -> Preparing {self.description}...")
        
        # If there's a specified start pose, prepare transition
        if self.specified_start_pose:
            actual_current_pose = self.get_current_pose_from_position(current_position_in)
            self.transition_command = self.create_transition_command(
                actual_current_pose, self.specified_start_pose
            )
            
            if self.transition_command:
                self.transition_command.prepare_for_execution(current_position_in)
                if not self.transition_command.is_valid:
                    print(f"  -> ERROR: Cannot reach specified start position")
                    self.is_valid = False
                    self.error_state = True
                    self.error_message = "Cannot reach specified start position"
                    return
        else:
            self.transition_command = None
            
        # DON'T generate trajectory yet - wait until execution
        self.trajectory_generated = False
        self.trajectory_prepared = False
        print(f"  -> {self.description} preparation complete (trajectory will be generated at execution)")
            
    def generate_main_trajectory(self, effective_start_pose):
        """Override this in subclasses to generate the specific motion trajectory."""
        raise NotImplementedError("Subclasses must implement generate_main_trajectory")
        
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """Execute transition first if needed, then generate and execute trajectory."""
        if self.is_finished or not self.is_valid:
            return True
        
        # Execute transition first if needed
        if self.transition_command and not self.transition_complete:
            is_done = self.transition_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            if is_done:
                print(f"  -> Transition complete")
                self.transition_complete = True
            return False
        
        # Generate trajectory on first execution step (not during preparation!)
        if not self.trajectory_generated:
            # Get ACTUAL current position NOW
            actual_current_pose = self.get_current_pose_from_position(Position_in)
            print(f"  -> Generating {self.description} from ACTUAL position: {[round(p, 1) for p in actual_current_pose[:3]]}")
            
            # Generate trajectory from where we ACTUALLY are
            self.trajectory = self.generate_main_trajectory(actual_current_pose)
            self.trajectory_command = SmoothTrajectoryCommand(
                self.trajectory, self.description
            )
            
            # Quick validation of first point only
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(Position_in)])
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
            )
            
            if not ik_result.success:
                print(f"  -> ERROR: Cannot reach first trajectory point")
                self.is_finished = True
                self.error_state = True
                self.error_message = "Cannot reach trajectory start"
                Speed_out[:] = [0] * 6
                Command_out.value = 255
                return True
                
            self.trajectory_generated = True
            self.trajectory_prepared = True
            
            # Verify first point is close to current
            distance = np.linalg.norm(first_pose[:3] - np.array(actual_current_pose[:3]))
            if distance > 5.0:
                print(f"  -> WARNING: First trajectory point {distance:.1f}mm from current!")
        
        # Execute main trajectory
        if self.trajectory_command and self.trajectory_prepared:
            is_done = self.trajectory_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            # Check for errors in trajectory execution
            if hasattr(self.trajectory_command, 'error_state') and self.trajectory_command.error_state:
                self.error_state = True
                self.error_message = self.trajectory_command.error_message
            
            if is_done:
                self.is_finished = True
            
            return is_done
        else:
            self.is_finished = True
            return True

class SmoothTrajectoryCommand:
    """Command class for executing pre-generated smooth trajectories."""
    
    def __init__(self, trajectory, description="smooth motion"):
        self.trajectory = np.array(trajectory)
        self.description = description
        self.trajectory_index = 0
        self.is_valid = True
        self.is_finished = False
        self.first_step = True
        self.error_state = False
        self.error_message = ""
        
        print(f"Initializing smooth {description} with {len(trajectory)} points")
    
    def prepare_for_execution(self, current_position_in):
        """Skip validation - trajectory is already generated from correct position"""
        # No validation needed since trajectory was just generated from current position
        self.is_valid = True
        return
    
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, Position_out=None, **kwargs):
        """Execute one step of the smooth trajectory"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Get Position_out from kwargs if not provided
        if Position_out is None:
            Position_out = kwargs.get('Position_out', Position_in)
        
        if self.trajectory_index >= len(self.trajectory):
            print(f"Smooth {self.description} finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get target pose for this step
        target_pose = self.trajectory[self.trajectory_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                            for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
        )
        
        if not ik_result.success:
            print(f"  -> IK failed at trajectory point {self.trajectory_index}")
            self.is_finished = True
            self.error_state = True
            self.error_message = f"IK failed at point {self.trajectory_index}/{len(self.trajectory)}"
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                    for i, q in enumerate(ik_result.q)]
        
        # ADD VELOCITY LIMITING - This prevents violent movements
        if self.trajectory_index > 0:
            for i in range(6):
                step_diff = abs(target_steps[i] - Position_in[i])
                max_step_diff = PAROL6_ROBOT.Joint_max_speed[i] * 0.01  # Max steps in 10ms
                
                # Use 1.2x safety margin (not 2x as before)
                if step_diff > max_step_diff * 1.2:
                    #print(f"  -> WARNING: Joint {i+1} velocity limit exceeded at point {self.trajectory_index}")
                    #print(f"     Step difference: {step_diff}, Max allowed: {max_step_diff * 1.2:.1f}")
                    
                    # Clamp the motion
                    sign = 1 if target_steps[i] > Position_in[i] else -1
                    target_steps[i] = Position_in[i] + sign * int(max_step_diff)
        
        # Send position command
        Position_out[:] = target_steps
        Speed_out[:] = [0] * 6
        Command_out.value = 156
        
        # Advance to next point
        self.trajectory_index += 1
        
        return False

class SmoothCircleCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, plane, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"circle (r={radius}mm, {frame})")
        self.center = center
        self.radius = radius
        self.plane = plane
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame  # Store reference frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None  # Store for TRF transformation
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        # Store current position for potential use in generate_main_trajectory
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'center': self.center,
                'plane': self.plane
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_CIRCLE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Circle: center {self.center[:3]} (WRF), normal {self.normal_vector}")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_CIRCLE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        # Now do normal preparation with transformed parameters
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate circle starting from the actual start position."""
        motion_gen = CircularMotion()
        
        # Use transformed normal for TRF, or standard for WRF
        if self.normal_vector is not None:
            # TRF - use the transformed normal vector
            normal = np.array(self.normal_vector)
            print(f"    Using transformed normal: {normal.round(3)}")
        else:
            # WRF - use standard plane definition
            plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
            normal = np.array(plane_normals.get(self.plane, [0, 0, 1]))  # Convert to numpy array
            print(f"    Using WRF plane {self.plane} with normal: {normal}")
        
        print(f"    Generating circle from position: {[round(p, 1) for p in effective_start_pose[:3]]}")
        print(f"    Circle center: {[round(c, 1) for c in self.center]}")
        
        # Add geometry validation
        center_np = np.array(self.center)
        start_np = np.array(effective_start_pose[:3])
        
        # Project start point onto circle plane to check distance
        to_start = start_np - center_np
        to_start_plane = to_start - np.dot(to_start, normal) * normal
        distance_to_center = np.linalg.norm(to_start_plane)
        
        if abs(distance_to_center - self.radius) > self.radius * 0.3:
            print(f"    WARNING: Robot is {distance_to_center:.1f}mm from center, but radius is {self.radius:.1f}mm")
            print(f"    Circle geometry will be auto-corrected")
        
        # Generate circle that starts at effective_start_pose
        trajectory = motion_gen.generate_circle_3d(
            self.center, 
            self.radius, 
            normal,  # This normal now correctly represents the plane
            start_point=effective_start_pose[:3],
            duration=self.duration
        )
        
        if self.clockwise:
            trajectory = trajectory[::-1]
        
        # Update orientations to match start pose
        for i in range(len(trajectory)):
            trajectory[i][3:] = effective_start_pose[3:]
        
        return trajectory
    
class SmoothArcCenterCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, center, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"arc (center-based, {frame})")
        self.end_pose = end_pose
        self.center = center
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {
                'end_pose': self.end_pose,
                'center': self.center
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
            )
            self.end_pose = transformed['end_pose']
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc from actual start to end."""
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, self.center,
            normal=self.normal_vector,  # Use transformed normal if TRF
            clockwise=self.clockwise, duration=self.duration
        )
    
class SmoothArcParamCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, radius, arc_angle, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"parametric arc (r={radius}mm, Î¸={arc_angle}Â°, {frame})")
        self.end_pose = end_pose
        self.radius = radius
        self.arc_angle = arc_angle
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'end_pose': self.end_pose,
                'plane': 'XY'  # Default plane for parametric arc
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.end_pose = transformed['end_pose']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Parametric Arc: end {self.end_pose[:3]} (WRF)")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc based on radius and angle from actual start."""
        # Get start and end positions
        start_xyz = np.array(effective_start_pose[:3])
        end_xyz = np.array(self.end_pose[:3])
        
        # If we have a transformed normal (TRF), use it to define the arc plane
        if self.normal_vector is not None:
            normal = np.array(self.normal_vector)
            
            # Project start and end onto the plane perpendicular to normal
            # This ensures the arc stays in the correct plane for TRF
            
            # Find center of arc using radius and angle
            chord_vec = end_xyz - start_xyz
            chord_length = np.linalg.norm(chord_vec)
            
            if chord_length > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({chord_length:.1f}mm) for radius {self.radius}mm")
                self.radius = chord_length / 2 + 1
            
            # Calculate center position using the normal vector
            chord_mid = (start_xyz + end_xyz) / 2
            
            # Height from chord midpoint to arc center
            if chord_length > 0:
                h = np.sqrt(max(0, self.radius**2 - (chord_length/2)**2))
                
                # Find perpendicular in the plane defined by normal
                chord_dir = chord_vec / chord_length
                perp_in_plane = np.cross(normal, chord_dir)
                if np.linalg.norm(perp_in_plane) > 0.001:
                    perp_in_plane = perp_in_plane / np.linalg.norm(perp_in_plane)
                else:
                    # Chord is parallel to normal (shouldn't happen)
                    perp_in_plane = np.array([1, 0, 0])
                
                # Arc center
                if self.clockwise:
                    center_3d = chord_mid - h * perp_in_plane
                else:
                    center_3d = chord_mid + h * perp_in_plane
            else:
                center_3d = start_xyz
            
        else:
            # WRF - use XY plane (standard behavior)
            normal = np.array([0, 0, 1])
            
            # Calculate arc center in XY plane
            start_xy = start_xyz[:2]
            end_xy = end_xyz[:2]
            
            # Midpoint
            mid = (start_xy + end_xy) / 2
            
            # Distance between points
            d = np.linalg.norm(end_xy - start_xy)
            
            if d > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({d:.1f}mm) for radius {self.radius}mm")
                self.radius = d / 2 + 1
            
            # Height of arc center from midpoint
            h = np.sqrt(max(0, self.radius**2 - (d/2)**2))
            
            # Perpendicular direction
            if d > 0:
                perp = np.array([-(end_xy[1] - start_xy[1]), end_xy[0] - start_xy[0]])
                perp = perp / np.linalg.norm(perp)
            else:
                perp = np.array([1, 0])
            
            # Arc center (choose based on clockwise)
            if self.clockwise:
                center_2d = mid - h * perp
            else:
                center_2d = mid + h * perp
            
            # Use average Z for center
            center_3d = [center_2d[0], center_2d[1], (start_xyz[2] + end_xyz[2]) / 2]
        
        # Generate arc trajectory from actual start
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, center_3d.tolist(),
            normal=normal if self.normal_vector is not None else None,
            clockwise=self.clockwise, duration=self.duration
        )

class SmoothHelixCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, pitch, height, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"helix (h={height}mm, {frame})")
        self.center = center
        self.radius = radius
        self.pitch = pitch
        self.height = height
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.helix_axis = None
        self.up_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {'center': self.center}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_HELIX', params, 'TRF', current_position_in
            )
            self.center = transformed['center']
            self.helix_axis = transformed.get('helix_axis', [0, 0, 1])
            self.up_vector = transformed.get('up_vector', [0, 1, 0])
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_HELIX', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate helix with proper axis orientation."""
        num_revolutions = self.height / self.pitch if self.pitch > 0 else 1
        num_points = int(self.duration * 100)  # 100Hz
        
        # Get helix axis (default Z for WRF, transformed for TRF)
        if self.helix_axis is not None:
            axis = np.array(self.helix_axis)
        else:
            axis = np.array([0, 0, 1])  # Default vertical
        
        # Create orthonormal basis for helix
        if self.up_vector is not None:
            up = np.array(self.up_vector)
        else:
            # Find perpendicular to axis
            if abs(axis[2]) < 0.9:
                up = np.array([0, 0, 1])
            else:
                up = np.array([1, 0, 0])
        
        # Ensure up is perpendicular to axis
        up = up - np.dot(up, axis) * axis
        up = up / np.linalg.norm(up)
        
        # Create right vector
        right = np.cross(axis, up)
        
        # Calculate starting angle based on actual start position
        to_start = np.array(effective_start_pose[:3]) - np.array(self.center)
        # Project onto plane perpendicular to axis
        to_start_plane = to_start - np.dot(to_start, axis) * axis
        
        if np.linalg.norm(to_start_plane) > 0.001:
            to_start_normalized = to_start_plane / np.linalg.norm(to_start_plane)
            start_angle = np.arctan2(np.dot(to_start_normalized, up), 
                                    np.dot(to_start_normalized, right))
        else:
            start_angle = 0
        
        trajectory = []
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            
            angle = start_angle + 2 * np.pi * num_revolutions * t
            if self.clockwise:
                angle = start_angle - 2 * np.pi * num_revolutions * t
            
            # Position on helix
            pos = np.array(self.center) + \
                  self.radius * (np.cos(angle) * right + np.sin(angle) * up) + \
                  self.height * t * axis
            
            # Use orientation from effective start
            trajectory.append(np.concatenate([pos, effective_start_pose[3:]]))
        
        return np.array(trajectory)

class SmoothSplineCommand(BaseSmoothMotionCommand):
    def __init__(self, waypoints, duration, frame='WRF', start_pose=None):
        super().__init__(f"spline ({len(waypoints)} points, {frame})")
        self.waypoints = waypoints
        self.duration = duration
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform waypoints to WRF
            params = {'waypoints': self.waypoints}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_SPLINE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.waypoints = transformed['waypoints']
            
            print(f"  -> TRF Spline: transformed {len(self.waypoints)} waypoints to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_SPLINE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate spline starting from actual position."""
        motion_gen = SplineMotion()
        
        # Always start from the effective start pose
        first_wp_error = np.linalg.norm(
            np.array(self.waypoints[0][:3]) - np.array(effective_start_pose[:3])
        )
        
        if first_wp_error > 5.0:
            # First waypoint is far, prepend the start position
            modified_waypoints = [effective_start_pose] + self.waypoints
            print(f"    Added start position as first waypoint (distance: {first_wp_error:.1f}mm)")
        else:
            # Replace first waypoint with actual start to ensure continuity
            modified_waypoints = [effective_start_pose] + self.waypoints[1:]
            print(f"    Replaced first waypoint with actual start position")
        
        timestamps = np.linspace(0, self.duration, len(modified_waypoints))
        
        # Generate the spline trajectory
        trajectory = motion_gen.generate_cubic_spline(modified_waypoints, timestamps)
        
        print(f"    Generated spline with {len(trajectory)} points")
        
        return trajectory

class SmoothBlendCommand(BaseSmoothMotionCommand):
    def __init__(self, segment_definitions, blend_time, frame='WRF', start_pose=None):
        super().__init__(f"blended ({len(segment_definitions)} segments, {frame})")
        self.segment_definitions = segment_definitions
        self.blend_time = blend_time
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform all segment definitions to WRF
            params = {'segments': self.segment_definitions}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_BLEND', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.segment_definitions = transformed['segments']
            
            print(f"  -> TRF Blend: transformed {len(self.segment_definitions)} segments to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_BLEND', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate blended trajectory starting from actual position."""
        trajectories = []
        motion_gen_circle = CircularMotion()
        motion_gen_spline = SplineMotion()
        
        # Always start from effective start pose
        last_end_pose = effective_start_pose
        
        for i, seg_def in enumerate(self.segment_definitions):
            seg_type = seg_def['type']
            
            # First segment always starts from effective_start_pose
            segment_start = effective_start_pose if i == 0 else last_end_pose
            
            if seg_type == 'LINE':
                end = seg_def['end']
                duration = seg_def['duration']
                
                # Generate line segment from actual position
                num_points = int(duration * 100)
                timestamps = np.linspace(0, duration, num_points)
                
                traj = []
                for t in timestamps:
                    s = t / duration if duration > 0 else 1
                    # Interpolate position
                    pos = [
                        segment_start[j] * (1-s) + end[j] * s
                        for j in range(3)
                    ]
                    # Interpolate orientation
                    orient = [
                        segment_start[j+3] * (1-s) + end[j+3] * s
                        for j in range(3)
                    ]
                    traj.append(pos + orient)
                
                trajectories.append(np.array(traj))
                last_end_pose = end
                
            elif seg_type == 'ARC':
                end = seg_def['end']
                center = seg_def['center']
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Check if we have a transformed normal (from TRF)
                normal = seg_def.get('normal_vector', None)
                
                traj = motion_gen_circle.generate_arc_3d(
                    segment_start, end, center, 
                    normal=normal,  # Use transformed normal if available
                    clockwise=clockwise, duration=duration
                )
                trajectories.append(traj)
                last_end_pose = end
                
            elif seg_type == 'CIRCLE':
                center = seg_def['center']
                radius = seg_def['radius']
                plane = seg_def.get('plane', 'XY')
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Use transformed normal if available (from TRF)
                if 'normal_vector' in seg_def:
                    normal = seg_def['normal_vector']
                else:
                    plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
                    normal = plane_normals.get(plane, [0, 0, 1])
                
                traj = motion_gen_circle.generate_circle_3d(
                    center, radius, normal, 
                    start_point=segment_start[:3],
                    duration=duration
                )
                
                if clockwise:
                    traj = traj[::-1]
                    
                # Update orientations
                for j in range(len(traj)):
                    traj[j][3:] = segment_start[3:]
                    
                trajectories.append(traj)
                # Circle returns to start, so last pose is last point of trajectory
                last_end_pose = traj[-1].tolist()
                
            elif seg_type == 'SPLINE':
                waypoints = seg_def['waypoints']
                duration = seg_def['duration']
                
                # Check if first waypoint is close to segment start
                wp_error = np.linalg.norm(
                    np.array(waypoints[0][:3]) - np.array(segment_start[:3])
                )
                
                if wp_error > 5.0:
                    full_waypoints = [segment_start] + waypoints
                else:
                    full_waypoints = [segment_start] + waypoints[1:]
                
                timestamps = np.linspace(0, duration, len(full_waypoints))
                traj = motion_gen_spline.generate_cubic_spline(full_waypoints, timestamps)
                trajectories.append(traj)
                last_end_pose = waypoints[-1]
        
        # Blend all trajectories
        if len(trajectories) > 1:
            blender = MotionBlender(self.blend_time)
            blended = trajectories[0]
            blend_samples = int(self.blend_time * 100)
            
            for i in range(1, len(trajectories)):
                blended = blender.blend_trajectories(blended, trajectories[i], blend_samples)
            
            print(f"    Blended {len(trajectories)} segments into {len(blended)} points")
            return blended
        elif trajectories:
            return trajectories[0]
        else:
            raise ValueError("No trajectories generated in blend")
        
def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
    """
    Calculate duration based on trajectory length and speed percentage.
    
    Args:
        trajectory_length: Total path length in mm
        speed_percentage: Speed as percentage (1-100)
        
    Returns:
        Duration in seconds
    """
    # Map speed percentage to mm/s (adjustable based on robot capabilities)
    # For example: 100% = 100mm/s, 50% = 50mm/s
    speed_mm_s = np.interp(speed_percentage, [0, 100], 
                          [PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000,
                           PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000])
    
    if speed_mm_s > 0:
        return trajectory_length / speed_mm_s
    else:
        return 5.0  # Default fallback
    
def parse_smooth_motion_commands(parts):
    """
    Parse smooth motion commands received via UDP and create appropriate command objects.
    All commands support:
    - Reference frame selection (WRF or TRF)
    - Optional start position (CURRENT or specified pose)
    - Both DURATION and SPEED timing modes
    
    Args:
        parts: List of command parts split by '|'
        
    Returns:
        Command object or None if parsing fails
    """
    command_type = parts[0]
    
    # Helper function for parsing optional start pose
    def parse_start_pose(start_str):
        """Parse start pose - returns None for CURRENT, or list of floats for specified pose."""
        if start_str == 'CURRENT' or start_str == 'NONE':
            return None
        else:
            try:
                return list(map(float, start_str.split(',')))
            except:
                print(f"Warning: Invalid start pose format: {start_str}")
                return None
    
    # Helper function for calculating duration from speed
    def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
        """Calculate duration based on trajectory length and speed percentage."""
        # Map speed percentage to mm/s
        min_speed = PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000  # Convert to mm/s
        max_speed = PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000  # Convert to mm/s
        speed_mm_s = np.interp(speed_percentage, [0, 100], [min_speed, max_speed])
        
        if speed_mm_s > 0:
            return trajectory_length / speed_mm_s
        else:
            return 5.0  # Default fallback
    
    try:
        if command_type == 'SMOOTH_CIRCLE':
            # Format: SMOOTH_CIRCLE|center_x,center_y,center_z|radius|plane|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            plane = parts[3]
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Circle circumference
                path_length = 2 * np.pi * radius
                duration = calculate_duration_from_speed(path_length, timing_value)
            
            print(f"  -> Parsed circle: r={radius}mm, plane={plane}, frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command object with frame parameter
            return SmoothCircleCommand(center, radius, plane, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_CENTER':
            # Format: SMOOTH_ARC_CENTER|end_pose|center|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            center = list(map(float, parts[2].split(',')))
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[6])
            clockwise = parts[7] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Estimate arc length (will be more accurate when we have actual positions)
                # Use a conservative estimate based on radius
                radius_estimate = np.linalg.norm(np.array(center) - np.array(end_pose[:3]))
                estimated_arc_angle = np.pi / 2  # 90 degrees estimate
                arc_length = radius_estimate * estimated_arc_angle
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (center): frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command with frame
            return SmoothArcCenterCommand(end_pose, center, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_PARAM':
            # Format: SMOOTH_ARC_PARAM|end_pose|radius|angle|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            arc_angle = float(parts[3])
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Arc length = radius * angle (in radians)
                arc_length = radius * np.deg2rad(arc_angle)
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (param): r={radius}mm, Î¸={arc_angle}Â°, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothArcParamCommand(end_pose, radius, arc_angle, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_SPLINE':
            # Format: SMOOTH_SPLINE|num_waypoints|frame|start_pose|timing_type|timing_value|waypoint1|waypoint2|...
            num_waypoints = int(parts[1])
            frame = parts[2]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[3])
            timing_type = parts[4]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[5])
            
            # Parse waypoints
            waypoints = []
            idx = 6
            for i in range(num_waypoints):
                wp = []
                for j in range(6):  # Each waypoint has 6 values (x,y,z,rx,ry,rz)
                    wp.append(float(parts[idx]))
                    idx += 1
                waypoints.append(wp)
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate total path length
                total_dist = 0
                for i in range(1, len(waypoints)):
                    dist = np.linalg.norm(np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3]))
                    total_dist += dist
                
                duration = calculate_duration_from_speed(total_dist, timing_value)
            
            print(f"  -> Parsed spline: {num_waypoints} points, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothSplineCommand(waypoints, duration, frame, start_pose)
            
        elif command_type == 'SMOOTH_HELIX':
            # Format: SMOOTH_HELIX|center|radius|pitch|height|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            pitch = float(parts[3])
            height = float(parts[4])
            frame = parts[5]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[6])
            timing_type = parts[7]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[8])
            clockwise = parts[9] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate helix path length
                num_revolutions = height / pitch if pitch > 0 else 1
                horizontal_length = 2 * np.pi * radius * num_revolutions
                helix_length = np.sqrt(horizontal_length**2 + height**2)
                duration = calculate_duration_from_speed(helix_length, timing_value)
            
            print(f"  -> Parsed helix: h={height}mm, pitch={pitch}mm, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothHelixCommand(center, radius, pitch, height, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_BLEND':
            # Format: SMOOTH_BLEND|num_segments|blend_time|frame|start_pose|timing_type|timing_value|segment1||segment2||...
            num_segments = int(parts[1])
            blend_time = float(parts[2])
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DEFAULT', 'DURATION', or 'SPEED'
            
            # Parse overall timing
            if timing_type == 'DEFAULT':
                # Use individual segment durations as-is
                overall_duration = None
                overall_speed = None
                segments_start_idx = 6
            else:
                timing_value = float(parts[6])
                if timing_type == 'DURATION':
                    overall_duration = timing_value
                    overall_speed = None
                else:  # SPEED
                    overall_speed = timing_value
                    overall_duration = None
                segments_start_idx = 7
            
            # Parse segments (separated by ||)
            segments_data = '|'.join(parts[segments_start_idx:])
            segment_strs = segments_data.split('||')
            
            # Parse segment definitions
            segment_definitions = []
            total_original_duration = 0
            total_estimated_length = 0
            
            for seg_str in segment_strs:
                if not seg_str:  # Skip empty segments
                    continue
                    
                seg_parts = seg_str.split('|')
                seg_type = seg_parts[0]
                
                if seg_type == 'LINE':
                    # Format: LINE|end_x,end_y,end_z,end_rx,end_ry,end_rz|duration
                    end = list(map(float, seg_parts[1].split(',')))
                    segment_duration = float(seg_parts[2])
                    total_original_duration += segment_duration
                    
                    # Estimate length (will be refined when we have actual start)
                    estimated_length = 100  # mm, conservative estimate
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'LINE',
                        'end': end,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
                    
                elif seg_type == 'CIRCLE':
                    # Format: CIRCLE|center_x,center_y,center_z|radius|plane|duration|clockwise
                    center = list(map(float, seg_parts[1].split(',')))
                    radius = float(seg_parts[2])
                    plane = seg_parts[3]
                    segment_duration = float(seg_parts[4])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[5] == '1'
                    
                    # Circle circumference
                    estimated_length = 2 * np.pi * radius
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'CIRCLE',
                        'center': center,
                        'radius': radius,
                        'plane': plane,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'ARC':
                    # Format: ARC|end_x,end_y,end_z,end_rx,end_ry,end_rz|center_x,center_y,center_z|duration|clockwise
                    end = list(map(float, seg_parts[1].split(',')))
                    center = list(map(float, seg_parts[2].split(',')))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[4] == '1'
                    
                    # Estimate arc length
                    estimated_radius = 50  # mm
                    estimated_arc_angle = np.pi / 2  # 90 degrees
                    estimated_length = estimated_radius * estimated_arc_angle
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'ARC',
                        'end': end,
                        'center': center,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'SPLINE':
                    # Format: SPLINE|num_points|waypoint1;waypoint2;...|duration
                    num_points = int(seg_parts[1])
                    waypoints = []
                    wp_strs = seg_parts[2].split(';')
                    for wp_str in wp_strs:
                        waypoints.append(list(map(float, wp_str.split(','))))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    
                    # Estimate spline length
                    estimated_length = 0
                    for i in range(1, len(waypoints)):
                        estimated_length += np.linalg.norm(
                            np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3])
                        )
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'SPLINE',
                        'waypoints': waypoints,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
            
            # Adjust segment durations if overall timing is specified
            if overall_duration is not None:
                # Scale all segment durations proportionally
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Scaled blend segments to total duration: {overall_duration:.2f}s")
                        
            elif overall_speed is not None:
                # Calculate duration from speed and estimated path length
                overall_duration = calculate_duration_from_speed(total_estimated_length, overall_speed)
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Calculated blend duration from speed: {overall_duration:.2f}s")
            else:
                print(f"  -> Using original segment durations (total: {total_original_duration:.2f}s)")
            
            print(f"  -> Parsed blend: {num_segments} segments, frame={frame}, blend_time={blend_time}s")
            
            # Return command with frame
            return SmoothBlendCommand(segment_definitions, blend_time, frame, start_pose)
            
    except Exception as e:
        print(f"Error parsing smooth motion command: {e}")
        print(f"Command parts: {parts}")
        import traceback
        traceback.print_exc()
        return None
    
    print(f"Warning: Unknown smooth motion command type: {command_type}")
    return None

def transform_command_params_to_wrf(command_type: str, params: dict, frame: str, current_position_in) -> dict:
    """
    Transform command parameters from TRF to WRF.
    Handles position, orientation, and directional vectors correctly.
    """
    if frame == 'WRF':
        return params
    
    # Get current tool pose
    current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                         for i, p in enumerate(current_position_in)])
    tool_pose = PAROL6_ROBOT.robot.fkine(current_q)
    
    transformed = params.copy()
    
    # SMOOTH_CIRCLE - Transform center and plane normal
    if command_type == 'SMOOTH_CIRCLE':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'plane' in params:
            plane_normals_trf = {
                'XY': [0, 0, 1],   # Tool's Z-axis
                'XZ': [0, 1, 0],   # Tool's Y-axis  
                'YZ': [1, 0, 0]    # Tool's X-axis
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
            print(f"  -> TRF circle plane {params['plane']} transformed to WRF")
    
    # SMOOTH_ARC_CENTER - Transform center, end_pose, and implied plane
    elif command_type == 'SMOOTH_ARC_CENTER':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # Arc plane is determined by start, end, and center points
        # But we should transform any specified plane normal
        if 'plane' in params:
            # Similar to circle plane transformation
            plane_normals_trf = {
                'XY': [0, 0, 1],
                'XZ': [0, 1, 0],
                'YZ': [1, 0, 0]
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_ARC_PARAM - Transform end_pose and arc plane
    elif command_type == 'SMOOTH_ARC_PARAM':
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # For parametric arc, the plane is usually XY of the tool
        # Transform the assumed plane normal
        if 'plane' not in params:
            params['plane'] = 'XY'  # Default to XY plane
        
        plane_normals_trf = {
            'XY': [0, 0, 1],
            'XZ': [0, 1, 0],
            'YZ': [1, 0, 0]
        }
        normal_trf = np.array(plane_normals_trf[params.get('plane', 'XY')])
        normal_wrf = tool_pose.R @ normal_trf
        transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_HELIX - Transform center and helix axis
    elif command_type == 'SMOOTH_HELIX':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        # Helix axis - default is Z-axis (vertical in TRF)
        # In TRF, helix rises along tool's Z-axis
        helix_axis_trf = np.array([0, 0, 1])  # Tool's Z-axis
        helix_axis_wrf = tool_pose.R @ helix_axis_trf
        transformed['helix_axis'] = helix_axis_wrf.tolist()
        
        # Also need to transform the "up" direction for proper orientation
        up_vector_trf = np.array([0, 1, 0])  # Tool's Y-axis
        up_vector_wrf = tool_pose.R @ up_vector_trf
        transformed['up_vector'] = up_vector_wrf.tolist()
    
    # SMOOTH_SPLINE - Transform all waypoints
    elif command_type == 'SMOOTH_SPLINE':
        if 'waypoints' in params:
            transformed_waypoints = []
            for wp in params['waypoints']:
                wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                         SE3.RPY(wp[3:], unit='deg', order='xyz')
                wp_wrf = tool_pose * wp_trf
                wp_transformed = np.concatenate([
                    wp_wrf.t * 1000,
                    wp_wrf.rpy(unit='deg', order='xyz')
                ]).tolist()
                transformed_waypoints.append(wp_transformed)
            transformed['waypoints'] = transformed_waypoints
    
    # SMOOTH_BLEND - Transform all segments recursively
    elif command_type == 'SMOOTH_BLEND':
        if 'segments' in params:
            transformed_segments = []
            for seg in params['segments']:
                seg_copy = seg.copy()
                seg_type = seg['type']
                
                if seg_type == 'LINE':
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'CIRCLE':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'plane' in seg:
                        plane_normals_trf = {
                            'XY': [0, 0, 1],
                            'XZ': [0, 1, 0],
                            'YZ': [1, 0, 0]
                        }
                        normal_trf = np.array(plane_normals_trf[seg['plane']])
                        normal_wrf = tool_pose.R @ normal_trf
                        seg_copy['normal_vector'] = normal_wrf.tolist()
                
                elif seg_type == 'ARC':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'SPLINE':
                    if 'waypoints' in seg:
                        transformed_waypoints = []
                        for wp in seg['waypoints']:
                            wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                                     SE3.RPY(wp[3:], unit='deg', order='xyz')
                            wp_wrf = tool_pose * wp_trf
                            wp_transformed = np.concatenate([
                                wp_wrf.t * 1000,
                                wp_wrf.rpy(unit='deg', order='xyz')
                            ]).tolist()
                            transformed_waypoints.append(wp_transformed)
                        seg_copy['waypoints'] = transformed_waypoints
                
                transformed_segments.append(seg_copy)
            transformed['segments'] = transformed_segments
    
    # Transform start_pose if specified (common to all commands)
    if 'start_pose' in params and params['start_pose'] is not None:
        start_trf = SE3(params['start_pose'][0]/1000, 
                       params['start_pose'][1]/1000, 
                       params['start_pose'][2]/1000) * \
                    SE3.RPY(params['start_pose'][3:], unit='deg', order='xyz')
        start_wrf = tool_pose * start_trf
        transformed['start_pose'] = np.concatenate([
            start_wrf.t * 1000,
            start_wrf.rpy(unit='deg', order='xyz')
        ]).tolist()
    
    return transformed

#########################################################################
# Smooth Motion Commands and Robot Commands End Here
#########################################################################

# Acknowledgment system configuration
CLIENT_ACK_PORT = 5002  # Port where clients listen for acknowledgments
ack_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Command tracking
active_command_id = None
command_id_map = {}  # Maps command objects to their IDs

def send_acknowledgment(cmd_id: str, status: str, details: str = "", addr=None):
    """Send acknowledgment back to client"""
    if not cmd_id:
        return
        
    ack_message = f"ACK|{cmd_id}|{status}|{details}"
    
    # Send to the original sender if we have their address
    if addr:
        try:
            ack_socket.sendto(ack_message.encode('utf-8'), (addr[0], CLIENT_ACK_PORT))
        except Exception as e:
            print(f"Failed to send ack to {addr}: {e}")
    
    # Also broadcast to localhost in case the client is local
    try:
        ack_socket.sendto(ack_message.encode('utf-8'), ('127.0.0.1', CLIENT_ACK_PORT))
    except:
        pass

def parse_command_with_id(message: str) -> Tuple[Optional[str], str]:
    """
    Parse command ID if present.
    Format: [cmd_id|]COMMAND|params...
    Returns: (cmd_id or None, command_string)
    """
    # Clean up any logging artifacts
    if "ID:" in message or "):" in message:
        # Extract the actual command after these artifacts
        if "):" in message:
            message = message[message.rindex("):")+2:].strip()
        elif "ID:" in message:
            message = message[message.index("ID:")+3:].strip()
            # Remove any trailing parentheses or colons
            message = message.lstrip('):').strip()
    
    parts = message.split('|', 1)
    
    # Check if first part looks like a valid command ID (8 chars, alphanumeric)
    # IMPORTANT: Command IDs from uuid.uuid4()[:8] will contain lowercase letters/numbers
    # Actual commands are all uppercase, so exclude all-uppercase strings
    if (len(parts) > 1 and 
        len(parts[0]) == 8 and 
        parts[0].replace('-', '').isalnum() and 
        not parts[0].isupper()):  # This prevents "MOVEPOSE" from being treated as an ID
        return parts[0], parts[1]
    else:
        return None, message


# Create a new, empty command queue
command_queue = deque()

# --------------------------------------------------------------------------
# --- Test 1: Homing and Initial Setup
# --------------------------------------------------------------------------

# 1. Start with the mandatory Home command.
command_queue.append(HomeCommand())

# --- State variable for the currently running command ---
active_command = None
e_stop_active = False

# Use deque for an efficient FIFO queue
incoming_command_buffer = deque()
# Timestamp of the last processed network command
last_command_time = 0
# Cooldown period in seconds to prevent command flooding
COMMAND_COOLDOWN_S = 0.1 # 100ms

# Set interval
timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)

# ============================================================================
# MODIFIED MAIN LOOP WITH ACKNOWLEDGMENTS
# ============================================================================

timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)
prev_time = 0

while timer.elapsed_time < 1100000:
    
    # --- Connection Handling ---
    if ser is None or not ser.is_open:
        print("Serial port not open. Attempting to reconnect...")
        try:
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            if ser.is_open:
                print(f"Successfully reconnected to {com_port_str}")
        except serial.SerialException as e:
            ser = None
            time.sleep(1) 
        continue

    # =======================================================================
    # === NETWORK COMMAND RECEPTION WITH ID PARSING ===
    # =======================================================================
    try:
        while sock in select.select([sock], [], [], 0)[0]:
            data, addr = sock.recvfrom(1024)
            raw_message = data.decode('utf-8').strip()
            if raw_message:
                # Parse command ID if present
                cmd_id, message = parse_command_with_id(raw_message)
                
                parts = message.split('|')
                command_name = parts[0].upper()

                # Handle immediate response commands
                if command_name == 'STOP':
                    print("Received STOP command. Halting all motion and clearing queue.")
                    
                    # Cancel active command
                    if active_command and active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "Stopped by user", addr)
                    active_command = None
                    active_command_id = None
                    
                    # Clear queue and notify about cancelled commands
                    for queued_cmd in command_id_map.keys():
                        if queued_cmd != active_command:
                            if queued_cmd in command_id_map:
                                send_acknowledgment(command_id_map[queued_cmd], 
                                                  "CANCELLED", "Queue cleared by STOP", addr)
                    
                    command_queue.clear()
                    command_id_map.clear()
                    
                    # Stop robot
                    Command_out.value = 255
                    Speed_out[:] = [0] * 6
                    
                    # Send acknowledgment for STOP command itself
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Emergency stop executed", addr)

                elif command_name == 'GET_POSE':
                    q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
                    current_pose_matrix = PAROL6_ROBOT.robot.fkine(q_current).A
                    pose_flat = current_pose_matrix.flatten()
                    pose_str = ",".join(map(str, pose_flat))
                    response_message = f"POSE|{pose_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Pose data sent", addr)

                elif command_name == 'GET_ANGLES':
                    angles_rad = [PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)]
                    angles_deg = np.rad2deg(angles_rad)
                    angles_str = ",".join(map(str, angles_deg))
                    response_message = f"ANGLES|{angles_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Angles data sent", addr)

                elif command_name == 'GET_IO':
                    io_status_str = ",".join(map(str, InOut_in[:5]))
                    response_message = f"IO|{io_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "IO data sent", addr)

                elif command_name == 'GET_GRIPPER':
                    gripper_status_str = ",".join(map(str, Gripper_data_in))
                    response_message = f"GRIPPER|{gripper_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Gripper data sent", addr)

                elif command_name == 'GET_SPEEDS':
                    speeds_str = ",".join(map(str, Speed_in))
                    response_message = f"SPEEDS|{speeds_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Speed data sent", addr)

                else:
                    # Queue command for processing
                    incoming_command_buffer.append((raw_message, addr))

    except Exception as e:
        print(f"Network receive error: {e}")

    # =======================================================================
    # === PROCESS COMMANDS FROM BUFFER WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    current_time = time.time()
    if incoming_command_buffer and (current_time - last_command_time) > COMMAND_COOLDOWN_S and not e_stop_active:
        raw_message, addr = incoming_command_buffer.popleft()
        last_command_time = current_time
        
        # Parse command ID
        cmd_id, message = parse_command_with_id(raw_message)
        print(f"Processing command{' (ID: ' + cmd_id + ')' if cmd_id else ''}: {message[:50]}...")
        
        parts = message.split('|')
        command_name = parts[0].upper()
        
        # Variable to track if command was successfully queued
        command_queued = False
        command_obj = None
        error_details = ""

        # Parse and create command objects
        try:
            if command_name == 'MOVEPOSE' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MovePoseCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
                
            elif command_name == 'MOVEJOINT' and len(parts) == 9:
                joint_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveJointCommand(target_angles=joint_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name in ['SMOOTH_CIRCLE', 'SMOOTH_ARC_CENTER', 'SMOOTH_ARC_PARAM', 
                                 'SMOOTH_SPLINE', 'SMOOTH_HELIX', 'SMOOTH_BLEND']:
                command_obj = parse_smooth_motion_commands(parts)
                if command_obj:
                    command_queued = True
                else:
                    error_details = "Failed to parse smooth motion parameters"
            
            elif command_name == 'MOVECART' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveCartCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name == 'DELAY' and len(parts) == 2:
                duration = float(parts[1])
                command_obj = DelayCommand(duration=duration)
                command_queued = True
            
            elif command_name == 'HOME':
                command_obj = HomeCommand()
                command_queued = True
                
            elif command_name == 'CARTJOG' and len(parts) == 5:
                frame, axis, speed, duration = parts[1].upper(), parts[2], float(parts[3]), float(parts[4])
                command_obj = CartesianJogCommand(frame=frame, axis=axis, speed_percentage=speed, duration=duration)
                command_queued = True
                
            elif command_name == 'JOG' and len(parts) == 5:
                joint_idx, speed = int(parts[1]), float(parts[2])
                duration = None if parts[3].upper() == 'NONE' else float(parts[3])
                distance = None if parts[4].upper() == 'NONE' else float(parts[4])
                command_obj = JogCommand(joint=joint_idx, speed_percentage=speed, duration=duration, distance_deg=distance)
                command_queued = True
            
            elif command_name == 'MULTIJOG' and len(parts) == 4:
                joint_indices = [int(j) for j in parts[1].split(',')]
                speeds = [float(s) for s in parts[2].split(',')]
                duration = float(parts[3])
                command_obj = MultiJogCommand(joints=joint_indices, speed_percentages=speeds, duration=duration)
                command_queued = True
                
            elif command_name == 'PNEUMATICGRIPPER' and len(parts) == 3:
                action, port = parts[1].lower(), int(parts[2])
                command_obj = GripperCommand(gripper_type='pneumatic', action=action, output_port=port)
                command_queued = True
                
            elif command_name == 'ELECTRICGRIPPER' and len(parts) == 5:
                action = None if parts[1].upper() == 'NONE' or parts[1].upper() == 'MOVE' else parts[1].lower()
                pos, spd, curr = int(parts[2]), int(parts[3]), int(parts[4])
                command_obj = GripperCommand(gripper_type='electric', action=action, position=pos, speed=spd, current=curr)
                command_queued = True
            
            else:
                error_details = f"Unknown or malformed command: {command_name}"
                
        except Exception as e:
            error_details = f"Error parsing command: {str(e)}"
            command_queued = False
        
        # Handle command queueing and acknowledgments
        if command_queued and command_obj:
            # Check if command is initially valid
            if hasattr(command_obj, 'is_valid') and not command_obj.is_valid:
                if cmd_id:
                    send_acknowledgment(cmd_id, "INVALID", 
                                       "Command failed validation", addr)
            else:
                # Add to queue
                command_queue.append(command_obj)
                if cmd_id:
                    command_id_map[command_obj] = (cmd_id, addr)
                    send_acknowledgment(cmd_id, "QUEUED", 
                                       f"Position {len(command_queue)} in queue", addr)
        else:
            # Command was not queued
            if cmd_id:
                send_acknowledgment(cmd_id, "INVALID", error_details, addr)
            print(f"Warning: {error_details}")

    # =======================================================================
    # === MAIN EXECUTION LOGIC WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    try:
        # --- E-Stop Handling ---
        if InOut_in[4] == 0:  # E-Stop pressed
            if not e_stop_active:
                cancelled_command_info = "None"
                if active_command is not None:
                    cancelled_command_info = type(active_command).__name__
                    if active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "E-Stop activated")
                
                # Cancel all queued commands
                for cmd_obj in command_queue:
                    if cmd_obj in command_id_map:
                        cmd_id, addr = command_id_map[cmd_obj]
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated", addr)
                
                # Cancel all buffered but unprocessed commands
                for raw_message, addr in incoming_command_buffer:
                    cmd_id, _ = parse_command_with_id(raw_message)
                    if cmd_id:
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated - command not processed", addr)
                
                print(f"E-STOP TRIGGERED! Active command '{cancelled_command_info}' cancelled.")
                print("Release E-Stop and press 'e' to re-enable.")
                e_stop_active = True
            
            Command_out.value = 102
            Speed_out[:] = [0] * 6
            Gripper_data_out[3] = 0
            active_command = None
            active_command_id = None
            command_queue.clear()
            command_id_map.clear()
            incoming_command_buffer.clear()
            
        elif e_stop_active:
            # Waiting for re-enable
            if keyboard.is_pressed('e'):
                print("Re-enabling robot...")
                Command_out.value = 101
                e_stop_active = False
            else:
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]
                
        else:
            # --- Normal Command Processing ---
            
            # Start new command if none active
            if active_command is None and command_queue:
                new_command = command_queue.popleft()
                
                # Get command ID and address if tracked
                cmd_info = command_id_map.get(new_command, (None, None))
                new_cmd_id, new_addr = cmd_info
                
                # Initial validation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Command was invalid from the start
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "INVALID", 
                                        "Initial validation failed", new_addr)
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                    continue  # Skip to next command
                
                # Prepare command
                if hasattr(new_command, 'prepare_for_execution'):
                    try:
                        new_command.prepare_for_execution(current_position_in=Position_in)
                    except Exception as e:
                        print(f"Command preparation failed: {e}")
                        if hasattr(new_command, 'is_valid'):
                            new_command.is_valid = False
                        if hasattr(new_command, 'error_message'):
                            new_command.error_message = str(e)
                
                # Check if still valid after preparation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Failed during preparation
                    error_msg = "Failed during preparation"
                    if hasattr(new_command, 'error_message'):
                        error_msg = new_command.error_message
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "FAILED", error_msg, new_addr)
                    
                    # Clean up
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                else:
                    # Command is valid, make it active
                    active_command = new_command
                    active_command_id = new_cmd_id
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "EXECUTING", 
                                        f"Starting {type(new_command).__name__}", new_addr)
            
            # Execute active command
            if active_command:
                try:
                    is_done = active_command.execute_step(
                        Position_in=Position_in,
                        Homed_in=Homed_in,
                        Speed_out=Speed_out,
                        Command_out=Command_out,
                        Gripper_data_out=Gripper_data_out,
                        InOut_out=InOut_out,
                        InOut_in=InOut_in,
                        Gripper_data_in=Gripper_data_in,
                        Position_out=Position_out  # Add this if needed
                    )
                    
                    if is_done:
                        # Command completed
                        if active_command_id:
                            # Check for error state in smooth motion commands
                            if hasattr(active_command, 'error_state') and active_command.error_state:
                                error_msg = getattr(active_command, 'error_message', 'Command failed during execution')
                                send_acknowledgment(active_command_id, "FAILED", error_msg)
                            else:
                                send_acknowledgment(active_command_id, "COMPLETED", 
                                                f"{type(active_command).__name__} finished successfully")
                        
                        # Clean up
                        if active_command in command_id_map:
                            del command_id_map[active_command]
                        
                        active_command = None
                        active_command_id = None
                        
                except Exception as e:
                    # Command execution error
                    print(f"Command execution error: {e}")
                    if active_command_id:
                        send_acknowledgment(active_command_id, "FAILED", 
                                          f"Execution error: {str(e)}")
                    
                    # Clean up
                    if active_command in command_id_map:
                        del command_id_map[active_command]
                    
                    active_command = None
                    active_command_id = None
                    
            else:
                # No active command - idle
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]

        # --- Communication with Robot ---
        s = Pack_data(Position_out, Speed_out, Command_out.value, 
                     Affected_joint_out, InOut_out, Timeout_out, Gripper_data_out)
        for chunk in s:
            ser.write(chunk)
            
        Get_data(Position_in, Speed_in, Homed_in, InOut_in, Temperature_error_in, 
                Position_error_in, Timeout_error, Timing_data_in, XTR_data, Gripper_data_in)

    except serial.SerialException as e:
        print(f"Serial communication error: {e}")
        
        # Send failure acknowledgments for active command
        if active_command_id:
            send_acknowledgment(active_command_id, "FAILED", "Serial communication lost")
        
        if ser:
            ser.close()
        ser = None
        active_command = None
        active_command_id = None

    timer.checkpt()
````

## File: headless_commander.py.backup_1757427986
````
'''
A full fledged "API" for the PAROL6 robot. To use this, you should pair it with the "robot_api.py" where you can import commands
from said file and use them anywhere within your code. This Python script will handle sending and performing all the commands
to the PAROL6 robot, as well as E-Stop functionality and safety limitations.

To run this program, you must use the "experimental-kinematics" branch of the "PAROL-commander-software" on GitHub
which can be found through this link: https://github.com/PCrnjak/PAROL-commander-software/tree/experimental_kinematics.
You must also save these files into the following folder: "Project Files\PAROL-commander-software\GUI\files".
'''

# * If you press estop robot will stop and you need to enable it by pressing e

from roboticstoolbox import DHRobot, RevoluteDH, ERobot, ELink, ETS, trapezoidal, quintic
import roboticstoolbox as rp
from math import pi, sin, cos
import numpy as np
from oclock import Timer, loop, interactiveloop
import time
import socket
from spatialmath import SE3
import select
import serial
import platform
import os
import re
import logging
import struct
import keyboard
from typing import Optional, Tuple
from spatialmath.base import trinterp
from collections import namedtuple, deque
import GUI.files.PAROL6_ROBOT as PAROL6_ROBOT
from smooth_motion import CircularMotion, SplineMotion, MotionBlender

# Set interval
INTERVAL_S = 0.01
prev_time = 0

logging.basicConfig(level = logging.DEBUG,
    format='%(asctime)s.%(msecs)03d %(levelname)s:\t%(message)s',
    datefmt='%H:%M:%S'
)
logging.disable(logging.DEBUG)


my_os = platform.system()
if my_os == "Windows":
    # Try to read the COM port from a file
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved COM port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        # If the file doesn't exist or the port is invalid, ask the user
        while True:
            try:
                com_port = input("Enter the COM port (e.g., COM9): ")
                ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                print(f"Successfully connected to {com_port}")
                # Save the successful port to the file
                with open("com_port.txt", "w") as f:
                    f.write(com_port)
                break
            except serial.SerialException:
                print(f"Could not open port {com_port}. Please try again.")

# in big endian machines, first byte of binary representation of the multibyte data-type is stored first. 
int_to_3_bytes = struct.Struct('>I').pack # BIG endian order

# data for output string (data that is being sent to the robot)
#######################################################################################
#######################################################################################
start_bytes =  [0xff,0xff,0xff] 
start_bytes = bytes(start_bytes)

end_bytes =  [0x01,0x02] 
end_bytes = bytes(end_bytes)


# data for input string (Data that is being sent by the robot)
#######################################################################################
#######################################################################################
input_byte = 0 # Here save incoming bytes from serial

start_cond1_byte = bytes([0xff])
start_cond2_byte = bytes([0xff])
start_cond3_byte = bytes([0xff])

end_cond1_byte = bytes([0x01])
end_cond2_byte = bytes([0x02])

start_cond1 = 0 #Flag if start_cond1_byte is received
start_cond2 = 0 #Flag if start_cond2_byte is received
start_cond3 = 0 #Flag if start_cond3_byte is received

good_start = 0 #Flag if we got all 3 start condition bytes
data_len = 0 #Length of the data after -3 start condition bytes and length byte, so -4 bytes

data_buffer = [None]*255 #Here save all data after data length byte
data_counter = 0 #Data counter for incoming bytes; compared to data length to see if we have correct length
#######################################################################################
#######################################################################################
prev_positions = [0,0,0,0,0,0]
prev_speed = [0,0,0,0,0,0]
robot_pose = [0,0,0,0,0,0] #np.array([0,0,0,0,0,0])
#######################################################################################
#######################################################################################

# --- Wrapper class to make integers mutable when passed to functions ---
class CommandValue:
    def __init__(self, value):
        self.value = value

#######################################################################################
#######################################################################################
Position_out = [1,11,111,1111,11111,10]
Speed_out = [2,21,22,23,24,25]
Command_out = CommandValue(255)
Affected_joint_out = [1,1,1,1,1,1,1,1]
InOut_out = [0,0,0,0,0,0,0,0]
Timeout_out = 0
#Positon,speed,current,command,mode,ID
Gripper_data_out = [1,1,1,1,0,0]
#######################################################################################
#######################################################################################
# Data sent from robot to PC
Position_in = [31,32,33,34,35,36]
Speed_in = [41,42,43,44,45,46]
Homed_in = [0,0,0,0,0,0,0,0]
InOut_in = [1,1,1,1,1,1,1,1]
Temperature_error_in = [1,1,1,1,1,1,1,1]
Position_error_in = [1,1,1,1,1,1,1,1]
Timeout_error = 0
# how much time passed between 2 sent commands (2byte value, last 2 digits are decimal so max value is 655.35ms?)
Timing_data_in = [0]
XTR_data =   0

# --- State variables for program execution ---
Robot_mode = "Dummy"  # Start in an idle state
Program_step = 0      # Which line of the program to run
Command_step = 0      # The current step within a single command
Command_len = 0       # The total steps for the current command
ik_error = 0          # Flag for inverse kinematics errors
error_state = 0       # General error flag
program_running = False # A flag to start and stop the program

# This will be your "program"
command_list = []

#ID,Position,speed,current,status,obj_detection
Gripper_data_in = [1,1,1,1,1,1] 

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179Â° and 181Â° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    
    Parameters
    ----------
    robot : DHRobot
        Robot model
    q : array_like
        Joint configuration
    strict_tol : float
        Strict tolerance away from singularities (default: 1e-10)
    loose_tol : float
        Loose tolerance near singularities (1e-7)
        
    Returns
    -------
    float
        Adaptive tolerance value
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    
    Parameters
    ----------
    q_seed : array_like
        Current joint configuration in radians
        
    Returns
    -------
    float
        Configuration-dependent maximum reach threshold
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90Â°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 | None = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities:
    - Near singularities: looser tolerance for easier convergence
    - Away from singularities: stricter tolerance for precise solutions
    If necessary, recursively subdivide the motion until ikine_LMS converges
    on every segment. Finally check that solution respects joint limits. From experimentation,
    jogging with lower tolerances often produces q_paths that do not differ from current_q,
    essentially freezing the robot.

    Parameters
    ----------
    robot : DHRobot
        Robot model
    target_pose : SE3
        Target pose to reach
    current_q : array_like
        Current joint configuration
    current_pose : SE3, optional
        Current pose (computed if None)
    max_depth : int, optional
        Maximum subdivision depth (default: 8)
    ilimit : int, optional
        Maximum iterations for IK solver (default: 100)

    Returns
    -------
    IKResult
        success  - True/False
        q_path   - (mxn) array of the final joint configuration 
        iterations, residual  - aggregated diagnostics
        tolerance_used - which tolerance was used
        violations - joint limit violations (if any)
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # â”€â”€ inner recursive solverâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            # print(f"current_reach:{current_reach:.3f}, max_reach_threshold:{max_reach_threshold:.3f}")
            if not is_recovery and target_reach > max_reach_threshold:
                print(f"Target reach limit exceeded: {target_reach:.3f} > {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LMS(Tb, q0=q_seed, ilimit=ilimit, tol=tol, wN=damping)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # â”€â”€ kick-off with adaptive tolerance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    # Check if solution respects joint limits
    target_q = path[-1] if len(path) != 0 else None
    solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
    if ok and solution_valid:
        return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
    else:
        return IKResult(False, None, its, resid, adaptive_tol, violations)

#Setup IP address and Simulator port
ip = "127.0.0.1" #Loopback address
port = 5001
# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((ip, port))
print(f'Start listening to {ip}:{port}')

def Unpack_data(data_buffer_list, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):

    Joints = []
    Speed = []

    for i in range(0,18, 3):
        variable = data_buffer_list[i:i+3]
        Joints.append(variable)

    for i in range(18,36, 3):
        variable = data_buffer_list[i:i+3]
        Speed.append(variable)


    for i in range(6):
        var =  b'\x00' + b''.join(Joints[i])
        Position_in[i] = Fuse_3_bytes(var)
        var =  b'\x00' + b''.join(Speed[i])
        Speed_in[i] = Fuse_3_bytes(var)

    Homed = data_buffer_list[36]
    IO_var = data_buffer_list[37]
    temp_error = data_buffer_list[38]
    position_error = data_buffer_list[39]
    timing_data = data_buffer_list[40:42]
    Timeout_error_var = data_buffer_list[42]
    xtr2 = data_buffer_list[43]
    device_ID = data_buffer_list[44]
    Gripper_position = data_buffer_list[45:47]
    Gripper_speed = data_buffer_list[47:49]
    Gripper_current = data_buffer_list[49:51]
    Status = data_buffer_list[51]
    # The original object_detection byte at index 52 is ignored as it is not reliable.
    CRC_byte = data_buffer_list[53]
    endy_byte1 = data_buffer_list[54]
    endy_byte2 = data_buffer_list[55]

    # ... (Code for Homed, IO_var, temp_error, etc. remains the same) ...

    temp = Split_2_bitfield(int.from_bytes(Homed,"big"))
    for i in range(8):
        Homed_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(IO_var,"big"))
    for i in range(8):
        InOut_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(temp_error,"big"))
    for i in range(8):
        Temperature_error_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(position_error,"big"))
    for i in range(8):
        Position_error_in[i] = temp[i]

    var = b'\x00' + b'\x00' + b''.join(timing_data)
    Timing_data_in[0] = Fuse_3_bytes(var)
    Timeout_error = int.from_bytes(Timeout_error_var,"big")
    XTR_data = int.from_bytes(xtr2,"big")

    # --- Gripper Data Unpacking ---
    Gripper_data_in[0] = int.from_bytes(device_ID,"big")

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_position)
    Gripper_data_in[1] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_speed)
    Gripper_data_in[2] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_current)
    Gripper_data_in[3] = Fuse_2_bytes(var)

    # --- Start of Corrected Logic ---
    # This section now mirrors the working logic from GUI_PAROL_latest.py
    
    # 1. Store the raw status byte (from index 51)
    status_byte = int.from_bytes(Status,"big")
    Gripper_data_in[4] = status_byte

    # 2. Split the status byte into a list of 8 individual bits
    status_bits = Split_2_bitfield(status_byte)
    
    # 3. Combine the 3rd and 4th bits (at indices 2 and 3) to get the true object detection status
    # This creates a 2-bit number (0-3) which represents the full state.
    object_detection_status = (status_bits[2] << 1) | status_bits[3]
    Gripper_data_in[5] = object_detection_status
    # --- End of Corrected Logic ---

def Pack_data(Position_out,Speed_out,Command_out,Affected_joint_out,InOut_out,Timeout_out,Gripper_data_out):

    # Len is defined by all bytes EXCEPT start bytes and len
    # Start bytes = 3
    len = 52 #1
    Position = [Position_out[0],Position_out[1],Position_out[2],Position_out[3],Position_out[4],Position_out[5]]  #18
    Speed = [Speed_out[0], Speed_out[1], Speed_out[2], Speed_out[3], Speed_out[4], Speed_out[5],] #18
    Command = Command_out#1
    Affected_joint = Affected_joint_out
    InOut = InOut_out #1
    Timeout = Timeout_out #1
    Gripper_data = Gripper_data_out #9
    CRC_byte = 228 #1
    # End bytes = 2


    test_list = []
    #print(test_list)

    #x = bytes(start_bytes)
    test_list.append((start_bytes))
    
    test_list.append(bytes([len]))


    # Position data
    for i in range(6):
        position_split = Split_2_3_bytes(Position[i])
        test_list.append(position_split[1:4])

    # Speed data
    for i in range(6):
        speed_split = Split_2_3_bytes(Speed[i])
        test_list.append(speed_split[1:4])

    # Command data
    test_list.append(bytes([Command]))

    # Affected joint data
    Affected_list = Fuse_bitfield_2_bytearray(Affected_joint[:])
    test_list.append(Affected_list)

    # Inputs outputs data
    InOut_list = Fuse_bitfield_2_bytearray(InOut[:])
    test_list.append(InOut_list)

    # Timeout data
    test_list.append(bytes([Timeout]))

    # Gripper position
    Gripper_position = Split_2_3_bytes(Gripper_data[0])
    test_list.append(Gripper_position[2:4])

    # Gripper speed
    Gripper_speed = Split_2_3_bytes(Gripper_data[1])
    test_list.append(Gripper_speed[2:4])

    # Gripper current
    Gripper_current = Split_2_3_bytes(Gripper_data[2])
    test_list.append(Gripper_current[2:4])  

    # Gripper command
    test_list.append(bytes([Gripper_data[3]]))
    # Gripper mode
    test_list.append(bytes([Gripper_data[4]]))
    
    # ==========================================================
    # === FIX: Make sure calibrate is a one-shot command      ====
    # ==========================================================
    # If the mode was set to calibrate (1) or clear_error (2), reset it
    # back to normal (0) for the next cycle. This prevents an endless loop.
    if Gripper_data_out[4] == 1 or Gripper_data_out[4] == 2:
        Gripper_data_out[4] = 0
    # ==========================================================
    
    # Gripper ID
    test_list.append(bytes([Gripper_data[5]]))
 
    # CRC byte
    test_list.append(bytes([CRC_byte]))

    # END bytes
    test_list.append((end_bytes))
    
    #print(test_list)
    return test_list

def Get_data(Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):
    global input_byte 

    global start_cond1_byte 
    global start_cond2_byte 
    global start_cond3_byte 

    global end_cond1_byte 
    global end_cond2_byte 

    global start_cond1 
    global start_cond2 
    global start_cond3 

    global good_start 
    global data_len 

    global data_buffer 
    global data_counter

    while (ser.inWaiting() > 0):
        input_byte = ser.read()

        #UNCOMMENT THIS TO GET ALL DATA FROM THE ROBOT PRINTED
        #print(input_byte) 

        # When data len is received start is good and after that put all data in receive buffer
        # Data len is ALL data after it; that includes input buffer, end bytes and CRC
        if (good_start != 1):
            # All start bytes are good and next byte is data len
            if (start_cond1 == 1 and start_cond2 == 1 and start_cond3 == 1):
                good_start = 1
                data_len = input_byte
                data_len = struct.unpack('B', data_len)[0]
                logging.debug("data len we got from robot packet= ")
                logging.debug(input_byte)
                logging.debug("good start for DATA that we received at PC")
            # Third start byte is good
            if (input_byte == start_cond3_byte and start_cond2 == 1 and start_cond1 == 1):
                start_cond3 = 1
                #print("good cond 3 PC")
            #Third start byte is bad, reset all flags
            elif (start_cond2 == 1 and start_cond1 == 1):
                #print("bad cond 3 PC")
                start_cond1 = 0
                start_cond2 = 0
            # Second start byte is good
            if (input_byte == start_cond2_byte and start_cond1 == 1):
                start_cond2 = 1
                #print("good cond 2 PC ")
            #Second start byte is bad, reset all flags   
            elif (start_cond1 == 1):
                #print("Bad cond 2 PC")
                start_cond1 = 0
            # First start byte is good
            if (input_byte == start_cond1_byte):
                start_cond1 = 1
                #print("good cond 1 PC")
        else:
            # Here data goes after good  start
            data_buffer[data_counter] = input_byte
            if (data_counter == data_len - 1):

                logging.debug("Data len PC")
                logging.debug(data_len)
                logging.debug("End bytes are:")
                logging.debug(data_buffer[data_len -1])
                logging.debug(data_buffer[data_len -2])

                # Here if last 2 bytes are end condition bytes we process the data 
                if (data_buffer[data_len -1] == end_cond2_byte and data_buffer[data_len - 2] == end_cond1_byte):

                    logging.debug("GOOD END CONDITION PC")
                    logging.debug("I UNPACKED RAW DATA RECEIVED FROM THE ROBOT")
                    Unpack_data(data_buffer, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
                    XTR_data,Gripper_data_in)
                    logging.debug("DATA UNPACK FINISHED")
                    # ako su dobri izraÄunaj crc
                    # if crc dobar raspakiraj podatke
                    # ako je dobar paket je dobar i spremi ga u nove variable!
                
                # Print every byte
                #print("podaci u data bufferu su:")
                #for i in range(data_len):
                    #print(data_buffer[i])

                good_start = 0
                start_cond1 = 0
                start_cond3 = 0
                start_cond2 = 0
                data_len = 0
                data_counter = 0
            else:
                data_counter = data_counter + 1

# Split data to 3 bytes 
def Split_2_3_bytes(var_in):
    y = int_to_3_bytes(var_in & 0xFFFFFF) # converts my int value to bytes array
    return y

# Splits byte to bitfield list
def Split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]

# Fuses 3 bytes to 1 signed int
def Fuse_3_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<23:
        value -= 1<<24

    return value

# Fuses 2 bytes to 1 signed int
def Fuse_2_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<15:
        value -= 1<<16

    return value

# Fuse bitfield list to byte
def Fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Check if there is element 1 in the list. 
# If yes return its index, if no element is 1 return -1
def check_elements(lst):
    for i, element in enumerate(lst):
        if element == 1:
            return i
    return -1  # Return -1 if no element is 1

def quintic_scaling(s: float) -> float:
    """
    Calculates a smooth 0-to-1 scaling factor for progress 's'
    using a quintic polynomial, ensuring smooth start/end accelerations.
    """
    return 6 * (s**5) - 15 * (s**4) + 10 * (s**3)

#########################################################################
# Robot Commands Start Here
#########################################################################

class HomeCommand:
    """
    A non-blocking command that tells the robot to perform its internal homing sequence.
    This version uses a state machine to allow re-homing even if the robot is already homed.
    """
    def __init__(self):
        self.is_valid = True
        self.is_finished = False
        # State machine: START -> WAIT_FOR_UNHOMED -> WAIT_FOR_HOMED -> FINISHED
        self.state = "START"
        # Counter to send the home command for multiple cycles
        self.start_cmd_counter = 10  # Send command 100 for 10 cycles (0.1s)
        # Safety timeout (20 seconds at 0.01s interval)
        self.timeout_counter = 2000
        print("Initializing Home command...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Manages the homing command and monitors for completion using a state machine.
        """
        if self.is_finished:
            return True

        # --- State: START ---
        # On the first few executions, continuously send the 'home' (100) command.
        if self.state == "START":
            print(f"  -> Sending home signal (100)... Countdown: {self.start_cmd_counter}")
            Command_out.value = 100
            self.start_cmd_counter -= 1
            if self.start_cmd_counter <= 0:
                # Once sent for enough cycles, move to the next state
                self.state = "WAITING_FOR_UNHOMED"
            return False

        # --- State: WAITING_FOR_UNHOMED ---
        # The robot's firmware should reset the homed status. We wait to see that happen.
        # During this time, we send 'idle' (255) to let the robot's controller take over.
        if self.state == "WAITING_FOR_UNHOMED":
            Command_out.value = 255
            # Check if at least one joint has started homing (is no longer homed)
            if any(h == 0 for h in Homed_in[:6]):
                print("  -> Homing sequence initiated by robot.")
                self.state = "WAITING_FOR_HOMED"
            # Check for timeout
            self.timeout_counter -= 1
            if self.timeout_counter <= 0:
                print("  -> ERROR: Timeout waiting for robot to start homing sequence.")
                self.is_finished = True
            return self.is_finished

        # --- State: WAITING_FOR_HOMED ---
        # Now we wait for all joints to report that they are homed (all flags are 1).
        if self.state == "WAITING_FOR_HOMED":
            Command_out.value = 255
            # Check if all joints have finished homing
            if all(h == 1 for h in Homed_in[:6]):
                print("Homing sequence complete. All joints reported home.")
                self.is_finished = True
                Speed_out[:] = [0] * 6 # Ensure robot is stopped

        return self.is_finished

class JogCommand:
    """
    A non-blocking command to jog a joint for a specific duration or distance.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joint, speed_percentage=None, duration=None, distance_deg=None):
        """
        Initializes and validates the jog command. This is the SETUP phase.
        """
        self.is_valid = False
        self.is_finished = False
        self.mode = None
        self.command_step = 0

        # --- 1. Parameter Validation and Mode Selection ---
        if duration and distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Distance {distance_deg} deg, Duration {duration}s.")
        elif duration:
            self.mode = 'time'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Duration {duration}s.")
        elif distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Distance {distance_deg} deg.")
        else:
            print("Error: JogCommand requires either 'duration', 'distance_deg', or both.")
            return

        # --- 2. Store parameters for deferred calculation ---
        self.joint = joint
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.distance_deg = distance_deg

        # --- These will be calculated later ---
        self.direction = 1
        self.joint_index = 0
        self.speed_out = 0
        self.command_len = 0
        self.target_position = 0

        self.is_valid = True # Mark as valid for now; preparation step will confirm.


    def prepare_for_execution(self, current_position_in):
        """Pre-computes speeds and target positions using live data."""
        print(f"  -> Preparing for Jog command...")

        # Determine direction and joint index
        self.direction = 1 if 0 <= self.joint <= 5 else -1
        self.joint_index = self.joint if self.direction == 1 else self.joint - 6
        
        distance_steps = 0
        if self.distance_deg:
            distance_steps = int(PAROL6_ROBOT.DEG2STEPS(abs(self.distance_deg), self.joint_index))
            # --- MOVED LOGIC: Calculate target using the LIVE position ---
            self.target_position = current_position_in[self.joint_index] + (distance_steps * self.direction)
            
            min_limit, max_limit = PAROL6_ROBOT.Joint_limits_steps[self.joint_index]
            if not (min_limit <= self.target_position <= max_limit):
                print(f"  -> VALIDATION FAILED: Target position {self.target_position} is out of joint limits ({min_limit}, {max_limit}).")
                self.is_valid = False
                return

        # Calculate speed and duration
        speed_steps_per_sec = 0
        if self.mode == 'distance' and self.duration:
            speed_steps_per_sec = int(distance_steps / self.duration) if self.duration > 0 else 0
            max_joint_speed = PAROL6_ROBOT.Joint_max_speed[self.joint_index]
            if speed_steps_per_sec > max_joint_speed:
                print(f"  -> VALIDATION FAILED: Required speed ({speed_steps_per_sec} steps/s) exceeds joint's max speed ({max_joint_speed} steps/s).")
                self.is_valid = False
                return
        else:
            if self.speed_percentage is None:
                print("Error: 'speed_percentage' must be provided if not calculating automatically.")
                self.is_valid = False
                return
            speed_steps_per_sec = int(np.interp(abs(self.speed_percentage), [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[self.joint_index] * 2]))

        self.speed_out = speed_steps_per_sec * self.direction
        self.command_len = int(self.duration / INTERVAL_S) if self.duration else float('inf')
        print("  -> Jog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        stop_reason = None
        current_pos = Position_in[self.joint_index]

        if self.mode == 'time':
            if self.command_step >= self.command_len:
                stop_reason = "Timed jog finished."
        elif self.mode == 'distance':
            if (self.direction == 1 and current_pos >= self.target_position) or \
               (self.direction == -1 and current_pos <= self.target_position):
                stop_reason = "Distance jog finished."
        
        if not stop_reason:
            if (self.direction == 1 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][1]) or \
               (self.direction == -1 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][0]):
                stop_reason = f"Limit reached on joint {self.joint_index + 1}."

        if stop_reason:
            print(stop_reason)
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            Speed_out[:] = [0] * 6
            Speed_out[self.joint_index] = self.speed_out
            Command_out.value = 123
            self.command_step += 1
            return False
        
class MultiJogCommand:
    """
    A non-blocking command to jog multiple joints simultaneously for a specific duration.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joints, speed_percentages, duration):
        """
        Initializes and validates the multi-jog command.
        """
        self.is_valid = False
        self.is_finished = False
        self.command_step = 0

        # --- 1. Parameter Validation ---
        if not isinstance(joints, list) or not isinstance(speed_percentages, list):
            print("Error: MultiJogCommand requires 'joints' and 'speed_percentages' to be lists.")
            return

        if len(joints) != len(speed_percentages):
            print("Error: The number of joints must match the number of speed percentages.")
            return

        if not duration or duration <= 0:
            print("Error: MultiJogCommand requires a positive 'duration'.")
            return

        # ==========================================================
        # === NEW: Check for conflicting joint commands          ===
        # ==========================================================
        base_joints = set()
        for joint in joints:
            # Normalize the joint index to its base (0-5)
            base_joint = joint % 6
            # If the base joint is already in our set, it's a conflict.
            if base_joint in base_joints:
                print(f"  -> VALIDATION FAILED: Conflicting commands for Joint {base_joint + 1} (e.g., J1+ and J1-).")
                self.is_valid = False
                return
            base_joints.add(base_joint)
        # ==========================================================

        print(f"Initializing MultiJog for joints {joints} with speeds {speed_percentages}% for {duration}s.")

        # --- 2. Store parameters ---
        self.joints = joints
        self.speed_percentages = speed_percentages
        self.duration = duration
        self.command_len = int(self.duration / INTERVAL_S)

        # --- This will be calculated in the prepare step ---
        self.speeds_out = [0] * 6

        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Pre-computes the speeds for each joint."""
        print(f"  -> Preparing for MultiJog command...")

        for i, joint in enumerate(self.joints):
            # Determine direction and joint index (0-5 for positive, 6-11 for negative)
            direction = 1 if 0 <= joint <= 5 else -1
            joint_index = joint if direction == 1 else joint - 6
            speed_percentage = self.speed_percentages[i]

            # Check for joint index validity
            if not (0 <= joint_index < 6):
                print(f"  -> VALIDATION FAILED: Invalid joint index {joint_index}.")
                self.is_valid = False
                return

            # Calculate speed in steps/sec
            speed_steps_per_sec = int(np.interp(speed_percentage, [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[joint_index]]))
            self.speeds_out[joint_index] = speed_steps_per_sec * direction

        print("  -> MultiJog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        # Stop if the duration has elapsed
        if self.command_step >= self.command_len:
            print("Timed multi-jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            # Continuously check for joint limits during the jog
            for i in range(6):
                if self.speeds_out[i] != 0:
                    current_pos = Position_in[i]
                    # Hitting positive limit while moving positively
                    if self.speeds_out[i] > 0 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[i][1]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True
                    # Hitting negative limit while moving negatively
                    elif self.speeds_out[i] < 0 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[i][0]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True

            # If no limits are hit, apply the speeds
            Speed_out[:] = self.speeds_out
            Command_out.value = 123 # Jog command
            self.command_step += 1
            return False # Command is still running
        
# This dictionary maps descriptive axis names to movement vectors, which is cleaner.
# Format: ([x, y, z], [rx, ry, rz])
AXIS_MAP = {
    'X+': ([1, 0, 0], [0, 0, 0]), 'X-': ([-1, 0, 0], [0, 0, 0]),
    'Y+': ([0, 1, 0], [0, 0, 0]), 'Y-': ([0, -1, 0], [0, 0, 0]),
    'Z+': ([0, 0, 1], [0, 0, 0]), 'Z-': ([0, 0, -1], [0, 0, 0]),
    'RX+': ([0, 0, 0], [1, 0, 0]), 'RX-': ([0, 0, 0], [-1, 0, 0]),
    'RY+': ([0, 0, 0], [0, 1, 0]), 'RY-': ([0, 0, 0], [0, -1, 0]),
    'RZ+': ([0, 0, 0], [0, 0, 1]), 'RZ-': ([0, 0, 0], [0, 0, -1]),
}

class CartesianJogCommand:
    """
    A non-blocking command to jog the robot's end-effector in Cartesian space.
    This is the final, refactored version using clean, standard spatial math
    operations now that the core unit bug has been fixed.
    """
    def __init__(self, frame, axis, speed_percentage=50, duration=1.5, **kwargs):
        """
        Initializes and validates the Cartesian jog command.
        """
        self.is_valid = False
        self.is_finished = False
        print(f"Initializing CartesianJog: Frame {frame}, Axis {axis}...")

        if axis not in AXIS_MAP:
            print(f"  -> VALIDATION FAILED: Invalid axis '{axis}'.")
            return
        
        # Store all necessary parameters for use in execute_step
        self.frame = frame
        self.axis_vectors = AXIS_MAP[axis]
        self.is_rotation = any(self.axis_vectors[1])
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.end_time = time.time() + self.duration
        
        self.is_valid = True
        print("  -> Command is valid and ready.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Check for completion ---
        if time.time() >= self.end_time:
            print("Cartesian jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- B. Calculate Target Pose using clean vector math ---
        Command_out.value = 123 # Set jog command
        
        q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        T_current = PAROL6_ROBOT.robot.fkine(q_current)

        if not isinstance(T_current, SE3):
            return False # Wait for valid pose data

        # Calculate speed and displacement for this cycle
        linear_speed_ms = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min_JOG, PAROL6_ROBOT.Cartesian_linear_velocity_max_JOG]))
        angular_speed_degs = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max]))

        delta_linear = linear_speed_ms * INTERVAL_S
        delta_angular_rad = np.deg2rad(angular_speed_degs * INTERVAL_S)

        # Create the small incremental transformation (delta_pose)
        trans_vec = np.array(self.axis_vectors[0]) * delta_linear
        rot_vec = np.array(self.axis_vectors[1]) * delta_angular_rad
        delta_pose = SE3.Rt(SE3.Eul(rot_vec).R, trans_vec)

        # Apply the transformation in the correct reference frame
        if self.frame == 'WRF':
            # Pre-multiply to apply the change in the World Reference Frame
            target_pose = delta_pose * T_current
        else: # TRF
            # Post-multiply to apply the change in the Tool Reference Frame
            target_pose = T_current * delta_pose
        
        # --- C. Solve IK and Calculate Velocities ---
        var = solve_ik_with_adaptive_tol_subdivision(PAROL6_ROBOT.robot, target_pose, q_current, jogging=True)

        if var.success:
            q_velocities = (var.q - q_current) / INTERVAL_S
            for i in range(6):
                Speed_out[i] = int(PAROL6_ROBOT.SPEED_RAD2STEP(q_velocities[i], i))
        else:
            print("IK Warning: Could not find solution for jog step. Stopping.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- D. Speed Scaling ---
        max_scale_factor = 1.0
        for i in range(6):
            if abs(Speed_out[i]) > PAROL6_ROBOT.Joint_max_speed[i]:
                scale = abs(Speed_out[i]) / PAROL6_ROBOT.Joint_max_speed[i]
                if scale > max_scale_factor:
                    max_scale_factor = scale
        
        if max_scale_factor > 1.0:
            for i in range(6):
                Speed_out[i] = int(Speed_out[i] / max_scale_factor)

        return False # Command is still running

class MovePoseCommand:
    """
    A non-blocking command to move the robot to a specific Cartesian pose.
    The movement itself is a joint-space interpolation.
    """
    def __init__(self, pose, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = True  # Assume valid; preparation step will confirm.
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MovePose to {pose}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.pose = pose
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

    """
        Initializes, validates, and pre-computes the trajectory for a move-to-pose command.

        Args:
            pose (list): A list of 6 values [x, y, z, r, p, y] for the target pose.
                         Positions are in mm, rotations are in degrees.
            duration (float, optional): The total time for the movement in seconds.
            velocity_percent (float, optional): The target velocity as a percentage (0-100).
            accel_percent (float, optional): The target acceleration as a percentage (0-100).
            trajectory_type (str, optional): The type of trajectory ('poly' or 'trap').
        """
    
    def prepare_for_execution(self, current_position_in):
        """Calculates the full trajectory just-in-time before execution."""
        print(f"  -> Preparing trajectory for MovePose to {self.pose}...")

        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pose = SE3(self.pose[0] / 1000.0, self.pose[1] / 1000.0, self.pose[2] / 1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')
        
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_pose, initial_pos_rad, ilimit=100)

        if not ik_solution.success:
            print("  -> VALIDATION FAILED: Inverse kinematics failed at execution time.")
            self.is_valid = False
            return

        target_pos_rad = ik_solution.q

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])

                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue
                    
                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)
            
                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                self.is_valid = False
                return

        else:
            print("  -> Using conservative values for MovePose.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveJointCommand:
    """
    A non-blocking command to move the robot's joints to a specific configuration.
    It pre-calculates the entire trajectory upon initialization.
    """
    def __init__(self, target_angles, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = False  # Will be set to True after basic validation
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MoveJoint to {target_angles}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.target_angles = target_angles
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

        # --- Perform only state-independent validation ---
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])
        for i in range(6):
            min_rad, max_rad = PAROL6_ROBOT.Joint_limits_radian[i]
            if not (min_rad <= target_pos_rad[i] <= max_rad):
                print(f"  -> VALIDATION FAILED: Target for Joint {i+1} ({self.target_angles[i]} deg) is out of range.")
                return
        
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Calculates the trajectory just before execution begins."""
        print(f"  -> Preparing trajectory for MoveJoint to {self.target_angles}...")
        
        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])
                
                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue

                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)

                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                print(f"  -> Please check Joint_min/max_speed and Joint_min/max_acc values in PAROL6_ROBOT.py.")
                self.is_valid = False
                return
        
        else:
            print("  -> Using conservative values for MoveJoint.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveCartCommand:
    """
    A non-blocking command to move the robot's end-effector in a straight line
    in Cartesian space, completing the move in an exact duration.

    It works by:
    1. Pre-validating the final target pose.
    2. Interpolating the pose in Cartesian space in real-time.
    3. Solving Inverse Kinematics for each intermediate step to ensure path validity.
    """
    def __init__(self, pose, duration=None, velocity_percent=None):
        self.is_valid = False
        self.is_finished = False

        # --- MODIFICATION: Validate that at least one timing parameter is given ---
        if duration is None and velocity_percent is None:
            print("  -> VALIDATION FAILED: MoveCartCommand requires either 'duration' or 'velocity_percent'.")
            return
        if duration is not None and velocity_percent is not None:
            print("  -> INFO: Both duration and velocity_percent provided. Using duration.")
            self.velocity_percent = None # Prioritize duration
        else:
            self.velocity_percent = velocity_percent

        # --- Store parameters and set placeholders ---
        self.duration = duration
        self.pose = pose
        self.start_time = None
        self.initial_pose = None
        self.target_pose = None
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Captures the initial state and validates the path just before execution."""
        print(f"  -> Preparing for MoveCart to {self.pose}...")
        
        # --- MOVED LOGIC: Capture initial state from live data ---
        initial_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        self.initial_pose = PAROL6_ROBOT.robot.fkine(initial_q_rad)
        self.target_pose = SE3(self.pose[0]/1000.0, self.pose[1]/1000.0, self.pose[2]/1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')

        print("  -> Pre-validating final target pose...")
        ik_check = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, self.target_pose, initial_q_rad
        )

        if not ik_check.success:
            print("  -> VALIDATION FAILED: The final target pose is unreachable.")
            if ik_check.violations:
                print(f"     Reason: Solution violates joint limits: {ik_check.violations}")
            self.is_valid = False # Mark as invalid if path fails
            return

        # --- NEW BLOCK: Calculate duration from velocity if needed ---
        if self.velocity_percent is not None:
            print(f"  -> Calculating duration for {self.velocity_percent}% speed...")
            # Calculate the total distance for translation and rotation
            linear_distance = np.linalg.norm(self.target_pose.t - self.initial_pose.t)
            angular_distance_rad = self.initial_pose.angdist(self.target_pose)

            # Interpolate the target speeds from percentages, assuming constants exist in PAROL6_ROBOT
            target_linear_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min, PAROL6_ROBOT.Cartesian_linear_velocity_max])
            target_angular_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max])
            target_angular_speed_rad = np.deg2rad(target_angular_speed)

            # Calculate time required for each component of the movement
            time_linear = linear_distance / target_linear_speed if target_linear_speed > 0 else 0
            time_angular = angular_distance_rad / target_angular_speed_rad if target_angular_speed_rad > 0 else 0

            # The total duration is the longer of the two times to ensure synchronization
            calculated_duration = max(time_linear, time_angular)

            if calculated_duration <= 0:
                print("  -> INFO: MoveCart has zero duration. Marking as finished.")
                self.is_finished = True
                self.is_valid = True # It's valid, just already done.
                return

            self.duration = calculated_duration
            print(f"  -> Calculated MoveCart duration: {self.duration:.2f}s")

        print("  -> Command is valid and ready for execution.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        if self.start_time is None:
            self.start_time = time.time()

        elapsed_time = time.time() - self.start_time
        s = min(elapsed_time / self.duration, 1.0)
        s_scaled = quintic_scaling(s)

        current_target_pose = self.initial_pose.interp(self.target_pose, s_scaled)

        current_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, current_target_pose, current_q_rad
        )

        if not ik_solution.success:
            print("  -> ERROR: MoveCart failed. An intermediate point on the path is unreachable.")
            if ik_solution.violations:
                 print(f"     Reason: Path violates joint limits: {ik_solution.violations}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        current_pos_rad = ik_solution.q

        # --- MODIFIED BLOCK ---
        # Send only the target position and let the firmware's P-controller handle speed.
        Position_out[:] = [int(PAROL6_ROBOT.RAD2STEPS(p, i)) for i, p in enumerate(current_pos_rad)]
        Speed_out[:] = [0] * 6 # Set feed-forward velocity to zero for smooth P-control.
        Command_out.value = 156
        # --- END MODIFIED BLOCK ---

        if s >= 1.0:
            print(f"MoveCart finished in ~{elapsed_time:.2f}s.")
            self.is_finished = True
            # The main loop will handle holding the final position.

        return self.is_finished
        
class GripperCommand:
    """
    A single, unified, non-blocking command to control all gripper functions.
    It internally selects the correct logic (position-based waiting, timed delay,
    or instantaneous) based on the specified action.
    """
    def __init__(self, gripper_type, action=None, position=100, speed=100, current=500, output_port=1):
        """
        Initializes the Gripper command and configures its internal state machine
        based on the requested action.
        """
        self.is_valid = True
        self.is_finished = False
        self.gripper_type = gripper_type.lower()
        self.action = action.lower() if action else 'move'
        self.state = "START"
        self.timeout_counter = 1000 # 10-second safety timeout for all waiting states

        # --- Configure based on Gripper Type and Action ---
        if self.gripper_type == 'electric':
            if self.action == 'move':
                self.target_position = position
                self.speed = speed
                self.current = current
                if not (0 <= position <= 255 and 0 <= speed <= 255 and 100 <= current <= 1000):
                    self.is_valid = False
            elif self.action == 'calibrate':
                self.wait_counter = 200 # 2-second fixed delay for calibration
            else:
                self.is_valid = False # Invalid action

        elif self.gripper_type == 'pneumatic':
            if self.action not in ['open', 'close']:
                self.is_valid = False
            self.state_to_set = 1 if self.action == 'open' else 0
            self.port_index = 2 if output_port == 1 else 3
        else:
            self.is_valid = False

        if not self.is_valid:
            print(f"  -> VALIDATION FAILED for GripperCommand with action: '{self.action}'")

    def execute_step(self, Gripper_data_out, InOut_out, Gripper_data_in, InOut_in, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        self.timeout_counter -= 1
        if self.timeout_counter <= 0:
            print(f"  -> ERROR: Gripper command timed out in state {self.state}.")
            self.is_finished = True
            return True

        # --- Pneumatic Logic (Instantaneous) ---
        if self.gripper_type == 'pneumatic':
            InOut_out[self.port_index] = self.state_to_set
            print("  -> Pneumatic gripper command sent.")
            self.is_finished = True
            return True

        # --- Electric Gripper Logic ---
        if self.gripper_type == 'electric':
            # On the first run, transition to the correct state for the action
            if self.state == "START":
                if self.action == 'calibrate':
                    self.state = "SEND_CALIBRATE"
                else: # 'move'
                    self.state = "WAIT_FOR_POSITION"
            
            # --- Calibrate Logic (Timed Delay) ---
            if self.state == "SEND_CALIBRATE":
                print("  -> Sending one-shot calibrate command...")
                Gripper_data_out[4] = 1 # Set mode to calibrate
                self.state = "WAITING_CALIBRATION"
                return False

            if self.state == "WAITING_CALIBRATION":
                self.wait_counter -= 1
                if self.wait_counter <= 0:
                    print("  -> Calibration delay finished.")
                    Gripper_data_out[4] = 0 # Reset to operation mode
                    self.is_finished = True
                    return True
                return False

            # --- Move Logic (Position-Based) ---
            if self.state == "WAIT_FOR_POSITION":
                # Persistently send the move command
                Gripper_data_out[0], Gripper_data_out[1], Gripper_data_out[2] = self.target_position, self.speed, self.current
                Gripper_data_out[4] = 0 # Operation mode
                bitfield = [1, 1, not InOut_in[4], 1, 0, 0, 0, 0]
                fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                Gripper_data_out[3] = int(fused.hex(), 16)

                # Check for completion
                current_position = Gripper_data_in[1]
                if abs(current_position - self.target_position) <= 5:
                    print(f"  -> Gripper move complete.")
                    self.is_finished = True
                    # Set command back to idle
                    bitfield = [1, 0, not InOut_in[4], 1, 0, 0, 0, 0]
                    fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                    Gripper_data_out[3] = int(fused.hex(), 16)
                    return True
                return False
        
        return self.is_finished

class DelayCommand:
    """
    A non-blocking command that pauses execution for a specified duration.
    During the delay, it ensures the robot remains idle by sending the
    appropriate commands.
    """
    def __init__(self, duration):
        """
        Initializes and validates the Delay command.

        Args:
            duration (float): The delay time in seconds.
        """
        self.is_valid = False
        self.is_finished = False

        # --- 1. Parameter Validation ---
        if not isinstance(duration, (int, float)) or duration <= 0:
            print(f"  -> VALIDATION FAILED: Delay duration must be a positive number, but got {duration}.")
            return

        print(f"Initializing Delay for {duration} seconds...")
        
        self.duration = duration
        self.end_time = None  # Will be set in prepare_for_execution
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Set the end time when the command actually starts."""
        self.end_time = time.time() + self.duration
        print(f"  -> Delay starting for {self.duration} seconds...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Checks if the delay duration has passed and keeps the robot idle.
        This method is called on every loop cycle (~0.01s).
        """
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Keep the robot idle during the delay ---
        Command_out.value = 255  # Set command to idle
        Speed_out[:] = [0] * 6   # Set all speeds to zero

        # --- B. Check for completion ---
        if self.end_time and time.time() >= self.end_time:
            print(f"Delay finished after {self.duration} seconds.")
            self.is_finished = True
        
        return self.is_finished
    
#########################################################################
# Smooth Motion Commands Start Here
#########################################################################
    
class BaseSmoothMotionCommand:
    """
    Base class for all smooth motion commands with proper error tracking.
    """
    
    def __init__(self, description="smooth motion"):
        self.description = description
        self.trajectory = None
        self.trajectory_command = None
        self.transition_command = None
        self.is_valid = True
        self.is_finished = False
        self.specified_start_pose = None
        self.transition_complete = False
        self.trajectory_prepared = False
        self.error_state = False
        self.error_message = ""
        self.trajectory_generated = False  # NEW: Track if trajectory is generated
        
    def create_transition_command(self, current_pose, target_pose):
        """Create a MovePose command for smooth transition to start position."""
        pos_error = np.linalg.norm(
            np.array(target_pose[:3]) - np.array(current_pose[:3])
        )
        
        # Lower threshold to 2mm for more aggressive transition generation
        if pos_error < 2.0:  # Changed from 5.0mm to 2.0mm
            print(f"  -> Already near start position (error: {pos_error:.1f}mm)")
            return None
        
        print(f"  -> Creating smooth transition to start ({pos_error:.1f}mm away)")
        
        # Calculate transition speed based on distance
        # Slower for short distances, faster for long distances
        if pos_error < 10:
            transition_speed = 20.0  # mm/s for short distances
        elif pos_error < 30:
            transition_speed = 30.0  # mm/s for medium distances
        else:
            transition_speed = 40.0  # mm/s for long distances
        
        transition_duration = max(pos_error / transition_speed, 0.5)  # Minimum 0.5s
        
        transition_cmd = MovePoseCommand(
            pose=target_pose,
            duration=transition_duration
        )
        
        return transition_cmd
    
    def get_current_pose_from_position(self, position_in):
        """Convert current position to pose [x,y,z,rx,ry,rz]"""
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(position_in)])
        current_pose_se3 = PAROL6_ROBOT.robot.fkine(current_q)
        
        current_xyz = current_pose_se3.t * 1000  # Convert to mm
        current_rpy = current_pose_se3.rpy(unit='deg', order='xyz')
        return np.concatenate([current_xyz, current_rpy]).tolist()
        
    def prepare_for_execution(self, current_position_in):
        """Minimal preparation - just check if we need a transition."""
        print(f"  -> Preparing {self.description}...")
        
        # If there's a specified start pose, prepare transition
        if self.specified_start_pose:
            actual_current_pose = self.get_current_pose_from_position(current_position_in)
            self.transition_command = self.create_transition_command(
                actual_current_pose, self.specified_start_pose
            )
            
            if self.transition_command:
                self.transition_command.prepare_for_execution(current_position_in)
                if not self.transition_command.is_valid:
                    print(f"  -> ERROR: Cannot reach specified start position")
                    self.is_valid = False
                    self.error_state = True
                    self.error_message = "Cannot reach specified start position"
                    return
        else:
            self.transition_command = None
            
        # DON'T generate trajectory yet - wait until execution
        self.trajectory_generated = False
        self.trajectory_prepared = False
        print(f"  -> {self.description} preparation complete (trajectory will be generated at execution)")
            
    def generate_main_trajectory(self, effective_start_pose):
        """Override this in subclasses to generate the specific motion trajectory."""
        raise NotImplementedError("Subclasses must implement generate_main_trajectory")
        
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """Execute transition first if needed, then generate and execute trajectory."""
        if self.is_finished or not self.is_valid:
            return True
        
        # Execute transition first if needed
        if self.transition_command and not self.transition_complete:
            is_done = self.transition_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            if is_done:
                print(f"  -> Transition complete")
                self.transition_complete = True
            return False
        
        # Generate trajectory on first execution step (not during preparation!)
        if not self.trajectory_generated:
            # Get ACTUAL current position NOW
            actual_current_pose = self.get_current_pose_from_position(Position_in)
            print(f"  -> Generating {self.description} from ACTUAL position: {[round(p, 1) for p in actual_current_pose[:3]]}")
            
            # Generate trajectory from where we ACTUALLY are
            self.trajectory = self.generate_main_trajectory(actual_current_pose)
            self.trajectory_command = SmoothTrajectoryCommand(
                self.trajectory, self.description
            )
            
            # Quick validation of first point only
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(Position_in)])
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
            )
            
            if not ik_result.success:
                print(f"  -> ERROR: Cannot reach first trajectory point")
                self.is_finished = True
                self.error_state = True
                self.error_message = "Cannot reach trajectory start"
                Speed_out[:] = [0] * 6
                Command_out.value = 255
                return True
                
            self.trajectory_generated = True
            self.trajectory_prepared = True
            
            # Verify first point is close to current
            distance = np.linalg.norm(first_pose[:3] - np.array(actual_current_pose[:3]))
            if distance > 5.0:
                print(f"  -> WARNING: First trajectory point {distance:.1f}mm from current!")
        
        # Execute main trajectory
        if self.trajectory_command and self.trajectory_prepared:
            is_done = self.trajectory_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            # Check for errors in trajectory execution
            if hasattr(self.trajectory_command, 'error_state') and self.trajectory_command.error_state:
                self.error_state = True
                self.error_message = self.trajectory_command.error_message
            
            if is_done:
                self.is_finished = True
            
            return is_done
        else:
            self.is_finished = True
            return True

class SmoothTrajectoryCommand:
    """Command class for executing pre-generated smooth trajectories."""
    
    def __init__(self, trajectory, description="smooth motion"):
        self.trajectory = np.array(trajectory)
        self.description = description
        self.trajectory_index = 0
        self.is_valid = True
        self.is_finished = False
        self.first_step = True
        self.error_state = False
        self.error_message = ""
        
        print(f"Initializing smooth {description} with {len(trajectory)} points")
    
    def prepare_for_execution(self, current_position_in):
        """Skip validation - trajectory is already generated from correct position"""
        # No validation needed since trajectory was just generated from current position
        self.is_valid = True
        return
    
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, Position_out=None, **kwargs):
        """Execute one step of the smooth trajectory"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Get Position_out from kwargs if not provided
        if Position_out is None:
            Position_out = kwargs.get('Position_out', Position_in)
        
        if self.trajectory_index >= len(self.trajectory):
            print(f"Smooth {self.description} finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get target pose for this step
        target_pose = self.trajectory[self.trajectory_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                            for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
        )
        
        if not ik_result.success:
            print(f"  -> IK failed at trajectory point {self.trajectory_index}")
            self.is_finished = True
            self.error_state = True
            self.error_message = f"IK failed at point {self.trajectory_index}/{len(self.trajectory)}"
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                    for i, q in enumerate(ik_result.q)]
        
        # ADD VELOCITY LIMITING - This prevents violent movements
        if self.trajectory_index > 0:
            for i in range(6):
                step_diff = abs(target_steps[i] - Position_in[i])
                max_step_diff = PAROL6_ROBOT.Joint_max_speed[i] * 0.01  # Max steps in 10ms
                
                # Use 1.2x safety margin (not 2x as before)
                if step_diff > max_step_diff * 1.2:
                    #print(f"  -> WARNING: Joint {i+1} velocity limit exceeded at point {self.trajectory_index}")
                    #print(f"     Step difference: {step_diff}, Max allowed: {max_step_diff * 1.2:.1f}")
                    
                    # Clamp the motion
                    sign = 1 if target_steps[i] > Position_in[i] else -1
                    target_steps[i] = Position_in[i] + sign * int(max_step_diff)
        
        # Send position command
        Position_out[:] = target_steps
        Speed_out[:] = [0] * 6
        Command_out.value = 156
        
        # Advance to next point
        self.trajectory_index += 1
        
        return False

class SmoothCircleCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, plane, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"circle (r={radius}mm, {frame})")
        self.center = center
        self.radius = radius
        self.plane = plane
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame  # Store reference frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None  # Store for TRF transformation
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        # Store current position for potential use in generate_main_trajectory
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'center': self.center,
                'plane': self.plane
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_CIRCLE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Circle: center {self.center[:3]} (WRF), normal {self.normal_vector}")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_CIRCLE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        # Now do normal preparation with transformed parameters
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate circle starting from the actual start position."""
        motion_gen = CircularMotion()
        
        # Use transformed normal for TRF, or standard for WRF
        if self.normal_vector is not None:
            # TRF - use the transformed normal vector
            normal = np.array(self.normal_vector)
            print(f"    Using transformed normal: {normal.round(3)}")
        else:
            # WRF - use standard plane definition
            plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
            normal = np.array(plane_normals.get(self.plane, [0, 0, 1]))  # Convert to numpy array
            print(f"    Using WRF plane {self.plane} with normal: {normal}")
        
        print(f"    Generating circle from position: {[round(p, 1) for p in effective_start_pose[:3]]}")
        print(f"    Circle center: {[round(c, 1) for c in self.center]}")
        
        # Add geometry validation
        center_np = np.array(self.center)
        start_np = np.array(effective_start_pose[:3])
        
        # Project start point onto circle plane to check distance
        to_start = start_np - center_np
        to_start_plane = to_start - np.dot(to_start, normal) * normal
        distance_to_center = np.linalg.norm(to_start_plane)
        
        if abs(distance_to_center - self.radius) > self.radius * 0.3:
            print(f"    WARNING: Robot is {distance_to_center:.1f}mm from center, but radius is {self.radius:.1f}mm")
            print(f"    Circle geometry will be auto-corrected")
        
        # Generate circle that starts at effective_start_pose
        trajectory = motion_gen.generate_circle_3d(
            self.center, 
            self.radius, 
            normal,  # This normal now correctly represents the plane
            start_point=effective_start_pose[:3],
            duration=self.duration
        )
        
        if self.clockwise:
            trajectory = trajectory[::-1]
        
        # Update orientations to match start pose
        for i in range(len(trajectory)):
            trajectory[i][3:] = effective_start_pose[3:]
        
        return trajectory
    
class SmoothArcCenterCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, center, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"arc (center-based, {frame})")
        self.end_pose = end_pose
        self.center = center
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {
                'end_pose': self.end_pose,
                'center': self.center
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
            )
            self.end_pose = transformed['end_pose']
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc from actual start to end."""
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, self.center,
            normal=self.normal_vector,  # Use transformed normal if TRF
            clockwise=self.clockwise, duration=self.duration
        )
    
class SmoothArcParamCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, radius, arc_angle, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"parametric arc (r={radius}mm, Î¸={arc_angle}Â°, {frame})")
        self.end_pose = end_pose
        self.radius = radius
        self.arc_angle = arc_angle
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'end_pose': self.end_pose,
                'plane': 'XY'  # Default plane for parametric arc
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.end_pose = transformed['end_pose']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Parametric Arc: end {self.end_pose[:3]} (WRF)")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc based on radius and angle from actual start."""
        # Get start and end positions
        start_xyz = np.array(effective_start_pose[:3])
        end_xyz = np.array(self.end_pose[:3])
        
        # If we have a transformed normal (TRF), use it to define the arc plane
        if self.normal_vector is not None:
            normal = np.array(self.normal_vector)
            
            # Project start and end onto the plane perpendicular to normal
            # This ensures the arc stays in the correct plane for TRF
            
            # Find center of arc using radius and angle
            chord_vec = end_xyz - start_xyz
            chord_length = np.linalg.norm(chord_vec)
            
            if chord_length > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({chord_length:.1f}mm) for radius {self.radius}mm")
                self.radius = chord_length / 2 + 1
            
            # Calculate center position using the normal vector
            chord_mid = (start_xyz + end_xyz) / 2
            
            # Height from chord midpoint to arc center
            if chord_length > 0:
                h = np.sqrt(max(0, self.radius**2 - (chord_length/2)**2))
                
                # Find perpendicular in the plane defined by normal
                chord_dir = chord_vec / chord_length
                perp_in_plane = np.cross(normal, chord_dir)
                if np.linalg.norm(perp_in_plane) > 0.001:
                    perp_in_plane = perp_in_plane / np.linalg.norm(perp_in_plane)
                else:
                    # Chord is parallel to normal (shouldn't happen)
                    perp_in_plane = np.array([1, 0, 0])
                
                # Arc center
                if self.clockwise:
                    center_3d = chord_mid - h * perp_in_plane
                else:
                    center_3d = chord_mid + h * perp_in_plane
            else:
                center_3d = start_xyz
            
        else:
            # WRF - use XY plane (standard behavior)
            normal = np.array([0, 0, 1])
            
            # Calculate arc center in XY plane
            start_xy = start_xyz[:2]
            end_xy = end_xyz[:2]
            
            # Midpoint
            mid = (start_xy + end_xy) / 2
            
            # Distance between points
            d = np.linalg.norm(end_xy - start_xy)
            
            if d > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({d:.1f}mm) for radius {self.radius}mm")
                self.radius = d / 2 + 1
            
            # Height of arc center from midpoint
            h = np.sqrt(max(0, self.radius**2 - (d/2)**2))
            
            # Perpendicular direction
            if d > 0:
                perp = np.array([-(end_xy[1] - start_xy[1]), end_xy[0] - start_xy[0]])
                perp = perp / np.linalg.norm(perp)
            else:
                perp = np.array([1, 0])
            
            # Arc center (choose based on clockwise)
            if self.clockwise:
                center_2d = mid - h * perp
            else:
                center_2d = mid + h * perp
            
            # Use average Z for center
            center_3d = [center_2d[0], center_2d[1], (start_xyz[2] + end_xyz[2]) / 2]
        
        # Generate arc trajectory from actual start
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, center_3d.tolist(),
            normal=normal if self.normal_vector is not None else None,
            clockwise=self.clockwise, duration=self.duration
        )

class SmoothHelixCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, pitch, height, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"helix (h={height}mm, {frame})")
        self.center = center
        self.radius = radius
        self.pitch = pitch
        self.height = height
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.helix_axis = None
        self.up_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {'center': self.center}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_HELIX', params, 'TRF', current_position_in
            )
            self.center = transformed['center']
            self.helix_axis = transformed.get('helix_axis', [0, 0, 1])
            self.up_vector = transformed.get('up_vector', [0, 1, 0])
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_HELIX', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate helix with proper axis orientation."""
        num_revolutions = self.height / self.pitch if self.pitch > 0 else 1
        num_points = int(self.duration * 100)  # 100Hz
        
        # Get helix axis (default Z for WRF, transformed for TRF)
        if self.helix_axis is not None:
            axis = np.array(self.helix_axis)
        else:
            axis = np.array([0, 0, 1])  # Default vertical
        
        # Create orthonormal basis for helix
        if self.up_vector is not None:
            up = np.array(self.up_vector)
        else:
            # Find perpendicular to axis
            if abs(axis[2]) < 0.9:
                up = np.array([0, 0, 1])
            else:
                up = np.array([1, 0, 0])
        
        # Ensure up is perpendicular to axis
        up = up - np.dot(up, axis) * axis
        up = up / np.linalg.norm(up)
        
        # Create right vector
        right = np.cross(axis, up)
        
        # Calculate starting angle based on actual start position
        to_start = np.array(effective_start_pose[:3]) - np.array(self.center)
        # Project onto plane perpendicular to axis
        to_start_plane = to_start - np.dot(to_start, axis) * axis
        
        if np.linalg.norm(to_start_plane) > 0.001:
            to_start_normalized = to_start_plane / np.linalg.norm(to_start_plane)
            start_angle = np.arctan2(np.dot(to_start_normalized, up), 
                                    np.dot(to_start_normalized, right))
        else:
            start_angle = 0
        
        trajectory = []
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            
            angle = start_angle + 2 * np.pi * num_revolutions * t
            if self.clockwise:
                angle = start_angle - 2 * np.pi * num_revolutions * t
            
            # Position on helix
            pos = np.array(self.center) + \
                  self.radius * (np.cos(angle) * right + np.sin(angle) * up) + \
                  self.height * t * axis
            
            # Use orientation from effective start
            trajectory.append(np.concatenate([pos, effective_start_pose[3:]]))
        
        return np.array(trajectory)

class SmoothSplineCommand(BaseSmoothMotionCommand):
    def __init__(self, waypoints, duration, frame='WRF', start_pose=None):
        super().__init__(f"spline ({len(waypoints)} points, {frame})")
        self.waypoints = waypoints
        self.duration = duration
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform waypoints to WRF
            params = {'waypoints': self.waypoints}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_SPLINE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.waypoints = transformed['waypoints']
            
            print(f"  -> TRF Spline: transformed {len(self.waypoints)} waypoints to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_SPLINE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate spline starting from actual position."""
        motion_gen = SplineMotion()
        
        # Always start from the effective start pose
        first_wp_error = np.linalg.norm(
            np.array(self.waypoints[0][:3]) - np.array(effective_start_pose[:3])
        )
        
        if first_wp_error > 5.0:
            # First waypoint is far, prepend the start position
            modified_waypoints = [effective_start_pose] + self.waypoints
            print(f"    Added start position as first waypoint (distance: {first_wp_error:.1f}mm)")
        else:
            # Replace first waypoint with actual start to ensure continuity
            modified_waypoints = [effective_start_pose] + self.waypoints[1:]
            print(f"    Replaced first waypoint with actual start position")
        
        timestamps = np.linspace(0, self.duration, len(modified_waypoints))
        
        # Generate the spline trajectory
        trajectory = motion_gen.generate_cubic_spline(modified_waypoints, timestamps)
        
        print(f"    Generated spline with {len(trajectory)} points")
        
        return trajectory

class SmoothBlendCommand(BaseSmoothMotionCommand):
    def __init__(self, segment_definitions, blend_time, frame='WRF', start_pose=None):
        super().__init__(f"blended ({len(segment_definitions)} segments, {frame})")
        self.segment_definitions = segment_definitions
        self.blend_time = blend_time
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform all segment definitions to WRF
            params = {'segments': self.segment_definitions}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_BLEND', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.segment_definitions = transformed['segments']
            
            print(f"  -> TRF Blend: transformed {len(self.segment_definitions)} segments to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_BLEND', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate blended trajectory starting from actual position."""
        trajectories = []
        motion_gen_circle = CircularMotion()
        motion_gen_spline = SplineMotion()
        
        # Always start from effective start pose
        last_end_pose = effective_start_pose
        
        for i, seg_def in enumerate(self.segment_definitions):
            seg_type = seg_def['type']
            
            # First segment always starts from effective_start_pose
            segment_start = effective_start_pose if i == 0 else last_end_pose
            
            if seg_type == 'LINE':
                end = seg_def['end']
                duration = seg_def['duration']
                
                # Generate line segment from actual position
                num_points = int(duration * 100)
                timestamps = np.linspace(0, duration, num_points)
                
                traj = []
                for t in timestamps:
                    s = t / duration if duration > 0 else 1
                    # Interpolate position
                    pos = [
                        segment_start[j] * (1-s) + end[j] * s
                        for j in range(3)
                    ]
                    # Interpolate orientation
                    orient = [
                        segment_start[j+3] * (1-s) + end[j+3] * s
                        for j in range(3)
                    ]
                    traj.append(pos + orient)
                
                trajectories.append(np.array(traj))
                last_end_pose = end
                
            elif seg_type == 'ARC':
                end = seg_def['end']
                center = seg_def['center']
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Check if we have a transformed normal (from TRF)
                normal = seg_def.get('normal_vector', None)
                
                traj = motion_gen_circle.generate_arc_3d(
                    segment_start, end, center, 
                    normal=normal,  # Use transformed normal if available
                    clockwise=clockwise, duration=duration
                )
                trajectories.append(traj)
                last_end_pose = end
                
            elif seg_type == 'CIRCLE':
                center = seg_def['center']
                radius = seg_def['radius']
                plane = seg_def.get('plane', 'XY')
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Use transformed normal if available (from TRF)
                if 'normal_vector' in seg_def:
                    normal = seg_def['normal_vector']
                else:
                    plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
                    normal = plane_normals.get(plane, [0, 0, 1])
                
                traj = motion_gen_circle.generate_circle_3d(
                    center, radius, normal, 
                    start_point=segment_start[:3],
                    duration=duration
                )
                
                if clockwise:
                    traj = traj[::-1]
                    
                # Update orientations
                for j in range(len(traj)):
                    traj[j][3:] = segment_start[3:]
                    
                trajectories.append(traj)
                # Circle returns to start, so last pose is last point of trajectory
                last_end_pose = traj[-1].tolist()
                
            elif seg_type == 'SPLINE':
                waypoints = seg_def['waypoints']
                duration = seg_def['duration']
                
                # Check if first waypoint is close to segment start
                wp_error = np.linalg.norm(
                    np.array(waypoints[0][:3]) - np.array(segment_start[:3])
                )
                
                if wp_error > 5.0:
                    full_waypoints = [segment_start] + waypoints
                else:
                    full_waypoints = [segment_start] + waypoints[1:]
                
                timestamps = np.linspace(0, duration, len(full_waypoints))
                traj = motion_gen_spline.generate_cubic_spline(full_waypoints, timestamps)
                trajectories.append(traj)
                last_end_pose = waypoints[-1]
        
        # Blend all trajectories
        if len(trajectories) > 1:
            blender = MotionBlender(self.blend_time)
            blended = trajectories[0]
            blend_samples = int(self.blend_time * 100)
            
            for i in range(1, len(trajectories)):
                blended = blender.blend_trajectories(blended, trajectories[i], blend_samples)
            
            print(f"    Blended {len(trajectories)} segments into {len(blended)} points")
            return blended
        elif trajectories:
            return trajectories[0]
        else:
            raise ValueError("No trajectories generated in blend")
        
def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
    """
    Calculate duration based on trajectory length and speed percentage.
    
    Args:
        trajectory_length: Total path length in mm
        speed_percentage: Speed as percentage (1-100)
        
    Returns:
        Duration in seconds
    """
    # Map speed percentage to mm/s (adjustable based on robot capabilities)
    # For example: 100% = 100mm/s, 50% = 50mm/s
    speed_mm_s = np.interp(speed_percentage, [0, 100], 
                          [PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000,
                           PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000])
    
    if speed_mm_s > 0:
        return trajectory_length / speed_mm_s
    else:
        return 5.0  # Default fallback
    
def parse_smooth_motion_commands(parts):
    """
    Parse smooth motion commands received via UDP and create appropriate command objects.
    All commands support:
    - Reference frame selection (WRF or TRF)
    - Optional start position (CURRENT or specified pose)
    - Both DURATION and SPEED timing modes
    
    Args:
        parts: List of command parts split by '|'
        
    Returns:
        Command object or None if parsing fails
    """
    command_type = parts[0]
    
    # Helper function for parsing optional start pose
    def parse_start_pose(start_str):
        """Parse start pose - returns None for CURRENT, or list of floats for specified pose."""
        if start_str == 'CURRENT' or start_str == 'NONE':
            return None
        else:
            try:
                return list(map(float, start_str.split(',')))
            except:
                print(f"Warning: Invalid start pose format: {start_str}")
                return None
    
    # Helper function for calculating duration from speed
    def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
        """Calculate duration based on trajectory length and speed percentage."""
        # Map speed percentage to mm/s
        min_speed = PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000  # Convert to mm/s
        max_speed = PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000  # Convert to mm/s
        speed_mm_s = np.interp(speed_percentage, [0, 100], [min_speed, max_speed])
        
        if speed_mm_s > 0:
            return trajectory_length / speed_mm_s
        else:
            return 5.0  # Default fallback
    
    try:
        if command_type == 'SMOOTH_CIRCLE':
            # Format: SMOOTH_CIRCLE|center_x,center_y,center_z|radius|plane|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            plane = parts[3]
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Circle circumference
                path_length = 2 * np.pi * radius
                duration = calculate_duration_from_speed(path_length, timing_value)
            
            print(f"  -> Parsed circle: r={radius}mm, plane={plane}, frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command object with frame parameter
            return SmoothCircleCommand(center, radius, plane, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_CENTER':
            # Format: SMOOTH_ARC_CENTER|end_pose|center|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            center = list(map(float, parts[2].split(',')))
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[6])
            clockwise = parts[7] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Estimate arc length (will be more accurate when we have actual positions)
                # Use a conservative estimate based on radius
                radius_estimate = np.linalg.norm(np.array(center) - np.array(end_pose[:3]))
                estimated_arc_angle = np.pi / 2  # 90 degrees estimate
                arc_length = radius_estimate * estimated_arc_angle
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (center): frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command with frame
            return SmoothArcCenterCommand(end_pose, center, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_PARAM':
            # Format: SMOOTH_ARC_PARAM|end_pose|radius|angle|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            arc_angle = float(parts[3])
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Arc length = radius * angle (in radians)
                arc_length = radius * np.deg2rad(arc_angle)
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (param): r={radius}mm, Î¸={arc_angle}Â°, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothArcParamCommand(end_pose, radius, arc_angle, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_SPLINE':
            # Format: SMOOTH_SPLINE|num_waypoints|frame|start_pose|timing_type|timing_value|waypoint1|waypoint2|...
            num_waypoints = int(parts[1])
            frame = parts[2]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[3])
            timing_type = parts[4]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[5])
            
            # Parse waypoints
            waypoints = []
            idx = 6
            for i in range(num_waypoints):
                wp = []
                for j in range(6):  # Each waypoint has 6 values (x,y,z,rx,ry,rz)
                    wp.append(float(parts[idx]))
                    idx += 1
                waypoints.append(wp)
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate total path length
                total_dist = 0
                for i in range(1, len(waypoints)):
                    dist = np.linalg.norm(np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3]))
                    total_dist += dist
                
                duration = calculate_duration_from_speed(total_dist, timing_value)
            
            print(f"  -> Parsed spline: {num_waypoints} points, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothSplineCommand(waypoints, duration, frame, start_pose)
            
        elif command_type == 'SMOOTH_HELIX':
            # Format: SMOOTH_HELIX|center|radius|pitch|height|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            pitch = float(parts[3])
            height = float(parts[4])
            frame = parts[5]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[6])
            timing_type = parts[7]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[8])
            clockwise = parts[9] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate helix path length
                num_revolutions = height / pitch if pitch > 0 else 1
                horizontal_length = 2 * np.pi * radius * num_revolutions
                helix_length = np.sqrt(horizontal_length**2 + height**2)
                duration = calculate_duration_from_speed(helix_length, timing_value)
            
            print(f"  -> Parsed helix: h={height}mm, pitch={pitch}mm, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothHelixCommand(center, radius, pitch, height, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_BLEND':
            # Format: SMOOTH_BLEND|num_segments|blend_time|frame|start_pose|timing_type|timing_value|segment1||segment2||...
            num_segments = int(parts[1])
            blend_time = float(parts[2])
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DEFAULT', 'DURATION', or 'SPEED'
            
            # Parse overall timing
            if timing_type == 'DEFAULT':
                # Use individual segment durations as-is
                overall_duration = None
                overall_speed = None
                segments_start_idx = 6
            else:
                timing_value = float(parts[6])
                if timing_type == 'DURATION':
                    overall_duration = timing_value
                    overall_speed = None
                else:  # SPEED
                    overall_speed = timing_value
                    overall_duration = None
                segments_start_idx = 7
            
            # Parse segments (separated by ||)
            segments_data = '|'.join(parts[segments_start_idx:])
            segment_strs = segments_data.split('||')
            
            # Parse segment definitions
            segment_definitions = []
            total_original_duration = 0
            total_estimated_length = 0
            
            for seg_str in segment_strs:
                if not seg_str:  # Skip empty segments
                    continue
                    
                seg_parts = seg_str.split('|')
                seg_type = seg_parts[0]
                
                if seg_type == 'LINE':
                    # Format: LINE|end_x,end_y,end_z,end_rx,end_ry,end_rz|duration
                    end = list(map(float, seg_parts[1].split(',')))
                    segment_duration = float(seg_parts[2])
                    total_original_duration += segment_duration
                    
                    # Estimate length (will be refined when we have actual start)
                    estimated_length = 100  # mm, conservative estimate
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'LINE',
                        'end': end,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
                    
                elif seg_type == 'CIRCLE':
                    # Format: CIRCLE|center_x,center_y,center_z|radius|plane|duration|clockwise
                    center = list(map(float, seg_parts[1].split(',')))
                    radius = float(seg_parts[2])
                    plane = seg_parts[3]
                    segment_duration = float(seg_parts[4])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[5] == '1'
                    
                    # Circle circumference
                    estimated_length = 2 * np.pi * radius
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'CIRCLE',
                        'center': center,
                        'radius': radius,
                        'plane': plane,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'ARC':
                    # Format: ARC|end_x,end_y,end_z,end_rx,end_ry,end_rz|center_x,center_y,center_z|duration|clockwise
                    end = list(map(float, seg_parts[1].split(',')))
                    center = list(map(float, seg_parts[2].split(',')))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[4] == '1'
                    
                    # Estimate arc length
                    estimated_radius = 50  # mm
                    estimated_arc_angle = np.pi / 2  # 90 degrees
                    estimated_length = estimated_radius * estimated_arc_angle
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'ARC',
                        'end': end,
                        'center': center,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'SPLINE':
                    # Format: SPLINE|num_points|waypoint1;waypoint2;...|duration
                    num_points = int(seg_parts[1])
                    waypoints = []
                    wp_strs = seg_parts[2].split(';')
                    for wp_str in wp_strs:
                        waypoints.append(list(map(float, wp_str.split(','))))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    
                    # Estimate spline length
                    estimated_length = 0
                    for i in range(1, len(waypoints)):
                        estimated_length += np.linalg.norm(
                            np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3])
                        )
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'SPLINE',
                        'waypoints': waypoints,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
            
            # Adjust segment durations if overall timing is specified
            if overall_duration is not None:
                # Scale all segment durations proportionally
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Scaled blend segments to total duration: {overall_duration:.2f}s")
                        
            elif overall_speed is not None:
                # Calculate duration from speed and estimated path length
                overall_duration = calculate_duration_from_speed(total_estimated_length, overall_speed)
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Calculated blend duration from speed: {overall_duration:.2f}s")
            else:
                print(f"  -> Using original segment durations (total: {total_original_duration:.2f}s)")
            
            print(f"  -> Parsed blend: {num_segments} segments, frame={frame}, blend_time={blend_time}s")
            
            # Return command with frame
            return SmoothBlendCommand(segment_definitions, blend_time, frame, start_pose)
            
    except Exception as e:
        print(f"Error parsing smooth motion command: {e}")
        print(f"Command parts: {parts}")
        import traceback
        traceback.print_exc()
        return None
    
    print(f"Warning: Unknown smooth motion command type: {command_type}")
    return None

def transform_command_params_to_wrf(command_type: str, params: dict, frame: str, current_position_in) -> dict:
    """
    Transform command parameters from TRF to WRF.
    Handles position, orientation, and directional vectors correctly.
    """
    if frame == 'WRF':
        return params
    
    # Get current tool pose
    current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                         for i, p in enumerate(current_position_in)])
    tool_pose = PAROL6_ROBOT.robot.fkine(current_q)
    
    transformed = params.copy()
    
    # SMOOTH_CIRCLE - Transform center and plane normal
    if command_type == 'SMOOTH_CIRCLE':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'plane' in params:
            plane_normals_trf = {
                'XY': [0, 0, 1],   # Tool's Z-axis
                'XZ': [0, 1, 0],   # Tool's Y-axis  
                'YZ': [1, 0, 0]    # Tool's X-axis
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
            print(f"  -> TRF circle plane {params['plane']} transformed to WRF")
    
    # SMOOTH_ARC_CENTER - Transform center, end_pose, and implied plane
    elif command_type == 'SMOOTH_ARC_CENTER':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # Arc plane is determined by start, end, and center points
        # But we should transform any specified plane normal
        if 'plane' in params:
            # Similar to circle plane transformation
            plane_normals_trf = {
                'XY': [0, 0, 1],
                'XZ': [0, 1, 0],
                'YZ': [1, 0, 0]
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_ARC_PARAM - Transform end_pose and arc plane
    elif command_type == 'SMOOTH_ARC_PARAM':
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # For parametric arc, the plane is usually XY of the tool
        # Transform the assumed plane normal
        if 'plane' not in params:
            params['plane'] = 'XY'  # Default to XY plane
        
        plane_normals_trf = {
            'XY': [0, 0, 1],
            'XZ': [0, 1, 0],
            'YZ': [1, 0, 0]
        }
        normal_trf = np.array(plane_normals_trf[params.get('plane', 'XY')])
        normal_wrf = tool_pose.R @ normal_trf
        transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_HELIX - Transform center and helix axis
    elif command_type == 'SMOOTH_HELIX':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        # Helix axis - default is Z-axis (vertical in TRF)
        # In TRF, helix rises along tool's Z-axis
        helix_axis_trf = np.array([0, 0, 1])  # Tool's Z-axis
        helix_axis_wrf = tool_pose.R @ helix_axis_trf
        transformed['helix_axis'] = helix_axis_wrf.tolist()
        
        # Also need to transform the "up" direction for proper orientation
        up_vector_trf = np.array([0, 1, 0])  # Tool's Y-axis
        up_vector_wrf = tool_pose.R @ up_vector_trf
        transformed['up_vector'] = up_vector_wrf.tolist()
    
    # SMOOTH_SPLINE - Transform all waypoints
    elif command_type == 'SMOOTH_SPLINE':
        if 'waypoints' in params:
            transformed_waypoints = []
            for wp in params['waypoints']:
                wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                         SE3.RPY(wp[3:], unit='deg', order='xyz')
                wp_wrf = tool_pose * wp_trf
                wp_transformed = np.concatenate([
                    wp_wrf.t * 1000,
                    wp_wrf.rpy(unit='deg', order='xyz')
                ]).tolist()
                transformed_waypoints.append(wp_transformed)
            transformed['waypoints'] = transformed_waypoints
    
    # SMOOTH_BLEND - Transform all segments recursively
    elif command_type == 'SMOOTH_BLEND':
        if 'segments' in params:
            transformed_segments = []
            for seg in params['segments']:
                seg_copy = seg.copy()
                seg_type = seg['type']
                
                if seg_type == 'LINE':
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'CIRCLE':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'plane' in seg:
                        plane_normals_trf = {
                            'XY': [0, 0, 1],
                            'XZ': [0, 1, 0],
                            'YZ': [1, 0, 0]
                        }
                        normal_trf = np.array(plane_normals_trf[seg['plane']])
                        normal_wrf = tool_pose.R @ normal_trf
                        seg_copy['normal_vector'] = normal_wrf.tolist()
                
                elif seg_type == 'ARC':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'SPLINE':
                    if 'waypoints' in seg:
                        transformed_waypoints = []
                        for wp in seg['waypoints']:
                            wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                                     SE3.RPY(wp[3:], unit='deg', order='xyz')
                            wp_wrf = tool_pose * wp_trf
                            wp_transformed = np.concatenate([
                                wp_wrf.t * 1000,
                                wp_wrf.rpy(unit='deg', order='xyz')
                            ]).tolist()
                            transformed_waypoints.append(wp_transformed)
                        seg_copy['waypoints'] = transformed_waypoints
                
                transformed_segments.append(seg_copy)
            transformed['segments'] = transformed_segments
    
    # Transform start_pose if specified (common to all commands)
    if 'start_pose' in params and params['start_pose'] is not None:
        start_trf = SE3(params['start_pose'][0]/1000, 
                       params['start_pose'][1]/1000, 
                       params['start_pose'][2]/1000) * \
                    SE3.RPY(params['start_pose'][3:], unit='deg', order='xyz')
        start_wrf = tool_pose * start_trf
        transformed['start_pose'] = np.concatenate([
            start_wrf.t * 1000,
            start_wrf.rpy(unit='deg', order='xyz')
        ]).tolist()
    
    return transformed

#########################################################################
# Smooth Motion Commands and Robot Commands End Here
#########################################################################

# Acknowledgment system configuration
CLIENT_ACK_PORT = 5002  # Port where clients listen for acknowledgments
ack_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Command tracking
active_command_id = None
command_id_map = {}  # Maps command objects to their IDs

def send_acknowledgment(cmd_id: str, status: str, details: str = "", addr=None):
    """Send acknowledgment back to client"""
    if not cmd_id:
        return
        
    ack_message = f"ACK|{cmd_id}|{status}|{details}"
    
    # Send to the original sender if we have their address
    if addr:
        try:
            ack_socket.sendto(ack_message.encode('utf-8'), (addr[0], CLIENT_ACK_PORT))
        except Exception as e:
            print(f"Failed to send ack to {addr}: {e}")
    
    # Also broadcast to localhost in case the client is local
    try:
        ack_socket.sendto(ack_message.encode('utf-8'), ('127.0.0.1', CLIENT_ACK_PORT))
    except:
        pass

def parse_command_with_id(message: str) -> Tuple[Optional[str], str]:
    """
    Parse command ID if present.
    Format: [cmd_id|]COMMAND|params...
    Returns: (cmd_id or None, command_string)
    """
    # Clean up any logging artifacts
    if "ID:" in message or "):" in message:
        # Extract the actual command after these artifacts
        if "):" in message:
            message = message[message.rindex("):")+2:].strip()
        elif "ID:" in message:
            message = message[message.index("ID:")+3:].strip()
            # Remove any trailing parentheses or colons
            message = message.lstrip('):').strip()
    
    parts = message.split('|', 1)
    
    # Check if first part looks like a valid command ID (8 chars, alphanumeric)
    # IMPORTANT: Command IDs from uuid.uuid4()[:8] will contain lowercase letters/numbers
    # Actual commands are all uppercase, so exclude all-uppercase strings
    if (len(parts) > 1 and 
        len(parts[0]) == 8 and 
        parts[0].replace('-', '').isalnum() and 
        not parts[0].isupper()):  # This prevents "MOVEPOSE" from being treated as an ID
        return parts[0], parts[1]
    else:
        return None, message


# Create a new, empty command queue
command_queue = deque()

# --------------------------------------------------------------------------
# --- Test 1: Homing and Initial Setup
# --------------------------------------------------------------------------

# 1. Start with the mandatory Home command.
command_queue.append(HomeCommand())

# --- State variable for the currently running command ---
active_command = None
e_stop_active = False

# Use deque for an efficient FIFO queue
incoming_command_buffer = deque()
# Timestamp of the last processed network command
last_command_time = 0
# Cooldown period in seconds to prevent command flooding
COMMAND_COOLDOWN_S = 0.1 # 100ms

# Set interval
timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)

# ============================================================================
# MODIFIED MAIN LOOP WITH ACKNOWLEDGMENTS
# ============================================================================

timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)
prev_time = 0

while timer.elapsed_time < 1100000:
    
    # --- Connection Handling ---
    if ser is None or not ser.is_open:
        print("Serial port not open. Attempting to reconnect...")
        try:
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            if ser.is_open:
                print(f"Successfully reconnected to {com_port_str}")
        except serial.SerialException as e:
            ser = None
            time.sleep(1) 
        continue

    # =======================================================================
    # === NETWORK COMMAND RECEPTION WITH ID PARSING ===
    # =======================================================================
    try:
        while sock in select.select([sock], [], [], 0)[0]:
            data, addr = sock.recvfrom(1024)
            raw_message = data.decode('utf-8').strip()
            if raw_message:
                # Parse command ID if present
                cmd_id, message = parse_command_with_id(raw_message)
                
                parts = message.split('|')
                command_name = parts[0].upper()

                # Handle immediate response commands
                if command_name == 'STOP':
                    print("Received STOP command. Halting all motion and clearing queue.")
                    
                    # Cancel active command
                    if active_command and active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "Stopped by user", addr)
                    active_command = None
                    active_command_id = None
                    
                    # Clear queue and notify about cancelled commands
                    for queued_cmd in command_id_map.keys():
                        if queued_cmd != active_command:
                            if queued_cmd in command_id_map:
                                send_acknowledgment(command_id_map[queued_cmd], 
                                                  "CANCELLED", "Queue cleared by STOP", addr)
                    
                    command_queue.clear()
                    command_id_map.clear()
                    
                    # Stop robot
                    Command_out.value = 255
                    Speed_out[:] = [0] * 6
                    
                    # Send acknowledgment for STOP command itself
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Emergency stop executed", addr)

                elif command_name == 'GET_POSE':
                    q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
                    current_pose_matrix = PAROL6_ROBOT.robot.fkine(q_current).A
                    pose_flat = current_pose_matrix.flatten()
                    pose_str = ",".join(map(str, pose_flat))
                    response_message = f"POSE|{pose_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Pose data sent", addr)

                elif command_name == 'GET_ANGLES':
                    angles_rad = [PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)]
                    angles_deg = np.rad2deg(angles_rad)
                    angles_str = ",".join(map(str, angles_deg))
                    response_message = f"ANGLES|{angles_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Angles data sent", addr)

                elif command_name == 'GET_IO':
                    io_status_str = ",".join(map(str, InOut_in[:5]))
                    response_message = f"IO|{io_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "IO data sent", addr)

                elif command_name == 'GET_GRIPPER':
                    gripper_status_str = ",".join(map(str, Gripper_data_in))
                    response_message = f"GRIPPER|{gripper_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Gripper data sent", addr)

                elif command_name == 'GET_SPEEDS':
                    speeds_str = ",".join(map(str, Speed_in))
                    response_message = f"SPEEDS|{speeds_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Speed data sent", addr)

                else:
                    # Queue command for processing
                    incoming_command_buffer.append((raw_message, addr))

    except Exception as e:
        print(f"Network receive error: {e}")

    # =======================================================================
    # === PROCESS COMMANDS FROM BUFFER WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    current_time = time.time()
    if incoming_command_buffer and (current_time - last_command_time) > COMMAND_COOLDOWN_S and not e_stop_active:
        raw_message, addr = incoming_command_buffer.popleft()
        last_command_time = current_time
        
        # Parse command ID
        cmd_id, message = parse_command_with_id(raw_message)
        print(f"Processing command{' (ID: ' + cmd_id + ')' if cmd_id else ''}: {message[:50]}...")
        
        parts = message.split('|')
        command_name = parts[0].upper()
        
        # Variable to track if command was successfully queued
        command_queued = False
        command_obj = None
        error_details = ""

        # Parse and create command objects
        try:
            if command_name == 'MOVEPOSE' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MovePoseCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
                
            elif command_name == 'MOVEJOINT' and len(parts) == 9:
                joint_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveJointCommand(target_angles=joint_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name in ['SMOOTH_CIRCLE', 'SMOOTH_ARC_CENTER', 'SMOOTH_ARC_PARAM', 
                                 'SMOOTH_SPLINE', 'SMOOTH_HELIX', 'SMOOTH_BLEND']:
                command_obj = parse_smooth_motion_commands(parts)
                if command_obj:
                    command_queued = True
                else:
                    error_details = "Failed to parse smooth motion parameters"
            
            elif command_name == 'MOVECART' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveCartCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name == 'DELAY' and len(parts) == 2:
                duration = float(parts[1])
                command_obj = DelayCommand(duration=duration)
                command_queued = True
            
            elif command_name == 'HOME':
                command_obj = HomeCommand()
                command_queued = True
                
            elif command_name == 'CARTJOG' and len(parts) == 5:
                frame, axis, speed, duration = parts[1].upper(), parts[2], float(parts[3]), float(parts[4])
                command_obj = CartesianJogCommand(frame=frame, axis=axis, speed_percentage=speed, duration=duration)
                command_queued = True
                
            elif command_name == 'JOG' and len(parts) == 5:
                joint_idx, speed = int(parts[1]), float(parts[2])
                duration = None if parts[3].upper() == 'NONE' else float(parts[3])
                distance = None if parts[4].upper() == 'NONE' else float(parts[4])
                command_obj = JogCommand(joint=joint_idx, speed_percentage=speed, duration=duration, distance_deg=distance)
                command_queued = True
            
            elif command_name == 'MULTIJOG' and len(parts) == 4:
                joint_indices = [int(j) for j in parts[1].split(',')]
                speeds = [float(s) for s in parts[2].split(',')]
                duration = float(parts[3])
                command_obj = MultiJogCommand(joints=joint_indices, speed_percentages=speeds, duration=duration)
                command_queued = True
                
            elif command_name == 'PNEUMATICGRIPPER' and len(parts) == 3:
                action, port = parts[1].lower(), int(parts[2])
                command_obj = GripperCommand(gripper_type='pneumatic', action=action, output_port=port)
                command_queued = True
                
            elif command_name == 'ELECTRICGRIPPER' and len(parts) == 5:
                action = None if parts[1].upper() == 'NONE' or parts[1].upper() == 'MOVE' else parts[1].lower()
                pos, spd, curr = int(parts[2]), int(parts[3]), int(parts[4])
                command_obj = GripperCommand(gripper_type='electric', action=action, position=pos, speed=spd, current=curr)
                command_queued = True
            
            else:
                error_details = f"Unknown or malformed command: {command_name}"
                
        except Exception as e:
            error_details = f"Error parsing command: {str(e)}"
            command_queued = False
        
        # Handle command queueing and acknowledgments
        if command_queued and command_obj:
            # Check if command is initially valid
            if hasattr(command_obj, 'is_valid') and not command_obj.is_valid:
                if cmd_id:
                    send_acknowledgment(cmd_id, "INVALID", 
                                       "Command failed validation", addr)
            else:
                # Add to queue
                command_queue.append(command_obj)
                if cmd_id:
                    command_id_map[command_obj] = (cmd_id, addr)
                    send_acknowledgment(cmd_id, "QUEUED", 
                                       f"Position {len(command_queue)} in queue", addr)
        else:
            # Command was not queued
            if cmd_id:
                send_acknowledgment(cmd_id, "INVALID", error_details, addr)
            print(f"Warning: {error_details}")

    # =======================================================================
    # === MAIN EXECUTION LOGIC WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    try:
        # --- E-Stop Handling ---
        if InOut_in[4] == 0:  # E-Stop pressed
            if not e_stop_active:
                cancelled_command_info = "None"
                if active_command is not None:
                    cancelled_command_info = type(active_command).__name__
                    if active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "E-Stop activated")
                
                # Cancel all queued commands
                for cmd_obj in command_queue:
                    if cmd_obj in command_id_map:
                        cmd_id, addr = command_id_map[cmd_obj]
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated", addr)
                
                # Cancel all buffered but unprocessed commands
                for raw_message, addr in incoming_command_buffer:
                    cmd_id, _ = parse_command_with_id(raw_message)
                    if cmd_id:
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated - command not processed", addr)
                
                print(f"E-STOP TRIGGERED! Active command '{cancelled_command_info}' cancelled.")
                print("Release E-Stop and press 'e' to re-enable.")
                e_stop_active = True
            
            Command_out.value = 102
            Speed_out[:] = [0] * 6
            Gripper_data_out[3] = 0
            active_command = None
            active_command_id = None
            command_queue.clear()
            command_id_map.clear()
            incoming_command_buffer.clear()
            
        elif e_stop_active:
            # Waiting for re-enable
            if keyboard.is_pressed('e'):
                print("Re-enabling robot...")
                Command_out.value = 101
                e_stop_active = False
            else:
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]
                
        else:
            # --- Normal Command Processing ---
            
            # Start new command if none active
            if active_command is None and command_queue:
                new_command = command_queue.popleft()
                
                # Get command ID and address if tracked
                cmd_info = command_id_map.get(new_command, (None, None))
                new_cmd_id, new_addr = cmd_info
                
                # Initial validation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Command was invalid from the start
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "INVALID", 
                                        "Initial validation failed", new_addr)
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                    continue  # Skip to next command
                
                # Prepare command
                if hasattr(new_command, 'prepare_for_execution'):
                    try:
                        new_command.prepare_for_execution(current_position_in=Position_in)
                    except Exception as e:
                        print(f"Command preparation failed: {e}")
                        if hasattr(new_command, 'is_valid'):
                            new_command.is_valid = False
                        if hasattr(new_command, 'error_message'):
                            new_command.error_message = str(e)
                
                # Check if still valid after preparation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Failed during preparation
                    error_msg = "Failed during preparation"
                    if hasattr(new_command, 'error_message'):
                        error_msg = new_command.error_message
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "FAILED", error_msg, new_addr)
                    
                    # Clean up
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                else:
                    # Command is valid, make it active
                    active_command = new_command
                    active_command_id = new_cmd_id
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "EXECUTING", 
                                        f"Starting {type(new_command).__name__}", new_addr)
            
            # Execute active command
            if active_command:
                try:
                    is_done = active_command.execute_step(
                        Position_in=Position_in,
                        Homed_in=Homed_in,
                        Speed_out=Speed_out,
                        Command_out=Command_out,
                        Gripper_data_out=Gripper_data_out,
                        InOut_out=InOut_out,
                        InOut_in=InOut_in,
                        Gripper_data_in=Gripper_data_in,
                        Position_out=Position_out  # Add this if needed
                    )
                    
                    if is_done:
                        # Command completed
                        if active_command_id:
                            # Check for error state in smooth motion commands
                            if hasattr(active_command, 'error_state') and active_command.error_state:
                                error_msg = getattr(active_command, 'error_message', 'Command failed during execution')
                                send_acknowledgment(active_command_id, "FAILED", error_msg)
                            else:
                                send_acknowledgment(active_command_id, "COMPLETED", 
                                                f"{type(active_command).__name__} finished successfully")
                        
                        # Clean up
                        if active_command in command_id_map:
                            del command_id_map[active_command]
                        
                        active_command = None
                        active_command_id = None
                        
                except Exception as e:
                    # Command execution error
                    print(f"Command execution error: {e}")
                    if active_command_id:
                        send_acknowledgment(active_command_id, "FAILED", 
                                          f"Execution error: {str(e)}")
                    
                    # Clean up
                    if active_command in command_id_map:
                        del command_id_map[active_command]
                    
                    active_command = None
                    active_command_id = None
                    
            else:
                # No active command - idle
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]

        # --- Communication with Robot ---
        s = Pack_data(Position_out, Speed_out, Command_out.value, 
                     Affected_joint_out, InOut_out, Timeout_out, Gripper_data_out)
        for chunk in s:
            ser.write(chunk)
            
        Get_data(Position_in, Speed_in, Homed_in, InOut_in, Temperature_error_in, 
                Position_error_in, Timeout_error, Timing_data_in, XTR_data, Gripper_data_in)

    except serial.SerialException as e:
        print(f"Serial communication error: {e}")
        
        # Send failure acknowledgments for active command
        if active_command_id:
            send_acknowledgment(active_command_id, "FAILED", "Serial communication lost")
        
        if ser:
            ser.close()
        ser = None
        active_command = None
        active_command_id = None

    timer.checkpt()
````

## File: headless_commander.py.backup_wN_1757428702
````
'''
A full fledged "API" for the PAROL6 robot. To use this, you should pair it with the "robot_api.py" where you can import commands
from said file and use them anywhere within your code. This Python script will handle sending and performing all the commands
to the PAROL6 robot, as well as E-Stop functionality and safety limitations.

To run this program, you must use the "experimental-kinematics" branch of the "PAROL-commander-software" on GitHub
which can be found through this link: https://github.com/PCrnjak/PAROL-commander-software/tree/experimental_kinematics.
You must also save these files into the following folder: "Project Files\PAROL-commander-software\GUI\files".
'''

# * If you press estop robot will stop and you need to enable it by pressing e

from roboticstoolbox import DHRobot, RevoluteDH, ERobot, ELink, ETS, trapezoidal, quintic
import roboticstoolbox as rp
from math import pi, sin, cos
import numpy as np
from oclock import Timer, loop, interactiveloop
import time
import socket
from spatialmath import SE3
import select
import serial
import platform
import os
import re
import logging
import struct
import keyboard
from typing import Optional, Tuple
from spatialmath.base import trinterp
from collections import namedtuple, deque
import GUI.files.PAROL6_ROBOT as PAROL6_ROBOT
from smooth_motion import CircularMotion, SplineMotion, MotionBlender

# Set interval
INTERVAL_S = 0.01
prev_time = 0

logging.basicConfig(level = logging.DEBUG,
    format='%(asctime)s.%(msecs)03d %(levelname)s:\t%(message)s',
    datefmt='%H:%M:%S'
)
logging.disable(logging.DEBUG)


my_os = platform.system()
if my_os == "Windows":
    # Try to read the COM port from a file
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved COM port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        # If the file doesn't exist or the port is invalid, ask the user
        while True:
            try:
                com_port = input("Enter the COM port (e.g., COM9): ")
                ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                print(f"Successfully connected to {com_port}")
                # Save the successful port to the file
                with open("com_port.txt", "w") as f:
                    f.write(com_port)
                break
            except serial.SerialException:
                print(f"Could not open port {com_port}. Please try again.")

# in big endian machines, first byte of binary representation of the multibyte data-type is stored first. 
int_to_3_bytes = struct.Struct('>I').pack # BIG endian order

# data for output string (data that is being sent to the robot)
#######################################################################################
#######################################################################################
start_bytes =  [0xff,0xff,0xff] 
start_bytes = bytes(start_bytes)

end_bytes =  [0x01,0x02] 
end_bytes = bytes(end_bytes)


# data for input string (Data that is being sent by the robot)
#######################################################################################
#######################################################################################
input_byte = 0 # Here save incoming bytes from serial

start_cond1_byte = bytes([0xff])
start_cond2_byte = bytes([0xff])
start_cond3_byte = bytes([0xff])

end_cond1_byte = bytes([0x01])
end_cond2_byte = bytes([0x02])

start_cond1 = 0 #Flag if start_cond1_byte is received
start_cond2 = 0 #Flag if start_cond2_byte is received
start_cond3 = 0 #Flag if start_cond3_byte is received

good_start = 0 #Flag if we got all 3 start condition bytes
data_len = 0 #Length of the data after -3 start condition bytes and length byte, so -4 bytes

data_buffer = [None]*255 #Here save all data after data length byte
data_counter = 0 #Data counter for incoming bytes; compared to data length to see if we have correct length
#######################################################################################
#######################################################################################
prev_positions = [0,0,0,0,0,0]
prev_speed = [0,0,0,0,0,0]
robot_pose = [0,0,0,0,0,0] #np.array([0,0,0,0,0,0])
#######################################################################################
#######################################################################################

# --- Wrapper class to make integers mutable when passed to functions ---
class CommandValue:
    def __init__(self, value):
        self.value = value

#######################################################################################
#######################################################################################
Position_out = [1,11,111,1111,11111,10]
Speed_out = [2,21,22,23,24,25]
Command_out = CommandValue(255)
Affected_joint_out = [1,1,1,1,1,1,1,1]
InOut_out = [0,0,0,0,0,0,0,0]
Timeout_out = 0
#Positon,speed,current,command,mode,ID
Gripper_data_out = [1,1,1,1,0,0]
#######################################################################################
#######################################################################################
# Data sent from robot to PC
Position_in = [31,32,33,34,35,36]
Speed_in = [41,42,43,44,45,46]
Homed_in = [0,0,0,0,0,0,0,0]
InOut_in = [1,1,1,1,1,1,1,1]
Temperature_error_in = [1,1,1,1,1,1,1,1]
Position_error_in = [1,1,1,1,1,1,1,1]
Timeout_error = 0
# how much time passed between 2 sent commands (2byte value, last 2 digits are decimal so max value is 655.35ms?)
Timing_data_in = [0]
XTR_data =   0

# --- State variables for program execution ---
Robot_mode = "Dummy"  # Start in an idle state
Program_step = 0      # Which line of the program to run
Command_step = 0      # The current step within a single command
Command_len = 0       # The total steps for the current command
ik_error = 0          # Flag for inverse kinematics errors
error_state = 0       # General error flag
program_running = False # A flag to start and stop the program

# This will be your "program"
command_list = []

#ID,Position,speed,current,status,obj_detection
Gripper_data_in = [1,1,1,1,1,1] 

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179Â° and 181Â° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    
    Parameters
    ----------
    robot : DHRobot
        Robot model
    q : array_like
        Joint configuration
    strict_tol : float
        Strict tolerance away from singularities (default: 1e-10)
    loose_tol : float
        Loose tolerance near singularities (1e-7)
        
    Returns
    -------
    float
        Adaptive tolerance value
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    
    Parameters
    ----------
    q_seed : array_like
        Current joint configuration in radians
        
    Returns
    -------
    float
        Configuration-dependent maximum reach threshold
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90Â°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 | None = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities:
    - Near singularities: looser tolerance for easier convergence
    - Away from singularities: stricter tolerance for precise solutions
    If necessary, recursively subdivide the motion until ikine_LM converges
    on every segment. Finally check that solution respects joint limits. From experimentation,
    jogging with lower tolerances often produces q_paths that do not differ from current_q,
    essentially freezing the robot.

    Parameters
    ----------
    robot : DHRobot
        Robot model
    target_pose : SE3
        Target pose to reach
    current_q : array_like
        Current joint configuration
    current_pose : SE3, optional
        Current pose (computed if None)
    max_depth : int, optional
        Maximum subdivision depth (default: 8)
    ilimit : int, optional
        Maximum iterations for IK solver (default: 100)

    Returns
    -------
    IKResult
        success  - True/False
        q_path   - (mxn) array of the final joint configuration 
        iterations, residual  - aggregated diagnostics
        tolerance_used - which tolerance was used
        violations - joint limit violations (if any)
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # â”€â”€ inner recursive solverâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            # print(f"current_reach:{current_reach:.3f}, max_reach_threshold:{max_reach_threshold:.3f}")
            if not is_recovery and target_reach > max_reach_threshold:
                print(f"Target reach limit exceeded: {target_reach:.3f} > {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LM(Tb, q0=q_seed, ilimit=ilimit, tol=tol, wN=damping)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # â”€â”€ kick-off with adaptive tolerance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    # Check if solution respects joint limits
    target_q = path[-1] if len(path) != 0 else None
    solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
    if ok and solution_valid:
        return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
    else:
        return IKResult(False, None, its, resid, adaptive_tol, violations)

#Setup IP address and Simulator port
ip = "127.0.0.1" #Loopback address
port = 5001
# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((ip, port))
print(f'Start listening to {ip}:{port}')

def Unpack_data(data_buffer_list, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):

    Joints = []
    Speed = []

    for i in range(0,18, 3):
        variable = data_buffer_list[i:i+3]
        Joints.append(variable)

    for i in range(18,36, 3):
        variable = data_buffer_list[i:i+3]
        Speed.append(variable)


    for i in range(6):
        var =  b'\x00' + b''.join(Joints[i])
        Position_in[i] = Fuse_3_bytes(var)
        var =  b'\x00' + b''.join(Speed[i])
        Speed_in[i] = Fuse_3_bytes(var)

    Homed = data_buffer_list[36]
    IO_var = data_buffer_list[37]
    temp_error = data_buffer_list[38]
    position_error = data_buffer_list[39]
    timing_data = data_buffer_list[40:42]
    Timeout_error_var = data_buffer_list[42]
    xtr2 = data_buffer_list[43]
    device_ID = data_buffer_list[44]
    Gripper_position = data_buffer_list[45:47]
    Gripper_speed = data_buffer_list[47:49]
    Gripper_current = data_buffer_list[49:51]
    Status = data_buffer_list[51]
    # The original object_detection byte at index 52 is ignored as it is not reliable.
    CRC_byte = data_buffer_list[53]
    endy_byte1 = data_buffer_list[54]
    endy_byte2 = data_buffer_list[55]

    # ... (Code for Homed, IO_var, temp_error, etc. remains the same) ...

    temp = Split_2_bitfield(int.from_bytes(Homed,"big"))
    for i in range(8):
        Homed_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(IO_var,"big"))
    for i in range(8):
        InOut_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(temp_error,"big"))
    for i in range(8):
        Temperature_error_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(position_error,"big"))
    for i in range(8):
        Position_error_in[i] = temp[i]

    var = b'\x00' + b'\x00' + b''.join(timing_data)
    Timing_data_in[0] = Fuse_3_bytes(var)
    Timeout_error = int.from_bytes(Timeout_error_var,"big")
    XTR_data = int.from_bytes(xtr2,"big")

    # --- Gripper Data Unpacking ---
    Gripper_data_in[0] = int.from_bytes(device_ID,"big")

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_position)
    Gripper_data_in[1] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_speed)
    Gripper_data_in[2] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_current)
    Gripper_data_in[3] = Fuse_2_bytes(var)

    # --- Start of Corrected Logic ---
    # This section now mirrors the working logic from GUI_PAROL_latest.py
    
    # 1. Store the raw status byte (from index 51)
    status_byte = int.from_bytes(Status,"big")
    Gripper_data_in[4] = status_byte

    # 2. Split the status byte into a list of 8 individual bits
    status_bits = Split_2_bitfield(status_byte)
    
    # 3. Combine the 3rd and 4th bits (at indices 2 and 3) to get the true object detection status
    # This creates a 2-bit number (0-3) which represents the full state.
    object_detection_status = (status_bits[2] << 1) | status_bits[3]
    Gripper_data_in[5] = object_detection_status
    # --- End of Corrected Logic ---

def Pack_data(Position_out,Speed_out,Command_out,Affected_joint_out,InOut_out,Timeout_out,Gripper_data_out):

    # Len is defined by all bytes EXCEPT start bytes and len
    # Start bytes = 3
    len = 52 #1
    Position = [Position_out[0],Position_out[1],Position_out[2],Position_out[3],Position_out[4],Position_out[5]]  #18
    Speed = [Speed_out[0], Speed_out[1], Speed_out[2], Speed_out[3], Speed_out[4], Speed_out[5],] #18
    Command = Command_out#1
    Affected_joint = Affected_joint_out
    InOut = InOut_out #1
    Timeout = Timeout_out #1
    Gripper_data = Gripper_data_out #9
    CRC_byte = 228 #1
    # End bytes = 2


    test_list = []
    #print(test_list)

    #x = bytes(start_bytes)
    test_list.append((start_bytes))
    
    test_list.append(bytes([len]))


    # Position data
    for i in range(6):
        position_split = Split_2_3_bytes(Position[i])
        test_list.append(position_split[1:4])

    # Speed data
    for i in range(6):
        speed_split = Split_2_3_bytes(Speed[i])
        test_list.append(speed_split[1:4])

    # Command data
    test_list.append(bytes([Command]))

    # Affected joint data
    Affected_list = Fuse_bitfield_2_bytearray(Affected_joint[:])
    test_list.append(Affected_list)

    # Inputs outputs data
    InOut_list = Fuse_bitfield_2_bytearray(InOut[:])
    test_list.append(InOut_list)

    # Timeout data
    test_list.append(bytes([Timeout]))

    # Gripper position
    Gripper_position = Split_2_3_bytes(Gripper_data[0])
    test_list.append(Gripper_position[2:4])

    # Gripper speed
    Gripper_speed = Split_2_3_bytes(Gripper_data[1])
    test_list.append(Gripper_speed[2:4])

    # Gripper current
    Gripper_current = Split_2_3_bytes(Gripper_data[2])
    test_list.append(Gripper_current[2:4])  

    # Gripper command
    test_list.append(bytes([Gripper_data[3]]))
    # Gripper mode
    test_list.append(bytes([Gripper_data[4]]))
    
    # ==========================================================
    # === FIX: Make sure calibrate is a one-shot command      ====
    # ==========================================================
    # If the mode was set to calibrate (1) or clear_error (2), reset it
    # back to normal (0) for the next cycle. This prevents an endless loop.
    if Gripper_data_out[4] == 1 or Gripper_data_out[4] == 2:
        Gripper_data_out[4] = 0
    # ==========================================================
    
    # Gripper ID
    test_list.append(bytes([Gripper_data[5]]))
 
    # CRC byte
    test_list.append(bytes([CRC_byte]))

    # END bytes
    test_list.append((end_bytes))
    
    #print(test_list)
    return test_list

def Get_data(Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):
    global input_byte 

    global start_cond1_byte 
    global start_cond2_byte 
    global start_cond3_byte 

    global end_cond1_byte 
    global end_cond2_byte 

    global start_cond1 
    global start_cond2 
    global start_cond3 

    global good_start 
    global data_len 

    global data_buffer 
    global data_counter

    while (ser.inWaiting() > 0):
        input_byte = ser.read()

        #UNCOMMENT THIS TO GET ALL DATA FROM THE ROBOT PRINTED
        #print(input_byte) 

        # When data len is received start is good and after that put all data in receive buffer
        # Data len is ALL data after it; that includes input buffer, end bytes and CRC
        if (good_start != 1):
            # All start bytes are good and next byte is data len
            if (start_cond1 == 1 and start_cond2 == 1 and start_cond3 == 1):
                good_start = 1
                data_len = input_byte
                data_len = struct.unpack('B', data_len)[0]
                logging.debug("data len we got from robot packet= ")
                logging.debug(input_byte)
                logging.debug("good start for DATA that we received at PC")
            # Third start byte is good
            if (input_byte == start_cond3_byte and start_cond2 == 1 and start_cond1 == 1):
                start_cond3 = 1
                #print("good cond 3 PC")
            #Third start byte is bad, reset all flags
            elif (start_cond2 == 1 and start_cond1 == 1):
                #print("bad cond 3 PC")
                start_cond1 = 0
                start_cond2 = 0
            # Second start byte is good
            if (input_byte == start_cond2_byte and start_cond1 == 1):
                start_cond2 = 1
                #print("good cond 2 PC ")
            #Second start byte is bad, reset all flags   
            elif (start_cond1 == 1):
                #print("Bad cond 2 PC")
                start_cond1 = 0
            # First start byte is good
            if (input_byte == start_cond1_byte):
                start_cond1 = 1
                #print("good cond 1 PC")
        else:
            # Here data goes after good  start
            data_buffer[data_counter] = input_byte
            if (data_counter == data_len - 1):

                logging.debug("Data len PC")
                logging.debug(data_len)
                logging.debug("End bytes are:")
                logging.debug(data_buffer[data_len -1])
                logging.debug(data_buffer[data_len -2])

                # Here if last 2 bytes are end condition bytes we process the data 
                if (data_buffer[data_len -1] == end_cond2_byte and data_buffer[data_len - 2] == end_cond1_byte):

                    logging.debug("GOOD END CONDITION PC")
                    logging.debug("I UNPACKED RAW DATA RECEIVED FROM THE ROBOT")
                    Unpack_data(data_buffer, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
                    XTR_data,Gripper_data_in)
                    logging.debug("DATA UNPACK FINISHED")
                    # ako su dobri izraÄunaj crc
                    # if crc dobar raspakiraj podatke
                    # ako je dobar paket je dobar i spremi ga u nove variable!
                
                # Print every byte
                #print("podaci u data bufferu su:")
                #for i in range(data_len):
                    #print(data_buffer[i])

                good_start = 0
                start_cond1 = 0
                start_cond3 = 0
                start_cond2 = 0
                data_len = 0
                data_counter = 0
            else:
                data_counter = data_counter + 1

# Split data to 3 bytes 
def Split_2_3_bytes(var_in):
    y = int_to_3_bytes(var_in & 0xFFFFFF) # converts my int value to bytes array
    return y

# Splits byte to bitfield list
def Split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]

# Fuses 3 bytes to 1 signed int
def Fuse_3_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<23:
        value -= 1<<24

    return value

# Fuses 2 bytes to 1 signed int
def Fuse_2_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<15:
        value -= 1<<16

    return value

# Fuse bitfield list to byte
def Fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Check if there is element 1 in the list. 
# If yes return its index, if no element is 1 return -1
def check_elements(lst):
    for i, element in enumerate(lst):
        if element == 1:
            return i
    return -1  # Return -1 if no element is 1

def quintic_scaling(s: float) -> float:
    """
    Calculates a smooth 0-to-1 scaling factor for progress 's'
    using a quintic polynomial, ensuring smooth start/end accelerations.
    """
    return 6 * (s**5) - 15 * (s**4) + 10 * (s**3)

#########################################################################
# Robot Commands Start Here
#########################################################################

class HomeCommand:
    """
    A non-blocking command that tells the robot to perform its internal homing sequence.
    This version uses a state machine to allow re-homing even if the robot is already homed.
    """
    def __init__(self):
        self.is_valid = True
        self.is_finished = False
        # State machine: START -> WAIT_FOR_UNHOMED -> WAIT_FOR_HOMED -> FINISHED
        self.state = "START"
        # Counter to send the home command for multiple cycles
        self.start_cmd_counter = 10  # Send command 100 for 10 cycles (0.1s)
        # Safety timeout (20 seconds at 0.01s interval)
        self.timeout_counter = 2000
        print("Initializing Home command...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Manages the homing command and monitors for completion using a state machine.
        """
        if self.is_finished:
            return True

        # --- State: START ---
        # On the first few executions, continuously send the 'home' (100) command.
        if self.state == "START":
            print(f"  -> Sending home signal (100)... Countdown: {self.start_cmd_counter}")
            Command_out.value = 100
            self.start_cmd_counter -= 1
            if self.start_cmd_counter <= 0:
                # Once sent for enough cycles, move to the next state
                self.state = "WAITING_FOR_UNHOMED"
            return False

        # --- State: WAITING_FOR_UNHOMED ---
        # The robot's firmware should reset the homed status. We wait to see that happen.
        # During this time, we send 'idle' (255) to let the robot's controller take over.
        if self.state == "WAITING_FOR_UNHOMED":
            Command_out.value = 255
            # Check if at least one joint has started homing (is no longer homed)
            if any(h == 0 for h in Homed_in[:6]):
                print("  -> Homing sequence initiated by robot.")
                self.state = "WAITING_FOR_HOMED"
            # Check for timeout
            self.timeout_counter -= 1
            if self.timeout_counter <= 0:
                print("  -> ERROR: Timeout waiting for robot to start homing sequence.")
                self.is_finished = True
            return self.is_finished

        # --- State: WAITING_FOR_HOMED ---
        # Now we wait for all joints to report that they are homed (all flags are 1).
        if self.state == "WAITING_FOR_HOMED":
            Command_out.value = 255
            # Check if all joints have finished homing
            if all(h == 1 for h in Homed_in[:6]):
                print("Homing sequence complete. All joints reported home.")
                self.is_finished = True
                Speed_out[:] = [0] * 6 # Ensure robot is stopped

        return self.is_finished

class JogCommand:
    """
    A non-blocking command to jog a joint for a specific duration or distance.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joint, speed_percentage=None, duration=None, distance_deg=None):
        """
        Initializes and validates the jog command. This is the SETUP phase.
        """
        self.is_valid = False
        self.is_finished = False
        self.mode = None
        self.command_step = 0

        # --- 1. Parameter Validation and Mode Selection ---
        if duration and distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Distance {distance_deg} deg, Duration {duration}s.")
        elif duration:
            self.mode = 'time'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Duration {duration}s.")
        elif distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Distance {distance_deg} deg.")
        else:
            print("Error: JogCommand requires either 'duration', 'distance_deg', or both.")
            return

        # --- 2. Store parameters for deferred calculation ---
        self.joint = joint
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.distance_deg = distance_deg

        # --- These will be calculated later ---
        self.direction = 1
        self.joint_index = 0
        self.speed_out = 0
        self.command_len = 0
        self.target_position = 0

        self.is_valid = True # Mark as valid for now; preparation step will confirm.


    def prepare_for_execution(self, current_position_in):
        """Pre-computes speeds and target positions using live data."""
        print(f"  -> Preparing for Jog command...")

        # Determine direction and joint index
        self.direction = 1 if 0 <= self.joint <= 5 else -1
        self.joint_index = self.joint if self.direction == 1 else self.joint - 6
        
        distance_steps = 0
        if self.distance_deg:
            distance_steps = int(PAROL6_ROBOT.DEG2STEPS(abs(self.distance_deg), self.joint_index))
            # --- MOVED LOGIC: Calculate target using the LIVE position ---
            self.target_position = current_position_in[self.joint_index] + (distance_steps * self.direction)
            
            min_limit, max_limit = PAROL6_ROBOT.Joint_limits_steps[self.joint_index]
            if not (min_limit <= self.target_position <= max_limit):
                print(f"  -> VALIDATION FAILED: Target position {self.target_position} is out of joint limits ({min_limit}, {max_limit}).")
                self.is_valid = False
                return

        # Calculate speed and duration
        speed_steps_per_sec = 0
        if self.mode == 'distance' and self.duration:
            speed_steps_per_sec = int(distance_steps / self.duration) if self.duration > 0 else 0
            max_joint_speed = PAROL6_ROBOT.Joint_max_speed[self.joint_index]
            if speed_steps_per_sec > max_joint_speed:
                print(f"  -> VALIDATION FAILED: Required speed ({speed_steps_per_sec} steps/s) exceeds joint's max speed ({max_joint_speed} steps/s).")
                self.is_valid = False
                return
        else:
            if self.speed_percentage is None:
                print("Error: 'speed_percentage' must be provided if not calculating automatically.")
                self.is_valid = False
                return
            speed_steps_per_sec = int(np.interp(abs(self.speed_percentage), [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[self.joint_index] * 2]))

        self.speed_out = speed_steps_per_sec * self.direction
        self.command_len = int(self.duration / INTERVAL_S) if self.duration else float('inf')
        print("  -> Jog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        stop_reason = None
        current_pos = Position_in[self.joint_index]

        if self.mode == 'time':
            if self.command_step >= self.command_len:
                stop_reason = "Timed jog finished."
        elif self.mode == 'distance':
            if (self.direction == 1 and current_pos >= self.target_position) or \
               (self.direction == -1 and current_pos <= self.target_position):
                stop_reason = "Distance jog finished."
        
        if not stop_reason:
            if (self.direction == 1 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][1]) or \
               (self.direction == -1 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][0]):
                stop_reason = f"Limit reached on joint {self.joint_index + 1}."

        if stop_reason:
            print(stop_reason)
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            Speed_out[:] = [0] * 6
            Speed_out[self.joint_index] = self.speed_out
            Command_out.value = 123
            self.command_step += 1
            return False
        
class MultiJogCommand:
    """
    A non-blocking command to jog multiple joints simultaneously for a specific duration.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joints, speed_percentages, duration):
        """
        Initializes and validates the multi-jog command.
        """
        self.is_valid = False
        self.is_finished = False
        self.command_step = 0

        # --- 1. Parameter Validation ---
        if not isinstance(joints, list) or not isinstance(speed_percentages, list):
            print("Error: MultiJogCommand requires 'joints' and 'speed_percentages' to be lists.")
            return

        if len(joints) != len(speed_percentages):
            print("Error: The number of joints must match the number of speed percentages.")
            return

        if not duration or duration <= 0:
            print("Error: MultiJogCommand requires a positive 'duration'.")
            return

        # ==========================================================
        # === NEW: Check for conflicting joint commands          ===
        # ==========================================================
        base_joints = set()
        for joint in joints:
            # Normalize the joint index to its base (0-5)
            base_joint = joint % 6
            # If the base joint is already in our set, it's a conflict.
            if base_joint in base_joints:
                print(f"  -> VALIDATION FAILED: Conflicting commands for Joint {base_joint + 1} (e.g., J1+ and J1-).")
                self.is_valid = False
                return
            base_joints.add(base_joint)
        # ==========================================================

        print(f"Initializing MultiJog for joints {joints} with speeds {speed_percentages}% for {duration}s.")

        # --- 2. Store parameters ---
        self.joints = joints
        self.speed_percentages = speed_percentages
        self.duration = duration
        self.command_len = int(self.duration / INTERVAL_S)

        # --- This will be calculated in the prepare step ---
        self.speeds_out = [0] * 6

        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Pre-computes the speeds for each joint."""
        print(f"  -> Preparing for MultiJog command...")

        for i, joint in enumerate(self.joints):
            # Determine direction and joint index (0-5 for positive, 6-11 for negative)
            direction = 1 if 0 <= joint <= 5 else -1
            joint_index = joint if direction == 1 else joint - 6
            speed_percentage = self.speed_percentages[i]

            # Check for joint index validity
            if not (0 <= joint_index < 6):
                print(f"  -> VALIDATION FAILED: Invalid joint index {joint_index}.")
                self.is_valid = False
                return

            # Calculate speed in steps/sec
            speed_steps_per_sec = int(np.interp(speed_percentage, [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[joint_index]]))
            self.speeds_out[joint_index] = speed_steps_per_sec * direction

        print("  -> MultiJog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        # Stop if the duration has elapsed
        if self.command_step >= self.command_len:
            print("Timed multi-jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            # Continuously check for joint limits during the jog
            for i in range(6):
                if self.speeds_out[i] != 0:
                    current_pos = Position_in[i]
                    # Hitting positive limit while moving positively
                    if self.speeds_out[i] > 0 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[i][1]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True
                    # Hitting negative limit while moving negatively
                    elif self.speeds_out[i] < 0 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[i][0]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True

            # If no limits are hit, apply the speeds
            Speed_out[:] = self.speeds_out
            Command_out.value = 123 # Jog command
            self.command_step += 1
            return False # Command is still running
        
# This dictionary maps descriptive axis names to movement vectors, which is cleaner.
# Format: ([x, y, z], [rx, ry, rz])
AXIS_MAP = {
    'X+': ([1, 0, 0], [0, 0, 0]), 'X-': ([-1, 0, 0], [0, 0, 0]),
    'Y+': ([0, 1, 0], [0, 0, 0]), 'Y-': ([0, -1, 0], [0, 0, 0]),
    'Z+': ([0, 0, 1], [0, 0, 0]), 'Z-': ([0, 0, -1], [0, 0, 0]),
    'RX+': ([0, 0, 0], [1, 0, 0]), 'RX-': ([0, 0, 0], [-1, 0, 0]),
    'RY+': ([0, 0, 0], [0, 1, 0]), 'RY-': ([0, 0, 0], [0, -1, 0]),
    'RZ+': ([0, 0, 0], [0, 0, 1]), 'RZ-': ([0, 0, 0], [0, 0, -1]),
}

class CartesianJogCommand:
    """
    A non-blocking command to jog the robot's end-effector in Cartesian space.
    This is the final, refactored version using clean, standard spatial math
    operations now that the core unit bug has been fixed.
    """
    def __init__(self, frame, axis, speed_percentage=50, duration=1.5, **kwargs):
        """
        Initializes and validates the Cartesian jog command.
        """
        self.is_valid = False
        self.is_finished = False
        print(f"Initializing CartesianJog: Frame {frame}, Axis {axis}...")

        if axis not in AXIS_MAP:
            print(f"  -> VALIDATION FAILED: Invalid axis '{axis}'.")
            return
        
        # Store all necessary parameters for use in execute_step
        self.frame = frame
        self.axis_vectors = AXIS_MAP[axis]
        self.is_rotation = any(self.axis_vectors[1])
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.end_time = time.time() + self.duration
        
        self.is_valid = True
        print("  -> Command is valid and ready.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Check for completion ---
        if time.time() >= self.end_time:
            print("Cartesian jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- B. Calculate Target Pose using clean vector math ---
        Command_out.value = 123 # Set jog command
        
        q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        T_current = PAROL6_ROBOT.robot.fkine(q_current)

        if not isinstance(T_current, SE3):
            return False # Wait for valid pose data

        # Calculate speed and displacement for this cycle
        linear_speed_ms = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min_JOG, PAROL6_ROBOT.Cartesian_linear_velocity_max_JOG]))
        angular_speed_degs = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max]))

        delta_linear = linear_speed_ms * INTERVAL_S
        delta_angular_rad = np.deg2rad(angular_speed_degs * INTERVAL_S)

        # Create the small incremental transformation (delta_pose)
        trans_vec = np.array(self.axis_vectors[0]) * delta_linear
        rot_vec = np.array(self.axis_vectors[1]) * delta_angular_rad
        delta_pose = SE3.Rt(SE3.Eul(rot_vec).R, trans_vec)

        # Apply the transformation in the correct reference frame
        if self.frame == 'WRF':
            # Pre-multiply to apply the change in the World Reference Frame
            target_pose = delta_pose * T_current
        else: # TRF
            # Post-multiply to apply the change in the Tool Reference Frame
            target_pose = T_current * delta_pose
        
        # --- C. Solve IK and Calculate Velocities ---
        var = solve_ik_with_adaptive_tol_subdivision(PAROL6_ROBOT.robot, target_pose, q_current, jogging=True)

        if var.success:
            q_velocities = (var.q - q_current) / INTERVAL_S
            for i in range(6):
                Speed_out[i] = int(PAROL6_ROBOT.SPEED_RAD2STEP(q_velocities[i], i))
        else:
            print("IK Warning: Could not find solution for jog step. Stopping.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- D. Speed Scaling ---
        max_scale_factor = 1.0
        for i in range(6):
            if abs(Speed_out[i]) > PAROL6_ROBOT.Joint_max_speed[i]:
                scale = abs(Speed_out[i]) / PAROL6_ROBOT.Joint_max_speed[i]
                if scale > max_scale_factor:
                    max_scale_factor = scale
        
        if max_scale_factor > 1.0:
            for i in range(6):
                Speed_out[i] = int(Speed_out[i] / max_scale_factor)

        return False # Command is still running

class MovePoseCommand:
    """
    A non-blocking command to move the robot to a specific Cartesian pose.
    The movement itself is a joint-space interpolation.
    """
    def __init__(self, pose, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = True  # Assume valid; preparation step will confirm.
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MovePose to {pose}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.pose = pose
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

    """
        Initializes, validates, and pre-computes the trajectory for a move-to-pose command.

        Args:
            pose (list): A list of 6 values [x, y, z, r, p, y] for the target pose.
                         Positions are in mm, rotations are in degrees.
            duration (float, optional): The total time for the movement in seconds.
            velocity_percent (float, optional): The target velocity as a percentage (0-100).
            accel_percent (float, optional): The target acceleration as a percentage (0-100).
            trajectory_type (str, optional): The type of trajectory ('poly' or 'trap').
        """
    
    def prepare_for_execution(self, current_position_in):
        """Calculates the full trajectory just-in-time before execution."""
        print(f"  -> Preparing trajectory for MovePose to {self.pose}...")

        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pose = SE3(self.pose[0] / 1000.0, self.pose[1] / 1000.0, self.pose[2] / 1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')
        
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_pose, initial_pos_rad, ilimit=100)

        if not ik_solution.success:
            print("  -> VALIDATION FAILED: Inverse kinematics failed at execution time.")
            self.is_valid = False
            return

        target_pos_rad = ik_solution.q

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])

                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue
                    
                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)
            
                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                self.is_valid = False
                return

        else:
            print("  -> Using conservative values for MovePose.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveJointCommand:
    """
    A non-blocking command to move the robot's joints to a specific configuration.
    It pre-calculates the entire trajectory upon initialization.
    """
    def __init__(self, target_angles, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = False  # Will be set to True after basic validation
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MoveJoint to {target_angles}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.target_angles = target_angles
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

        # --- Perform only state-independent validation ---
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])
        for i in range(6):
            min_rad, max_rad = PAROL6_ROBOT.Joint_limits_radian[i]
            if not (min_rad <= target_pos_rad[i] <= max_rad):
                print(f"  -> VALIDATION FAILED: Target for Joint {i+1} ({self.target_angles[i]} deg) is out of range.")
                return
        
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Calculates the trajectory just before execution begins."""
        print(f"  -> Preparing trajectory for MoveJoint to {self.target_angles}...")
        
        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])
                
                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue

                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)

                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                print(f"  -> Please check Joint_min/max_speed and Joint_min/max_acc values in PAROL6_ROBOT.py.")
                self.is_valid = False
                return
        
        else:
            print("  -> Using conservative values for MoveJoint.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveCartCommand:
    """
    A non-blocking command to move the robot's end-effector in a straight line
    in Cartesian space, completing the move in an exact duration.

    It works by:
    1. Pre-validating the final target pose.
    2. Interpolating the pose in Cartesian space in real-time.
    3. Solving Inverse Kinematics for each intermediate step to ensure path validity.
    """
    def __init__(self, pose, duration=None, velocity_percent=None):
        self.is_valid = False
        self.is_finished = False

        # --- MODIFICATION: Validate that at least one timing parameter is given ---
        if duration is None and velocity_percent is None:
            print("  -> VALIDATION FAILED: MoveCartCommand requires either 'duration' or 'velocity_percent'.")
            return
        if duration is not None and velocity_percent is not None:
            print("  -> INFO: Both duration and velocity_percent provided. Using duration.")
            self.velocity_percent = None # Prioritize duration
        else:
            self.velocity_percent = velocity_percent

        # --- Store parameters and set placeholders ---
        self.duration = duration
        self.pose = pose
        self.start_time = None
        self.initial_pose = None
        self.target_pose = None
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Captures the initial state and validates the path just before execution."""
        print(f"  -> Preparing for MoveCart to {self.pose}...")
        
        # --- MOVED LOGIC: Capture initial state from live data ---
        initial_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        self.initial_pose = PAROL6_ROBOT.robot.fkine(initial_q_rad)
        self.target_pose = SE3(self.pose[0]/1000.0, self.pose[1]/1000.0, self.pose[2]/1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')

        print("  -> Pre-validating final target pose...")
        ik_check = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, self.target_pose, initial_q_rad
        )

        if not ik_check.success:
            print("  -> VALIDATION FAILED: The final target pose is unreachable.")
            if ik_check.violations:
                print(f"     Reason: Solution violates joint limits: {ik_check.violations}")
            self.is_valid = False # Mark as invalid if path fails
            return

        # --- NEW BLOCK: Calculate duration from velocity if needed ---
        if self.velocity_percent is not None:
            print(f"  -> Calculating duration for {self.velocity_percent}% speed...")
            # Calculate the total distance for translation and rotation
            linear_distance = np.linalg.norm(self.target_pose.t - self.initial_pose.t)
            angular_distance_rad = self.initial_pose.angdist(self.target_pose)

            # Interpolate the target speeds from percentages, assuming constants exist in PAROL6_ROBOT
            target_linear_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min, PAROL6_ROBOT.Cartesian_linear_velocity_max])
            target_angular_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max])
            target_angular_speed_rad = np.deg2rad(target_angular_speed)

            # Calculate time required for each component of the movement
            time_linear = linear_distance / target_linear_speed if target_linear_speed > 0 else 0
            time_angular = angular_distance_rad / target_angular_speed_rad if target_angular_speed_rad > 0 else 0

            # The total duration is the longer of the two times to ensure synchronization
            calculated_duration = max(time_linear, time_angular)

            if calculated_duration <= 0:
                print("  -> INFO: MoveCart has zero duration. Marking as finished.")
                self.is_finished = True
                self.is_valid = True # It's valid, just already done.
                return

            self.duration = calculated_duration
            print(f"  -> Calculated MoveCart duration: {self.duration:.2f}s")

        print("  -> Command is valid and ready for execution.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        if self.start_time is None:
            self.start_time = time.time()

        elapsed_time = time.time() - self.start_time
        s = min(elapsed_time / self.duration, 1.0)
        s_scaled = quintic_scaling(s)

        current_target_pose = self.initial_pose.interp(self.target_pose, s_scaled)

        current_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, current_target_pose, current_q_rad
        )

        if not ik_solution.success:
            print("  -> ERROR: MoveCart failed. An intermediate point on the path is unreachable.")
            if ik_solution.violations:
                 print(f"     Reason: Path violates joint limits: {ik_solution.violations}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        current_pos_rad = ik_solution.q

        # --- MODIFIED BLOCK ---
        # Send only the target position and let the firmware's P-controller handle speed.
        Position_out[:] = [int(PAROL6_ROBOT.RAD2STEPS(p, i)) for i, p in enumerate(current_pos_rad)]
        Speed_out[:] = [0] * 6 # Set feed-forward velocity to zero for smooth P-control.
        Command_out.value = 156
        # --- END MODIFIED BLOCK ---

        if s >= 1.0:
            print(f"MoveCart finished in ~{elapsed_time:.2f}s.")
            self.is_finished = True
            # The main loop will handle holding the final position.

        return self.is_finished
        
class GripperCommand:
    """
    A single, unified, non-blocking command to control all gripper functions.
    It internally selects the correct logic (position-based waiting, timed delay,
    or instantaneous) based on the specified action.
    """
    def __init__(self, gripper_type, action=None, position=100, speed=100, current=500, output_port=1):
        """
        Initializes the Gripper command and configures its internal state machine
        based on the requested action.
        """
        self.is_valid = True
        self.is_finished = False
        self.gripper_type = gripper_type.lower()
        self.action = action.lower() if action else 'move'
        self.state = "START"
        self.timeout_counter = 1000 # 10-second safety timeout for all waiting states

        # --- Configure based on Gripper Type and Action ---
        if self.gripper_type == 'electric':
            if self.action == 'move':
                self.target_position = position
                self.speed = speed
                self.current = current
                if not (0 <= position <= 255 and 0 <= speed <= 255 and 100 <= current <= 1000):
                    self.is_valid = False
            elif self.action == 'calibrate':
                self.wait_counter = 200 # 2-second fixed delay for calibration
            else:
                self.is_valid = False # Invalid action

        elif self.gripper_type == 'pneumatic':
            if self.action not in ['open', 'close']:
                self.is_valid = False
            self.state_to_set = 1 if self.action == 'open' else 0
            self.port_index = 2 if output_port == 1 else 3
        else:
            self.is_valid = False

        if not self.is_valid:
            print(f"  -> VALIDATION FAILED for GripperCommand with action: '{self.action}'")

    def execute_step(self, Gripper_data_out, InOut_out, Gripper_data_in, InOut_in, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        self.timeout_counter -= 1
        if self.timeout_counter <= 0:
            print(f"  -> ERROR: Gripper command timed out in state {self.state}.")
            self.is_finished = True
            return True

        # --- Pneumatic Logic (Instantaneous) ---
        if self.gripper_type == 'pneumatic':
            InOut_out[self.port_index] = self.state_to_set
            print("  -> Pneumatic gripper command sent.")
            self.is_finished = True
            return True

        # --- Electric Gripper Logic ---
        if self.gripper_type == 'electric':
            # On the first run, transition to the correct state for the action
            if self.state == "START":
                if self.action == 'calibrate':
                    self.state = "SEND_CALIBRATE"
                else: # 'move'
                    self.state = "WAIT_FOR_POSITION"
            
            # --- Calibrate Logic (Timed Delay) ---
            if self.state == "SEND_CALIBRATE":
                print("  -> Sending one-shot calibrate command...")
                Gripper_data_out[4] = 1 # Set mode to calibrate
                self.state = "WAITING_CALIBRATION"
                return False

            if self.state == "WAITING_CALIBRATION":
                self.wait_counter -= 1
                if self.wait_counter <= 0:
                    print("  -> Calibration delay finished.")
                    Gripper_data_out[4] = 0 # Reset to operation mode
                    self.is_finished = True
                    return True
                return False

            # --- Move Logic (Position-Based) ---
            if self.state == "WAIT_FOR_POSITION":
                # Persistently send the move command
                Gripper_data_out[0], Gripper_data_out[1], Gripper_data_out[2] = self.target_position, self.speed, self.current
                Gripper_data_out[4] = 0 # Operation mode
                bitfield = [1, 1, not InOut_in[4], 1, 0, 0, 0, 0]
                fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                Gripper_data_out[3] = int(fused.hex(), 16)

                # Check for completion
                current_position = Gripper_data_in[1]
                if abs(current_position - self.target_position) <= 5:
                    print(f"  -> Gripper move complete.")
                    self.is_finished = True
                    # Set command back to idle
                    bitfield = [1, 0, not InOut_in[4], 1, 0, 0, 0, 0]
                    fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                    Gripper_data_out[3] = int(fused.hex(), 16)
                    return True
                return False
        
        return self.is_finished

class DelayCommand:
    """
    A non-blocking command that pauses execution for a specified duration.
    During the delay, it ensures the robot remains idle by sending the
    appropriate commands.
    """
    def __init__(self, duration):
        """
        Initializes and validates the Delay command.

        Args:
            duration (float): The delay time in seconds.
        """
        self.is_valid = False
        self.is_finished = False

        # --- 1. Parameter Validation ---
        if not isinstance(duration, (int, float)) or duration <= 0:
            print(f"  -> VALIDATION FAILED: Delay duration must be a positive number, but got {duration}.")
            return

        print(f"Initializing Delay for {duration} seconds...")
        
        self.duration = duration
        self.end_time = None  # Will be set in prepare_for_execution
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Set the end time when the command actually starts."""
        self.end_time = time.time() + self.duration
        print(f"  -> Delay starting for {self.duration} seconds...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Checks if the delay duration has passed and keeps the robot idle.
        This method is called on every loop cycle (~0.01s).
        """
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Keep the robot idle during the delay ---
        Command_out.value = 255  # Set command to idle
        Speed_out[:] = [0] * 6   # Set all speeds to zero

        # --- B. Check for completion ---
        if self.end_time and time.time() >= self.end_time:
            print(f"Delay finished after {self.duration} seconds.")
            self.is_finished = True
        
        return self.is_finished
    
#########################################################################
# Smooth Motion Commands Start Here
#########################################################################
    
class BaseSmoothMotionCommand:
    """
    Base class for all smooth motion commands with proper error tracking.
    """
    
    def __init__(self, description="smooth motion"):
        self.description = description
        self.trajectory = None
        self.trajectory_command = None
        self.transition_command = None
        self.is_valid = True
        self.is_finished = False
        self.specified_start_pose = None
        self.transition_complete = False
        self.trajectory_prepared = False
        self.error_state = False
        self.error_message = ""
        self.trajectory_generated = False  # NEW: Track if trajectory is generated
        
    def create_transition_command(self, current_pose, target_pose):
        """Create a MovePose command for smooth transition to start position."""
        pos_error = np.linalg.norm(
            np.array(target_pose[:3]) - np.array(current_pose[:3])
        )
        
        # Lower threshold to 2mm for more aggressive transition generation
        if pos_error < 2.0:  # Changed from 5.0mm to 2.0mm
            print(f"  -> Already near start position (error: {pos_error:.1f}mm)")
            return None
        
        print(f"  -> Creating smooth transition to start ({pos_error:.1f}mm away)")
        
        # Calculate transition speed based on distance
        # Slower for short distances, faster for long distances
        if pos_error < 10:
            transition_speed = 20.0  # mm/s for short distances
        elif pos_error < 30:
            transition_speed = 30.0  # mm/s for medium distances
        else:
            transition_speed = 40.0  # mm/s for long distances
        
        transition_duration = max(pos_error / transition_speed, 0.5)  # Minimum 0.5s
        
        transition_cmd = MovePoseCommand(
            pose=target_pose,
            duration=transition_duration
        )
        
        return transition_cmd
    
    def get_current_pose_from_position(self, position_in):
        """Convert current position to pose [x,y,z,rx,ry,rz]"""
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(position_in)])
        current_pose_se3 = PAROL6_ROBOT.robot.fkine(current_q)
        
        current_xyz = current_pose_se3.t * 1000  # Convert to mm
        current_rpy = current_pose_se3.rpy(unit='deg', order='xyz')
        return np.concatenate([current_xyz, current_rpy]).tolist()
        
    def prepare_for_execution(self, current_position_in):
        """Minimal preparation - just check if we need a transition."""
        print(f"  -> Preparing {self.description}...")
        
        # If there's a specified start pose, prepare transition
        if self.specified_start_pose:
            actual_current_pose = self.get_current_pose_from_position(current_position_in)
            self.transition_command = self.create_transition_command(
                actual_current_pose, self.specified_start_pose
            )
            
            if self.transition_command:
                self.transition_command.prepare_for_execution(current_position_in)
                if not self.transition_command.is_valid:
                    print(f"  -> ERROR: Cannot reach specified start position")
                    self.is_valid = False
                    self.error_state = True
                    self.error_message = "Cannot reach specified start position"
                    return
        else:
            self.transition_command = None
            
        # DON'T generate trajectory yet - wait until execution
        self.trajectory_generated = False
        self.trajectory_prepared = False
        print(f"  -> {self.description} preparation complete (trajectory will be generated at execution)")
            
    def generate_main_trajectory(self, effective_start_pose):
        """Override this in subclasses to generate the specific motion trajectory."""
        raise NotImplementedError("Subclasses must implement generate_main_trajectory")
        
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """Execute transition first if needed, then generate and execute trajectory."""
        if self.is_finished or not self.is_valid:
            return True
        
        # Execute transition first if needed
        if self.transition_command and not self.transition_complete:
            is_done = self.transition_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            if is_done:
                print(f"  -> Transition complete")
                self.transition_complete = True
            return False
        
        # Generate trajectory on first execution step (not during preparation!)
        if not self.trajectory_generated:
            # Get ACTUAL current position NOW
            actual_current_pose = self.get_current_pose_from_position(Position_in)
            print(f"  -> Generating {self.description} from ACTUAL position: {[round(p, 1) for p in actual_current_pose[:3]]}")
            
            # Generate trajectory from where we ACTUALLY are
            self.trajectory = self.generate_main_trajectory(actual_current_pose)
            self.trajectory_command = SmoothTrajectoryCommand(
                self.trajectory, self.description
            )
            
            # Quick validation of first point only
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(Position_in)])
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
            )
            
            if not ik_result.success:
                print(f"  -> ERROR: Cannot reach first trajectory point")
                self.is_finished = True
                self.error_state = True
                self.error_message = "Cannot reach trajectory start"
                Speed_out[:] = [0] * 6
                Command_out.value = 255
                return True
                
            self.trajectory_generated = True
            self.trajectory_prepared = True
            
            # Verify first point is close to current
            distance = np.linalg.norm(first_pose[:3] - np.array(actual_current_pose[:3]))
            if distance > 5.0:
                print(f"  -> WARNING: First trajectory point {distance:.1f}mm from current!")
        
        # Execute main trajectory
        if self.trajectory_command and self.trajectory_prepared:
            is_done = self.trajectory_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            # Check for errors in trajectory execution
            if hasattr(self.trajectory_command, 'error_state') and self.trajectory_command.error_state:
                self.error_state = True
                self.error_message = self.trajectory_command.error_message
            
            if is_done:
                self.is_finished = True
            
            return is_done
        else:
            self.is_finished = True
            return True

class SmoothTrajectoryCommand:
    """Command class for executing pre-generated smooth trajectories."""
    
    def __init__(self, trajectory, description="smooth motion"):
        self.trajectory = np.array(trajectory)
        self.description = description
        self.trajectory_index = 0
        self.is_valid = True
        self.is_finished = False
        self.first_step = True
        self.error_state = False
        self.error_message = ""
        
        print(f"Initializing smooth {description} with {len(trajectory)} points")
    
    def prepare_for_execution(self, current_position_in):
        """Skip validation - trajectory is already generated from correct position"""
        # No validation needed since trajectory was just generated from current position
        self.is_valid = True
        return
    
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, Position_out=None, **kwargs):
        """Execute one step of the smooth trajectory"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Get Position_out from kwargs if not provided
        if Position_out is None:
            Position_out = kwargs.get('Position_out', Position_in)
        
        if self.trajectory_index >= len(self.trajectory):
            print(f"Smooth {self.description} finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get target pose for this step
        target_pose = self.trajectory[self.trajectory_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                            for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
        )
        
        if not ik_result.success:
            print(f"  -> IK failed at trajectory point {self.trajectory_index}")
            self.is_finished = True
            self.error_state = True
            self.error_message = f"IK failed at point {self.trajectory_index}/{len(self.trajectory)}"
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                    for i, q in enumerate(ik_result.q)]
        
        # ADD VELOCITY LIMITING - This prevents violent movements
        if self.trajectory_index > 0:
            for i in range(6):
                step_diff = abs(target_steps[i] - Position_in[i])
                max_step_diff = PAROL6_ROBOT.Joint_max_speed[i] * 0.01  # Max steps in 10ms
                
                # Use 1.2x safety margin (not 2x as before)
                if step_diff > max_step_diff * 1.2:
                    #print(f"  -> WARNING: Joint {i+1} velocity limit exceeded at point {self.trajectory_index}")
                    #print(f"     Step difference: {step_diff}, Max allowed: {max_step_diff * 1.2:.1f}")
                    
                    # Clamp the motion
                    sign = 1 if target_steps[i] > Position_in[i] else -1
                    target_steps[i] = Position_in[i] + sign * int(max_step_diff)
        
        # Send position command
        Position_out[:] = target_steps
        Speed_out[:] = [0] * 6
        Command_out.value = 156
        
        # Advance to next point
        self.trajectory_index += 1
        
        return False

class SmoothCircleCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, plane, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"circle (r={radius}mm, {frame})")
        self.center = center
        self.radius = radius
        self.plane = plane
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame  # Store reference frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None  # Store for TRF transformation
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        # Store current position for potential use in generate_main_trajectory
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'center': self.center,
                'plane': self.plane
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_CIRCLE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Circle: center {self.center[:3]} (WRF), normal {self.normal_vector}")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_CIRCLE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        # Now do normal preparation with transformed parameters
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate circle starting from the actual start position."""
        motion_gen = CircularMotion()
        
        # Use transformed normal for TRF, or standard for WRF
        if self.normal_vector is not None:
            # TRF - use the transformed normal vector
            normal = np.array(self.normal_vector)
            print(f"    Using transformed normal: {normal.round(3)}")
        else:
            # WRF - use standard plane definition
            plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
            normal = np.array(plane_normals.get(self.plane, [0, 0, 1]))  # Convert to numpy array
            print(f"    Using WRF plane {self.plane} with normal: {normal}")
        
        print(f"    Generating circle from position: {[round(p, 1) for p in effective_start_pose[:3]]}")
        print(f"    Circle center: {[round(c, 1) for c in self.center]}")
        
        # Add geometry validation
        center_np = np.array(self.center)
        start_np = np.array(effective_start_pose[:3])
        
        # Project start point onto circle plane to check distance
        to_start = start_np - center_np
        to_start_plane = to_start - np.dot(to_start, normal) * normal
        distance_to_center = np.linalg.norm(to_start_plane)
        
        if abs(distance_to_center - self.radius) > self.radius * 0.3:
            print(f"    WARNING: Robot is {distance_to_center:.1f}mm from center, but radius is {self.radius:.1f}mm")
            print(f"    Circle geometry will be auto-corrected")
        
        # Generate circle that starts at effective_start_pose
        trajectory = motion_gen.generate_circle_3d(
            self.center, 
            self.radius, 
            normal,  # This normal now correctly represents the plane
            start_point=effective_start_pose[:3],
            duration=self.duration
        )
        
        if self.clockwise:
            trajectory = trajectory[::-1]
        
        # Update orientations to match start pose
        for i in range(len(trajectory)):
            trajectory[i][3:] = effective_start_pose[3:]
        
        return trajectory
    
class SmoothArcCenterCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, center, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"arc (center-based, {frame})")
        self.end_pose = end_pose
        self.center = center
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {
                'end_pose': self.end_pose,
                'center': self.center
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
            )
            self.end_pose = transformed['end_pose']
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc from actual start to end."""
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, self.center,
            normal=self.normal_vector,  # Use transformed normal if TRF
            clockwise=self.clockwise, duration=self.duration
        )
    
class SmoothArcParamCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, radius, arc_angle, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"parametric arc (r={radius}mm, Î¸={arc_angle}Â°, {frame})")
        self.end_pose = end_pose
        self.radius = radius
        self.arc_angle = arc_angle
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'end_pose': self.end_pose,
                'plane': 'XY'  # Default plane for parametric arc
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.end_pose = transformed['end_pose']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Parametric Arc: end {self.end_pose[:3]} (WRF)")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc based on radius and angle from actual start."""
        # Get start and end positions
        start_xyz = np.array(effective_start_pose[:3])
        end_xyz = np.array(self.end_pose[:3])
        
        # If we have a transformed normal (TRF), use it to define the arc plane
        if self.normal_vector is not None:
            normal = np.array(self.normal_vector)
            
            # Project start and end onto the plane perpendicular to normal
            # This ensures the arc stays in the correct plane for TRF
            
            # Find center of arc using radius and angle
            chord_vec = end_xyz - start_xyz
            chord_length = np.linalg.norm(chord_vec)
            
            if chord_length > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({chord_length:.1f}mm) for radius {self.radius}mm")
                self.radius = chord_length / 2 + 1
            
            # Calculate center position using the normal vector
            chord_mid = (start_xyz + end_xyz) / 2
            
            # Height from chord midpoint to arc center
            if chord_length > 0:
                h = np.sqrt(max(0, self.radius**2 - (chord_length/2)**2))
                
                # Find perpendicular in the plane defined by normal
                chord_dir = chord_vec / chord_length
                perp_in_plane = np.cross(normal, chord_dir)
                if np.linalg.norm(perp_in_plane) > 0.001:
                    perp_in_plane = perp_in_plane / np.linalg.norm(perp_in_plane)
                else:
                    # Chord is parallel to normal (shouldn't happen)
                    perp_in_plane = np.array([1, 0, 0])
                
                # Arc center
                if self.clockwise:
                    center_3d = chord_mid - h * perp_in_plane
                else:
                    center_3d = chord_mid + h * perp_in_plane
            else:
                center_3d = start_xyz
            
        else:
            # WRF - use XY plane (standard behavior)
            normal = np.array([0, 0, 1])
            
            # Calculate arc center in XY plane
            start_xy = start_xyz[:2]
            end_xy = end_xyz[:2]
            
            # Midpoint
            mid = (start_xy + end_xy) / 2
            
            # Distance between points
            d = np.linalg.norm(end_xy - start_xy)
            
            if d > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({d:.1f}mm) for radius {self.radius}mm")
                self.radius = d / 2 + 1
            
            # Height of arc center from midpoint
            h = np.sqrt(max(0, self.radius**2 - (d/2)**2))
            
            # Perpendicular direction
            if d > 0:
                perp = np.array([-(end_xy[1] - start_xy[1]), end_xy[0] - start_xy[0]])
                perp = perp / np.linalg.norm(perp)
            else:
                perp = np.array([1, 0])
            
            # Arc center (choose based on clockwise)
            if self.clockwise:
                center_2d = mid - h * perp
            else:
                center_2d = mid + h * perp
            
            # Use average Z for center
            center_3d = [center_2d[0], center_2d[1], (start_xyz[2] + end_xyz[2]) / 2]
        
        # Generate arc trajectory from actual start
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, center_3d.tolist(),
            normal=normal if self.normal_vector is not None else None,
            clockwise=self.clockwise, duration=self.duration
        )

class SmoothHelixCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, pitch, height, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"helix (h={height}mm, {frame})")
        self.center = center
        self.radius = radius
        self.pitch = pitch
        self.height = height
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.helix_axis = None
        self.up_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {'center': self.center}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_HELIX', params, 'TRF', current_position_in
            )
            self.center = transformed['center']
            self.helix_axis = transformed.get('helix_axis', [0, 0, 1])
            self.up_vector = transformed.get('up_vector', [0, 1, 0])
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_HELIX', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate helix with proper axis orientation."""
        num_revolutions = self.height / self.pitch if self.pitch > 0 else 1
        num_points = int(self.duration * 100)  # 100Hz
        
        # Get helix axis (default Z for WRF, transformed for TRF)
        if self.helix_axis is not None:
            axis = np.array(self.helix_axis)
        else:
            axis = np.array([0, 0, 1])  # Default vertical
        
        # Create orthonormal basis for helix
        if self.up_vector is not None:
            up = np.array(self.up_vector)
        else:
            # Find perpendicular to axis
            if abs(axis[2]) < 0.9:
                up = np.array([0, 0, 1])
            else:
                up = np.array([1, 0, 0])
        
        # Ensure up is perpendicular to axis
        up = up - np.dot(up, axis) * axis
        up = up / np.linalg.norm(up)
        
        # Create right vector
        right = np.cross(axis, up)
        
        # Calculate starting angle based on actual start position
        to_start = np.array(effective_start_pose[:3]) - np.array(self.center)
        # Project onto plane perpendicular to axis
        to_start_plane = to_start - np.dot(to_start, axis) * axis
        
        if np.linalg.norm(to_start_plane) > 0.001:
            to_start_normalized = to_start_plane / np.linalg.norm(to_start_plane)
            start_angle = np.arctan2(np.dot(to_start_normalized, up), 
                                    np.dot(to_start_normalized, right))
        else:
            start_angle = 0
        
        trajectory = []
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            
            angle = start_angle + 2 * np.pi * num_revolutions * t
            if self.clockwise:
                angle = start_angle - 2 * np.pi * num_revolutions * t
            
            # Position on helix
            pos = np.array(self.center) + \
                  self.radius * (np.cos(angle) * right + np.sin(angle) * up) + \
                  self.height * t * axis
            
            # Use orientation from effective start
            trajectory.append(np.concatenate([pos, effective_start_pose[3:]]))
        
        return np.array(trajectory)

class SmoothSplineCommand(BaseSmoothMotionCommand):
    def __init__(self, waypoints, duration, frame='WRF', start_pose=None):
        super().__init__(f"spline ({len(waypoints)} points, {frame})")
        self.waypoints = waypoints
        self.duration = duration
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform waypoints to WRF
            params = {'waypoints': self.waypoints}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_SPLINE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.waypoints = transformed['waypoints']
            
            print(f"  -> TRF Spline: transformed {len(self.waypoints)} waypoints to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_SPLINE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate spline starting from actual position."""
        motion_gen = SplineMotion()
        
        # Always start from the effective start pose
        first_wp_error = np.linalg.norm(
            np.array(self.waypoints[0][:3]) - np.array(effective_start_pose[:3])
        )
        
        if first_wp_error > 5.0:
            # First waypoint is far, prepend the start position
            modified_waypoints = [effective_start_pose] + self.waypoints
            print(f"    Added start position as first waypoint (distance: {first_wp_error:.1f}mm)")
        else:
            # Replace first waypoint with actual start to ensure continuity
            modified_waypoints = [effective_start_pose] + self.waypoints[1:]
            print(f"    Replaced first waypoint with actual start position")
        
        timestamps = np.linspace(0, self.duration, len(modified_waypoints))
        
        # Generate the spline trajectory
        trajectory = motion_gen.generate_cubic_spline(modified_waypoints, timestamps)
        
        print(f"    Generated spline with {len(trajectory)} points")
        
        return trajectory

class SmoothBlendCommand(BaseSmoothMotionCommand):
    def __init__(self, segment_definitions, blend_time, frame='WRF', start_pose=None):
        super().__init__(f"blended ({len(segment_definitions)} segments, {frame})")
        self.segment_definitions = segment_definitions
        self.blend_time = blend_time
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform all segment definitions to WRF
            params = {'segments': self.segment_definitions}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_BLEND', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.segment_definitions = transformed['segments']
            
            print(f"  -> TRF Blend: transformed {len(self.segment_definitions)} segments to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_BLEND', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate blended trajectory starting from actual position."""
        trajectories = []
        motion_gen_circle = CircularMotion()
        motion_gen_spline = SplineMotion()
        
        # Always start from effective start pose
        last_end_pose = effective_start_pose
        
        for i, seg_def in enumerate(self.segment_definitions):
            seg_type = seg_def['type']
            
            # First segment always starts from effective_start_pose
            segment_start = effective_start_pose if i == 0 else last_end_pose
            
            if seg_type == 'LINE':
                end = seg_def['end']
                duration = seg_def['duration']
                
                # Generate line segment from actual position
                num_points = int(duration * 100)
                timestamps = np.linspace(0, duration, num_points)
                
                traj = []
                for t in timestamps:
                    s = t / duration if duration > 0 else 1
                    # Interpolate position
                    pos = [
                        segment_start[j] * (1-s) + end[j] * s
                        for j in range(3)
                    ]
                    # Interpolate orientation
                    orient = [
                        segment_start[j+3] * (1-s) + end[j+3] * s
                        for j in range(3)
                    ]
                    traj.append(pos + orient)
                
                trajectories.append(np.array(traj))
                last_end_pose = end
                
            elif seg_type == 'ARC':
                end = seg_def['end']
                center = seg_def['center']
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Check if we have a transformed normal (from TRF)
                normal = seg_def.get('normal_vector', None)
                
                traj = motion_gen_circle.generate_arc_3d(
                    segment_start, end, center, 
                    normal=normal,  # Use transformed normal if available
                    clockwise=clockwise, duration=duration
                )
                trajectories.append(traj)
                last_end_pose = end
                
            elif seg_type == 'CIRCLE':
                center = seg_def['center']
                radius = seg_def['radius']
                plane = seg_def.get('plane', 'XY')
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Use transformed normal if available (from TRF)
                if 'normal_vector' in seg_def:
                    normal = seg_def['normal_vector']
                else:
                    plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
                    normal = plane_normals.get(plane, [0, 0, 1])
                
                traj = motion_gen_circle.generate_circle_3d(
                    center, radius, normal, 
                    start_point=segment_start[:3],
                    duration=duration
                )
                
                if clockwise:
                    traj = traj[::-1]
                    
                # Update orientations
                for j in range(len(traj)):
                    traj[j][3:] = segment_start[3:]
                    
                trajectories.append(traj)
                # Circle returns to start, so last pose is last point of trajectory
                last_end_pose = traj[-1].tolist()
                
            elif seg_type == 'SPLINE':
                waypoints = seg_def['waypoints']
                duration = seg_def['duration']
                
                # Check if first waypoint is close to segment start
                wp_error = np.linalg.norm(
                    np.array(waypoints[0][:3]) - np.array(segment_start[:3])
                )
                
                if wp_error > 5.0:
                    full_waypoints = [segment_start] + waypoints
                else:
                    full_waypoints = [segment_start] + waypoints[1:]
                
                timestamps = np.linspace(0, duration, len(full_waypoints))
                traj = motion_gen_spline.generate_cubic_spline(full_waypoints, timestamps)
                trajectories.append(traj)
                last_end_pose = waypoints[-1]
        
        # Blend all trajectories
        if len(trajectories) > 1:
            blender = MotionBlender(self.blend_time)
            blended = trajectories[0]
            blend_samples = int(self.blend_time * 100)
            
            for i in range(1, len(trajectories)):
                blended = blender.blend_trajectories(blended, trajectories[i], blend_samples)
            
            print(f"    Blended {len(trajectories)} segments into {len(blended)} points")
            return blended
        elif trajectories:
            return trajectories[0]
        else:
            raise ValueError("No trajectories generated in blend")
        
def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
    """
    Calculate duration based on trajectory length and speed percentage.
    
    Args:
        trajectory_length: Total path length in mm
        speed_percentage: Speed as percentage (1-100)
        
    Returns:
        Duration in seconds
    """
    # Map speed percentage to mm/s (adjustable based on robot capabilities)
    # For example: 100% = 100mm/s, 50% = 50mm/s
    speed_mm_s = np.interp(speed_percentage, [0, 100], 
                          [PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000,
                           PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000])
    
    if speed_mm_s > 0:
        return trajectory_length / speed_mm_s
    else:
        return 5.0  # Default fallback
    
def parse_smooth_motion_commands(parts):
    """
    Parse smooth motion commands received via UDP and create appropriate command objects.
    All commands support:
    - Reference frame selection (WRF or TRF)
    - Optional start position (CURRENT or specified pose)
    - Both DURATION and SPEED timing modes
    
    Args:
        parts: List of command parts split by '|'
        
    Returns:
        Command object or None if parsing fails
    """
    command_type = parts[0]
    
    # Helper function for parsing optional start pose
    def parse_start_pose(start_str):
        """Parse start pose - returns None for CURRENT, or list of floats for specified pose."""
        if start_str == 'CURRENT' or start_str == 'NONE':
            return None
        else:
            try:
                return list(map(float, start_str.split(',')))
            except:
                print(f"Warning: Invalid start pose format: {start_str}")
                return None
    
    # Helper function for calculating duration from speed
    def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
        """Calculate duration based on trajectory length and speed percentage."""
        # Map speed percentage to mm/s
        min_speed = PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000  # Convert to mm/s
        max_speed = PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000  # Convert to mm/s
        speed_mm_s = np.interp(speed_percentage, [0, 100], [min_speed, max_speed])
        
        if speed_mm_s > 0:
            return trajectory_length / speed_mm_s
        else:
            return 5.0  # Default fallback
    
    try:
        if command_type == 'SMOOTH_CIRCLE':
            # Format: SMOOTH_CIRCLE|center_x,center_y,center_z|radius|plane|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            plane = parts[3]
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Circle circumference
                path_length = 2 * np.pi * radius
                duration = calculate_duration_from_speed(path_length, timing_value)
            
            print(f"  -> Parsed circle: r={radius}mm, plane={plane}, frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command object with frame parameter
            return SmoothCircleCommand(center, radius, plane, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_CENTER':
            # Format: SMOOTH_ARC_CENTER|end_pose|center|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            center = list(map(float, parts[2].split(',')))
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[6])
            clockwise = parts[7] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Estimate arc length (will be more accurate when we have actual positions)
                # Use a conservative estimate based on radius
                radius_estimate = np.linalg.norm(np.array(center) - np.array(end_pose[:3]))
                estimated_arc_angle = np.pi / 2  # 90 degrees estimate
                arc_length = radius_estimate * estimated_arc_angle
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (center): frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command with frame
            return SmoothArcCenterCommand(end_pose, center, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_PARAM':
            # Format: SMOOTH_ARC_PARAM|end_pose|radius|angle|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            arc_angle = float(parts[3])
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Arc length = radius * angle (in radians)
                arc_length = radius * np.deg2rad(arc_angle)
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (param): r={radius}mm, Î¸={arc_angle}Â°, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothArcParamCommand(end_pose, radius, arc_angle, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_SPLINE':
            # Format: SMOOTH_SPLINE|num_waypoints|frame|start_pose|timing_type|timing_value|waypoint1|waypoint2|...
            num_waypoints = int(parts[1])
            frame = parts[2]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[3])
            timing_type = parts[4]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[5])
            
            # Parse waypoints
            waypoints = []
            idx = 6
            for i in range(num_waypoints):
                wp = []
                for j in range(6):  # Each waypoint has 6 values (x,y,z,rx,ry,rz)
                    wp.append(float(parts[idx]))
                    idx += 1
                waypoints.append(wp)
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate total path length
                total_dist = 0
                for i in range(1, len(waypoints)):
                    dist = np.linalg.norm(np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3]))
                    total_dist += dist
                
                duration = calculate_duration_from_speed(total_dist, timing_value)
            
            print(f"  -> Parsed spline: {num_waypoints} points, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothSplineCommand(waypoints, duration, frame, start_pose)
            
        elif command_type == 'SMOOTH_HELIX':
            # Format: SMOOTH_HELIX|center|radius|pitch|height|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            pitch = float(parts[3])
            height = float(parts[4])
            frame = parts[5]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[6])
            timing_type = parts[7]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[8])
            clockwise = parts[9] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate helix path length
                num_revolutions = height / pitch if pitch > 0 else 1
                horizontal_length = 2 * np.pi * radius * num_revolutions
                helix_length = np.sqrt(horizontal_length**2 + height**2)
                duration = calculate_duration_from_speed(helix_length, timing_value)
            
            print(f"  -> Parsed helix: h={height}mm, pitch={pitch}mm, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothHelixCommand(center, radius, pitch, height, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_BLEND':
            # Format: SMOOTH_BLEND|num_segments|blend_time|frame|start_pose|timing_type|timing_value|segment1||segment2||...
            num_segments = int(parts[1])
            blend_time = float(parts[2])
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DEFAULT', 'DURATION', or 'SPEED'
            
            # Parse overall timing
            if timing_type == 'DEFAULT':
                # Use individual segment durations as-is
                overall_duration = None
                overall_speed = None
                segments_start_idx = 6
            else:
                timing_value = float(parts[6])
                if timing_type == 'DURATION':
                    overall_duration = timing_value
                    overall_speed = None
                else:  # SPEED
                    overall_speed = timing_value
                    overall_duration = None
                segments_start_idx = 7
            
            # Parse segments (separated by ||)
            segments_data = '|'.join(parts[segments_start_idx:])
            segment_strs = segments_data.split('||')
            
            # Parse segment definitions
            segment_definitions = []
            total_original_duration = 0
            total_estimated_length = 0
            
            for seg_str in segment_strs:
                if not seg_str:  # Skip empty segments
                    continue
                    
                seg_parts = seg_str.split('|')
                seg_type = seg_parts[0]
                
                if seg_type == 'LINE':
                    # Format: LINE|end_x,end_y,end_z,end_rx,end_ry,end_rz|duration
                    end = list(map(float, seg_parts[1].split(',')))
                    segment_duration = float(seg_parts[2])
                    total_original_duration += segment_duration
                    
                    # Estimate length (will be refined when we have actual start)
                    estimated_length = 100  # mm, conservative estimate
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'LINE',
                        'end': end,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
                    
                elif seg_type == 'CIRCLE':
                    # Format: CIRCLE|center_x,center_y,center_z|radius|plane|duration|clockwise
                    center = list(map(float, seg_parts[1].split(',')))
                    radius = float(seg_parts[2])
                    plane = seg_parts[3]
                    segment_duration = float(seg_parts[4])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[5] == '1'
                    
                    # Circle circumference
                    estimated_length = 2 * np.pi * radius
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'CIRCLE',
                        'center': center,
                        'radius': radius,
                        'plane': plane,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'ARC':
                    # Format: ARC|end_x,end_y,end_z,end_rx,end_ry,end_rz|center_x,center_y,center_z|duration|clockwise
                    end = list(map(float, seg_parts[1].split(',')))
                    center = list(map(float, seg_parts[2].split(',')))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[4] == '1'
                    
                    # Estimate arc length
                    estimated_radius = 50  # mm
                    estimated_arc_angle = np.pi / 2  # 90 degrees
                    estimated_length = estimated_radius * estimated_arc_angle
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'ARC',
                        'end': end,
                        'center': center,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'SPLINE':
                    # Format: SPLINE|num_points|waypoint1;waypoint2;...|duration
                    num_points = int(seg_parts[1])
                    waypoints = []
                    wp_strs = seg_parts[2].split(';')
                    for wp_str in wp_strs:
                        waypoints.append(list(map(float, wp_str.split(','))))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    
                    # Estimate spline length
                    estimated_length = 0
                    for i in range(1, len(waypoints)):
                        estimated_length += np.linalg.norm(
                            np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3])
                        )
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'SPLINE',
                        'waypoints': waypoints,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
            
            # Adjust segment durations if overall timing is specified
            if overall_duration is not None:
                # Scale all segment durations proportionally
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Scaled blend segments to total duration: {overall_duration:.2f}s")
                        
            elif overall_speed is not None:
                # Calculate duration from speed and estimated path length
                overall_duration = calculate_duration_from_speed(total_estimated_length, overall_speed)
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Calculated blend duration from speed: {overall_duration:.2f}s")
            else:
                print(f"  -> Using original segment durations (total: {total_original_duration:.2f}s)")
            
            print(f"  -> Parsed blend: {num_segments} segments, frame={frame}, blend_time={blend_time}s")
            
            # Return command with frame
            return SmoothBlendCommand(segment_definitions, blend_time, frame, start_pose)
            
    except Exception as e:
        print(f"Error parsing smooth motion command: {e}")
        print(f"Command parts: {parts}")
        import traceback
        traceback.print_exc()
        return None
    
    print(f"Warning: Unknown smooth motion command type: {command_type}")
    return None

def transform_command_params_to_wrf(command_type: str, params: dict, frame: str, current_position_in) -> dict:
    """
    Transform command parameters from TRF to WRF.
    Handles position, orientation, and directional vectors correctly.
    """
    if frame == 'WRF':
        return params
    
    # Get current tool pose
    current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                         for i, p in enumerate(current_position_in)])
    tool_pose = PAROL6_ROBOT.robot.fkine(current_q)
    
    transformed = params.copy()
    
    # SMOOTH_CIRCLE - Transform center and plane normal
    if command_type == 'SMOOTH_CIRCLE':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'plane' in params:
            plane_normals_trf = {
                'XY': [0, 0, 1],   # Tool's Z-axis
                'XZ': [0, 1, 0],   # Tool's Y-axis  
                'YZ': [1, 0, 0]    # Tool's X-axis
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
            print(f"  -> TRF circle plane {params['plane']} transformed to WRF")
    
    # SMOOTH_ARC_CENTER - Transform center, end_pose, and implied plane
    elif command_type == 'SMOOTH_ARC_CENTER':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # Arc plane is determined by start, end, and center points
        # But we should transform any specified plane normal
        if 'plane' in params:
            # Similar to circle plane transformation
            plane_normals_trf = {
                'XY': [0, 0, 1],
                'XZ': [0, 1, 0],
                'YZ': [1, 0, 0]
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_ARC_PARAM - Transform end_pose and arc plane
    elif command_type == 'SMOOTH_ARC_PARAM':
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # For parametric arc, the plane is usually XY of the tool
        # Transform the assumed plane normal
        if 'plane' not in params:
            params['plane'] = 'XY'  # Default to XY plane
        
        plane_normals_trf = {
            'XY': [0, 0, 1],
            'XZ': [0, 1, 0],
            'YZ': [1, 0, 0]
        }
        normal_trf = np.array(plane_normals_trf[params.get('plane', 'XY')])
        normal_wrf = tool_pose.R @ normal_trf
        transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_HELIX - Transform center and helix axis
    elif command_type == 'SMOOTH_HELIX':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        # Helix axis - default is Z-axis (vertical in TRF)
        # In TRF, helix rises along tool's Z-axis
        helix_axis_trf = np.array([0, 0, 1])  # Tool's Z-axis
        helix_axis_wrf = tool_pose.R @ helix_axis_trf
        transformed['helix_axis'] = helix_axis_wrf.tolist()
        
        # Also need to transform the "up" direction for proper orientation
        up_vector_trf = np.array([0, 1, 0])  # Tool's Y-axis
        up_vector_wrf = tool_pose.R @ up_vector_trf
        transformed['up_vector'] = up_vector_wrf.tolist()
    
    # SMOOTH_SPLINE - Transform all waypoints
    elif command_type == 'SMOOTH_SPLINE':
        if 'waypoints' in params:
            transformed_waypoints = []
            for wp in params['waypoints']:
                wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                         SE3.RPY(wp[3:], unit='deg', order='xyz')
                wp_wrf = tool_pose * wp_trf
                wp_transformed = np.concatenate([
                    wp_wrf.t * 1000,
                    wp_wrf.rpy(unit='deg', order='xyz')
                ]).tolist()
                transformed_waypoints.append(wp_transformed)
            transformed['waypoints'] = transformed_waypoints
    
    # SMOOTH_BLEND - Transform all segments recursively
    elif command_type == 'SMOOTH_BLEND':
        if 'segments' in params:
            transformed_segments = []
            for seg in params['segments']:
                seg_copy = seg.copy()
                seg_type = seg['type']
                
                if seg_type == 'LINE':
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'CIRCLE':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'plane' in seg:
                        plane_normals_trf = {
                            'XY': [0, 0, 1],
                            'XZ': [0, 1, 0],
                            'YZ': [1, 0, 0]
                        }
                        normal_trf = np.array(plane_normals_trf[seg['plane']])
                        normal_wrf = tool_pose.R @ normal_trf
                        seg_copy['normal_vector'] = normal_wrf.tolist()
                
                elif seg_type == 'ARC':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'SPLINE':
                    if 'waypoints' in seg:
                        transformed_waypoints = []
                        for wp in seg['waypoints']:
                            wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                                     SE3.RPY(wp[3:], unit='deg', order='xyz')
                            wp_wrf = tool_pose * wp_trf
                            wp_transformed = np.concatenate([
                                wp_wrf.t * 1000,
                                wp_wrf.rpy(unit='deg', order='xyz')
                            ]).tolist()
                            transformed_waypoints.append(wp_transformed)
                        seg_copy['waypoints'] = transformed_waypoints
                
                transformed_segments.append(seg_copy)
            transformed['segments'] = transformed_segments
    
    # Transform start_pose if specified (common to all commands)
    if 'start_pose' in params and params['start_pose'] is not None:
        start_trf = SE3(params['start_pose'][0]/1000, 
                       params['start_pose'][1]/1000, 
                       params['start_pose'][2]/1000) * \
                    SE3.RPY(params['start_pose'][3:], unit='deg', order='xyz')
        start_wrf = tool_pose * start_trf
        transformed['start_pose'] = np.concatenate([
            start_wrf.t * 1000,
            start_wrf.rpy(unit='deg', order='xyz')
        ]).tolist()
    
    return transformed

#########################################################################
# Smooth Motion Commands and Robot Commands End Here
#########################################################################

# Acknowledgment system configuration
CLIENT_ACK_PORT = 5002  # Port where clients listen for acknowledgments
ack_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Command tracking
active_command_id = None
command_id_map = {}  # Maps command objects to their IDs

def send_acknowledgment(cmd_id: str, status: str, details: str = "", addr=None):
    """Send acknowledgment back to client"""
    if not cmd_id:
        return
        
    ack_message = f"ACK|{cmd_id}|{status}|{details}"
    
    # Send to the original sender if we have their address
    if addr:
        try:
            ack_socket.sendto(ack_message.encode('utf-8'), (addr[0], CLIENT_ACK_PORT))
        except Exception as e:
            print(f"Failed to send ack to {addr}: {e}")
    
    # Also broadcast to localhost in case the client is local
    try:
        ack_socket.sendto(ack_message.encode('utf-8'), ('127.0.0.1', CLIENT_ACK_PORT))
    except:
        pass

def parse_command_with_id(message: str) -> Tuple[Optional[str], str]:
    """
    Parse command ID if present.
    Format: [cmd_id|]COMMAND|params...
    Returns: (cmd_id or None, command_string)
    """
    # Clean up any logging artifacts
    if "ID:" in message or "):" in message:
        # Extract the actual command after these artifacts
        if "):" in message:
            message = message[message.rindex("):")+2:].strip()
        elif "ID:" in message:
            message = message[message.index("ID:")+3:].strip()
            # Remove any trailing parentheses or colons
            message = message.lstrip('):').strip()
    
    parts = message.split('|', 1)
    
    # Check if first part looks like a valid command ID (8 chars, alphanumeric)
    # IMPORTANT: Command IDs from uuid.uuid4()[:8] will contain lowercase letters/numbers
    # Actual commands are all uppercase, so exclude all-uppercase strings
    if (len(parts) > 1 and 
        len(parts[0]) == 8 and 
        parts[0].replace('-', '').isalnum() and 
        not parts[0].isupper()):  # This prevents "MOVEPOSE" from being treated as an ID
        return parts[0], parts[1]
    else:
        return None, message


# Create a new, empty command queue
command_queue = deque()

# --------------------------------------------------------------------------
# --- Test 1: Homing and Initial Setup
# --------------------------------------------------------------------------

# 1. Start with the mandatory Home command.
command_queue.append(HomeCommand())

# --- State variable for the currently running command ---
active_command = None
e_stop_active = False

# Use deque for an efficient FIFO queue
incoming_command_buffer = deque()
# Timestamp of the last processed network command
last_command_time = 0
# Cooldown period in seconds to prevent command flooding
COMMAND_COOLDOWN_S = 0.1 # 100ms

# Set interval
timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)

# ============================================================================
# MODIFIED MAIN LOOP WITH ACKNOWLEDGMENTS
# ============================================================================

timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)
prev_time = 0

while timer.elapsed_time < 1100000:
    
    # --- Connection Handling ---
    if ser is None or not ser.is_open:
        print("Serial port not open. Attempting to reconnect...")
        try:
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            if ser.is_open:
                print(f"Successfully reconnected to {com_port_str}")
        except serial.SerialException as e:
            ser = None
            time.sleep(1) 
        continue

    # =======================================================================
    # === NETWORK COMMAND RECEPTION WITH ID PARSING ===
    # =======================================================================
    try:
        while sock in select.select([sock], [], [], 0)[0]:
            data, addr = sock.recvfrom(1024)
            raw_message = data.decode('utf-8').strip()
            if raw_message:
                # Parse command ID if present
                cmd_id, message = parse_command_with_id(raw_message)
                
                parts = message.split('|')
                command_name = parts[0].upper()

                # Handle immediate response commands
                if command_name == 'STOP':
                    print("Received STOP command. Halting all motion and clearing queue.")
                    
                    # Cancel active command
                    if active_command and active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "Stopped by user", addr)
                    active_command = None
                    active_command_id = None
                    
                    # Clear queue and notify about cancelled commands
                    for queued_cmd in command_id_map.keys():
                        if queued_cmd != active_command:
                            if queued_cmd in command_id_map:
                                send_acknowledgment(command_id_map[queued_cmd], 
                                                  "CANCELLED", "Queue cleared by STOP", addr)
                    
                    command_queue.clear()
                    command_id_map.clear()
                    
                    # Stop robot
                    Command_out.value = 255
                    Speed_out[:] = [0] * 6
                    
                    # Send acknowledgment for STOP command itself
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Emergency stop executed", addr)

                elif command_name == 'GET_POSE':
                    q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
                    current_pose_matrix = PAROL6_ROBOT.robot.fkine(q_current).A
                    pose_flat = current_pose_matrix.flatten()
                    pose_str = ",".join(map(str, pose_flat))
                    response_message = f"POSE|{pose_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Pose data sent", addr)

                elif command_name == 'GET_ANGLES':
                    angles_rad = [PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)]
                    angles_deg = np.rad2deg(angles_rad)
                    angles_str = ",".join(map(str, angles_deg))
                    response_message = f"ANGLES|{angles_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Angles data sent", addr)

                elif command_name == 'GET_IO':
                    io_status_str = ",".join(map(str, InOut_in[:5]))
                    response_message = f"IO|{io_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "IO data sent", addr)

                elif command_name == 'GET_GRIPPER':
                    gripper_status_str = ",".join(map(str, Gripper_data_in))
                    response_message = f"GRIPPER|{gripper_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Gripper data sent", addr)

                elif command_name == 'GET_SPEEDS':
                    speeds_str = ",".join(map(str, Speed_in))
                    response_message = f"SPEEDS|{speeds_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Speed data sent", addr)

                else:
                    # Queue command for processing
                    incoming_command_buffer.append((raw_message, addr))

    except Exception as e:
        print(f"Network receive error: {e}")

    # =======================================================================
    # === PROCESS COMMANDS FROM BUFFER WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    current_time = time.time()
    if incoming_command_buffer and (current_time - last_command_time) > COMMAND_COOLDOWN_S and not e_stop_active:
        raw_message, addr = incoming_command_buffer.popleft()
        last_command_time = current_time
        
        # Parse command ID
        cmd_id, message = parse_command_with_id(raw_message)
        print(f"Processing command{' (ID: ' + cmd_id + ')' if cmd_id else ''}: {message[:50]}...")
        
        parts = message.split('|')
        command_name = parts[0].upper()
        
        # Variable to track if command was successfully queued
        command_queued = False
        command_obj = None
        error_details = ""

        # Parse and create command objects
        try:
            if command_name == 'MOVEPOSE' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MovePoseCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
                
            elif command_name == 'MOVEJOINT' and len(parts) == 9:
                joint_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveJointCommand(target_angles=joint_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name in ['SMOOTH_CIRCLE', 'SMOOTH_ARC_CENTER', 'SMOOTH_ARC_PARAM', 
                                 'SMOOTH_SPLINE', 'SMOOTH_HELIX', 'SMOOTH_BLEND']:
                command_obj = parse_smooth_motion_commands(parts)
                if command_obj:
                    command_queued = True
                else:
                    error_details = "Failed to parse smooth motion parameters"
            
            elif command_name == 'MOVECART' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveCartCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name == 'DELAY' and len(parts) == 2:
                duration = float(parts[1])
                command_obj = DelayCommand(duration=duration)
                command_queued = True
            
            elif command_name == 'HOME':
                command_obj = HomeCommand()
                command_queued = True
                
            elif command_name == 'CARTJOG' and len(parts) == 5:
                frame, axis, speed, duration = parts[1].upper(), parts[2], float(parts[3]), float(parts[4])
                command_obj = CartesianJogCommand(frame=frame, axis=axis, speed_percentage=speed, duration=duration)
                command_queued = True
                
            elif command_name == 'JOG' and len(parts) == 5:
                joint_idx, speed = int(parts[1]), float(parts[2])
                duration = None if parts[3].upper() == 'NONE' else float(parts[3])
                distance = None if parts[4].upper() == 'NONE' else float(parts[4])
                command_obj = JogCommand(joint=joint_idx, speed_percentage=speed, duration=duration, distance_deg=distance)
                command_queued = True
            
            elif command_name == 'MULTIJOG' and len(parts) == 4:
                joint_indices = [int(j) for j in parts[1].split(',')]
                speeds = [float(s) for s in parts[2].split(',')]
                duration = float(parts[3])
                command_obj = MultiJogCommand(joints=joint_indices, speed_percentages=speeds, duration=duration)
                command_queued = True
                
            elif command_name == 'PNEUMATICGRIPPER' and len(parts) == 3:
                action, port = parts[1].lower(), int(parts[2])
                command_obj = GripperCommand(gripper_type='pneumatic', action=action, output_port=port)
                command_queued = True
                
            elif command_name == 'ELECTRICGRIPPER' and len(parts) == 5:
                action = None if parts[1].upper() == 'NONE' or parts[1].upper() == 'MOVE' else parts[1].lower()
                pos, spd, curr = int(parts[2]), int(parts[3]), int(parts[4])
                command_obj = GripperCommand(gripper_type='electric', action=action, position=pos, speed=spd, current=curr)
                command_queued = True
            
            else:
                error_details = f"Unknown or malformed command: {command_name}"
                
        except Exception as e:
            error_details = f"Error parsing command: {str(e)}"
            command_queued = False
        
        # Handle command queueing and acknowledgments
        if command_queued and command_obj:
            # Check if command is initially valid
            if hasattr(command_obj, 'is_valid') and not command_obj.is_valid:
                if cmd_id:
                    send_acknowledgment(cmd_id, "INVALID", 
                                       "Command failed validation", addr)
            else:
                # Add to queue
                command_queue.append(command_obj)
                if cmd_id:
                    command_id_map[command_obj] = (cmd_id, addr)
                    send_acknowledgment(cmd_id, "QUEUED", 
                                       f"Position {len(command_queue)} in queue", addr)
        else:
            # Command was not queued
            if cmd_id:
                send_acknowledgment(cmd_id, "INVALID", error_details, addr)
            print(f"Warning: {error_details}")

    # =======================================================================
    # === MAIN EXECUTION LOGIC WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    try:
        # --- E-Stop Handling ---
        if InOut_in[4] == 0:  # E-Stop pressed
            if not e_stop_active:
                cancelled_command_info = "None"
                if active_command is not None:
                    cancelled_command_info = type(active_command).__name__
                    if active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "E-Stop activated")
                
                # Cancel all queued commands
                for cmd_obj in command_queue:
                    if cmd_obj in command_id_map:
                        cmd_id, addr = command_id_map[cmd_obj]
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated", addr)
                
                # Cancel all buffered but unprocessed commands
                for raw_message, addr in incoming_command_buffer:
                    cmd_id, _ = parse_command_with_id(raw_message)
                    if cmd_id:
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated - command not processed", addr)
                
                print(f"E-STOP TRIGGERED! Active command '{cancelled_command_info}' cancelled.")
                print("Release E-Stop and press 'e' to re-enable.")
                e_stop_active = True
            
            Command_out.value = 102
            Speed_out[:] = [0] * 6
            Gripper_data_out[3] = 0
            active_command = None
            active_command_id = None
            command_queue.clear()
            command_id_map.clear()
            incoming_command_buffer.clear()
            
        elif e_stop_active:
            # Waiting for re-enable
            if keyboard.is_pressed('e'):
                print("Re-enabling robot...")
                Command_out.value = 101
                e_stop_active = False
            else:
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]
                
        else:
            # --- Normal Command Processing ---
            
            # Start new command if none active
            if active_command is None and command_queue:
                new_command = command_queue.popleft()
                
                # Get command ID and address if tracked
                cmd_info = command_id_map.get(new_command, (None, None))
                new_cmd_id, new_addr = cmd_info
                
                # Initial validation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Command was invalid from the start
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "INVALID", 
                                        "Initial validation failed", new_addr)
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                    continue  # Skip to next command
                
                # Prepare command
                if hasattr(new_command, 'prepare_for_execution'):
                    try:
                        new_command.prepare_for_execution(current_position_in=Position_in)
                    except Exception as e:
                        print(f"Command preparation failed: {e}")
                        if hasattr(new_command, 'is_valid'):
                            new_command.is_valid = False
                        if hasattr(new_command, 'error_message'):
                            new_command.error_message = str(e)
                
                # Check if still valid after preparation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Failed during preparation
                    error_msg = "Failed during preparation"
                    if hasattr(new_command, 'error_message'):
                        error_msg = new_command.error_message
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "FAILED", error_msg, new_addr)
                    
                    # Clean up
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                else:
                    # Command is valid, make it active
                    active_command = new_command
                    active_command_id = new_cmd_id
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "EXECUTING", 
                                        f"Starting {type(new_command).__name__}", new_addr)
            
            # Execute active command
            if active_command:
                try:
                    is_done = active_command.execute_step(
                        Position_in=Position_in,
                        Homed_in=Homed_in,
                        Speed_out=Speed_out,
                        Command_out=Command_out,
                        Gripper_data_out=Gripper_data_out,
                        InOut_out=InOut_out,
                        InOut_in=InOut_in,
                        Gripper_data_in=Gripper_data_in,
                        Position_out=Position_out  # Add this if needed
                    )
                    
                    if is_done:
                        # Command completed
                        if active_command_id:
                            # Check for error state in smooth motion commands
                            if hasattr(active_command, 'error_state') and active_command.error_state:
                                error_msg = getattr(active_command, 'error_message', 'Command failed during execution')
                                send_acknowledgment(active_command_id, "FAILED", error_msg)
                            else:
                                send_acknowledgment(active_command_id, "COMPLETED", 
                                                f"{type(active_command).__name__} finished successfully")
                        
                        # Clean up
                        if active_command in command_id_map:
                            del command_id_map[active_command]
                        
                        active_command = None
                        active_command_id = None
                        
                except Exception as e:
                    # Command execution error
                    print(f"Command execution error: {e}")
                    if active_command_id:
                        send_acknowledgment(active_command_id, "FAILED", 
                                          f"Execution error: {str(e)}")
                    
                    # Clean up
                    if active_command in command_id_map:
                        del command_id_map[active_command]
                    
                    active_command = None
                    active_command_id = None
                    
            else:
                # No active command - idle
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]

        # --- Communication with Robot ---
        s = Pack_data(Position_out, Speed_out, Command_out.value, 
                     Affected_joint_out, InOut_out, Timeout_out, Gripper_data_out)
        for chunk in s:
            ser.write(chunk)
            
        Get_data(Position_in, Speed_in, Homed_in, InOut_in, Temperature_error_in, 
                Position_error_in, Timeout_error, Timing_data_in, XTR_data, Gripper_data_in)

    except serial.SerialException as e:
        print(f"Serial communication error: {e}")
        
        # Send failure acknowledgments for active command
        if active_command_id:
            send_acknowledgment(active_command_id, "FAILED", "Serial communication lost")
        
        if ser:
            ser.close()
        ser = None
        active_command = None
        active_command_id = None

    timer.checkpt()
````

## File: LICENSE
````
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
````

## File: linux_serial_patch.py
````python
else:
    # Linux/Mac system
    # Try to read the serial port from a file
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved serial port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        # If the file doesn't exist or the port is invalid, try default ports
        default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
        ser = None
        for port in default_ports:
            try:
                ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                print(f"Successfully connected to {port}")
                # Save the successful port to the file
                with open("com_port.txt", "w") as f:
                    f.write(port)
                break
            except serial.SerialException:
                continue
        
        if ser is None:
            print("Could not find any available serial ports.")
            import serial.tools.list_ports
            ports = serial.tools.list_ports.comports()
            if ports:
                print("Available ports:")
                for port in ports:
                    print(f"  {port.device}")
            
            while True:
                try:
                    com_port = input("Enter the serial port (e.g., /dev/ttyACM0): ")
                    ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                    print(f"Successfully connected to {com_port}")
                    # Save the successful port to the file
                    with open("com_port.txt", "w") as f:
                        f.write(com_port)
                    break
                except serial.SerialException:
                    print(f"Could not open port {com_port}. Please try again.")
````

## File: parol6_controller.py
````python
#!/usr/bin/env python3
"""
PAROL6 æœºæ¢°è‡‚æ§åˆ¶å™¨ - å®Œæ•´ç‰ˆæœ¬
åŒ…å«ä¸²å£é€šä¿¡ä¿®å¤å’ŒROS2æ¥å£å‡†å¤‡
"""
import os
import sys
import platform
import serial
import serial.tools.list_ports
import time
import threading
import numpy as np
from typing import Optional, List, Tuple
import logging

# è®¾ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class PAROL6Controller:
    """PAROL6æœºæ¢°è‡‚æ§åˆ¶å™¨ç±»"""
    
    def __init__(self, port: Optional[str] = None, baudrate: int = 3000000):
        """
        åˆå§‹åŒ–PAROL6æ§åˆ¶å™¨
        
        Args:
            port: ä¸²å£ç«¯å£å·ï¼Œå¦‚æœä¸ºNoneåˆ™è‡ªåŠ¨æ£€æµ‹
            baudrate: æ³¢ç‰¹ç‡ï¼Œé»˜è®¤3000000
        """
        self.ser = None
        self.com_port_str = port
        self.baudrate = baudrate
        self.is_connected = False
        self.lock = threading.Lock()
        
        # æœºæ¢°è‡‚å‚æ•°
        self.num_joints = 6
        self.joint_limits = [
            (-170, 170),  # Joint 1
            (-120, 120),  # Joint 2
            (-145, 145),  # Joint 3
            (-180, 180),  # Joint 4
            (-120, 120),  # Joint 5
            (-360, 360),  # Joint 6
        ]
        
        # åˆå§‹åŒ–è¿æ¥
        self.connect()

    
    def connect(self) -> bool:
        """è¿æ¥åˆ°PAROL6æœºæ¢°è‡‚"""
        logger.info("ğŸ”§ æ­£åœ¨è¿æ¥PAROL6æœºæ¢°è‡‚...")
        
        # å¦‚æœå·²æŒ‡å®šç«¯å£ï¼Œç›´æ¥å°è¯•è¿æ¥
        if self.com_port_str:
            if self._try_connect(self.com_port_str):
                return True
        
        # å°è¯•ä»é…ç½®æ–‡ä»¶è¯»å–
        try:
            with open("com_port.txt", "r") as f:
                saved_port = f.read().strip()
                if self._try_connect(saved_port):
                    self.com_port_str = saved_port
                    return True
        except FileNotFoundError:
            pass
        
        # è‡ªåŠ¨æ£€æµ‹ç«¯å£
        return self._auto_detect_port()
    
    def _try_connect(self, port: str) -> bool:
        """å°è¯•è¿æ¥æŒ‡å®šç«¯å£"""
        if not os.path.exists(port):
            logger.warning(f"ç«¯å£ {port} ä¸å­˜åœ¨")
            return False
            
        try:
            self.ser = serial.Serial(
                port=port,
                baudrate=self.baudrate,
                timeout=0.1,
                write_timeout=0.1
            )
            self.is_connected = True
            logger.info(f"âœ… æˆåŠŸè¿æ¥åˆ° {port}")
            
            # ä¿å­˜æˆåŠŸçš„ç«¯å£
            with open("com_port.txt", "w") as f:
                f.write(port)
            
            # å‘é€åˆå§‹åŒ–å‘½ä»¤æµ‹è¯•è¿æ¥
            time.sleep(2)  # ç­‰å¾…è®¾å¤‡å‡†å¤‡
            if self._test_connection():
                return True
            else:
                logger.warning(f"è®¾å¤‡åœ¨ {port} æ— å“åº”")
                self.disconnect()
                return False
                
        except serial.SerialException as e:
            logger.error(f"è¿æ¥ {port} å¤±è´¥: {e}")
            return False

    
    def _auto_detect_port(self) -> bool:
        """è‡ªåŠ¨æ£€æµ‹ä¸²å£"""
        logger.info("ğŸ” è‡ªåŠ¨æ£€æµ‹ä¸²å£...")
        
        # é»˜è®¤ç«¯å£åˆ—è¡¨
        default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
        
        # å°è¯•é»˜è®¤ç«¯å£
        for port in default_ports:
            if self._try_connect(port):
                self.com_port_str = port
                return True
        
        # åˆ—å‡ºæ‰€æœ‰å¯ç”¨ä¸²å£
        ports = serial.tools.list_ports.comports()
        for port in ports:
            logger.info(f"ğŸ“¡ å‘ç°ç«¯å£: {port.device} - {port.description}")
            if "ACM" in port.device or "USB" in port.device:
                if self._try_connect(port.device):
                    self.com_port_str = port.device
                    return True
        
        logger.error("âŒ æœªæ‰¾åˆ°å¯ç”¨çš„ä¸²å£")
        return False
    
    def _test_connection(self) -> bool:
        """æµ‹è¯•ä¸æœºæ¢°è‡‚çš„è¿æ¥"""
        try:
            # å‘é€æµ‹è¯•å‘½ä»¤ï¼ˆæ ¹æ®PAROL6åè®®è°ƒæ•´ï¼‰
            self.ser.write(b"READY\n")
            time.sleep(0.1)
            if self.ser.in_waiting > 0:
                response = self.ser.read(self.ser.in_waiting)
                logger.debug(f"æ”¶åˆ°å“åº”: {response}")
                return True
            return False
        except Exception as e:
            logger.error(f"æµ‹è¯•è¿æ¥å¤±è´¥: {e}")
            return False
    
    def disconnect(self):
        """æ–­å¼€ä¸æœºæ¢°è‡‚çš„è¿æ¥"""
        if self.ser and self.ser.is_open:
            self.ser.close()
            self.is_connected = False
            logger.info("ğŸ”Œ å·²æ–­å¼€è¿æ¥")
````

## File: parol6_ik_fix.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 ä¸“ç”¨ ikine_LM æµ‹è¯•å’Œä¿®å¤ç¨‹åº
åŸºäºç¡®è®¤å¯ç”¨çš„ ikine_LM æ–¹æ³•
"""
import sys
import os

# è·å–å½“å‰æ–‡ä»¶çš„ç»å¯¹è·¯å¾„
current_dir = os.path.dirname(os.path.abspath(__file__))

# è·å–çˆ¶ç›®å½•è·¯å¾„
parent_dir = os.path.dirname(current_dir)

# å°†çˆ¶ç›®å½•æ·»åŠ åˆ°æ¨¡å—æœç´¢è·¯å¾„ä¸­
sys.path.append(parent_dir)

# ç°åœ¨å¯ä»¥å¯¼å…¥çˆ¶ç›®å½•ä¸­çš„æ¨¡å—
from robot_api import *
import numpy as np
import time
import os
import shutil
from robot_api import *

# å°è¯•å¯¼å…¥PAROL6æ¨¡å‹
try:
    from PAROL6_ROBOT import PAROL6_ROBOT
    import spatialmath as sm
    PAROL_AVAILABLE = True
    print("âœ… PAROL6 æ¨¡å‹å’Œspatialmathå¯ç”¨")
except ImportError as e:
    PAROL_AVAILABLE = False
    print(f"âŒ å¯¼å…¥å¤±è´¥: {e}")

class PAROL6_IK_Fixer:
    def __init__(self):
        """åˆå§‹åŒ–PAROL6 IKä¿®å¤å™¨"""
        self.robot = None
        self.current_pose = None
        self.current_joints = None
        
        print("ğŸ”§ PAROL6 é€†è¿åŠ¨å­¦ä¿®å¤å·¥å…·")
        print("åŸºäºç¡®è®¤å¯ç”¨çš„ ikine_LM æ–¹æ³•")

    def test_parol6_ik(self):
        """æµ‹è¯•PAROL6æœºå™¨äººçš„é€†è¿åŠ¨å­¦"""
        print("\n" + "="*50)
        print("ğŸ§ª æµ‹è¯•PAROL6æœºå™¨äººé€†è¿åŠ¨å­¦")
        print("="*50)
        
        if not PAROL_AVAILABLE:
            print("âŒ æ— æ³•å¯¼å…¥PAROL6æ¨¡å‹ï¼Œè·³è¿‡IKæµ‹è¯•")
            return False
        
        try:
            # åˆå§‹åŒ–PAROL6æœºå™¨äºº
            self.robot = PAROL6_ROBOT()
            print("âœ… PAROL6æœºå™¨äººæ¨¡å‹åˆå§‹åŒ–æˆåŠŸ")
            
            # è·å–å½“å‰æœºå™¨äººçŠ¶æ€
            self.current_pose = get_robot_pose()
            self.current_joints = get_robot_joint_angles()
            
            if not self.current_pose or not self.current_joints:
                print("âŒ æ— æ³•è·å–æœºå™¨äººå½“å‰çŠ¶æ€")
                return False
            
            print(f"ğŸ“ å½“å‰ä½å§¿: {[round(p, 2) for p in self.current_pose]}")
            print(f"ğŸ”§ å½“å‰å…³èŠ‚: {[round(a, 2) for a in self.current_joints]}")
            
            # è½¬æ¢å½“å‰å…³èŠ‚è§’åº¦åˆ°å¼§åº¦
            q_current = np.radians(self.current_joints)
            
            # è®¡ç®—å½“å‰ä½å§¿çš„å˜æ¢çŸ©é˜µ
            T_current = self.robot.fkine(q_current)
            print("âœ… æ­£è¿åŠ¨å­¦è®¡ç®—æˆåŠŸ")
            
            # åˆ›å»ºæµ‹è¯•ç›®æ ‡ï¼ˆå°åç§»ï¼‰
            T_target = T_current * sm.SE3.Tx(0.02) * sm.SE3.Ty(0.02) * sm.SE3.Tz(0.01)
            print("ğŸ¯ æµ‹è¯•ç›®æ ‡ï¼šå½“å‰ä½ç½® + (20mm, 20mm, 10mm)")
            
            # æµ‹è¯• ikine_LM
            print("\nğŸ” æµ‹è¯• ikine_LM æ±‚è§£å™¨...")
            start_time = time.time()
            
            sol = self.robot.ikine_LM(T_target, q0=q_current)
            
            solve_time = time.time() - start_time
            
            if sol.success:
                print(f"âœ… ikine_LM æ±‚è§£æˆåŠŸï¼(è€—æ—¶: {solve_time:.3f}s)")
                solution_deg = np.degrees(sol.q)
                print(f"ğŸ¯ è§£ï¼ˆåº¦ï¼‰: {solution_deg.round(2)}")
                
                # éªŒè¯è§£çš„ç²¾åº¦
                T_verify = self.robot.fkine(sol.q)
                pos_error = np.linalg.norm(T_target.t - T_verify.t)
                print(f"ğŸ“ ä½ç½®è¯¯å·®: {pos_error*1000:.3f}mm")
                
                if pos_error < 0.001:  # 1mmç²¾åº¦
                    print("âœ… è§£éªŒè¯é€šè¿‡ï¼Œç²¾åº¦è‰¯å¥½")
                    return True
                else:
                    print("âš ï¸ è§£ç²¾åº¦è¾ƒä½ï¼Œä½†å¯ç”¨")
                    return True
            else:
                print(f"âŒ ikine_LM æ±‚è§£å¤±è´¥: {sol.reason}")
                return False
                
        except Exception as e:
            print(f"âŒ æµ‹è¯•è¿‡ç¨‹å‡ºé”™: {e}")
            return False

    def find_files_to_fix(self):
        """æŸ¥æ‰¾éœ€è¦ä¿®å¤çš„æ–‡ä»¶"""
        print("\n" + "="*50)
        print("ğŸ” æŸ¥æ‰¾éœ€è¦ä¿®å¤çš„æ–‡ä»¶")
        print("="*50)
        
        files_to_check = [
            "headless_commander.py",
            "PAROL6_ROBOT.py",
            "smooth_motion.py"
        ]
        
        files_needing_fix = []
        
        for filename in files_to_check:
            if os.path.exists(filename):
                try:
                    with open(filename, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    ikine_lms_count = content.count('ikine_LMS')
                    if ikine_lms_count > 0:
                        print(f"ğŸ“„ {filename}: å‘ç° {ikine_lms_count} ä¸ª 'ikine_LMS'")
                        files_needing_fix.append((filename, ikine_lms_count))
                        
                        # æ˜¾ç¤ºå…·ä½“ä½ç½®
                        lines = content.split('\n')
                        for i, line in enumerate(lines, 1):
                            if 'ikine_LMS' in line:
                                print(f"   è¡Œ {i}: {line.strip()}")
                    else:
                        print(f"ğŸ“„ {filename}: æ— éœ€ä¿®å¤")
                        
                except Exception as e:
                    print(f"ğŸ“„ {filename}: è¯»å–å¤±è´¥ - {e}")
            else:
                print(f"ğŸ“„ {filename}: æ–‡ä»¶ä¸å­˜åœ¨")
        
        return files_needing_fix

    def backup_and_fix_file(self, filename):
        """å¤‡ä»½å¹¶ä¿®å¤å•ä¸ªæ–‡ä»¶"""
        try:
            # è¯»å–åŸæ–‡ä»¶
            with open(filename, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿®å¤
            if 'ikine_LMS' not in original_content:
                print(f"ğŸ“„ {filename}: æ— éœ€ä¿®å¤")
                return True
            
            # åˆ›å»ºå¤‡ä»½
            backup_filename = f"{filename}.backup_{int(time.time())}"
            shutil.copy2(filename, backup_filename)
            print(f"ğŸ’¾ {filename}: å·²å¤‡ä»½åˆ° {backup_filename}")
            
            # æ‰§è¡Œæ›¿æ¢
            fixed_content = original_content.replace('ikine_LMS', 'ikine_LM')
            replacement_count = original_content.count('ikine_LMS')
            
            # å†™å…¥ä¿®å¤åçš„å†…å®¹
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(fixed_content)
            
            print(f"âœ… {filename}: æ›¿æ¢äº† {replacement_count} å¤„ 'ikine_LMS' -> 'ikine_LM'")
            return True
            
        except Exception as e:
            print(f"âŒ {filename}: ä¿®å¤å¤±è´¥ - {e}")
            return False

    def fix_all_files(self, files_needing_fix):
        """ä¿®å¤æ‰€æœ‰éœ€è¦çš„æ–‡ä»¶"""
        print("\n" + "="*50)
        print("ğŸ”§ å¼€å§‹ä¿®å¤æ–‡ä»¶")
        print("="*50)
        
        if not files_needing_fix:
            print("ğŸ‰ æ²¡æœ‰æ–‡ä»¶éœ€è¦ä¿®å¤ï¼")
            return True
        
        success_count = 0
        total_replacements = 0
        
        for filename, count in files_needing_fix:
            print(f"\nğŸ”§ ä¿®å¤ {filename}...")
            if self.backup_and_fix_file(filename):
                success_count += 1
                total_replacements += count
            
        print(f"\nğŸ“Š ä¿®å¤ç»Ÿè®¡:")
        print(f"   æˆåŠŸä¿®å¤: {success_count}/{len(files_needing_fix)} ä¸ªæ–‡ä»¶")
        print(f"   æ€»æ›¿æ¢æ•°: {total_replacements} å¤„")
        
        return success_count == len(files_needing_fix)

    def test_api_after_fix(self):
        """ä¿®å¤åæµ‹è¯•API"""
        print("\n" + "="*50)
        print("ğŸ§ª ä¿®å¤åAPIæµ‹è¯•")
        print("="*50)
        
        print("âš ï¸ è¯·å…ˆé‡å¯ headless_commander.pyï¼Œç„¶åæŒ‰Enterç»§ç»­...")
        input("æŒ‰Enterç»§ç»­æµ‹è¯•...")
        
        # æµ‹è¯•ä¸€ä¸ªç®€å•çš„ä½å§¿ç§»åŠ¨
        current_pose = get_robot_pose()
        if current_pose:
            print(f"ğŸ“ å½“å‰ä½å§¿: {[round(p, 2) for p in current_pose]}")
            
            # åˆ›å»ºä¸€ä¸ªå°çš„ç§»åŠ¨ç›®æ ‡
            target_pose = current_pose.copy()
            target_pose[0] += 10  # Xè½´ç§»åŠ¨10mm
            
            print(f"ğŸ¯ æµ‹è¯•ç›®æ ‡: {[round(p, 2) for p in target_pose]}")
            print("ğŸš€ æ‰§è¡Œæµ‹è¯•ç§»åŠ¨...")
            
            try:
                result = move_robot_pose(
                    target_pose,
                    speed_percentage=10,  # å¾ˆæ…¢çš„é€Ÿåº¦
                    wait_for_ack=True,
                    timeout=15
                )
                
                if result and result.get('status') == 'COMPLETED':
                    print("âœ… ä½å§¿ç§»åŠ¨æµ‹è¯•æˆåŠŸï¼ikine_LM ä¿®å¤æœ‰æ•ˆï¼")
                    return True
                else:
                    print(f"âŒ ä½å§¿ç§»åŠ¨æµ‹è¯•å¤±è´¥: {result}")
                    return False
                    
            except Exception as e:
                print(f"âŒ æµ‹è¯•è¿‡ç¨‹å‡ºé”™: {e}")
                return False
        else:
            print("âŒ æ— æ³•è·å–å½“å‰ä½å§¿")
            return False

    def run_complete_fix(self):
        """è¿è¡Œå®Œæ•´çš„ä¿®å¤æµç¨‹"""
        print("ğŸš€ PAROL6 ikine_LM å®Œæ•´ä¿®å¤æµç¨‹")
        print("="*50)
        
        # æ­¥éª¤1: æµ‹è¯• ikine_LM å¯ç”¨æ€§
        print("æ­¥éª¤1: éªŒè¯ ikine_LM å¯ç”¨æ€§")
        if not self.test_parol6_ik():
            print("âŒ ikine_LM ä¸å¯ç”¨ï¼Œæ— æ³•ç»§ç»­ä¿®å¤")
            return
        
        print("âœ… ikine_LM éªŒè¯é€šè¿‡ï¼Œå¯ä»¥ç”¨äºä¿®å¤")
        
        # æ­¥éª¤2: æŸ¥æ‰¾éœ€è¦ä¿®å¤çš„æ–‡ä»¶
        print("\næ­¥éª¤2: æŸ¥æ‰¾éœ€è¦ä¿®å¤çš„æ–‡ä»¶")
        files_needing_fix = self.find_files_to_fix()
        
        if not files_needing_fix:
            print("ğŸ‰ æ‰€æœ‰æ–‡ä»¶éƒ½å·²ç»æ˜¯æ­£ç¡®çš„ï¼")
            return
        
        # æ­¥éª¤3: ç”¨æˆ·ç¡®è®¤
        print(f"\næ­¥éª¤3: ç¡®è®¤ä¿®å¤")
        print(f"å°†è¦ä¿®å¤ {len(files_needing_fix)} ä¸ªæ–‡ä»¶:")
        for filename, count in files_needing_fix:
            print(f"   â€¢ {filename}: {count} å¤„æ›¿æ¢")
        
        if input("\nç¡®è®¤å¼€å§‹ä¿®å¤? (y/N): ").lower() != 'y':
            print("âŒ ç”¨æˆ·å–æ¶ˆä¿®å¤")
            return
        
        # æ­¥éª¤4: æ‰§è¡Œä¿®å¤
        print("\næ­¥éª¤4: æ‰§è¡Œæ–‡ä»¶ä¿®å¤")
        if not self.fix_all_files(files_needing_fix):
            print("âŒ ä¿®å¤è¿‡ç¨‹å‡ºç°é—®é¢˜")
            return
        
        print("âœ… æ–‡ä»¶ä¿®å¤å®Œæˆï¼")
        
        # æ­¥éª¤5: æŒ‡å¯¼æµ‹è¯•
        print("\næ­¥éª¤5: éªŒè¯ä¿®å¤æ•ˆæœ")
        print("ğŸ“‹ æ¥ä¸‹æ¥è¯·:")
        print("1. åœæ­¢å½“å‰çš„ headless_commander.py (Ctrl+C)")
        print("2. é‡æ–°å¯åŠ¨ headless_commander.py")
        print("3. æŒ‰Enterç»§ç»­APIæµ‹è¯•")
        
        if input("\nå·²é‡å¯æœåŠ¡å™¨ï¼ŸæŒ‰yç»§ç»­æµ‹è¯• (y/N): ").lower() == 'y':
            if self.test_api_after_fix():
                print("\nğŸ‰ ä¿®å¤æˆåŠŸï¼æ‰€æœ‰APIåº”è¯¥éƒ½èƒ½æ­£å¸¸å·¥ä½œäº†ï¼")
            else:
                print("\nâš ï¸ APIæµ‹è¯•æœªé€šè¿‡ï¼Œå¯èƒ½éœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥")
        
        print("\n" + "="*60)
        print("ğŸ“‹ ä¿®å¤å®Œæˆæ€»ç»“")
        print("="*60)
        print("âœ… ikine_LMS -> ikine_LM æ›¿æ¢å®Œæˆ")
        print("âœ… åŸæ–‡ä»¶å·²å¤‡ä»½")
        print("ğŸ¯ ç°åœ¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹API:")
        print("   â€¢ move_robot_pose")
        print("   â€¢ move_robot_cartesian") 
        print("   â€¢ jog_cartesian")
        print("   â€¢ smooth_circle")
        print("   â€¢ smooth_arc_*")
        print("   â€¢ smooth_spline")
        print("   â€¢ smooth_helix")
        print("="*60)

def main():
    """ä¸»ç¨‹åº"""
    print("ğŸ”§ PAROL6 ikine_LM è‡ªåŠ¨ä¿®å¤å·¥å…·")
    print("åŸºäºæ‚¨æµ‹è¯•é€šè¿‡çš„ ikine_LM æ–¹æ³•")
    
    fixer = PAROL6_IK_Fixer()
    
    print("\né€‰æ‹©æ“ä½œ:")
    print("1. å®Œæ•´ä¿®å¤æµç¨‹ï¼ˆæ¨èï¼‰")
    print("2. ä»…æµ‹è¯• ikine_LM")
    print("3. ä»…æŸ¥æ‰¾éœ€è¦ä¿®å¤çš„æ–‡ä»¶")
    print("4. é€€å‡º")
    
    choice = input("\nè¯·é€‰æ‹© (1-4): ").strip()
    
    if choice == '1':
        fixer.run_complete_fix()
    elif choice == '2':
        fixer.test_parol6_ik()
    elif choice == '3':
        fixer.find_files_to_fix()
    elif choice == '4':
        print("ğŸ‘‹ é€€å‡ºç¨‹åº")
    else:
        print("âŒ æ— æ•ˆé€‰æ‹©")

if __name__ == "__main__":
    main()
````

## File: PAROL6_ROBOT.py.backup_1757427986
````
# This file acts as configuration file for robot you are using
# It works in conjustion with configuration file from robotics toolbox

from swift import Swift
import spatialmath.base.symbolic as sym
from roboticstoolbox import ETS as ET
from roboticstoolbox import *
import roboticstoolbox as rtb
from spatialmath import *
from spatialgeometry import *
from math import pi
import numpy as np
import time
import random

Joint_num = 6 # Number of joints
Microstep = 32
steps_per_revolution=200
degree_per_step_constant = 360/(32*200) 
radian_per_step_constant = (2*pi) / (32*200)
radian_per_sec_2_deg_per_sec_const = 360/ (2*np.pi)
deg_per_sec_2_radian_per_sec_const = (2*np.pi) / 360

# robot length values (metres)
a1 = 110.50 / 1000
a2 = 23.42 / 1000
a3 = 180 / 1000
a4 = 43.5 / 1000
a5 = 176.35 / 1000
a6 = 62.8 / 1000
a7 = 45.25 / 1000

alpha_DH = [-pi / 2,pi,pi/2,-pi/2,pi/2,pi]

robot = DHRobot(
    [
        RevoluteDH(d=a1, a=a2, alpha=alpha_DH[0]),
        RevoluteDH(a=a3,d = 0,alpha=alpha_DH[1]),
        RevoluteDH(alpha= alpha_DH[2], a= -a4),
        RevoluteDH(d=-a5, a=0, alpha=alpha_DH[3]),
        RevoluteDH(a=0,d=0,alpha=alpha_DH[4]),
        RevoluteDH(alpha=alpha_DH[5], a = -a7,d = -a6),
    ],
    name="PAROL6",
)
#print(robot.isspherical())
#pyplot = rtb.backends.PyPlot()

# in degrees
Joints_standby_position_degree = np.array([0,-90,180,0,0,180]) 
# in radians
Joints_standby_position_radian = [np.deg2rad(angle) for angle in Joints_standby_position_degree]

# values you get after homing robot and moving it to its most left and right sides
# In degrees
Joint_limits_degree =[[-123.046875,123.046875], [-145.0088,-3.375], [107.866,287.8675], [-105.46975,105.46975], [-90,90], [0,360]] 

# in radians
Joint_limits_radian = []
for limits in Joint_limits_degree:
    radian_limits = [np.deg2rad(angle) for angle in limits]
    Joint_limits_radian.append(radian_limits)

# Reduction ratio we have on our joints
Joint_reduction_ratio = [6.4, 20, 20*(38/42) , 4, 4, 10] 

# min and max jog speeds. Usually slower from real maximal speeds
Joint_max_jog_speed = [1500, 3000, 3600, 7000, 7000, 18000]
Joint_min_jog_speed = [100,100,100,100,100,100]

# LINEAR CARTESIAN JOG MAX MIN SPEED IN METERS PER SECOND
Cartesian_linear_velocity_min_JOG = 0.002
Cartesian_linear_velocity_max_JOG = 0.06

# LINEAR CARTESIAN MAX MIN SPEED IN METERS PER SECOND
Cartesian_linear_velocity_min = 0.002
Cartesian_linear_velocity_max = 0.06

# LINEAR CARTESIAN MAX MIN ACC IN METERS PER SECONDÂ²
Cartesian_linear_acc_min = 0.002
Cartesian_linear_acc_max = 0.06

# ANGULAR CARTESIAN JOG MAX MIN SPEED IN DEGREES PER SECOND
Cartesian_angular_velocity_min = 0.7
Cartesian_angular_velocity_max = 25

Joint_max_speed = [6500,18000,20000,20000,22000,22000] # max speed in STEP/S used
Joint_min_speed = [100,100,100,100,100,100] # min speed in STEP/S used 

Joint_max_acc = 32000 # max acceleration in RAD/SÂ²
Joint_min_acc = 100 # min acceleration in RAD/SÂ²

Cart_lin_velocity_limits = [[-100,100],[-100,100],[-100,100]]
Cart_ang_velocity_limits = [[-100,100],[-100,100],[-100,100]]


Commands_list = [ "Input","Output","Dummy","Begin","Home","Delay","End","Loop","MoveJoint","MovePose","SpeedJoint","MoveCart",
                 "MoveCart","MoveCartRelTRF","Gripper","Gripper_cal"]

Commands_list_true = [item + "()" for item in Commands_list]

# 360 / (200 * 32) = 0.05625
def DEG2STEPS(Degrees, index):
    Steps = Degrees / degree_per_step_constant * Joint_reduction_ratio[index]
    return Steps

Joint_limits_steps =[[DEG2STEPS(Joint_limits_degree[0][0],0),DEG2STEPS(Joint_limits_degree[0][1],0)],
                      [DEG2STEPS(Joint_limits_degree[1][0],1),DEG2STEPS(Joint_limits_degree[1][1],1)],
                      [DEG2STEPS(Joint_limits_degree[2][0],2),DEG2STEPS(Joint_limits_degree[2][1],2)],
                      [DEG2STEPS(Joint_limits_degree[3][0],3),DEG2STEPS(Joint_limits_degree[3][1],3)],
                      [DEG2STEPS(Joint_limits_degree[4][0],4),DEG2STEPS(Joint_limits_degree[4][1],4)],
                      [DEG2STEPS(Joint_limits_degree[5][0],5),DEG2STEPS(Joint_limits_degree[5][1],5)]]
Joint_limits_steps = [[int(i[0]),int(i[1])] for i in Joint_limits_steps]


def STEPS2DEG(Steps,index):
    Degrees = Steps * degree_per_step_constant / Joint_reduction_ratio[index]
    return Degrees

def RAD2STEPS(Rads,index):
    deg = np.rad2deg(Rads)
    steps = DEG2STEPS(deg,index)
    return steps

def STEPS2RADS(Steps,index):
    deg = STEPS2DEG(Steps,index)
    rads = np.deg2rad(deg)
    return rads

def RAD2DEG(radian):
    return np.rad2deg(radian)

def DEG2RAD(degree):
    return np.deg2rad(degree)

def SPEED_STEPS2DEG(Steps_per_second,index):

    '''     Transform true RADS/S to true RPM.
    Both these values are true values at witch MOTORS SPIN  '''

    degrees_per_step = degree_per_step_constant / Joint_reduction_ratio[index]
    degrees_per_second = Steps_per_second * degrees_per_step
    return degrees_per_second

def SPEED_DEG2STEPS(Deg_per_second,index):
    steps_per_second = Deg_per_second / degree_per_step_constant * Joint_reduction_ratio[index]
    return steps_per_second

def SPEED_STEP2RAD(Steps_per_second,index):
    degrees_per_step = radian_per_step_constant / Joint_reduction_ratio[index]
    rad_per_second = Steps_per_second * degrees_per_step
    return rad_per_second

def SPEED_RAD2STEP(Rad_per_second,index):
    steps_per_second = Rad_per_second / radian_per_step_constant * Joint_reduction_ratio[index]
    return steps_per_second

def RAD_SEC_2_DEG_SEC(rad_per_sec):
    return rad_per_sec * radian_per_sec_2_deg_per_sec_const

def DEG_SEC_2_RAD_SEC(deg_per_sec):
    return deg_per_sec * deg_per_sec_2_radian_per_sec_const


def check_joint_limits(q, target_q=None, allow_recovery=True):
    """
    Check if joint angles are within their limits, with support for recovery movements.
    
    Parameters
    ----------
    q : array_like
        Current joint angles in radians
    target_q : array_like, optional
        Target joint angles in radians. If provided, recovery logic is applied.
    allow_recovery : bool, optional
        Whether to allow recovery movements when current position violates limits
        
    Returns
    -------
    bool
        True if movement is allowed (within limits or valid recovery), False otherwise
    dict
        Dictionary with joint limit violation details and recovery information
    """
    q_array = np.array(q)
    target_array = np.array(target_q) if target_q is not None else None
    violations = {}
    all_valid = True
    
    for i in range(min(len(q_array), len(Joint_limits_radian))):
        min_limit = Joint_limits_radian[i][0]
        max_limit = Joint_limits_radian[i][1]
        current_pos = q_array[i]
        
        # Check if current position violates limits
        current_violates = current_pos < min_limit or current_pos > max_limit
        
        if current_violates:
            violation_type = 'below_min' if current_pos < min_limit else 'above_max'
            
            # If we have a target and recovery is enabled, check if it's a recovery movement
            if target_array is not None and allow_recovery:
                target_pos = target_array[i]
                is_recovery = False
                
                if current_pos > max_limit:  # Past upper limit
                    # Recovery means moving towards or below the upper limit
                    is_recovery = target_pos <= current_pos
                    recovery_direction = "move joint towards negative direction"
                elif current_pos < min_limit:  # Past lower limit
                    # Recovery means moving towards or above the lower limit  
                    is_recovery = target_pos >= current_pos
                    recovery_direction = "move joint towards positive direction"
                
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': target_pos if target_array is not None else None,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': violation_type,
                    'is_recovery': is_recovery,
                    'recovery_direction': recovery_direction if not is_recovery else None,
                    'movement_allowed': is_recovery
                }
                
                # Only flag as invalid if it's not a recovery movement
                if not is_recovery:
                    all_valid = False
            else:
                # No target provided or recovery disabled - flag as violation
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': None,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': violation_type,
                    'is_recovery': False,
                    'recovery_direction': None,
                    'movement_allowed': False
                }
                all_valid = False
        elif target_array is not None:
            # Current is within limits, check if target would violate
            target_pos = target_array[i]
            target_violates = target_pos < min_limit or target_pos > max_limit
            
            if target_violates:
                target_violation_type = 'below_min' if target_pos < min_limit else 'above_max'
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': target_pos,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': f'target_{target_violation_type}',
                    'is_recovery': False,
                    'recovery_direction': None,
                    'movement_allowed': False
                }
                all_valid = False
    
    return all_valid, violations

def extract_from_can_id(can_id):
    # Extracting ID2 (first 4 MSB)
    id2 = (can_id >> 7) & 0xF

    # Extracting CAN Command (next 6 bits)
    can_command = (can_id >> 1) & 0x3F

    # Extracting Error Bit (last bit)
    error_bit = can_id & 0x1
    
    return id2, can_command, error_bit


def combine_2_can_id(id2, can_command, error_bit):
    # Combine components into an 11-bit CAN ID
    can_id = 0

    # Add ID2 (first 4 MSB)
    can_id |= (id2 & 0xF) << 7

    # Add CAN Command (next 6 bits)
    can_id |= (can_command & 0x3F) << 1

    # Add Error Bit (last bit)
    can_id |= (error_bit & 0x1)

    return can_id

# Fuse bitfield list to byte
def fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Splits byte to bitfield list
def split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]


if __name__ == "__main__":
    """
    print(DEG2STEPS(180,2))
    print(STEPS2DEG(57905,2))
    print(RAD2STEPS(pi,5))
    print(STEPS2RADS(32000,5))
    print(SPEED_STEPS2DEG(1000,5))
    print(SPEED_STEP2RAD(1000,5))
    print(Joint_limits_radian)
    print(Joints_standby_position_radian)
    print(Joint_limits_steps)
    print(Joint_limits_radian)
    print(DEG2STEPS(-62.5,1))
    """

    J0_var = STEPS2RADS(1,0)
    J1_var = STEPS2RADS(1,1)
    J2_var = STEPS2RADS(1,2)
    J3_var = STEPS2RADS(1,3)
    J4_var = STEPS2RADS(1,4)
    J5_var = STEPS2RADS(1,5)


    print("Joint 1 smallest step:",RAD2DEG(J0_var))
    print("Joint 2 smallest step:",RAD2DEG(J1_var))
    print("Joint 3 smallest step:",RAD2DEG(J2_var))
    print("Joint 4 smallest step:",RAD2DEG(J3_var))
    print("Joint 5 smallest step:",RAD2DEG(J4_var))
    print("Joint 6 smallest step:",RAD2DEG(J5_var))
    print("rad 2 step:",SPEED_RAD2STEP(-2.948504399390715 / 2,5))
    print("standby radian is",Joints_standby_position_radian)

    test = RAD2STEPS(0.0001,5)
    print(test)

    #robot.ikine_LMS()
````

## File: python quick_fix.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å¿«é€Ÿä¿®å¤è„šæœ¬ï¼šikine_LMS -> ikine_LM
åŸºäºæµ‹è¯•é€šè¿‡çš„æ–¹æ³•
"""

import os
import shutil
import time

def quick_fix():
    """å¿«é€Ÿä¿®å¤æ‰€æœ‰æ–‡ä»¶"""
    print("ğŸš€ PAROL6 å¿«é€Ÿä¿®å¤ï¼šikine_LMS -> ikine_LM")
    print("="*50)
    
    files = ["headless_commander.py", "PAROL6_ROBOT.py", "smooth_motion.py"]
    
    total_fixes = 0
    
    for filename in files:
        if not os.path.exists(filename):
            print(f"âš ï¸ {filename}: æ–‡ä»¶ä¸å­˜åœ¨")
            continue
            
        try:
            # è¯»å–æ–‡ä»¶
            with open(filename, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿®å¤
            count = content.count('ikine_LMS')
            if count == 0:
                print(f"ğŸ“„ {filename}: æ— éœ€ä¿®å¤")
                continue
            
            # å¤‡ä»½
            backup = f"{filename}.backup_{int(time.time())}"
            shutil.copy2(filename, backup)
            
            # ä¿®å¤
            fixed_content = content.replace('ikine_LMS', 'ikine_LM')
            
            # å†™å…¥
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(fixed_content)
            
            print(f"âœ… {filename}: ä¿®å¤ {count} å¤„ï¼Œå¤‡ä»½åˆ° {backup}")
            total_fixes += count
            
        except Exception as e:
            print(f"âŒ {filename}: ä¿®å¤å¤±è´¥ - {e}")
    
    print("="*50)
    print(f"ğŸ‰ ä¿®å¤å®Œæˆï¼æ€»å…±ä¿®å¤ {total_fixes} å¤„")
    print("\nğŸ“‹ ä¸‹ä¸€æ­¥:")
    print("1. é‡å¯ headless_commander.py")
    print("2. è¿è¡ŒAPIæµ‹è¯•éªŒè¯ä¿®å¤æ•ˆæœ")

if __name__ == "__main__":
    if input("ç¡®è®¤æ‰§è¡Œå¿«é€Ÿä¿®å¤? (y/N): ").lower() == 'y':
        quick_fix()
    else:
        print("âŒ å–æ¶ˆä¿®å¤")
````

## File: README_FIXED.md
````markdown
# PAROL6 Python API - Linuxä¿®å¤ç‰ˆ

## ğŸ“‹ é¡¹ç›®è¯´æ˜
è¿™æ˜¯PAROL6æœºæ¢°è‡‚çš„Python APIï¼Œå·²ä¿®å¤Linuxç¯å¢ƒä¸‹çš„ä¸²å£è¿æ¥é—®é¢˜ã€‚

## âœ… å·²ä¿®å¤çš„é—®é¢˜

### 1. **ä¸²å£è¿æ¥é—®é¢˜**
- ä¿®å¤äº†Linuxç¯å¢ƒä¸‹ä¸²å£åˆå§‹åŒ–å¤±è´¥çš„é—®é¢˜
- æ·»åŠ äº†è‡ªåŠ¨ä¸²å£æ£€æµ‹åŠŸèƒ½
- å®ç°äº†ä¸²å£æƒé™æ£€æŸ¥

### 2. **æ¨¡å—å¯¼å…¥é—®é¢˜**
- ä¿®å¤äº†GUIæ¨¡å—å¯¼å…¥è·¯å¾„é—®é¢˜
- æ­£ç¡®è®¾ç½®äº†PYTHONPATH

### 3. **ä¾èµ–ç®¡ç†**
- ä½¿ç”¨condaè™šæ‹Ÿç¯å¢ƒç®¡ç†ä¾èµ–
- ç¡®ä¿æ‰€æœ‰å¿…è¦çš„åŒ…éƒ½å·²å®‰è£…

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. æ¿€æ´»ç¯å¢ƒ
```bash
source ~/anaconda3/bin/activate
conda activate parol
```

### 2. æµ‹è¯•ä¸²å£è¿æ¥
```bash
cd ~/PAROL-commander-software/PAROL6-python-API
python test_serial.py
```

### 3. è¿è¡Œä¸»ç¨‹åº
```bash
python run_parol6_fixed.py
```

## ğŸ“ æ–‡ä»¶è¯´æ˜

- `run_parol6_fixed.py` - ä¸»å¯åŠ¨è„šæœ¬ï¼ˆä¿®å¤ç‰ˆï¼‰
- `test_serial.py` - ä¸²å£è¿æ¥æµ‹è¯•å·¥å…·
- `parol6_controller.py` - PAROL6æ§åˆ¶å™¨ç±»ï¼ˆå‡†å¤‡ROS2é›†æˆï¼‰
- `headless_commander.py` - åŸå§‹æ§åˆ¶ç¨‹åº
- `robot_api.py` - æœºå™¨äººAPI
- `PAROL6_ROBOT.py` - æœºå™¨äººæ¨¡å‹å®šä¹‰
- `smooth_motion.py` - å¹³æ»‘è¿åŠ¨æ§åˆ¶

## ğŸ”§ æ•…éšœæ’é™¤

### ä¸²å£æƒé™é—®é¢˜
å¦‚æœé‡åˆ°æƒé™é”™è¯¯ï¼Œè¿è¡Œï¼š
```bash
sudo usermod -a -G dialout $USER
# ç„¶åé‡æ–°ç™»å½•
```

### ä¸´æ—¶è§£å†³æ–¹æ¡ˆ
```bash
sudo -E python run_parol6_fixed.py
```

### ç«¯å£å†²çª
å¦‚æœé‡åˆ° "Address already in use" é”™è¯¯ï¼š
```bash
# æŸ¥æ‰¾å ç”¨ç«¯å£çš„è¿›ç¨‹
lsof -i :5001
# ç»“æŸè¿›ç¨‹
kill -9 <PID>
```

## ğŸ“¡ ä¸²å£é…ç½®

- é»˜è®¤æ³¢ç‰¹ç‡: 3000000
- é»˜è®¤ç«¯å£: /dev/ttyACM0 æˆ– /dev/ttyUSB0
- ç«¯å£é…ç½®æ–‡ä»¶: com_port.txt

## ğŸ¤– ROS2é›†æˆï¼ˆä¸‹ä¸€æ­¥ï¼‰

å‡†å¤‡å·¥ä½œå·²å®Œæˆï¼Œä¸‹ä¸€æ­¥å°†é›†æˆåˆ°ROS2å’ŒMoveItï¼š
1. åˆ›å»ºROS2åŒ…
2. å®ç°MoveItæ§åˆ¶å™¨æ¥å£
3. é…ç½®URDFæ¨¡å‹
4. è®¾ç½®MoveIté…ç½®

## ğŸ“ æ›´æ–°æ—¥å¿—

### 2024-09-01
- ä¿®å¤Linuxä¸²å£è¿æ¥é—®é¢˜
- æ·»åŠ ä¸²å£è‡ªåŠ¨æ£€æµ‹
- åˆ›å»ºæµ‹è¯•å·¥å…·
- å‡†å¤‡ROS2é›†æˆæ¥å£

## ğŸ‘¥ ç»´æŠ¤è€…
- wzy

## ğŸ“„ è®¸å¯è¯
MIT License
````

## File: README.md
````markdown
# PAROL6 Headless Commander Documentation

## 1. Important Notes & Disclaimers
* **Software Origin**: This control system is based on the `experimental_kinematics` branch of the `PAROL_commander_software` repository. The core communication functions were derived from the `Serial_sender_good_latest.py` file; however, the approach to motion planning has been altered from the original implementation. This system was created by editing the `Commander_minimal_version.py` file, which was used as a base.
* **Automatic Homing on Startup**: By default, the `headless_commander.py` script will immediately command the robot to home itself upon startup. This is done for convenience but can be disabled. To prevent automatic homing, comment out or delete the corresponding line in `headless_commander.py`.
* **AI-Assisted Development**: This code was developed with significant AI assistance. While the core logic has been corrected and improved, it has not been exhaustively tested in all scenarios. Users should proceed with caution and verify functionality for their specific needs.

## 2. Safety Precautions & Disclaimer
This control software includes several built-in safety features designed to prevent damage to the robot and ensure predictable operation:
* **E-Stop Monitoring**: The system constantly checks the physical E-Stop button. If triggered, all motion is immediately halted, the command queue is cleared, and the robot is disabled. The system must be manually re-enabled by pressing the `'e'` key after the E-Stop is released.
* **Synchronized Speed Calculation**: For moves defined by a speed percentage (`MoveJoint`, `MovePose`), the system now calculates the maximum possible synchronized speed for all joints involved. This prevents individual joints from exceeding their limits and ensures predictable, smooth motion.
* **Inverse Kinematics (IK) Validation**: The system verifies that a valid kinematic solution exists for any pose-based command. If the target pose is unreachable, the command will fail safely before any motion occurs.

> **WARNING**: These are software-based safety measures and are not a substitute for responsible operation and a safe work environment. The user assumes all responsibility for safe operation. Always be attentive when the robot is active, ensure you have immediate access to the physical E-Stop, and operate the robot in a clear area.

## 3. Installation

### Base Software Installation
Follow the official PAROL commander software installation guide:
- Repository: [PAROL Commander Software](https://github.com/PCrnjak/PAROL-commander-software)
- Branch: Use the `experimental_kinematics` branch
- Installation Guide: [Official Instructions](https://github.com/PCrnjak/PAROL-commander-software)

### Additional Dependencies for Headless Commander
After installing the base software, install these additional packages:

```bash
# Install Python 3 and pip (if not already installed)
# https://www.python.org/downloads/

# Install Git (if not already installed)
# https://git-scm.com/book/en/v2/Getting-Started-Installing-Git

# Core dependencies (from official installation)
pip3 install roboticstoolbox-python==1.0.3
pip3 install numpy==1.23.4
pip3 install scipy==1.11.4
pip3 install spatialmath
pip3 install pyserial
pip3 install oclock
pip3 install keyboard
```
## 4. System Architecture

### Client-Server Design
The system uses a UDP-based client-server architecture that separates robot control from command generation:

* **The Robot Controller (`headless_commander.py`)**: 
  - Runs on the computer physically connected to the robot via USB/Serial
  - Maintains a high-frequency control loop (100Hz) for real-time robot control
  - Handles all complex calculations (inverse kinematics, trajectory planning)
  - Requires heavy dependencies (roboticstoolbox, numpy, scipy)
  - Listens for UDP commands on port 5001

* **The Remote Client (`robot_api.py`)**: 
  - Can run on any computer (same or different from controller)
  - Sends simple text commands via UDP
  - Requires minimal dependencies (mostly Python standard library)
  - Extremely lightweight - can run on resource-constrained devices
  - Optionally receives acknowledgments on port 5002

* **Support Modules**:
  - `smooth_motion.py`: Advanced trajectory generation algorithms
  - `PAROL6_ROBOT.py`: Robot-specific parameters and kinematic model

### Why UDP?
The UDP protocol was chosen for several reasons:
- **Simplicity**: No connection management overhead
- **Low Latency**: Direct message passing without handshaking
- **Lightweight Client**: Client only needs to send text strings
- **Cross-Platform**: Works on any OS with network support
- **Flexible Deployment**: Client can run anywhere on the network

### Command Flow
1. Client calls API function (e.g., `move_robot_joints()`)
2. API formats command as text string (e.g., `"MOVEJOINT|90|-45|90|0|45|180|5.5|None"`)
3. Command sent via UDP to controller
4. Controller queues and executes command
5. Optional: Acknowledgment sent back to client
6. Optional: Client checks status using command ID

### Command Acknowledgment System
The system includes an optional acknowledgment tracking feature that provides feedback on command execution:
* **Tracking States**: Commands can report status as `QUEUED`, `EXECUTING`, `COMPLETED`, `FAILED`, `CANCELLED`, or `INVALID`
* **Zero Overhead**: When not used, the tracking system has zero resource overhead - no threads or sockets are created
* **Non-Blocking Mode**: Commands can be sent with `non_blocking=True` to return immediately with a command ID, allowing asynchronous operation
* **Status Checking**: Use `check_command_status(command_id)` to poll command status later

Example of non-blocking usage:
```python
# Send command and get ID immediately
cmd_id = move_robot_joints([90, -45, 90, 0, 45, 180], 
                          duration=5, 
                          wait_for_ack=True, 
                          non_blocking=True)

# Do other work...
time.sleep(1)

# Check status later
status = check_command_status(cmd_id)
if status and status['completed']:
    print(f"Command finished with status: {status['status']}")
```

## 5. Command Reference & API Usage

### Motion Commands

#### `home_robot()`
* **Purpose**: Initiates the robot's built-in homing sequence.
* **Parameters**: 
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 30.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import home_robot
    home_robot()  # Simple usage
    home_robot(wait_for_ack=True, timeout=30)  # With tracking
    ```

#### `move_robot_joints()`
* **Purpose**: Moves joints to a target configuration (in degrees).
* **Parameters**:
    * `joint_angles` (List[float]): List of 6 target angles in degrees for joints 1-6
    * `duration` (float, optional): Total time for the movement in seconds
    * `speed_percentage` (int, optional): Speed as percentage (0-100)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import move_robot_joints

    # Simple move by speed
    move_robot_joints([90, -45, 90, 0, 45, 180], speed_percentage=75)

    # Move with acknowledgment tracking
    result = move_robot_joints([0, -90, 180, 0, 0, 180], 
                               duration=5.5, 
                               wait_for_ack=True)
    if result['status'] == 'COMPLETED':
        print("Move completed successfully")
    ```

#### `move_robot_pose()`
* **Purpose**: Moves the end-effector to a Cartesian pose via a joint-based path.
* **Parameters**:
    * `pose` (List[float]): Target pose [x, y, z, Rx, Ry, Rz] in mm and degrees
    * `duration` (float, optional): Total time for the movement in seconds
    * `speed_percentage` (int, optional): Speed as percentage (0-100)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import move_robot_pose
    move_robot_pose([250, 0, 200, 180, 0, 90], speed_percentage=50)
    ```

#### `move_robot_cartesian()`
* **Purpose**: Moves the end-effector to a target pose in a guaranteed straight-line path.
* **Parameters**:
    * `pose` (List[float]): Target pose [x, y, z, Rx, Ry, Rz] in mm and degrees
    * `duration` (float, optional): Time for the movement in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import move_robot_cartesian
    move_robot_cartesian([200, -50, 180, 180, 0, 135], duration=4.0)
    ```

### Jogging Commands

#### `jog_robot_joint()`
* **Purpose**: Jogs a single joint by time or angular distance.
* **Parameters**:
    * `joint_index` (int): Joint to move (0-5 for positive direction, 6-11 for negative)
    * `speed_percentage` (int): Jog speed as percentage (0-100)
    * `duration` (float, optional): Time to jog in seconds
    * `distance_deg` (float, optional): Distance to jog in degrees
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `distance_deg`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import jog_robot_joint
    # Jog joint 1 for 2 seconds
    jog_robot_joint(joint_index=0, speed_percentage=40, duration=2.0)
    # Jog joint 3 backwards by 15 degrees
    jog_robot_joint(joint_index=8, speed_percentage=60, distance_deg=15)
    ```

#### `jog_multiple_joints()`
* **Purpose**: Jogs multiple joints simultaneously.
* **Parameters**:
    * `joints` (List[int]): List of joint indices (0-5 positive, 6-11 negative)
    * `speeds` (List[float]): List of corresponding speeds (1-100%)
    * `duration` (float): Duration in seconds
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import jog_multiple_joints
    # Jog joints 1, 4, and 6 simultaneously
    jog_multiple_joints([0, 3, 5], [70, 40, 60], 1.2)
    ```

#### `jog_cartesian()`
* **Purpose**: Jogs the end-effector continuously along an axis.
* **Parameters**:
    * `frame` (str): Reference frame ('TRF' for Tool, 'WRF' for World)
    * `axis` (str): Axis and direction ('X+', 'X-', 'Y+', 'Y-', 'Z+', 'Z-', 'RX+', 'RX-', 'RY+', 'RY-', 'RZ+', 'RZ-')
    * `speed_percentage` (int): Jog speed as percentage (0-100)
    * `duration` (float): Time to jog in seconds
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import jog_cartesian
    jog_cartesian(frame='TRF', axis='Z+', speed_percentage=50, duration=1.5)
    ```

### Smooth Motion Commands

These commands create smooth, curved trajectories with continuous velocity profiles. All commands support reference frame selection via the `frame` parameter:

- **WRF (World Reference Frame)**: Default. All coordinates are interpreted relative to the robot's base coordinate system.
- **TRF (Tool Reference Frame)**: All coordinates are interpreted relative to the tool's current position and orientation. This means:
  - Positions are relative to the tool's origin
  - Planes (XY, XZ, YZ) are the tool's local planes, not world planes
  - If the tool is rotated, the entire motion rotates with it

#### `smooth_circle()`
* **Purpose**: Execute a smooth circular motion.
* **Parameters**:
    * `center` (List[float]): Center point [x, y, z] in mm
    * `radius` (float): Circle radius in mm
    * `plane` (str, optional): Plane of circle ('XY', 'XZ', or 'YZ'). Default: 'XY'
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF'). Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose [x, y, z, rx, ry, rz], or None for current position. Default: None
    * `duration` (float, optional): Time to complete circle in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `clockwise` (bool, optional): Direction of motion. Default: False
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 10.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import smooth_circle
    
    # Draw a 50mm radius circle in world XY plane
    smooth_circle(center=[200, 0, 200], radius=50, plane='XY', duration=5.0)
    
    # Draw a circle in tool's XY plane (follows tool orientation)
    smooth_circle(center=[0, 30, 0], radius=25, plane='XY', frame='TRF', duration=4.0)
    ```

#### `smooth_arc_center()`
* **Purpose**: Execute a smooth arc motion defined by center point.
* **Parameters**:
    * `end_pose` (List[float]): End pose [x, y, z, rx, ry, rz] in mm and degrees
    * `center` (List[float]): Arc center point [x, y, z] in mm
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF'). Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose, or None for current position. Default: None
    * `duration` (float, optional): Time to complete arc in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `clockwise` (bool, optional): Direction of motion. Default: False
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 10.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import smooth_arc_center
    
    # Arc in world coordinates
    smooth_arc_center(end_pose=[250, 50, 200, 0, 0, 90], 
                     center=[200, 0, 200], 
                     duration=3.0)
    
    # Arc in tool coordinates (relative to tool position/orientation)
    smooth_arc_center(end_pose=[30, 30, 0, 0, 0, 45],
                     center=[15, 15, 0],
                     frame='TRF',
                     duration=3.0)
    ```

#### `smooth_arc_parametric()`
* **Purpose**: Execute a smooth arc motion defined by radius and angle.
* **Parameters**:
    * `end_pose` (List[float]): End pose [x, y, z, rx, ry, rz] in mm and degrees
    * `radius` (float): Arc radius in mm
    * `arc_angle` (float): Arc angle in degrees
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF'). Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose, or None for current position. Default: None
    * `duration` (float, optional): Time to complete arc in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `clockwise` (bool, optional): Direction of motion. Default: False
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 10.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import smooth_arc_parametric
    
    # Parametric arc in world frame
    smooth_arc_parametric(end_pose=[250, 50, 200, 0, 0, 90],
                         radius=50, arc_angle=90, duration=3.0)
    
    # Parametric arc in tool frame
    smooth_arc_parametric(end_pose=[40, 0, 0, 0, 0, 60],
                         radius=25, arc_angle=60,
                         frame='TRF',
                         speed_percentage=40)
    ```

#### `smooth_spline()`
* **Purpose**: Create smooth spline through waypoints.
* **Parameters**:
    * `waypoints` (List[List[float]]): List of poses [x, y, z, rx, ry, rz] to pass through
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF'). Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose, or None for current position. Default: None
    * `duration` (float, optional): Total time for motion in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 10.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import smooth_spline
    
    # Spline through world coordinates
    waypoints = [
        [200, 0, 100, 0, 0, 0],
        [250, 50, 150, 0, 15, 45],
        [200, 100, 200, 0, 30, 90]
    ]
    smooth_spline(waypoints, duration=8.0)
    
    # Spline through tool-relative coordinates
    tool_waypoints = [
        [20, 0, 0, 0, 0, 0],
        [20, 20, 10, 0, 0, 30],
        [0, 20, 20, 0, 0, 60]
    ]
    smooth_spline(tool_waypoints, frame='TRF', duration=6.0)
    ```

#### `smooth_helix()`
* **Purpose**: Execute helical motion.
* **Parameters**:
    * `center` (List[float]): Helix center point [x, y, z] in mm
    * `radius` (float): Helix radius in mm
    * `pitch` (float): Vertical distance per revolution in mm
    * `height` (float): Total height of helix in mm
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF'). Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose, or None for current position. Default: None
    * `duration` (float, optional): Time to complete helix in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `clockwise` (bool, optional): Direction of motion. Default: False
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 10.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* > *Note: In TRF mode, the helix rises along the tool's Z-axis, not the world Z-axis.*
* **Python API Usage**:
    ```python
    from robot_api import smooth_helix
    
    # Vertical helix in world frame
    smooth_helix(center=[200, 0, 150], radius=30, pitch=20, 
                height=100, duration=10.0)
    
    # Helix along tool's Z-axis (follows tool orientation)
    smooth_helix(center=[0, 30, 0], radius=20, pitch=15,
                height=60, frame='TRF', duration=8.0)
    ```

#### `smooth_blend()`
* **Purpose**: Blend multiple motion segments smoothly.
* **Parameters**:
    * `segments` (List[Dict]): List of segment dictionaries defining the motion path
    * `blend_time` (float, optional): Time for blending between segments in seconds. Default: 0.5
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF') for all segments. Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose, or None for current position. Default: None
    * `duration` (float, optional): Total time for entire motion in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 15.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import smooth_blend
    
    # Blend in world coordinates
    segments = [
        {'type': 'LINE', 'end': [250, 0, 200, 0, 0, 0], 'duration': 2.0},
        {'type': 'CIRCLE', 'center': [250, 0, 200], 'radius': 50, 
         'plane': 'XY', 'duration': 4.0, 'clockwise': False},
        {'type': 'LINE', 'end': [200, 0, 200, 0, 0, 0], 'duration': 2.0}
    ]
    smooth_blend(segments, blend_time=0.5, duration=10.0)
    
    # Blend in tool coordinates (all segments relative to tool)
    tool_segments = [
        {'type': 'LINE', 'end': [30, 0, 0, 0, 0, 0], 'duration': 2.0},
        {'type': 'CIRCLE', 'center': [30, 20, 0], 'radius': 20, 
         'plane': 'XY', 'duration': 4.0, 'clockwise': False},
        {'type': 'LINE', 'end': [0, 20, 0, 0, 0, 0], 'duration': 2.0}
    ]
    smooth_blend(tool_segments, frame='TRF', blend_time=0.5, duration=10.0)
    ```
### Gripper Commands

#### `control_pneumatic_gripper()`
* **Purpose**: Controls the pneumatic gripper.
* **Parameters**:
    * `action` (str): Action to perform ('open' or 'close')
    * `port` (int): Digital output port (1 or 2)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import control_pneumatic_gripper
    control_pneumatic_gripper(action='open', port=1)
    ```

#### `control_electric_gripper()`
* **Purpose**: Controls the electric gripper.
* **Parameters**:
    * `action` (str): Action to perform ('move' or 'calibrate')
    * `position` (int, optional): Target position (0-255). Default: 255
    * `speed` (int, optional): Movement speed (0-255). Default: 150
    * `current` (int, optional): Max motor current in mA (100-1000). Default: 500
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import control_electric_gripper
    control_electric_gripper(action='calibrate')
    control_electric_gripper(action='move', position=200, speed=150)
    ```

### Utility Commands

#### `delay_robot()`
* **Purpose**: Pauses command queue execution.
* **Parameters**:
    * `duration` (float): Pause time in seconds
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import delay_robot
    delay_robot(2.5)
    ```

#### `stop_robot_movement()`
* **Purpose**: Immediately stops all motion and clears command queue.
* **Parameters**:
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import stop_robot_movement
    stop_robot_movement()
    ```

### Query Commands

These commands request current robot state without moving the robot:

#### `get_robot_pose()`
* **Purpose**: Get current end-effector pose.
* **Parameters**: None
* **Returns**: List [x, y, z, Rx, Ry, Rz] in mm and degrees, or None if failed
* **Python API Usage**:
    ```python
    from robot_api import get_robot_pose
    pose = get_robot_pose()
    if pose:
        print(f"Current pose: {pose}")
    ```

#### `get_robot_joint_angles()`
* **Purpose**: Get current joint angles.
* **Parameters**: None
* **Returns**: List of 6 angles in degrees, or None if failed
* **Python API Usage**:
    ```python
    from robot_api import get_robot_joint_angles
    angles = get_robot_joint_angles()
    ```

#### `get_robot_joint_speeds()`
* **Purpose**: Get current joint speeds.
* **Parameters**: None
* **Returns**: List of 6 speeds in steps/sec, or None if failed

#### `get_robot_io()`
* **Purpose**: Get digital I/O status.
* **Parameters**:
    * `verbose` (bool, optional): Print formatted status to console. Default: False
* **Returns**: List [IN1, IN2, OUT1, OUT2, ESTOP] (0 or 1 values), or None if failed

#### `get_electric_gripper_status()`
* **Purpose**: Get electric gripper status.
* **Parameters**:
    * `verbose` (bool, optional): Print formatted status to console. Default: False
* **Returns**: List [ID, Position, Speed, Current, StatusByte, ObjectDetected], or None if failed

#### `get_robot_pose_matrix()`
* **Purpose**: Get robot pose as transformation matrix.
* **Parameters**: None
* **Returns**: 4x4 numpy array, or None if failed

#### `is_robot_stopped()`
* **Purpose**: Check if robot has stopped moving.
* **Parameters**:
    * `threshold_speed` (float, optional): Speed threshold in steps/sec. Default: 2.0
* **Returns**: Boolean (True if stopped, False otherwise)

#### `is_estop_pressed()`
* **Purpose**: Check if E-stop is currently pressed.
* **Parameters**: None
* **Returns**: Boolean (True if pressed, False otherwise)

#### `get_robot_status()`
* **Purpose**: Get comprehensive robot status.
* **Parameters**: None
* **Returns**: Dictionary containing pose, angles, speeds, IO, gripper status, stopped state, and E-stop state

### Helper Functions

#### `execute_trajectory()`
* **Purpose**: High-level trajectory execution with best method selection.
* **Parameters**:
    * `trajectory` (List[List[float]]): List of poses [x, y, z, rx, ry, rz]
    * `timing_mode` (str, optional): Either 'duration' or 'speed'. Default: 'duration'
    * `timing_value` (float, optional): Duration in seconds or speed percentage. Default: 5.0
    * `motion_type` (str, optional): Either 'spline' or 'linear'. Default: 'spline'
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF') for spline motion. Default: 'WRF'
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: True
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 30.0
* > *Note: The `frame` parameter only applies when `motion_type='spline'`. Linear motions are always in WRF.*
* **Python API Usage**:
    ```python
    from robot_api import execute_trajectory
    
    # Execute trajectory in world frame
    trajectory = [[200, 0, 200, 0, 0, 0], 
                  [250, 50, 200, 0, 0, 45],
                  [200, 100, 200, 0, 0, 90]]
    execute_trajectory(trajectory, timing_mode='duration', 
                      timing_value=10.0, motion_type='spline')
    
    # Execute trajectory in tool frame (spline only)
    tool_trajectory = [[20, 0, 0, 0, 0, 0],
                      [20, 20, 0, 0, 0, 30],
                      [0, 20, 10, 0, 0, 60]]
    execute_trajectory(tool_trajectory, frame='TRF',
                      timing_mode='speed', 
                      timing_value=40, motion_type='spline')
    ```


#### `wait_for_robot_stopped()`
* **Purpose**: Wait for robot to stop moving.
* **Parameters**:
    * `timeout` (float, optional): Maximum time to wait in seconds. Default: 10.0
    * `poll_rate` (float, optional): How often to check in seconds. Default: 0.1
* **Returns**: Boolean (True if robot stopped, False if timeout)

#### `safe_move_with_retry()`
* **Purpose**: Execute move with automatic retry on failure.
* **Parameters**:
    * `move_func` (callable): The movement function to call
    * `*args`: Arguments for the movement function
    * `max_retries` (int, optional): Maximum number of retry attempts. Default: 3
    * `retry_delay` (float, optional): Delay between retries in seconds. Default: 1.0
    * `**kwargs`: Keyword arguments for the movement function
* **Returns**: Result from the movement function or error dictionary

#### `chain_smooth_motions()`
* **Purpose**: Chain multiple smooth motions with automatic continuity.
* **Parameters**:
    * `motions` (List[Dict]): List of motion dictionaries
    * `ensure_continuity` (bool, optional): Automatically set start_pose for continuity. Default: True
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF') for all motions. Default: 'WRF'
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: True
    * `timeout` (float, optional): Timeout per motion in seconds. Default: 30.0
* **Returns**: List of results for each motion
* **Python API Usage**:
    ```python
    from robot_api import chain_smooth_motions
    
    # Chain motions in world frame (default)
    motions = [
        {'type': 'circle', 'center': [200, 0, 200], 'radius': 50, 'duration': 5},
        {'type': 'arc', 'end_pose': [250, 50, 200, 0, 0, 90], 
         'center': [225, 25, 200], 'duration': 3}
    ]
    chain_smooth_motions(motions, ensure_continuity=True)
    
    # Chain motions in tool frame
    tool_motions = [
        {'type': 'circle', 'center': [0, 30, 0], 'radius': 25, 'duration': 4},
        {'type': 'arc', 'end_pose': [30, 30, 0, 0, 0, 45], 
         'center': [15, 15, 0], 'duration': 3}
    ]
    chain_smooth_motions(tool_motions, frame='TRF', ensure_continuity=True)
    ```

#### `check_command_status()`
* **Purpose**: Check status of a previously sent command.
* **Parameters**:
    * `command_id` (str): The command ID returned from a non-blocking command
* **Returns**: Dictionary with status information, or None if tracker not initialized
* **Dictionary Contents**:
    * `status` (str): Current status ('QUEUED', 'EXECUTING', 'COMPLETED', 'FAILED', 'CANCELLED', 'INVALID')
    * `details` (str): Additional status details
    * `completed` (bool): Whether command has finished
    * `sent_time` (datetime): When command was sent
    * `ack_time` (datetime, optional): When acknowledgment was received

#### `is_tracking_active()`
* **Purpose**: Check if command tracking system is active.
* **Parameters**: None
* **Returns**: Boolean (True if tracking is active, False otherwise)

#### `get_tracking_stats()`
* **Purpose**: Get resource usage statistics for tracking system.
* **Parameters**: None
* **Returns**: Dictionary with tracking statistics
* **Dictionary Contents**:
    * `active` (bool): Whether tracking is active
    * `commands_tracked` (int): Number of commands being tracked
    * `memory_bytes` (int): Approximate memory usage
    * `thread_active` (bool): Whether tracking thread is running

## 6. Setup & Operation

### Dependencies

The system is designed with a client-server architecture where most dependencies are only needed on the server (robot controller) side. The client API (`robot_api.py`) uses only standard Python libraries for UDP communication, making it lightweight and portable.

#### Server Dependencies (for `headless_commander.py`)
Install Python 3 and the following packages on the computer connected to the robot:

```bash
# Core robotics libraries
pip3 install roboticstoolbox-python==1.0.3
pip3 install numpy==1.23.4
pip3 install scipy==1.11.4
pip3 install spatialmath

# Serial communication and timing
pip3 install pyserial
pip3 install oclock

# User input
pip3 install keyboard
```

#### Client Dependencies (for `robot_api.py`)
The client API is designed to be lightweight with minimal dependencies:

```bash
# Only needed for get_robot_pose() matrix conversion
pip3 install numpy==1.23.4
pip3 install spatialmath

# All other functionality uses only Python standard library:
# socket, threading, time, uuid, datetime, collections, typing
```

**Note**: If you only need to send commands and don't use `get_robot_pose()`, the client requires NO external dependencies - only Python's built-in libraries.

### File Structure

#### Server Side (Robot Controller Computer)
Required files in the same folder:
* `headless_commander.py` - Main server/controller
* `PAROL6_ROBOT.py` - Robot configuration and kinematic model  
* `smooth_motion.py` - Advanced trajectory generation
* `GUI/files/` folder structure - For imports to work correctly

Optional:
* `com_port.txt` - Contains the USB COM port (e.g., COM5)

#### Client Side (Any Computer)
Only required file:
* `robot_api.py` - Client API for sending commands

The client can run on any computer on the same network as the server, or on the same computer in a different process.

### How to Operate

#### Starting the Server (Robot Controller)

1. **Connect Robot**: Ensure the robot is connected via USB to the controller computer.

2. **Start Controller**: On the robot controller computer, navigate to the folder containing the server files and run:
    ```bash
    python headless_commander.py
    ```
    The controller will:
    - Connect to the robot via serial port (prompts if `com_port.txt` not found)
    - Start listening for UDP commands on port 5001
    - Optionally home the robot on startup (unless disabled)

#### Sending Commands (Client)

Commands can be sent from:
- **Same Computer**: Run Python scripts or interactive sessions in another terminal
- **Different Computer**: Ensure network connectivity and update `SERVER_IP` in `robot_api.py`

3. **Send Commands**: Use the API functions from `robot_api.py`:
    ```python
    from robot_api import *
    
    # Example sequence
    home_robot()
    move_robot_joints([90, -90, 160, 12, 12, 180], duration=5.5)
    delay_robot(0.5)
    
    # Smooth motion example
    smooth_circle([200, 0, 200], radius=50, duration=5.0)
    
    # Non-blocking example with status checking
    cmd_id = move_robot_pose([250, 0, 200, 180, 0, 90], 
                             speed_percentage=50,
                             wait_for_ack=True, 
                             non_blocking=True)
    
    # Check status after some time
    import time
    time.sleep(2)
    status = check_command_status(cmd_id)
    if status:
        print(f"Command status: {status['status']}")
    ```

#### Network Configuration

If running client and server on different computers:

1. **Update Server IP**: In `robot_api.py`, modify the `SERVER_IP` variable:
    ```python
    SERVER_IP = "192.168.1.100"  # Replace with robot controller's IP
    SERVER_PORT = 5001  # Default port (usually no change needed)
    ```

2. **Firewall Settings**: Ensure UDP port 5001 is open on the robot controller computer.

3. **Network Requirements**: 
    - Both computers must be on the same network
    - Low latency recommended for real-time control
    - Command acknowledgments use port 5002 (optional feature)

### Advanced Usage with Acknowledgments

The acknowledgment system allows for sophisticated command management:

```python
from robot_api import *
import time

# Send multiple commands non-blocking
cmd1 = move_robot_joints([90, -45, 90, 0, 45, 180], 
                         duration=3, 
                         wait_for_ack=True, 
                         non_blocking=True)

cmd2 = smooth_circle([200, 0, 200], radius=30, 
                    duration=5, 
                    wait_for_ack=True, 
                    non_blocking=True)

# Monitor both commands
while True:
    status1 = check_command_status(cmd1)
    status2 = check_command_status(cmd2)
    
    if status1 and status1['completed'] and status2 and status2['completed']:
        print("Both commands completed!")
        break
    
    time.sleep(0.1)
```

## 7. Troubleshooting

* **Serial Connection Issues**: Check COM port in Device Manager (Windows) and update `com_port.txt`
* **Command Not Executing**: Verify robot is homed and E-stop is not pressed
* **Tracking Not Working**: Ensure `wait_for_ack=True` is set for commands
* **IK Failures**: Target pose may be unreachable; check robot workspace limits
* **Smooth Motion Errors**: Verify waypoints are reachable and properly formatted

For additional support, refer to the [PAROL commander software repository](https://github.com/PCrnjak/PAROL-commander-software).

Or you can head over to the [PAROL6 Discord channel](https://discord.com/invite/prjUvjmGpZ) for extra support
````

## File: replace_ikine_LMS.py
````python
#!/usr/bin/env python3
# PAROL6 ikine_LMS æ›¿æ¢è„šæœ¬

import os
import re

def replace_in_file(filename, old_pattern, new_pattern):
    """åœ¨æ–‡ä»¶ä¸­æ›¿æ¢å†…å®¹"""
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # å¤‡ä»½åŸæ–‡ä»¶
        backup_filename = filename + '.backup'
        with open(backup_filename, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"âœ… å·²å¤‡ä»½: {backup_filename}")
        
        # æ‰§è¡Œæ›¿æ¢
        new_content = re.sub(old_pattern, new_pattern, content)
        changes = content.count(old_pattern.replace(r'\b', ''))
        
        if changes > 0:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(new_content)
            print(f"âœ… {filename}: æ›¿æ¢äº† {changes} å¤„")
        else:
            print(f"ğŸ“„ {filename}: æ— éœ€æ›¿æ¢")
            
    except Exception as e:
        print(f"âŒ {filename}: æ›¿æ¢å¤±è´¥ - {e}")

# è¦ä¿®æ”¹çš„æ–‡ä»¶åˆ—è¡¨
files_to_modify = [
    "headless_commander.py",
    "PAROL6_ROBOT.py", 
    "smooth_motion.py"
]

print("ğŸ”§ å¼€å§‹æ›¿æ¢ ikine_LMS -> ikine_LM")
for filename in files_to_modify:
    if os.path.exists(filename):
        replace_in_file(filename, r'\bikine_LMS\b', 'ikine_LM')
    else:
        print(f"âš ï¸ æ–‡ä»¶ä¸å­˜åœ¨: {filename}")

print("\nğŸ‰ æ›¿æ¢å®Œæˆï¼")
print("ğŸ’¡ å¦‚æœ ikine_LM ä¸å·¥ä½œï¼Œè¯·å°è¯•æ›¿æ¢ä¸º ik_LM")
````

## File: robot_api.py
````python
"""
Zero-Overhead Robot API with Optional Acknowledgments
======================================================
This version guarantees ZERO resource overhead when tracking is not used.
The tracking system is only initialized when explicitly requested.
"""

import socket
from typing import List, Optional, Literal, Dict, Tuple, Union
import time
import threading
import queue
import uuid
from collections import deque
from datetime import datetime, timedelta

# Global configuration
SERVER_IP = "127.0.0.1"
SERVER_PORT = 5001

# Global tracker - starts as None (no resources)
_command_tracker = None
_tracker_lock = threading.Lock()

# ============================================================================
# ORIGINAL SEND FUNCTION - ZERO OVERHEAD
# ============================================================================

def send_robot_command(command_string: str):
    """
    Original send function - NO TRACKING, NO OVERHEAD.
    This is what gets called for all backward-compatible operations.
    
    Resource usage:
    - No threads
    - No extra sockets
    - No memory allocation
    - Exactly the same as your original implementation
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
            sock.sendto(command_string.encode('utf-8'), (SERVER_IP, SERVER_PORT))
        return f"Successfully sent command: '{command_string[:50]}...'"
    except Exception as e:
        return f"Error sending command: {e}"

# ============================================================================
# TRACKING SYSTEM - ONLY LOADED WHEN NEEDED
# ============================================================================

class LazyCommandTracker:
    """
    Command tracker with lazy initialization.
    Resources are ONLY allocated when tracking is actually used.
    """
    
    def __init__(self, listen_port=5002, history_size=100):
        self.listen_port = listen_port
        self.history_size = history_size
        self.command_history = {}
        self.lock = threading.Lock()
        
        # Lazy initialization flags
        self._initialized = False
        self._thread = None
        self._socket = None
        self._running = False
    
    def _lazy_init(self):
        """
        Initialize resources only when first tracking is requested.
        This is called ONLY when someone uses tracking features.
        """
        if self._initialized:
            return True
            
        try:
            print("[Tracker] First tracking request - initializing resources...")
            
            # Create socket
            self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self._socket.bind(('', self.listen_port))
            self._socket.settimeout(0.1)
            
            # Start thread
            self._running = True
            self._thread = threading.Thread(target=self._listen_loop, daemon=True)
            self._thread.start()
            
            self._initialized = True
            print(f"[Tracker] Initialized on port {self.listen_port}")
            return True
            
        except Exception as e:
            print(f"[Tracker] Failed to initialize: {e}")
            self._cleanup()
            return False
    
    def _cleanup(self):
        """Clean up resources"""
        self._running = False
        if self._thread:
            self._thread.join(timeout=0.5)
            self._thread = None
        if self._socket:
            self._socket.close()
            self._socket = None
        self._initialized = False
    
    def _listen_loop(self):
        """Listener thread - only runs if tracking is used"""
        while self._running:
            try:
                data, addr = self._socket.recvfrom(2048)
                message = data.decode('utf-8')
                
                parts = message.split('|', 3)
                if parts[0] == 'ACK' and len(parts) >= 3:
                    cmd_id = parts[1]
                    status = parts[2]
                    details = parts[3] if len(parts) > 3 else ""
                    
                    with self.lock:
                        if cmd_id in self.command_history:
                            self.command_history[cmd_id].update({
                                'status': status,
                                'details': details,
                                'ack_time': datetime.now(),
                                'completed': status in ['COMPLETED', 'FAILED', 'INVALID', 'CANCELLED']
                            })
                    
                    # Clean old entries (only if we have many)
                    if len(self.command_history) > self.history_size:
                        self._cleanup_old_entries()
                        
            except socket.timeout:
                continue
            except Exception:
                if self._running:
                    pass  # Silently continue
    
    def _cleanup_old_entries(self):
        """Remove old entries to prevent memory growth"""
        with self.lock:
            now = datetime.now()
            expired = [cmd_id for cmd_id, info in self.command_history.items()
                      if now - info['sent_time'] > timedelta(seconds=30)]
            for cmd_id in expired:
                del self.command_history[cmd_id]
    
    def track_command(self, command: str) -> Tuple[str, str]:
        """
        Track a command - initializes tracker if needed.
        Returns (modified_command, cmd_id)
        """
        # Initialize on first use
        if not self._initialized:
            if not self._lazy_init():
                # Initialization failed - fall back to non-tracking
                return command, None
        
        # Generate ID and modify command
        cmd_id = str(uuid.uuid4())[:8]
        tracked_command = f"{cmd_id}|{command}"
        
        # Register in history
        with self.lock:
            self.command_history[cmd_id] = {
                'command': command,
                'sent_time': datetime.now(),
                'status': 'SENT',
                'details': '',
                'completed': False
            }
        
        return tracked_command, cmd_id
    
    def get_status(self, cmd_id: str) -> Optional[Dict]:
        """Get status if tracker is initialized"""
        if not self._initialized:
            return None
        with self.lock:
            return self.command_history.get(cmd_id, None)
    
    def wait_for_completion(self, cmd_id: str, timeout: float = 5.0) -> Dict:
        """Wait for completion if tracker is initialized"""
        if not self._initialized:
            return {'status': 'NO_TRACKING', 'details': 'Tracker not initialized', 'completed': True}
            
        start_time = time.time()
        while time.time() - start_time < timeout:
            status = self.get_status(cmd_id)
            if status and status['completed']:
                return status
            time.sleep(0.01)
        
        return self.get_status(cmd_id) or {
            'status': 'TIMEOUT',
            'details': 'No acknowledgment received',
            'completed': True
        }
    
    def is_active(self) -> bool:
        """Check if tracker is initialized and running"""
        return self._initialized and self._running

# ============================================================================
# LAZY TRACKER ACCESS
# ============================================================================

def _get_tracker_if_needed() -> Optional[LazyCommandTracker]:
    """
    Get tracker ONLY if tracking is requested.
    This ensures zero overhead for non-tracking operations.
    """
    global _command_tracker, _tracker_lock
    
    # Fast path - tracker already exists
    if _command_tracker is not None:
        return _command_tracker
    
    # Slow path - create tracker (only happens once)
    with _tracker_lock:
        if _command_tracker is None:
            _command_tracker = LazyCommandTracker()
        return _command_tracker

# ============================================================================
# ENHANCED SEND WITH OPTIONAL TRACKING
# ============================================================================

def send_robot_command_tracked(command_string: str) -> Tuple[str, Optional[str]]:
    """
    Send with tracking - initializes tracker on first use.
    
    Resource impact:
    - First call: Starts tracker thread
    - Subsequent calls: Minimal overhead (UUID generation)
    """
    tracker = _get_tracker_if_needed()
    if tracker:
        tracked_cmd, cmd_id = tracker.track_command(command_string)
        if cmd_id:
            # Send tracked command
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                    sock.sendto(tracked_cmd.encode('utf-8'), (SERVER_IP, SERVER_PORT))
                return f"Command sent with tracking (ID: {cmd_id})", cmd_id
            except Exception as e:
                return f"Error: {e}", None
    
    # Fall back to non-tracked
    return send_robot_command(command_string), None

def send_and_wait(
    command_string: str, 
    timeout: float = 2.0, 
    non_blocking: bool = False
    ) -> Union[Dict, str, None]:
    """
    Send and wait for acknowledgment OR return a command_id immediately.
    First use initializes tracker.
    """
    result, cmd_id = send_robot_command_tracked(command_string)
    
    if cmd_id:
        # If non_blocking is True, return the ID right away
        if non_blocking:
            return cmd_id
            
        # Otherwise, proceed with the original blocking logic
        tracker = _get_tracker_if_needed()
        if tracker:
            status_dict = tracker.wait_for_completion(cmd_id, timeout)
            # Add the command_id to the returned dictionary
            status_dict['command_id'] = cmd_id
            return status_dict
    
    # Handle cases where a command_id could not be generated
    if non_blocking:
        return None
    else:
        return {'status': 'NO_TRACKING', 'details': result, 'completed': True, 'command_id': None}

# ============================================================================
# BACKWARD COMPATIBLE MOVEMENT FUNCTIONS - ZERO OVERHEAD BY DEFAULT
# ============================================================================

def move_robot_joints(
    joint_angles: List[float],
    duration: Optional[float] = None,
    speed_percentage: Optional[int] = None,
    wait_for_ack: bool = False,  # Default: No tracking, no overhead
    timeout: float = 2.0,
    non_blocking: bool = False
):
    """
    Move robot joints.
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    # Validation
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either a duration or a speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    # Build command
    angles_str = "|".join(map(str, joint_angles))
    duration_str = str(duration) if duration is not None else "None"
    speed_str = str(speed_percentage) if speed_percentage is not None else "None"
    command = f"MOVEJOINT|{angles_str}|{duration_str}|{speed_str}"
    
    # Send with or without tracking
    if wait_for_ack:
        # User explicitly requested tracking - initialize if needed
        return send_and_wait(command, timeout, non_blocking)
    else:
        # Default path - NO TRACKING, NO OVERHEAD
        return send_robot_command(command)

def move_robot_pose(
    pose: List[float],
    duration: Optional[float] = None,
    speed_percentage: Optional[int] = None,
    wait_for_ack: bool = False,  # Default: No tracking
    timeout: float = 2.,
    non_blocking: bool = False
):
    """
    Move to pose - zero overhead by default.
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either a duration or a speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    pose_str = "|".join(map(str, pose))
    duration_str = str(duration) if duration is not None else "None"
    speed_str = str(speed_percentage) if speed_percentage is not None else "None"
    command = f"MOVEPOSE|{pose_str}|{duration_str}|{speed_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)
    
def jog_robot_joint(
    joint_index: int,
    speed_percentage: int,
    duration: Optional[float] = None,
    distance_deg: Optional[float] = None,
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
):
    """
    Jogs a single robot joint for a specified time or distance.
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    if duration is None and distance_deg is None:
        error = "Error: You must provide either a duration or a distance_deg."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    if duration is not None:
        try:
            duration = float(duration)
        except (ValueError, TypeError):
            error = "Error: Duration must be a valid number."
            return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    duration_str = str(duration) if duration is not None else "None"
    distance_str = str(distance_deg) if distance_deg is not None else "None"
    command = f"JOG|{joint_index}|{speed_percentage}|{duration_str}|{distance_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def jog_multiple_joints(
    joints: List[int], 
    speeds: List[float], 
    duration: float,
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
) -> str:
    """
    Jogs multiple robot joints simultaneously for a specified duration.

    Args:
        joints: List of joint indices (0-5 for positive, 6-11 for negative)
        speeds: List of corresponding speeds (1-100%)
        duration: Duration of the jog in seconds
        wait_for_ack: Enable command tracking (default False)
        timeout: Timeout for acknowledgment
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    if len(joints) != len(speeds):
        error = "Error: The number of joints must match the number of speeds."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    joints_str = ",".join(map(str, joints))
    speeds_str = ",".join(map(str, speeds))
    command = f"MULTIJOG|{joints_str}|{speeds_str}|{duration}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def jog_cartesian(
    frame: Literal['TRF', 'WRF'],
    axis: Literal['X+', 'X-', 'Y+', 'Y-', 'Z+', 'Z-', 'RX+', 'RX-', 'RY+', 'RY-', 'RZ+', 'RZ-'],
    speed_percentage: int,
    duration: float,
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
):
    """
    Jogs the robot's end-effector continuously in Cartesian space.
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    if duration is not None:
        try:
            duration = float(duration)
        except (ValueError, TypeError):
            error = "Error: Duration must be a valid number."
            return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    command = f"CARTJOG|{frame}|{axis}|{speed_percentage}|{duration}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def move_robot_cartesian(
    pose: List[float],
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
) -> str:
    """
    Moves the robot's end-effector to a specific Cartesian pose in a straight line.
    
    Args:
        pose: Target pose as [x, y, z, r, p, y] (mm and degrees)
        duration: Total time for the movement in seconds
        speed_percentage: Movement speed as a percentage (1-100)
        wait_for_ack: Enable command tracking (default False)
        timeout: Timeout for acknowledgment
        
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    # Validate timing arguments
    if (duration is None and speed_percentage is None):
        error = "Error: You must provide either 'duration' or 'speed_percentage'."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    if (duration is not None and speed_percentage is not None):
        error = "Error: Please provide either 'duration' or 'speed_percentage', not both."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    # Prepare command arguments
    duration_arg = 'NONE'
    speed_arg = 'NONE'
    
    if duration is not None:
        try:
            if float(duration) <= 0:
                error = "Error: Duration must be a positive number."
                return {'status': 'INVALID', 'details': error} if wait_for_ack else error
            duration_arg = str(duration)
        except (ValueError, TypeError):
            error = "Error: Duration must be a valid number."
            return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    if speed_percentage is not None:
        try:
            speed_val = float(speed_percentage)
            if not (0 < speed_val <= 100):
                error = "Error: Speed percentage must be between 1 and 100."
                return {'status': 'INVALID', 'details': error} if wait_for_ack else error
            speed_arg = str(speed_val)
        except (ValueError, TypeError):
            error = "Error: Speed percentage must be a valid number."
            return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    # Construct command
    pose_str = "|".join(map(str, pose))
    command = f"MOVECART|{pose_str}|{duration_arg}|{speed_arg}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def control_pneumatic_gripper(
    action: Literal['open', 'close'], 
    port: Literal[1, 2],
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
):
    """
    Controls the pneumatic gripper.
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    command = f"PNEUMATICGRIPPER|{action}|{port}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def control_electric_gripper(
    action: Literal['move', 'calibrate'],
    position: Optional[int] = 255,
    speed: Optional[int] = 150,
    current: Optional[int] = 500,
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
):
    """
    Controls the electric gripper.
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    action_str = "move" if action == 'move' else 'calibrate'
    command = f"ELECTRICGRIPPER|{action_str}|{position}|{speed}|{current}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)
    
# ============================================================================
# SMOOTH MOTION COMMANDS - WITH START POSITION AND DUAL TIMING SUPPORT
# ============================================================================

def smooth_circle(
    center: List[float],
    radius: float,
    plane: Literal['XY', 'XZ', 'YZ'] = 'XY',
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    clockwise: bool = False,
    wait_for_ack: bool = False,
    timeout: float = 10.0,
    non_blocking: bool = False
):
    """
    Execute a smooth circular motion.
    
    Args:
        center: [x, y, z] center point in mm
        radius: Circle radius in mm
        plane: Plane of the circle ('XY', 'XZ', or 'YZ')
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose (mm and degrees).
                   If None, starts from current position.
        duration: Time to complete the circle in seconds
        speed_percentage: Speed as percentage (1-100)
        clockwise: Direction of motion
        wait_for_ack: Enable command tracking (default False)
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead
    - wait_for_ack=True: Initializes tracker on first use
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either duration or speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    center_str = ",".join(map(str, center))
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    clockwise_str = "1" if clockwise else "0"
    
    # Format timing
    if duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    command = f"SMOOTH_CIRCLE|{center_str}|{radius}|{plane}|{frame}|{start_str}|{timing_str}|{clockwise_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def smooth_arc_center(
    end_pose: List[float],
    center: List[float],
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    clockwise: bool = False,
    wait_for_ack: bool = False,
    timeout: float = 10.0,
    non_blocking: bool = False
):
    """
    Execute a smooth arc motion defined by center point.
    
    Args:
        end_pose: [x, y, z, rx, ry, rz] end pose (mm and degrees)
        center: [x, y, z] arc center point in mm
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose.
                   If None, starts from current position.
                   If specified, adds smooth transition from current position.
        duration: Time to complete the arc in seconds
        speed_percentage: Speed as percentage (1-100)
        clockwise: Direction of motion
        wait_for_ack: Enable command tracking
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either duration or speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    end_str = ",".join(map(str, end_pose))
    center_str = ",".join(map(str, center))
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    clockwise_str = "1" if clockwise else "0"
    
    # Format timing
    if duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    command = f"SMOOTH_ARC_CENTER|{end_str}|{center_str}|{frame}|{start_str}|{timing_str}|{clockwise_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def smooth_arc_parametric(
    end_pose: List[float],
    radius: float,
    arc_angle: float,
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    clockwise: bool = False,
    wait_for_ack: bool = False,
    timeout: float = 10.0,
    non_blocking: bool = False
):
    """
    Execute a smooth arc motion defined by radius and angle.
    
    Args:
        end_pose: [x, y, z, rx, ry, rz] end pose (mm and degrees)
        radius: Arc radius in mm
        arc_angle: Arc angle in degrees
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose.
                   If None, starts from current position.
        duration: Time to complete the arc in seconds
        speed_percentage: Speed as percentage (1-100)
        clockwise: Direction of motion
        wait_for_ack: Enable command tracking
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either duration or speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    end_str = ",".join(map(str, end_pose))
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    clockwise_str = "1" if clockwise else "0"
    
    # Format timing
    if duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    command = f"SMOOTH_ARC_PARAM|{end_str}|{radius}|{arc_angle}|{frame}|{start_str}|{timing_str}|{clockwise_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def smooth_spline(
    waypoints: List[List[float]],
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    wait_for_ack: bool = False,
    timeout: float = 10.0,
    non_blocking: bool = False
):
    """
    Execute a smooth spline motion through waypoints.
    
    Args:
        waypoints: List of [x, y, z, rx, ry, rz] poses (mm and degrees)
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose.
                   If None, starts from current position.
                   If specified and different from first waypoint, adds transition.
        duration: Total time for the motion in seconds
        speed_percentage: Speed as percentage (1-100)
        wait_for_ack: Enable command tracking
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either duration or speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    num_waypoints = len(waypoints)
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    
    # Format timing
    if duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    # Format waypoints - flatten each waypoint's 6 values
    waypoint_strs = []
    for wp in waypoints:
        waypoint_strs.extend(map(str, wp))
    
    # Build command
    command_parts = [f"SMOOTH_SPLINE", str(num_waypoints), frame, start_str, timing_str]
    command_parts.extend(waypoint_strs)
    command = "|".join(command_parts)
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def smooth_helix(
    center: List[float],
    radius: float,
    pitch: float,
    height: float,
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    clockwise: bool = False,
    wait_for_ack: bool = False,
    timeout: float = 10.0,
    non_blocking: bool = False
):
    """
    Execute a smooth helical motion.
    
    Args:
        center: [x, y, z] helix center point in mm
        radius: Helix radius in mm
        pitch: Vertical distance per revolution in mm
        height: Total height of helix in mm
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose.
                   If None, starts from current position on helix perimeter.
        duration: Time to complete the helix in seconds
        speed_percentage: Speed as percentage (1-100)
        clockwise: Direction of motion
        wait_for_ack: Enable command tracking
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either duration or speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    center_str = ",".join(map(str, center))
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    clockwise_str = "1" if clockwise else "0"
    
    # Format timing
    if duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    command = f"SMOOTH_HELIX|{center_str}|{radius}|{pitch}|{height}|{frame}|{start_str}|{timing_str}|{clockwise_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def smooth_blend(
    segments: List[Dict],
    blend_time: float = 0.5,
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    wait_for_ack: bool = False,
    timeout: float = 15.0,
    non_blocking: bool = False
):
    """
    Execute a blended motion through multiple segments.
    
    Args:
        segments: List of segment dictionaries, each containing:
            - 'type': 'LINE', 'CIRCLE', 'ARC', or 'SPLINE'
            - Additional parameters based on type
        blend_time: Time to blend between segments in seconds
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose for first segment.
                   If None, starts from current position.
        duration: Total time for entire motion (scales all segments proportionally)
        speed_percentage: Speed as percentage (1-100) for entire motion
        wait_for_ack: Enable command tracking
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
        
    Example:
        segments = [
            {'type': 'LINE', 'end': [x,y,z,rx,ry,rz], 'duration': 2.0},
            {'type': 'CIRCLE', 'center': [x,y,z], 'radius': 50, 'plane': 'XY', 
             'duration': 3.0, 'clockwise': False},
            {'type': 'ARC', 'end': [x,y,z,rx,ry,rz], 'center': [x,y,z], 
             'duration': 2.0, 'clockwise': True}
        ]
    """
    num_segments = len(segments)
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    
    # Format timing
    if duration is None and speed_percentage is None:
        # Use individual segment durations
        timing_str = "DEFAULT"
    elif duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    # Format segments
    segment_strs = []
    for seg in segments:
        seg_type = seg['type']
        
        if seg_type == 'LINE':
            end_str = ",".join(map(str, seg['end']))
            seg_str = f"LINE|{end_str}|{seg.get('duration', 2.0)}"
            
        elif seg_type == 'CIRCLE':
            center_str = ",".join(map(str, seg['center']))
            clockwise_str = "1" if seg.get('clockwise', False) else "0"
            seg_str = f"CIRCLE|{center_str}|{seg['radius']}|{seg['plane']}|{seg.get('duration', 3.0)}|{clockwise_str}"
            
        elif seg_type == 'ARC':
            end_str = ",".join(map(str, seg['end']))
            center_str = ",".join(map(str, seg['center']))
            clockwise_str = "1" if seg.get('clockwise', False) else "0"
            seg_str = f"ARC|{end_str}|{center_str}|{seg.get('duration', 2.0)}|{clockwise_str}"
            
        elif seg_type == 'SPLINE':
            waypoints_str = ";".join([",".join(map(str, wp)) for wp in seg['waypoints']])
            seg_str = f"SPLINE|{len(seg['waypoints'])}|{waypoints_str}|{seg.get('duration', 3.0)}"
            
        else:
            continue
            
        segment_strs.append(seg_str)
    
    # Build command with || separators between segments
    command = f"SMOOTH_BLEND|{num_segments}|{blend_time}|{frame}|{start_str}|{timing_str}|" + "||".join(segment_strs)
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

# ============================================================================
# CONVENIENCE FUNCTIONS FOR SMOOTH MOTION CHAINS
# ============================================================================

def chain_smooth_motions(
    motions: List[Dict],
    ensure_continuity: bool = True,
    frame: Literal['WRF', 'TRF'] = 'WRF',  # ADD THIS
    wait_for_ack: bool = True,
    timeout: float = 30.0
):
    """
    Chain multiple smooth motions together with automatic continuity.
    
    Args:
        motions: List of motion dictionaries, each with 'type' and parameters
        ensure_continuity: If True, automatically sets start_pose of each motion
                          to end of previous motion for perfect continuity
        frame: Reference frame for all motions ('WRF' or 'TRF')  # ADD THIS
        wait_for_ack: Enable command tracking
        timeout: Timeout per motion
        
    Example:
        chain_smooth_motions([
            {'type': 'circle', 'center': [200, 0, 200], 'radius': 50, 'duration': 5},
            {'type': 'arc', 'end_pose': [250, 50, 200, 0, 0, 90], 'center': [225, 25, 200], 'duration': 3},
            {'type': 'helix', 'center': [250, 50, 150], 'radius': 30, 'pitch': 20, 'height': 100, 'duration': 8}
        ], frame='TRF')  # Can now specify frame
    """
    results = []
    last_end_pose = None
    
    for i, motion in enumerate(motions):
        motion_type = motion.get('type', '').lower()
        
        # Add frame to motion parameters
        motion['frame'] = frame
        
        # Add start_pose from previous motion if ensuring continuity
        if ensure_continuity and last_end_pose and i > 0:
            motion['start_pose'] = last_end_pose
        
        # Execute the appropriate motion (add frame parameter to each call)
        if motion_type == 'circle':
            result = smooth_circle(**{k: v for k, v in motion.items() if k != 'type'}, 
                                  wait_for_ack=wait_for_ack, timeout=timeout)
            last_end_pose = None  # Circles return to start
            
        elif motion_type == 'arc' or motion_type == 'arc_center':
            result = smooth_arc_center(**{k: v for k, v in motion.items() if k != 'type'},
                                      wait_for_ack=wait_for_ack, timeout=timeout)
            last_end_pose = motion.get('end_pose')
            
        elif motion_type == 'arc_param' or motion_type == 'arc_parametric':
            result = smooth_arc_parametric(**{k: v for k, v in motion.items() if k != 'type'},
                                          wait_for_ack=wait_for_ack, timeout=timeout)
            last_end_pose = motion.get('end_pose')
            
        elif motion_type == 'spline':
            result = smooth_spline(**{k: v for k, v in motion.items() if k != 'type'},
                                  wait_for_ack=wait_for_ack, timeout=timeout)
            waypoints = motion.get('waypoints', [])
            last_end_pose = waypoints[-1] if waypoints else None
            
        elif motion_type == 'helix':
            result = smooth_helix(**{k: v for k, v in motion.items() if k != 'type'},
                                 wait_for_ack=wait_for_ack, timeout=timeout)
            last_end_pose = None
            
        else:
            result = {'status': 'INVALID', 'details': f'Unknown motion type: {motion_type}'}
        
        results.append(result)
        
        # Check for failures if tracking
        if wait_for_ack and isinstance(result, dict) and result.get('status') == 'FAILED':
            print(f"Motion {i+1} failed: {result.get('details')}")
            break
    
    return results

def execute_trajectory(
    trajectory: List[List[float]],
    timing_mode: Literal['duration', 'speed'] = 'duration',
    timing_value: float = 5.0,
    motion_type: Literal['spline', 'linear'] = 'spline',
    frame: Literal['WRF', 'TRF'] = 'WRF',  # ADD THIS
    wait_for_ack: bool = True,
    timeout: float = 30.0,
):
    """
    High-level function to execute a trajectory using the best method.
    
    Args:
        trajectory: List of poses [x, y, z, rx, ry, rz]
        timing_mode: 'duration' for total time, 'speed' for percentage
        timing_value: Duration in seconds or speed percentage
        motion_type: 'spline' for smooth curves, 'linear' for point-to-point
        frame: Reference frame ('WRF' or 'TRF')  # ADD THIS
        wait_for_ack: Enable command tracking (recommended for trajectories)
        timeout: Timeout for acknowledgment
    """
    if motion_type == 'spline':
        if timing_mode == 'duration':
            return smooth_spline(trajectory, frame=frame, duration=timing_value,  # ADD frame
                               wait_for_ack=wait_for_ack, timeout=timeout)
        else:
            return smooth_spline(trajectory, frame=frame, speed_percentage=timing_value,  # ADD frame
                               wait_for_ack=wait_for_ack, timeout=timeout)
    else:
        # Linear motion - send as individual move commands
        results = []
        for pose in trajectory:
            if timing_mode == 'duration':
                segment_duration = timing_value / len(trajectory)
                # Note: move_robot_cartesian doesn't support TRF, only smooth motions do
                result = move_robot_cartesian(pose, duration=segment_duration,
                                             wait_for_ack=wait_for_ack, timeout=timeout)
            else:
                result = move_robot_cartesian(pose, speed_percentage=timing_value,
                                             wait_for_ack=wait_for_ack, timeout=timeout)
            results.append(result)
            
            # Check for failures if tracking
            if wait_for_ack and result.get('status') == 'FAILED':
                break
        
        return results

# ============================================================================
# BASIC FUNCTIONS
# ============================================================================

def delay_robot(duration: float, wait_for_ack: bool = False, timeout: float = 2.0, non_blocking: bool = False):
    """Delay - optional tracking"""
    command = f"DELAY|{duration}"
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def home_robot(wait_for_ack: bool = False, timeout: float = 30.0, non_blocking: bool = False):
    """Home robot - optional tracking (longer timeout for homing)"""
    command = "HOME"
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def stop_robot_movement(wait_for_ack: bool = False, timeout: float = 2.0, non_blocking: bool = False):
    """Stop robot - optional tracking"""
    command = "STOP"
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

# ============================================================================
# GET FUNCTIONS - ZERO OVERHEAD, IMMEDIATE RESPONSE
# ============================================================================

def get_robot_pose():
    """
    Get the robot's current end-effector pose.
    Returns [x, y, z, roll, pitch, yaw] or None if it fails.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_POSE"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(2048)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'POSE' and len(parts) == 2:
                pose_values = [float(v) for v in parts[1].split(',')]
                if len(pose_values) == 16:
                    # Convert 4x4 matrix to [x,y,z,r,p,y]
                    import numpy as np
                    from spatialmath import SE3
                    
                    pose_matrix = np.array(pose_values).reshape((4, 4))
                    T = SE3(pose_matrix, check=False)
                    xyz_mm = T.t * 1000  # Convert to mm
                    rpy_deg = T.rpy(unit='deg', order='xyz')
                    
                    # Convert numpy float64 to regular Python floats
                    return [float(x) for x in xyz_mm] + [float(r) for r in rpy_deg]
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for pose response")
        return None
    except Exception as e:
        print(f"Error getting robot pose: {e}")
        return None

def get_robot_joint_angles():
    """
    Get the robot's current joint angles in degrees.
    Returns list of 6 angles or None if it fails.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_ANGLES"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(1024)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'ANGLES' and len(parts) == 2:
                angles = [float(v) for v in parts[1].split(',')]
                return angles
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for angles response")
        return None
    except Exception as e:
        print(f"Error getting robot angles: {e}")
        return None

def get_robot_io(verbose = False):
    """
    Get the robot's current digital I/O status.
    Returns [IN1, IN2, OUT1, OUT2, ESTOP] or None if it fails.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_IO"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(1024)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'IO' and len(parts) == 2:
                io_values = [int(v) for v in parts[1].split(',')]

                if verbose:
                    print("--- I/O Status ---")
                    print(f"  IN1:   {io_values[0]} | {'ON' if io_values[0] else 'OFF'}")
                    print(f"  IN2:   {io_values[1]} | {'ON' if io_values[1] else 'OFF'}")
                    print(f"  OUT1:  {io_values[2]} | {'ON' if io_values[2] else 'OFF'}")
                    print(f"  OUT2:  {io_values[3]} | {'ON' if io_values[3] else 'OFF'}")
                    # More intuitive E-stop display
                    if io_values[4] == 0:
                        print(f"  ESTOP: {io_values[4]} | PRESSED (Emergency Stop Active!)")
                    else:
                        print(f"  ESTOP: {io_values[4]} | OK (Normal Operation)")
                    print("--------------------------")

                return io_values
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for I/O response")
        return None
    except Exception as e:
        print(f"Error getting robot I/O: {e}")
        return None

def get_electric_gripper_status(verbose = False):
    """
    Get the electric gripper's current status.
    Returns [ID, Position, Speed, Current, StatusByte, ObjectDetected] or None.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_GRIPPER"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(1024)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'GRIPPER' and len(parts) == 2:
                gripper_values = [int(v) for v in parts[1].split(',')]
                
                # Decode the status byte
                status_byte = gripper_values[4] if len(gripper_values) > 4 else 0
                is_active = (status_byte & 0b00000001) != 0
                is_moving = (status_byte & 0b00000010) != 0
                is_calibrated = (status_byte & 0b10000000) != 0
                
                # Interpret object detection
                object_detection = gripper_values[5] if len(gripper_values) > 5 else 0
                if object_detection == 1:
                    detection_text = "Yes (closing)"
                elif object_detection == 2:
                    detection_text = "Yes (opening)"
                else:
                    detection_text = "No"


                if verbose:
                    # Print formatted status
                    print("--- Electric Gripper Status ---")
                    print(f"  Device ID:         {gripper_values[0]}")
                    print(f"  Current Position:  {gripper_values[1]}")
                    print(f"  Current Speed:     {gripper_values[2]}")
                    print(f"  Current Current:   {gripper_values[3]}")
                    print(f"  Object Detected:   {detection_text}")
                    print(f"  Status Byte:       {bin(status_byte)}")
                    print(f"    - Calibrated:    {is_calibrated}")
                    print(f"    - Active:        {is_active}")
                    print(f"    - Moving:        {is_moving}")
                    print("-------------------------------")
                
                return gripper_values
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for gripper response")
        return None
    except Exception as e:
        print(f"Error getting gripper status: {e}")
        return None

def get_robot_joint_speeds():
    """
    Get the robot's current joint speeds in steps/sec.
    Returns list of 6 speed values or None if it fails.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_SPEEDS"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(1024)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'SPEEDS' and len(parts) == 2:
                speeds = [float(v) for v in parts[1].split(',')]
                return speeds
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for speeds response")
        return None
    except Exception as e:
        print(f"Error getting robot speeds: {e}")
        return None

def get_robot_pose_matrix():
    """
    Get the robot's current pose as a 4x4 transformation matrix.
    Returns 4x4 numpy array or None if it fails.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_POSE"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(2048)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'POSE' and len(parts) == 2:
                pose_values = [float(v) for v in parts[1].split(',')]
                if len(pose_values) == 16:
                    import numpy as np
                    return np.array(pose_values).reshape((4, 4))
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for pose response")
        return None
    except Exception as e:
        print(f"Error getting robot pose matrix: {e}")
        return None

def is_robot_stopped(threshold_speed: float = 2.0) -> bool:
    """
    Check if the robot has stopped moving.
    
    Args:
        threshold_speed: Speed threshold in steps/sec
        
    Returns:
        True if all joints below threshold, False otherwise
        
    Resource usage: ZERO overhead - simple request/response
    """
    speeds = get_robot_joint_speeds()
    if not speeds:
        return False
    
    max_speed = max(abs(s) for s in speeds)
    return max_speed < threshold_speed

def is_estop_pressed() -> bool:
    """
    Check if the E-stop is currently pressed.
    
    Returns:
        True if E-stop is pressed, False otherwise
        
    Resource usage: ZERO overhead - simple request/response
    """
    io_status = get_robot_io()
    if io_status and len(io_status) >= 5:
        return io_status[4] == 0  # E-stop is at index 4, 0 means pressed
    return False

def get_robot_status() -> Dict:
    """
    Get comprehensive robot status in one call.
    
    Returns:
        Dictionary with pose, angles, speeds, IO, gripper status
        
    Resource usage: Multiple requests but still zero overhead
    """
    return {
        'pose': get_robot_pose(),
        'angles': get_robot_joint_angles(),
        'speeds': get_robot_joint_speeds(),
        'io': get_robot_io(),
        'gripper': get_electric_gripper_status(),
        'stopped': is_robot_stopped(),
        'estop': is_estop_pressed()
    }

# ============================================================================
# TRACKING FUNCTIONS - ONLY FOR EXPLICIT USE
# ============================================================================

def check_command_status(command_id: str) -> Optional[Dict]:
    """
    Check status - returns None if tracker not initialized.
    Does NOT initialize tracker (read-only).
    """
    if _command_tracker and _command_tracker.is_active():
        return _command_tracker.get_status(command_id)
    return None

def is_tracking_active() -> bool:
    """
    Check if tracking is active.
    Returns False if never used (zero overhead check).
    """
    return _command_tracker is not None and _command_tracker.is_active()

def get_tracking_stats() -> Dict:
    """
    Get resource usage statistics.
    """
    if _command_tracker and _command_tracker.is_active():
        with _command_tracker.lock:
            return {
                'active': True,
                'commands_tracked': len(_command_tracker.command_history),
                'memory_bytes': len(str(_command_tracker.command_history)),
                'thread_active': _command_tracker._thread.is_alive() if _command_tracker._thread else False
            }
    else:
        return {
            'active': False,
            'commands_tracked': 0,
            'memory_bytes': 0,
            'thread_active': False
        }

# ============================================================================
# CONVENIENCE FUNCTIONS FOR COMMON OPERATIONS
# ============================================================================

def wait_for_robot_stopped(timeout: float = 10.0, poll_rate: float = 0.1) -> bool:
    """
    Wait for the robot to stop moving.
    
    Args:
        timeout: Maximum time to wait in seconds
        poll_rate: How often to check in seconds
        
    Returns:
        True if robot stopped, False if timeout
    """
    import time
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        if is_robot_stopped():
            return True
        time.sleep(poll_rate)
    
    return False

def safe_move_with_retry(
    move_func,
    *args,
    max_retries: int = 3,
    retry_delay: float = 1.0,
    **kwargs
):
    """
    Execute a move command with automatic retry on failure.
    
    Args:
        move_func: The movement function to call
        *args: Arguments for the movement function
        max_retries: Maximum number of retry attempts
        retry_delay: Delay between retries in seconds
        **kwargs: Keyword arguments for the movement function
        
    Returns:
        Result from the movement function or error dict
    """
    import time
    
    # Ensure tracking is enabled for retry logic
    kwargs['wait_for_ack'] = True
    
    for attempt in range(max_retries):
        result = move_func(*args, **kwargs)
        
        if isinstance(result, dict):
            if result.get('status') in ['COMPLETED', 'QUEUED', 'EXECUTING']:
                return result
            elif result.get('status') in ['FAILED', 'TIMEOUT', 'CANCELLED']:
                if attempt < max_retries - 1:
                    print(f"Attempt {attempt + 1} failed: {result.get('details', 'Unknown error')}")
                    print(f"Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                else:
                    print(f"All {max_retries} attempts failed")
                    return result
        else:
            # Non-tracked response, assume success
            return result
    
    return {'status': 'FAILED', 'details': f'Failed after {max_retries} attempts'}
````

## File: run_headless_complete_fix.py
````python
#!/usr/bin/env python3
"""
PAROL6 Headless Commander å®Œæ•´ä¿®å¤ç‰ˆ
ä¿®å¤æ‰€æœ‰Linuxä¸²å£ç›¸å…³é—®é¢˜ï¼ŒåŒ…æ‹¬com_port_strå˜é‡å®šä¹‰
"""
import os
import sys
import platform
import serial
import serial.tools.list_ports
import time

def init_serial_connection():
    """åˆå§‹åŒ–ä¸²å£è¿æ¥å¹¶è¿”å›ä¸²å£å¯¹è±¡å’Œç«¯å£å­—ç¬¦ä¸²"""
    print("ğŸ”§ Initializing serial connection for Linux...")
    
    ser = None
    com_port_str = None
    
    # å°è¯•ä»æ–‡ä»¶è¯»å–ä¸²å£é…ç½®
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"âœ… Connected to saved serial port: {com_port_str}")
            return ser, com_port_str
    except (FileNotFoundError, serial.SerialException) as e:
        print(f"âš ï¸ Could not connect to saved port: {e}")
    
    # å°è¯•é»˜è®¤ç«¯å£
    default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
    print("ğŸ” Trying default ports...")
    
    for port in default_ports:
        if os.path.exists(port):
            try:
                ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                com_port_str = port
                print(f"âœ… Successfully connected to {port}")
                # ä¿å­˜æˆåŠŸçš„ç«¯å£åˆ°æ–‡ä»¶
                with open("com_port.txt", "w") as f:
                    f.write(port)
                return ser, com_port_str
            except serial.SerialException as e:
                print(f"âŒ Failed to connect to {port}: {e}")
                continue
        else:
            print(f"âš ï¸ Port {port} does not exist")
    
    # å¦‚æœéƒ½å¤±è´¥äº†ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
    print("\nâŒ Could not connect to any serial port.")
    print("\nAvailable serial ports:")
    ports = serial.tools.list_ports.comports()
    if ports:
        for port in ports:
            print(f"  ğŸ“¡ {port.device} - {port.description}")
    else:
        print("  No serial ports detected!")
    
    print("\nğŸ”§ Troubleshooting:")
    print("1. Make sure the robot is connected and powered on")
    print("2. Check if user has permission to access serial ports:")
    print("   sudo usermod -a -G dialout $USER")
    print("   (then logout and login again)")
    print("3. Try running with sudo (temporary fix):")
    print("   sudo -E python run_headless_complete_fix.py")
    
    return None, None

def patch_and_run_original():
    """è¯»å–ã€ä¿®å¤å¹¶è¿è¡ŒåŸå§‹è„šæœ¬"""
    # åˆå§‹åŒ–ä¸²å£è¿æ¥
    ser, com_port_str = init_serial_connection()
    
    if ser is None or com_port_str is None:
        print("âŒ Failed to initialize serial connection. Exiting.")
        sys.exit(1)
    
    print(f"âœ… Serial connection established: {ser.port}")
    
    # è¯»å–åŸå§‹è„šæœ¬
    with open('headless_commander.py', 'r') as f:
        script_content = f.read()
    
    # åˆ›å»ºä¿®å¤åçš„å…¨å±€å‘½åç©ºé—´
    script_globals = globals().copy()
    script_globals.update({
        'ser': ser,
        'com_port_str': com_port_str,
        'my_os': platform.system()
    })
    
    print("ğŸš€ Starting PAROL6 headless commander...")
    print(f"ğŸ“¡ Using serial port: {com_port_str}")
    print("ğŸ”„ Press Ctrl+C to stop\n")
    
    try:
        # æ‰§è¡ŒåŸå§‹è„šæœ¬
        exec(script_content, script_globals)
    except KeyboardInterrupt:
        print("\nâ¹ï¸ Program interrupted by user")
    except Exception as e:
        print(f"\nâŒ Error running program: {e}")
        import traceback
        traceback.print_exc()
    finally:
        # æ¸…ç†ä¸²å£è¿æ¥
        if ser and ser.is_open:
            print("ğŸ”Œ Closing serial connection...")
            ser.close()

if __name__ == "__main__":
    print("ğŸ¤– PAROL6 Headless Commander - Linux Complete Fix")
    print("=" * 50)
    
    # æ£€æŸ¥æ˜¯å¦åœ¨Linuxç³»ç»Ÿä¸Š
    if platform.system() == "Windows":
        print("â„¹ï¸ This is a Linux-specific fix. On Windows, run headless_commander.py directly.")
        sys.exit(1)
    
    # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if not os.path.exists('headless_commander.py'):
        print("âŒ headless_commander.py not found in current directory!")
        sys.exit(1)
    
    patch_and_run_original()
````

## File: run_headless_fixed.py
````python
#!/usr/bin/env python3
"""
PAROL6 Headless Commander å¯åŠ¨å™¨ - Linuxä¿®å¤ç‰ˆ
ä¿®å¤åŸå§‹è„šæœ¬ä¸­ç¼ºå°‘Linuxä¸²å£åˆå§‹åŒ–çš„é—®é¢˜
"""
import os
import sys
import platform
import serial
import serial.tools.list_ports

def init_serial():
    """åˆå§‹åŒ–ä¸²å£è¿æ¥"""
    print("Initializing serial connection...")
    
    my_os = platform.system()
    ser = None
    
    if my_os != "Windows":
        # Linux/Macç³»ç»Ÿ
        try:
            # å°è¯•ä»æ–‡ä»¶è¯»å–ä¸²å£é…ç½®
            with open("com_port.txt", "r") as f:
                com_port_str = f.read().strip()
                ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
                print(f"Connected to saved serial port: {com_port_str}")
        except (FileNotFoundError, serial.SerialException) as e:
            print(f"Could not connect to saved port: {e}")
            # å°è¯•é»˜è®¤ç«¯å£
            default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
            for port in default_ports:
                try:
                    ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                    print(f"Successfully connected to {port}")
                    # ä¿å­˜æˆåŠŸçš„ç«¯å£åˆ°æ–‡ä»¶
                    with open("com_port.txt", "w") as f:
                        f.write(port)
                    break
                except serial.SerialException as e:
                    print(f"Failed to connect to {port}: {e}")
                    continue
            
            if ser is None:
                print("\nError: Could not connect to any serial port.")
                print("\nAvailable serial ports:")
                ports = serial.tools.list_ports.comports()
                if ports:
                    for port in ports:
                        print(f"  {port.device} - {port.description}")
                else:
                    print("  No serial ports found!")
                
                print("\nTroubleshooting:")
                print("1. Make sure the robot is connected and powered on")
                print("2. Check if user has permission to access serial ports:")
                print("   sudo usermod -a -G dialout $USER")
                print("   (then logout and login again)")
                print("3. Check device permissions:")
                print("   ls -l /dev/ttyACM* /dev/ttyUSB*")
                print("4. Try running with sudo (temporary fix):")
                print("   sudo -E python run_headless_fixed.py")
                return None
    
    return ser

def run_original_with_ser(ser):
    """è¿è¡ŒåŸå§‹è„šæœ¬ï¼Œé¢„å…ˆå®šä¹‰serå˜é‡"""
    # å°†serå˜é‡æ³¨å…¥å…¨å±€å‘½åç©ºé—´
    globals()['ser'] = ser
    
    # è¯»å–åŸå§‹è„šæœ¬å†…å®¹
    with open('headless_commander.py', 'r') as f:
        script_content = f.read()
    
    # åœ¨å…¨å±€å‘½åç©ºé—´ä¸­æ‰§è¡Œè„šæœ¬
    print("Starting PAROL6 headless commander...")
    exec(script_content, globals())

if __name__ == "__main__":
    # åˆå§‹åŒ–ä¸²å£
    ser = init_serial()
    
    if ser is not None:
        print(f"Serial port initialized successfully: {ser.port}")
        try:
            run_original_with_ser(ser)
        except KeyboardInterrupt:
            print("\nProgram interrupted by user")
            if ser and ser.is_open:
                ser.close()
        except Exception as e:
            print(f"Error running program: {e}")
            if ser and ser.is_open:
                ser.close()
    else:
        print("Failed to initialize serial connection. Exiting.")
        sys.exit(1)
````

## File: run_headless_linux.py
````python
#!/usr/bin/env python3
"""
å¯åŠ¨å™¨è„šæœ¬æ¥ä¿®å¤headless_commander.pyä¸­çš„Linuxä¸²å£é—®é¢˜
"""
import platform
import serial
import serial.tools.list_ports

def initialize_serial_for_linux():
    """ä¸ºLinuxç³»ç»Ÿåˆå§‹åŒ–ä¸²å£è¿æ¥"""
    ser = None
    
    # å°è¯•ä»æ–‡ä»¶è¯»å–ä¸²å£é…ç½®
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved serial port: {com_port_str}")
            return ser
    except (FileNotFoundError, serial.SerialException) as e:
        print(f"Failed to connect to saved port: {e}")
    
    # å°è¯•é»˜è®¤ç«¯å£
    default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
    for port in default_ports:
        try:
            ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
            print(f"Successfully connected to {port}")
            # ä¿å­˜æˆåŠŸçš„ç«¯å£åˆ°æ–‡ä»¶
            with open("com_port.txt", "w") as f:
                f.write(port)
            return ser
        except serial.SerialException:
            print(f"Failed to connect to {port}")
            continue
    
    # å¦‚æœéƒ½å¤±è´¥äº†ï¼Œæ˜¾ç¤ºå¯ç”¨ç«¯å£å¹¶è¦æ±‚ç”¨æˆ·è¾“å…¥
    print("Could not find any available serial ports.")
    ports = serial.tools.list_ports.comports()
    if ports:
        print("Available ports:")
        for port in ports:
            print(f"  {port.device}")
    else:
        print("No serial ports detected!")
    
    while True:
        try:
            com_port = input("Enter the serial port (e.g., /dev/ttyACM0): ").strip()
            if not com_port:
                continue
            ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
            print(f"Successfully connected to {com_port}")
            # ä¿å­˜æˆåŠŸçš„ç«¯å£åˆ°æ–‡ä»¶
            with open("com_port.txt", "w") as f:
                f.write(com_port)
            return ser
        except serial.SerialException as e:
            print(f"Could not open port {com_port}: {e}. Please try again.")

if __name__ == "__main__":
    print("Initializing serial connection for Linux...")
    
    my_os = platform.system()
    if my_os != "Windows":
        ser = initialize_serial_for_linux()
        if ser:
            # å°†serå˜é‡æ³¨å…¥åˆ°å…¨å±€å‘½åç©ºé—´ï¼Œç„¶åå¯¼å…¥åŸå§‹è„šæœ¬
            import sys
            import os
            
            # ä¸´æ—¶å°†seræ·»åŠ åˆ°builtinsä¸­ï¼Œè¿™æ ·åŸå§‹è„šæœ¬å°±èƒ½çœ‹åˆ°å®ƒ
            import builtins
            builtins.ser = ser
            
            print("Serial connection established. Starting main program...")
            
            # ç°åœ¨æ‰§è¡ŒåŸå§‹è„šæœ¬
            exec(compile(open("headless_commander.py").read(), "headless_commander.py", 'exec'))
        else:
            print("Failed to establish serial connection!")
            sys.exit(1)
    else:
        print("This is a Linux-specific fix. On Windows, run headless_commander.py directly.")
        sys.exit(1)
````

## File: run_minimal.py
````python
#!/usr/bin/env python3
"""
PAROL6 Headless Commander æœ€å°åŒ–å¯åŠ¨å™¨
ç›´æ¥åˆå§‹åŒ–ä¸²å£å¹¶è¿è¡ŒåŸå§‹ç¨‹åº
"""
import os
import sys
import serial
import platform

# è®¾ç½®ç¯å¢ƒ
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['PYTHONPATH'] = os.pathsep.join([
    os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
    os.environ.get('PYTHONPATH', '')
])

# åˆå§‹åŒ–ä¸²å£
print("ğŸ”§ åˆå§‹åŒ–ä¸²å£...")
try:
    ser = serial.Serial(
        port='/dev/ttyACM0',
        baudrate=3000000,
        timeout=0
    )
    com_port_str = '/dev/ttyACM0'
    print(f"âœ… ä¸²å£è¿æ¥æˆåŠŸ: {com_port_str}")
except Exception as e:
    print(f"âŒ ä¸²å£åˆå§‹åŒ–å¤±è´¥: {e}")
    sys.exit(1)

# è®¾ç½®å…¨å±€å˜é‡
import builtins
builtins.ser = ser
builtins.com_port_str = com_port_str
builtins.my_os = platform.system()

# è¿è¡ŒåŸå§‹ç¨‹åº
print("ğŸš€ å¯åŠ¨PAROL6 Headless Commander...")
print("-" * 50)

try:
    exec(open('headless_commander.py').read(), {
        '__name__': '__main__',
        'ser': ser,
        'com_port_str': com_port_str,
        'my_os': platform.system()
    })
except KeyboardInterrupt:
    print("\nâ¹ï¸ ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­")
except Exception as e:
    print(f"\nâŒ è¿è¡Œé”™è¯¯: {e}")
    import traceback
    traceback.print_exc()
finally:
    if ser and ser.is_open:
        ser.close()
        print("ğŸ”Œ ä¸²å£å·²å…³é—­")
````

## File: run_parol6_fixed.py
````python
#!/usr/bin/env python3
"""
PAROL6 Headless Commander - å®Œæ•´Linuxä¿®å¤ç‰ˆ
ä¿®å¤æ‰€æœ‰ä¸²å£è¿æ¥é—®é¢˜å¹¶æä¾›ç¨³å®šçš„è¿è¡Œç¯å¢ƒ
"""
import os
import sys
import platform
import serial
import serial.tools.list_ports
import time
import threading

# æ·»åŠ ä¸Šçº§ç›®å½•åˆ°Pythonè·¯å¾„ï¼ˆç”¨äºå¯¼å…¥GUIæ¨¡å—ï¼‰
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def check_permissions():
    """æ£€æŸ¥ä¸²å£æƒé™"""
    import grp
    import pwd
    
    username = pwd.getpwuid(os.getuid()).pw_name
    groups = [g.gr_name for g in grp.getgrall() if username in g.gr_mem]
    
    if 'dialout' not in groups:
        print("âš ï¸  è­¦å‘Š: ç”¨æˆ·ä¸åœ¨dialoutç»„ä¸­")
        print("   è¯·è¿è¡Œ: sudo usermod -a -G dialout $USER")
        print("   ç„¶åé‡æ–°ç™»å½•")
        return False
    return True

def init_serial_connection():
    """åˆå§‹åŒ–ä¸²å£è¿æ¥"""
    print("ğŸ”§ åˆå§‹åŒ–Linuxä¸²å£è¿æ¥...")
    
    ser = None
    com_port_str = None
    
    # 1. æ£€æŸ¥æƒé™
    if not check_permissions():
        print("âš ï¸  ç»§ç»­å°è¯•è¿æ¥ï¼ˆå¯èƒ½éœ€è¦sudoï¼‰...")
    
    # 2. å°è¯•ä»æ–‡ä»¶è¯»å–ä¸Šæ¬¡ä½¿ç”¨çš„ç«¯å£
    try:
        with open("com_port.txt", "r") as f:
            saved_port = f.read().strip()
            if os.path.exists(saved_port):
                try:
                    ser = serial.Serial(
                        port=saved_port,
                        baudrate=3000000,
                        timeout=0.1,
                        write_timeout=0.1
                    )
                    com_port_str = saved_port
                    print(f"âœ… è¿æ¥åˆ°ä¿å­˜çš„ç«¯å£: {saved_port}")
                    return ser, com_port_str
                except serial.SerialException as e:
                    print(f"âš ï¸  æ— æ³•è¿æ¥åˆ°ä¿å­˜çš„ç«¯å£ {saved_port}: {e}")
    except FileNotFoundError:
        pass
    
    # 3. è‡ªåŠ¨æ£€æµ‹å¯ç”¨ç«¯å£
    print("ğŸ” æ‰«æå¯ç”¨ä¸²å£...")
    
    # é»˜è®¤ç«¯å£åˆ—è¡¨
    default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
    
    for port in default_ports:
        if os.path.exists(port):
            print(f"  å°è¯• {port}...")
            try:
                ser = serial.Serial(
                    port=port,
                    baudrate=3000000,
                    timeout=0.1,
                    write_timeout=0.1
                )
                com_port_str = port
                print(f"âœ… æˆåŠŸè¿æ¥åˆ° {port}")
                
                # ä¿å­˜æˆåŠŸçš„ç«¯å£
                with open("com_port.txt", "w") as f:
                    f.write(port)
                
                return ser, com_port_str
            except serial.SerialException as e:
                print(f"  âŒ æ— æ³•è¿æ¥åˆ° {port}: {e}")
                continue
    
    # 4. åˆ—å‡ºæ‰€æœ‰å¯ç”¨ä¸²å£ä¾›é€‰æ‹©
    print("\nğŸ“¡ å¯ç”¨çš„ä¸²å£è®¾å¤‡:")
    ports = serial.tools.list_ports.comports()
    
    if not ports:
        print("  æœªæ£€æµ‹åˆ°ä»»ä½•ä¸²å£è®¾å¤‡!")
        print("\næ’æŸ¥æ­¥éª¤:")
        print("1. ç¡®è®¤æœºæ¢°è‡‚å·²è¿æ¥å¹¶ä¸Šç”µ")
        print("2. æ£€æŸ¥USBçº¿ç¼†è¿æ¥")
        print("3. è¿è¡Œ 'lsusb' æŸ¥çœ‹USBè®¾å¤‡")
        return None, None
    
    for i, port in enumerate(ports):
        print(f"  [{i}] {port.device} - {port.description}")
    
    # 5. è®©ç”¨æˆ·é€‰æ‹©ï¼ˆæˆ–è‡ªåŠ¨å°è¯•æ‰€æœ‰ï¼‰
    for port in ports:
        if "ACM" in port.device or "USB" in port.device:
            try:
                ser = serial.Serial(
                    port=port.device,
                    baudrate=3000000,
                    timeout=0.1,
                    write_timeout=0.1
                )
                com_port_str = port.device
                print(f"âœ… æˆåŠŸè¿æ¥åˆ° {port.device}")
                
                with open("com_port.txt", "w") as f:
                    f.write(port.device)
                
                return ser, com_port_str
            except Exception as e:
                continue
    
    print("\nâŒ æ— æ³•è¿æ¥åˆ°ä»»ä½•ä¸²å£")
    return None, None


def run_headless_commander():
    """è¿è¡Œheadless commanderä¸»ç¨‹åº"""
    print("\nğŸš€ å¯åŠ¨PAROL6 Headless Commander...")
    
    # åˆå§‹åŒ–ä¸²å£
    ser, com_port_str = init_serial_connection()
    
    if ser is None or com_port_str is None:
        print("âŒ æ— æ³•åˆå§‹åŒ–ä¸²å£è¿æ¥")
        print("\nå¯èƒ½çš„è§£å†³æ–¹æ¡ˆ:")
        print("1. ä½¿ç”¨sudoè¿è¡Œ: sudo -E python run_parol6_fixed.py")
        print("2. æ·»åŠ ç”¨æˆ·åˆ°dialoutç»„: sudo usermod -a -G dialout $USER")
        print("3. æ£€æŸ¥è®¾å¤‡è¿æ¥å’Œç”µæº")
        return False
    
    print(f"ğŸ“¡ ä½¿ç”¨ä¸²å£: {com_port_str}")
    print(f"âš¡ æ³¢ç‰¹ç‡: 3000000")
    
    # å‡†å¤‡è¿è¡ŒåŸå§‹è„šæœ¬
    script_path = os.path.join(os.path.dirname(__file__), 'headless_commander.py')
    
    if not os.path.exists(script_path):
        print(f"âŒ æ‰¾ä¸åˆ° {script_path}")
        return False
    
    # è¯»å–åŸå§‹è„šæœ¬
    with open(script_path, 'r') as f:
        script_content = f.read()
    
    # è®¾ç½®å…¨å±€å˜é‡
    script_globals = {
        '__name__': '__main__',
        '__file__': script_path,
        'ser': ser,
        'com_port_str': com_port_str,
        'my_os': platform.system()
    }
    
    # æ·»åŠ æ‰€éœ€çš„å¯¼å…¥
    import_code = """
import serial
import serial.tools.list_ports
import platform
import sys
import os
import time
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
"""
    
    print("\nâœ… ä¸²å£è¿æ¥å°±ç»ª")
    print("ğŸ¤– æŒ‰Ctrl+Cåœæ­¢ç¨‹åº\n")
    print("-" * 50)
    
    try:
        # å…ˆæ‰§è¡Œå¯¼å…¥
        exec(import_code, script_globals)
        # ç„¶åæ‰§è¡Œä¸»è„šæœ¬
        exec(script_content, script_globals)
        return True
    except KeyboardInterrupt:
        print("\n\nâ¹ï¸  ç”¨æˆ·ä¸­æ–­ç¨‹åº")
        return True
    except Exception as e:
        print(f"\nâŒ è¿è¡Œé”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        return False
    finally:
        # æ¸…ç†
        if ser and ser.is_open:
            print("ğŸ”Œ å…³é—­ä¸²å£è¿æ¥...")
            ser.close()


def main():
    """ä¸»å‡½æ•°"""
    print("=" * 60)
    print("ğŸ¤– PAROL6 Headless Commander - Linuxå®Œæ•´ä¿®å¤ç‰ˆ")
    print("=" * 60)
    
    # æ£€æŸ¥æ“ä½œç³»ç»Ÿ
    if platform.system() == "Windows":
        print("â„¹ï¸  è¿™æ˜¯Linuxä¿®å¤ç‰ˆã€‚Windowsè¯·ç›´æ¥è¿è¡Œheadless_commander.py")
        return 1
    
    # æ£€æŸ¥Pythonç‰ˆæœ¬
    if sys.version_info < (3, 6):
        print(f"âŒ éœ€è¦Python 3.6æˆ–æ›´é«˜ç‰ˆæœ¬ï¼Œå½“å‰ç‰ˆæœ¬: {sys.version}")
        return 1
    
    # æ£€æŸ¥å¿…è¦çš„ä¾èµ–
    try:
        import serial
        import numpy
        import roboticstoolbox
    except ImportError as e:
        print(f"âŒ ç¼ºå°‘ä¾èµ–: {e}")
        print("è¯·è¿è¡Œ: pip install pyserial numpy roboticstoolbox-python")
        return 1
    
    # è¿è¡Œä¸»ç¨‹åº
    if run_headless_commander():
        print("\nâœ… ç¨‹åºæ­£å¸¸é€€å‡º")
        return 0
    else:
        print("\nâŒ ç¨‹åºå¼‚å¸¸é€€å‡º")
        return 1

if __name__ == "__main__":
    sys.exit(main())
````

## File: run_patched.py
````python
#!/usr/bin/env python3
"""
PAROL6 Headless Commander - å®Œæ•´Linuxä¿®è¡¥ç‰ˆ
ä¿®å¤åŸå§‹æ–‡ä»¶ç¼ºå°‘Linuxä¸²å£åˆå§‹åŒ–çš„é—®é¢˜
"""
import os
import sys
import serial
import platform
import serial.tools.list_ports

# æ·»åŠ ä¸Šçº§ç›®å½•åˆ°Pythonè·¯å¾„
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def patch_headless_commander():
    """ä¿®è¡¥headless_commander.pyä»¥æ”¯æŒLinux"""
    
    # è¯»å–åŸå§‹æ–‡ä»¶
    with open('headless_commander.py', 'r') as f:
        content = f.read()
    
    # æ‰¾åˆ°Windowsä¸²å£åˆå§‹åŒ–çš„ä½ç½®
    windows_init_start = content.find('my_os = platform.system()')
    if windows_init_start == -1:
        print("âŒ æ‰¾ä¸åˆ°æ“ä½œç³»ç»Ÿæ£€æµ‹ä»£ç ")
        return None
    
    # æ‰¾åˆ°ç»“æŸä½ç½®ï¼ˆç¬¬ä¸€ä¸ªint_to_3_byteså®šä¹‰ï¼‰
    init_end = content.find('# in big endian machines')
    if init_end == -1:
        print("âŒ æ‰¾ä¸åˆ°åˆå§‹åŒ–ä»£ç ç»“æŸä½ç½®")
        return None
    
    # åˆ›å»ºæ–°çš„åˆå§‹åŒ–ä»£ç ï¼ˆæ”¯æŒWindowså’ŒLinuxï¼‰
    new_init_code = '''
my_os = platform.system()

# Initialize serial port based on OS
ser = None
com_port_str = None

if my_os == "Windows":
    # Windows serial port initialization
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved COM port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        while True:
            try:
                com_port = input("Enter the COM port (e.g., COM9): ")
                ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                com_port_str = com_port
                print(f"Successfully connected to {com_port}")
                with open("com_port.txt", "w") as f:
                    f.write(com_port)
                break
            except serial.SerialException:
                print(f"Could not open port {com_port}. Please try again.")

else:  # Linux/Mac
    # Linux serial port initialization
    print("ğŸ”§ Initializing serial port for Linux/Mac...")
    
    # Try to read saved port
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            if os.path.exists(com_port_str):
                ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
                print(f"âœ… Connected to saved port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException) as e:
        print(f"âš ï¸ Could not connect to saved port: {e}")
        ser = None
    
    # If not connected, try default ports
    if ser is None:
        default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
        for port in default_ports:
            if os.path.exists(port):
                try:
                    ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                    com_port_str = port
                    print(f"âœ… Connected to {port}")
                    with open("com_port.txt", "w") as f:
                        f.write(port)
                    break
                except serial.SerialException as e:
                    print(f"âŒ Failed to connect to {port}: {e}")
    
    # If still not connected, list available ports
    if ser is None:
        print("\\nğŸ“¡ Available serial ports:")
        ports = serial.tools.list_ports.comports()
        for port in ports:
            print(f"  â€¢ {port.device} - {port.description}")
        
        # Try to connect to the first available ACM/USB port
        for port in ports:
            if "ACM" in port.device or "USB" in port.device:
                try:
                    ser = serial.Serial(port=port.device, baudrate=3000000, timeout=0)
                    com_port_str = port.device
                    print(f"âœ… Connected to {port.device}")
                    with open("com_port.txt", "w") as f:
                        f.write(port.device)
                    break
                except Exception:
                    pass
        
        if ser is None:
            print("\\nâŒ Could not connect to any serial port!")
            print("Please check:")
            print("1. Robot is connected and powered on")
            print("2. User has permission (sudo usermod -a -G dialout $USER)")
            print("3. No other program is using the serial port")
            sys.exit(1)

print(f"ğŸ“¡ Using serial port: {com_port_str}")
print(f"âš¡ Baudrate: 3000000")
print("ğŸ¤– PAROL6 Headless Commander Ready\\n")

'''
    
    # æ›¿æ¢åˆå§‹åŒ–ä»£ç 
    new_content = (
        content[:windows_init_start] + 
        new_init_code + 
        content[init_end:]
    )
    
    return new_content

def main():
    print("=" * 60)
    print("ğŸ”§ PAROL6 Headless Commander - Linuxä¿®è¡¥å™¨")
    print("=" * 60)
    
    # ä¿®è¡¥æ–‡ä»¶
    patched_content = patch_headless_commander()
    if patched_content is None:
        print("âŒ ä¿®è¡¥å¤±è´¥")
        return 1
    
    # ä¿å­˜ä¿®è¡¥åçš„æ–‡ä»¶
    with open('headless_commander_patched.py', 'w') as f:
        f.write(patched_content)
    
    print("âœ… å·²åˆ›å»ºä¿®è¡¥æ–‡ä»¶: headless_commander_patched.py")
    print("\nğŸš€ æ­£åœ¨è¿è¡Œä¿®è¡¥åçš„ç¨‹åº...")
    print("-" * 60)
    
    # è¿è¡Œä¿®è¡¥åçš„ç¨‹åº
    try:
        exec(patched_content, {'__name__': '__main__'})
    except KeyboardInterrupt:
        print("\nâ¹ï¸ ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­")
    except Exception as e:
        print(f"\nâŒ è¿è¡Œé”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
````

## File: smooth_motion.py.backup_1757427986
````
"""
Smooth Motion Module for PAROL6 Robotic Arm
============================================
This module provides advanced trajectory generation capabilities including:
- Circular and arc movements
- Cubic spline trajectories
- Motion blending
- Pre-computed and real-time trajectory generation

Compatible with:
- numpy==1.23.4
- scipy==1.11.4
- roboticstoolbox-python==1.0.3
"""

import sys
import warnings
from collections import namedtuple
from roboticstoolbox import DHRobot
from spatialmath.base import trinterp

# Version compatibility check
try:
    import numpy as np
    # Check numpy version
    np_version = tuple(map(int, np.__version__.split('.')[:2]))
    if np_version < (1, 23):
        warnings.warn(f"NumPy version {np.__version__} detected. Recommended: 1.23.4")
    
    from scipy.interpolate import CubicSpline
    from scipy.spatial.transform import Rotation, Slerp
    import scipy
    # Check scipy version
    scipy_version = tuple(map(int, scipy.__version__.split('.')[:2]))
    if scipy_version < (1, 11):
        warnings.warn(f"SciPy version {scipy.__version__} detected. Recommended: 1.11.4")
        
except ImportError as e:
    print(f"Error importing required packages: {e}")
    print("Please install: pip3 install numpy==1.23.4 scipy==1.11.4")
    sys.exit(1)

from spatialmath import SE3
import time
from typing import List, Tuple, Optional, Dict, Union
from collections import deque

# Import PAROL6 specific modules (these should be in your path)
try:
    import GUI.files.PAROL6_ROBOT
except ImportError:
    print("Warning: PAROL6 modules not found. Some functions may not work.")
    PAROL6_ROBOT = None

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

# IK Result structure
IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179Â° and 181Â° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90Â°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities.
    If necessary, recursively subdivide the motion until ikine_LMS converges
    on every segment. Finally check that solution respects joint limits.
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # â”€â”€ inner recursive solverâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            if current_reach >= max_reach_threshold:
                print(f"Reach limit exceeded: {current_reach:.3f} >= {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LMS(Tb, q0=q_seed, ilimit=ilimit, tol=tol, wN=damping)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # â”€â”€ kick-off with adaptive tolerance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    
    # Check if solution respects joint limits
    if PAROL6_ROBOT is not None:
        target_q = path[-1] if len(path) != 0 else None
        solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
        if ok and solution_valid:
            return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, violations)
    else:
        # If PAROL6_ROBOT not available, skip joint limit checking
        if ok and len(path) > 0:
            return IKResult(True, path[-1], its, resid, adaptive_tol, None)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, None)

# ============================================================================
# END OF IK SOLVER FUNCTIONS
# ============================================================================

class TrajectoryGenerator:
    """Base class for trajectory generation with caching support"""
    
    def __init__(self, control_rate: float = 100.0):
        """
        Initialize trajectory generator
        
        Args:
            control_rate: Control loop frequency in Hz (default 100Hz for PAROL6)
        """
        self.control_rate = control_rate
        self.dt = 1.0 / control_rate
        self.trajectory_cache = {}
        
    def generate_timestamps(self, duration: float) -> np.ndarray:
        """Generate evenly spaced timestamps for trajectory"""
        num_points = int(duration * self.control_rate)
        return np.linspace(0, duration, num_points)

class CircularMotion(TrajectoryGenerator):
    """Generate circular and arc trajectories in 3D space"""
    
    def generate_arc_3d(self, 
                       start_pose: List[float], 
                       end_pose: List[float], 
                       center: List[float], 
                       normal: Optional[List[float]] = None,
                       clockwise: bool = True,
                       duration: float = 2.0) -> np.ndarray:
        """
        Generate a 3D circular arc trajectory
        
        Args:
            start_pose: Starting pose [x, y, z, rx, ry, rz] (mm and degrees)
            end_pose: Ending pose [x, y, z, rx, ry, rz] (mm and degrees)
            center: Center point of arc [x, y, z] (mm)
            normal: Normal vector to arc plane (default: z-axis)
            clockwise: Direction of rotation
            duration: Time to complete arc (seconds)
            
        Returns:
            Array of poses along the arc trajectory
        """
        # Convert to numpy arrays
        start_pos = np.array(start_pose[:3])
        end_pos = np.array(end_pose[:3])
        center_pt = np.array(center)
        
        # Calculate radius vectors
        r1 = start_pos - center_pt
        r2 = end_pos - center_pt
        radius = np.linalg.norm(r1)
        
        # Determine arc plane normal if not provided
        if normal is None:
            normal = np.cross(r1, r2)
            if np.linalg.norm(normal) < 1e-6:  # Points are collinear
                normal = np.array([0, 0, 1])  # Default to XY plane
        normal = normal / np.linalg.norm(normal)
        
        # Calculate arc angle
        r1_norm = r1 / np.linalg.norm(r1)
        r2_norm = r2 / np.linalg.norm(r2)
        cos_angle = np.clip(np.dot(r1_norm, r2_norm), -1, 1)
        arc_angle = np.arccos(cos_angle)
        
        # Check direction using cross product
        cross = np.cross(r1_norm, r2_norm)
        if np.dot(cross, normal) < 0:
            arc_angle = 2 * np.pi - arc_angle
            
        if clockwise:
            arc_angle = -arc_angle
            
        # Generate trajectory points
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        for i, t in enumerate(timestamps):
            # Interpolation factor
            s = t / duration
            
            # For first point, use exact start position
            if i == 0:
                current_pos = start_pos
            else:
                # Rotate radius vector
                angle = s * arc_angle
                rot_matrix = self._rotation_matrix_from_axis_angle(normal, angle)
                current_pos = center_pt + rot_matrix @ r1
            
            # Interpolate orientation (SLERP)
            current_orient = self._slerp_orientation(start_pose[3:], end_pose[3:], s)
            
            # Combine position and orientation
            pose = np.concatenate([current_pos, current_orient])
            trajectory.append(pose)
            
        return np.array(trajectory)
    
    def generate_circle_3d(self,
                      center: List[float],
                      radius: float,
                      normal: List[float] = [0, 0, 1],
                      start_angle: float = None,
                      duration: float = 4.0,
                      start_point: List[float] = None) -> np.ndarray:
        """
        Generate a complete circle trajectory that starts at start_point
        """
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        # Create orthonormal basis for circle plane
        normal = np.array(normal) / np.linalg.norm(normal)
        u = self._get_perpendicular_vector(normal)
        v = np.cross(normal, u)
        
        center_np = np.array(center)
        
        # CRITICAL FIX: Validate and handle geometry
        if start_point is not None:
            start_pos = np.array(start_point[:3])
            
            # Project start point onto the circle plane
            to_start = start_pos - center_np
            to_start_plane = to_start - np.dot(to_start, normal) * normal
            
            # Get distance from center in the plane
            dist_in_plane = np.linalg.norm(to_start_plane)
            
            if dist_in_plane < 0.001:
                # Start point is at center - can't determine angle
                print(f"    WARNING: Start point is at circle center, using default position")
                start_angle = 0
                actual_start = center_np + radius * u
            else:
                # Calculate the angle of the start point
                to_start_normalized = to_start_plane / dist_in_plane
                u_comp = np.dot(to_start_normalized, u)
                v_comp = np.dot(to_start_normalized, v)
                start_angle = np.arctan2(v_comp, u_comp)
                
                # CHECK FOR INVALID GEOMETRY
                radius_error = abs(dist_in_plane - radius)
                if radius_error > radius * 0.3:  # More than 30% off
                    print(f"    WARNING: Start point is {dist_in_plane:.1f}mm from center,")
                    print(f"             but circle radius is {radius:.1f}mm!")
                    
                    # AUTO-CORRECT: Adjust center to make geometry valid
                    print(f"    AUTO-CORRECTING: Moving center to maintain {radius}mm radius from start")
                    direction = to_start_plane / dist_in_plane
                    center_np = start_pos - direction * radius
                    print(f"    New center: {center_np.round(1)}")
                    
                    # Recalculate with new center
                    to_start = start_pos - center_np
                    to_start_plane = to_start - np.dot(to_start, normal) * normal
                    dist_in_plane = np.linalg.norm(to_start_plane)
                
                actual_start = start_pos
        else:
            start_angle = 0 if start_angle is None else start_angle
            actual_start = None
        
        # Generate the circle 
        for i, t in enumerate(timestamps):
            if i == 0 and actual_start is not None:
                # First point MUST be exactly the start point
                pos = actual_start
            else:
                # Generate circle points
                angle = start_angle + (2 * np.pi * t / duration)
                pos = center_np + radius * (np.cos(angle) * u + np.sin(angle) * v)
            
            # Placeholder orientation (will be overridden)
            orient = [0, 0, 0]
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def _rotation_matrix_from_axis_angle(self, axis: np.ndarray, angle: float) -> np.ndarray:
        """Generate rotation matrix using Rodrigues' formula"""
        axis = axis / np.linalg.norm(axis)
        cos_a = np.cos(angle)
        sin_a = np.sin(angle)
        
        # Cross-product matrix
        K = np.array([[0, -axis[2], axis[1]],
                     [axis[2], 0, -axis[0]],
                     [-axis[1], axis[0], 0]])
        
        # Rodrigues' formula
        R = np.eye(3) + sin_a * K + (1 - cos_a) * K @ K
        return R
    
    def _get_perpendicular_vector(self, v: np.ndarray) -> np.ndarray:
        """Find a vector perpendicular to the given vector"""
        v = np.array(v)  # Ensure it's a numpy array
        if abs(v[0]) < 0.9:
            return np.cross(v, [1, 0, 0]) / np.linalg.norm(np.cross(v, [1, 0, 0]))
        else:
            return np.cross(v, [0, 1, 0]) / np.linalg.norm(np.cross(v, [0, 1, 0]))
    
    def _slerp_orientation(self, start_orient: List[float], 
                          end_orient: List[float], 
                          t: float) -> np.ndarray:
        """Spherical linear interpolation for orientation"""
        # Convert to quaternions
        r1 = Rotation.from_euler('xyz', start_orient, degrees=True)
        r2 = Rotation.from_euler('xyz', end_orient, degrees=True)
        
        # Create slerp object - compatible with scipy 1.11.4
        # Stack rotations into a single Rotation object
        key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
        slerp = Slerp([0, 1], key_rots)
        
        # Interpolate
        interp_rot = slerp(t)
        return interp_rot.as_euler('xyz', degrees=True)

class SplineMotion(TrajectoryGenerator):
    """Generate smooth spline trajectories through waypoints"""
    
    def generate_cubic_spline(self,
                             waypoints: List[List[float]],
                             timestamps: Optional[List[float]] = None,
                             velocity_start: Optional[List[float]] = None,
                             velocity_end: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate cubic spline trajectory through waypoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint (auto-generated if None)
            velocity_start: Initial velocity (zero if None)
            velocity_end: Final velocity (zero if None)
            
        Returns:
            Array of interpolated poses
        """
        waypoints = np.array(waypoints)
        num_waypoints = len(waypoints)
        
        # Auto-generate timestamps if not provided
        if timestamps is None:
            # Estimate based on distance
            total_dist = 0
            for i in range(1, num_waypoints):
                dist = np.linalg.norm(waypoints[i, :3] - waypoints[i-1, :3])
                total_dist += dist
            
            # Assume average speed of 50 mm/s
            total_time = total_dist / 50.0
            timestamps = np.linspace(0, total_time, num_waypoints)
        
        # Create splines for position
        pos_splines = []
        for i in range(3):
            bc_type = 'not-a-knot'  # Default boundary condition
            
            # Apply velocity boundary conditions if specified
            if velocity_start is not None and velocity_end is not None:
                bc_type = ((1, velocity_start[i]), (1, velocity_end[i]))
            
            spline = CubicSpline(timestamps, waypoints[:, i], bc_type=bc_type)
            pos_splines.append(spline)
        
        # Create splines for orientation (convert to quaternions for smooth interpolation)
        rotations = [Rotation.from_euler('xyz', wp[3:], degrees=True) for wp in waypoints]
        # Stack quaternions for scipy 1.11.4 compatibility
        quats = np.array([r.as_quat() for r in rotations])
        key_rots = Rotation.from_quat(quats)
        slerp = Slerp(timestamps, key_rots)
        
        # Generate dense trajectory
        t_eval = self.generate_timestamps(timestamps[-1])
        trajectory = []
        
        for t in t_eval:
            # Evaluate position splines
            pos = [spline(t) for spline in pos_splines]
            
            # Evaluate orientation
            rot = slerp(t)
            orient = rot.as_euler('xyz', degrees=True)
            
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def generate_quintic_spline(self,
                               waypoints: List[List[float]],
                               timestamps: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate quintic (5th order) spline with zero velocity and acceleration at endpoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint
            
        Returns:
            Array of interpolated poses
        """
        # For quintic spline, we need to ensure zero velocity and acceleration
        # at the endpoints for smooth motion
        return self.generate_cubic_spline(
            waypoints, 
            timestamps,
            velocity_start=[0, 0, 0],
            velocity_end=[0, 0, 0]
        )

class MotionBlender:
    """Blend between different motion segments for smooth transitions"""
    
    def __init__(self, blend_time: float = 0.5):
        self.blend_time = blend_time
        
    def blend_trajectories(self, traj1, traj2, blend_samples=50):
        """Blend two trajectory segments with improved velocity continuity"""
        
        if blend_samples < 4:
            return np.vstack([traj1, traj2])
        
        # Use more samples for smoother blending
        blend_samples = max(blend_samples, 20)  # Minimum 20 samples for smooth blend
        
        # Calculate overlap region more carefully
        overlap_start = max(0, len(traj1) - blend_samples // 3)
        overlap_end = min(len(traj2), blend_samples // 3)
        
        # Extract blend region
        blend_start_pose = traj1[overlap_start] if overlap_start < len(traj1) else traj1[-1]
        blend_end_pose = traj2[overlap_end] if overlap_end < len(traj2) else traj2[0]
        
        # Generate smooth transition using S-curve
        blended = []
        for i in range(blend_samples):
            t = i / (blend_samples - 1)
            # Use smoothstep function for smoother acceleration
            s = t * t * (3 - 2 * t)  # Smoothstep
            
            # Blend position
            pos_blend = blend_start_pose * (1 - s) + blend_end_pose * s
            
            # For orientation, use SLERP
            r1 = Rotation.from_euler('xyz', blend_start_pose[3:], degrees=True)
            r2 = Rotation.from_euler('xyz', blend_end_pose[3:], degrees=True)
            key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
            slerp = Slerp([0, 1], key_rots)
            orient_blend = slerp(s).as_euler('xyz', degrees=True)
            
            pos_blend[3:] = orient_blend
            blended.append(pos_blend)
        
        # Combine with better overlap handling
        result = np.vstack([
            traj1[:overlap_start],
            np.array(blended),
            traj2[overlap_end:]
        ])
        
        return result

class SmoothMotionCommand:
    """Command class for executing smooth motions on PAROL6"""
    
    def __init__(self, trajectory: np.ndarray, speed_factor: float = 1.0):
        """
        Initialize smooth motion command
        
        Args:
            trajectory: Pre-computed trajectory array
            speed_factor: Speed scaling factor (1.0 = normal speed)
        """
        self.trajectory = trajectory
        self.speed_factor = speed_factor
        self.current_index = 0
        self.is_finished = False
        self.is_valid = True
        
    def prepare_for_execution(self, current_position_in):
        """Validate trajectory is reachable from current position"""
        # Check if IK solver is available
        if solve_ik_with_adaptive_tol_subdivision is None:
            print("Warning: IK solver not available, skipping validation")
            self.is_valid = True
            return True
            
        try:
            # Convert current position to radians
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(current_position_in)])
            
            # Check first waypoint is reachable
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
            )
            
            if not ik_result.success:
                print(f"Smooth motion validation failed: Cannot reach first waypoint")
                self.is_valid = False
                return False
                
            print(f"Smooth motion prepared with {len(self.trajectory)} waypoints")
            return True
            
        except Exception as e:
            print(f"Smooth motion preparation error: {e}")
            self.is_valid = False
            return False
    
    def execute_step(self, Position_in, Speed_out, Command_out, **kwargs):
        """Execute one step of the smooth motion"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Check if required modules are available
        if PAROL6_ROBOT is None or solve_ik_with_adaptive_tol_subdivision is None:
            print("Error: Required PAROL6 modules not available")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Apply speed scaling
        step_increment = max(1, int(self.speed_factor))
        self.current_index += step_increment
        
        if self.current_index >= len(self.trajectory):
            print("Smooth motion completed")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get current target pose
        target_pose = self.trajectory[self.current_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
        )
        
        if not ik_result.success:
            print(f"IK failed at trajectory point {self.current_index}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps and send
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                       for i, q in enumerate(ik_result.q)]
        
        # Calculate velocities for smooth following
        for i in range(6):
            Speed_out[i] = int((target_steps[i] - Position_in[i]) * 10)  # P-control factor
        
        Command_out.value = 156  # Smooth motion command
        return False

# Helper functions for integration with robot_api.py

def execute_circle(center: List[float], 
                  radius: float, 
                  duration: float = 4.0,
                  normal: List[float] = [0, 0, 1]) -> str:
    """
    Execute a circular motion on PAROL6
    
    Args:
        center: Center point [x, y, z] in mm
        radius: Circle radius in mm
        duration: Time to complete circle
        normal: Normal vector to circle plane
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_circle_3d(center, radius, normal, 0, duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|CIRCLE|{traj_str}"
    
    return command

def execute_arc(start_pose: List[float],
               end_pose: List[float],
               center: List[float],
               clockwise: bool = True,
               duration: float = 2.0) -> str:
    """
    Execute an arc motion on PAROL6
    
    Args:
        start_pose: Starting pose [x, y, z, rx, ry, rz]
        end_pose: Ending pose [x, y, z, rx, ry, rz]
        center: Arc center point [x, y, z]
        clockwise: Direction of rotation
        duration: Time to complete arc
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_arc_3d(start_pose, end_pose, center, 
                                           clockwise=clockwise, duration=duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|ARC|{traj_str}"
    
    return command

def execute_spline(waypoints: List[List[float]], 
                  total_time: Optional[float] = None) -> str:
    """
    Execute a spline motion through waypoints
    
    Args:
        waypoints: List of poses [x, y, z, rx, ry, rz]
        total_time: Total time for motion (auto-calculated if None)
        
    Returns:
        Command string for robot_api
    """
    motion_gen = SplineMotion()
    
    # Generate timestamps if total_time is provided
    timestamps = None
    if total_time:
        timestamps = np.linspace(0, total_time, len(waypoints))
    
    trajectory = motion_gen.generate_cubic_spline(waypoints, timestamps)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|SPLINE|{traj_str}"
    
    return command

# Example usage
if __name__ == "__main__":
    # Example: Generate a circle trajectory
    circle_gen = CircularMotion()
    circle_traj = circle_gen.generate_circle_3d(
        center=[200, 0, 200],  # mm
        radius=50,  # mm
        duration=4.0  # seconds
    )
    print(f"Generated circle with {len(circle_traj)} points")
    
    # Example: Generate arc trajectory
    arc_traj = circle_gen.generate_arc_3d(
        start_pose=[250, 0, 200, 0, 0, 0],
        end_pose=[200, 50, 200, 0, 0, 90],
        center=[200, 0, 200],
        duration=2.0
    )
    print(f"Generated arc with {len(arc_traj)} points")
    
    # Example: Generate spline through waypoints
    spline_gen = SplineMotion()
    waypoints = [
        [200, 0, 100, 0, 0, 0],
        [250, 50, 150, 0, 15, 45],
        [200, 100, 200, 0, 30, 90],
        [150, 50, 150, 0, 15, 45],
        [200, 0, 100, 0, 0, 0]
    ]
    spline_traj = spline_gen.generate_cubic_spline(waypoints)
    print(f"Generated spline with {len(spline_traj)} points")
````

## File: smooth_motion.py.backup_wN_1757428702
````
"""
Smooth Motion Module for PAROL6 Robotic Arm
============================================
This module provides advanced trajectory generation capabilities including:
- Circular and arc movements
- Cubic spline trajectories
- Motion blending
- Pre-computed and real-time trajectory generation

Compatible with:
- numpy==1.23.4
- scipy==1.11.4
- roboticstoolbox-python==1.0.3
"""

import sys
import warnings
from collections import namedtuple
from roboticstoolbox import DHRobot
from spatialmath.base import trinterp

# Version compatibility check
try:
    import numpy as np
    # Check numpy version
    np_version = tuple(map(int, np.__version__.split('.')[:2]))
    if np_version < (1, 23):
        warnings.warn(f"NumPy version {np.__version__} detected. Recommended: 1.23.4")
    
    from scipy.interpolate import CubicSpline
    from scipy.spatial.transform import Rotation, Slerp
    import scipy
    # Check scipy version
    scipy_version = tuple(map(int, scipy.__version__.split('.')[:2]))
    if scipy_version < (1, 11):
        warnings.warn(f"SciPy version {scipy.__version__} detected. Recommended: 1.11.4")
        
except ImportError as e:
    print(f"Error importing required packages: {e}")
    print("Please install: pip3 install numpy==1.23.4 scipy==1.11.4")
    sys.exit(1)

from spatialmath import SE3
import time
from typing import List, Tuple, Optional, Dict, Union
from collections import deque

# Import PAROL6 specific modules (these should be in your path)
try:
    import GUI.files.PAROL6_ROBOT
except ImportError:
    print("Warning: PAROL6 modules not found. Some functions may not work.")
    PAROL6_ROBOT = None

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

# IK Result structure
IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179Â° and 181Â° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90Â°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities.
    If necessary, recursively subdivide the motion until ikine_LM converges
    on every segment. Finally check that solution respects joint limits.
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # â”€â”€ inner recursive solverâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            if current_reach >= max_reach_threshold:
                print(f"Reach limit exceeded: {current_reach:.3f} >= {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LM(Tb, q0=q_seed, ilimit=ilimit, tol=tol, wN=damping)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # â”€â”€ kick-off with adaptive tolerance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    
    # Check if solution respects joint limits
    if PAROL6_ROBOT is not None:
        target_q = path[-1] if len(path) != 0 else None
        solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
        if ok and solution_valid:
            return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, violations)
    else:
        # If PAROL6_ROBOT not available, skip joint limit checking
        if ok and len(path) > 0:
            return IKResult(True, path[-1], its, resid, adaptive_tol, None)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, None)

# ============================================================================
# END OF IK SOLVER FUNCTIONS
# ============================================================================

class TrajectoryGenerator:
    """Base class for trajectory generation with caching support"""
    
    def __init__(self, control_rate: float = 100.0):
        """
        Initialize trajectory generator
        
        Args:
            control_rate: Control loop frequency in Hz (default 100Hz for PAROL6)
        """
        self.control_rate = control_rate
        self.dt = 1.0 / control_rate
        self.trajectory_cache = {}
        
    def generate_timestamps(self, duration: float) -> np.ndarray:
        """Generate evenly spaced timestamps for trajectory"""
        num_points = int(duration * self.control_rate)
        return np.linspace(0, duration, num_points)

class CircularMotion(TrajectoryGenerator):
    """Generate circular and arc trajectories in 3D space"""
    
    def generate_arc_3d(self, 
                       start_pose: List[float], 
                       end_pose: List[float], 
                       center: List[float], 
                       normal: Optional[List[float]] = None,
                       clockwise: bool = True,
                       duration: float = 2.0) -> np.ndarray:
        """
        Generate a 3D circular arc trajectory
        
        Args:
            start_pose: Starting pose [x, y, z, rx, ry, rz] (mm and degrees)
            end_pose: Ending pose [x, y, z, rx, ry, rz] (mm and degrees)
            center: Center point of arc [x, y, z] (mm)
            normal: Normal vector to arc plane (default: z-axis)
            clockwise: Direction of rotation
            duration: Time to complete arc (seconds)
            
        Returns:
            Array of poses along the arc trajectory
        """
        # Convert to numpy arrays
        start_pos = np.array(start_pose[:3])
        end_pos = np.array(end_pose[:3])
        center_pt = np.array(center)
        
        # Calculate radius vectors
        r1 = start_pos - center_pt
        r2 = end_pos - center_pt
        radius = np.linalg.norm(r1)
        
        # Determine arc plane normal if not provided
        if normal is None:
            normal = np.cross(r1, r2)
            if np.linalg.norm(normal) < 1e-6:  # Points are collinear
                normal = np.array([0, 0, 1])  # Default to XY plane
        normal = normal / np.linalg.norm(normal)
        
        # Calculate arc angle
        r1_norm = r1 / np.linalg.norm(r1)
        r2_norm = r2 / np.linalg.norm(r2)
        cos_angle = np.clip(np.dot(r1_norm, r2_norm), -1, 1)
        arc_angle = np.arccos(cos_angle)
        
        # Check direction using cross product
        cross = np.cross(r1_norm, r2_norm)
        if np.dot(cross, normal) < 0:
            arc_angle = 2 * np.pi - arc_angle
            
        if clockwise:
            arc_angle = -arc_angle
            
        # Generate trajectory points
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        for i, t in enumerate(timestamps):
            # Interpolation factor
            s = t / duration
            
            # For first point, use exact start position
            if i == 0:
                current_pos = start_pos
            else:
                # Rotate radius vector
                angle = s * arc_angle
                rot_matrix = self._rotation_matrix_from_axis_angle(normal, angle)
                current_pos = center_pt + rot_matrix @ r1
            
            # Interpolate orientation (SLERP)
            current_orient = self._slerp_orientation(start_pose[3:], end_pose[3:], s)
            
            # Combine position and orientation
            pose = np.concatenate([current_pos, current_orient])
            trajectory.append(pose)
            
        return np.array(trajectory)
    
    def generate_circle_3d(self,
                      center: List[float],
                      radius: float,
                      normal: List[float] = [0, 0, 1],
                      start_angle: float = None,
                      duration: float = 4.0,
                      start_point: List[float] = None) -> np.ndarray:
        """
        Generate a complete circle trajectory that starts at start_point
        """
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        # Create orthonormal basis for circle plane
        normal = np.array(normal) / np.linalg.norm(normal)
        u = self._get_perpendicular_vector(normal)
        v = np.cross(normal, u)
        
        center_np = np.array(center)
        
        # CRITICAL FIX: Validate and handle geometry
        if start_point is not None:
            start_pos = np.array(start_point[:3])
            
            # Project start point onto the circle plane
            to_start = start_pos - center_np
            to_start_plane = to_start - np.dot(to_start, normal) * normal
            
            # Get distance from center in the plane
            dist_in_plane = np.linalg.norm(to_start_plane)
            
            if dist_in_plane < 0.001:
                # Start point is at center - can't determine angle
                print(f"    WARNING: Start point is at circle center, using default position")
                start_angle = 0
                actual_start = center_np + radius * u
            else:
                # Calculate the angle of the start point
                to_start_normalized = to_start_plane / dist_in_plane
                u_comp = np.dot(to_start_normalized, u)
                v_comp = np.dot(to_start_normalized, v)
                start_angle = np.arctan2(v_comp, u_comp)
                
                # CHECK FOR INVALID GEOMETRY
                radius_error = abs(dist_in_plane - radius)
                if radius_error > radius * 0.3:  # More than 30% off
                    print(f"    WARNING: Start point is {dist_in_plane:.1f}mm from center,")
                    print(f"             but circle radius is {radius:.1f}mm!")
                    
                    # AUTO-CORRECT: Adjust center to make geometry valid
                    print(f"    AUTO-CORRECTING: Moving center to maintain {radius}mm radius from start")
                    direction = to_start_plane / dist_in_plane
                    center_np = start_pos - direction * radius
                    print(f"    New center: {center_np.round(1)}")
                    
                    # Recalculate with new center
                    to_start = start_pos - center_np
                    to_start_plane = to_start - np.dot(to_start, normal) * normal
                    dist_in_plane = np.linalg.norm(to_start_plane)
                
                actual_start = start_pos
        else:
            start_angle = 0 if start_angle is None else start_angle
            actual_start = None
        
        # Generate the circle 
        for i, t in enumerate(timestamps):
            if i == 0 and actual_start is not None:
                # First point MUST be exactly the start point
                pos = actual_start
            else:
                # Generate circle points
                angle = start_angle + (2 * np.pi * t / duration)
                pos = center_np + radius * (np.cos(angle) * u + np.sin(angle) * v)
            
            # Placeholder orientation (will be overridden)
            orient = [0, 0, 0]
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def _rotation_matrix_from_axis_angle(self, axis: np.ndarray, angle: float) -> np.ndarray:
        """Generate rotation matrix using Rodrigues' formula"""
        axis = axis / np.linalg.norm(axis)
        cos_a = np.cos(angle)
        sin_a = np.sin(angle)
        
        # Cross-product matrix
        K = np.array([[0, -axis[2], axis[1]],
                     [axis[2], 0, -axis[0]],
                     [-axis[1], axis[0], 0]])
        
        # Rodrigues' formula
        R = np.eye(3) + sin_a * K + (1 - cos_a) * K @ K
        return R
    
    def _get_perpendicular_vector(self, v: np.ndarray) -> np.ndarray:
        """Find a vector perpendicular to the given vector"""
        v = np.array(v)  # Ensure it's a numpy array
        if abs(v[0]) < 0.9:
            return np.cross(v, [1, 0, 0]) / np.linalg.norm(np.cross(v, [1, 0, 0]))
        else:
            return np.cross(v, [0, 1, 0]) / np.linalg.norm(np.cross(v, [0, 1, 0]))
    
    def _slerp_orientation(self, start_orient: List[float], 
                          end_orient: List[float], 
                          t: float) -> np.ndarray:
        """Spherical linear interpolation for orientation"""
        # Convert to quaternions
        r1 = Rotation.from_euler('xyz', start_orient, degrees=True)
        r2 = Rotation.from_euler('xyz', end_orient, degrees=True)
        
        # Create slerp object - compatible with scipy 1.11.4
        # Stack rotations into a single Rotation object
        key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
        slerp = Slerp([0, 1], key_rots)
        
        # Interpolate
        interp_rot = slerp(t)
        return interp_rot.as_euler('xyz', degrees=True)

class SplineMotion(TrajectoryGenerator):
    """Generate smooth spline trajectories through waypoints"""
    
    def generate_cubic_spline(self,
                             waypoints: List[List[float]],
                             timestamps: Optional[List[float]] = None,
                             velocity_start: Optional[List[float]] = None,
                             velocity_end: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate cubic spline trajectory through waypoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint (auto-generated if None)
            velocity_start: Initial velocity (zero if None)
            velocity_end: Final velocity (zero if None)
            
        Returns:
            Array of interpolated poses
        """
        waypoints = np.array(waypoints)
        num_waypoints = len(waypoints)
        
        # Auto-generate timestamps if not provided
        if timestamps is None:
            # Estimate based on distance
            total_dist = 0
            for i in range(1, num_waypoints):
                dist = np.linalg.norm(waypoints[i, :3] - waypoints[i-1, :3])
                total_dist += dist
            
            # Assume average speed of 50 mm/s
            total_time = total_dist / 50.0
            timestamps = np.linspace(0, total_time, num_waypoints)
        
        # Create splines for position
        pos_splines = []
        for i in range(3):
            bc_type = 'not-a-knot'  # Default boundary condition
            
            # Apply velocity boundary conditions if specified
            if velocity_start is not None and velocity_end is not None:
                bc_type = ((1, velocity_start[i]), (1, velocity_end[i]))
            
            spline = CubicSpline(timestamps, waypoints[:, i], bc_type=bc_type)
            pos_splines.append(spline)
        
        # Create splines for orientation (convert to quaternions for smooth interpolation)
        rotations = [Rotation.from_euler('xyz', wp[3:], degrees=True) for wp in waypoints]
        # Stack quaternions for scipy 1.11.4 compatibility
        quats = np.array([r.as_quat() for r in rotations])
        key_rots = Rotation.from_quat(quats)
        slerp = Slerp(timestamps, key_rots)
        
        # Generate dense trajectory
        t_eval = self.generate_timestamps(timestamps[-1])
        trajectory = []
        
        for t in t_eval:
            # Evaluate position splines
            pos = [spline(t) for spline in pos_splines]
            
            # Evaluate orientation
            rot = slerp(t)
            orient = rot.as_euler('xyz', degrees=True)
            
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def generate_quintic_spline(self,
                               waypoints: List[List[float]],
                               timestamps: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate quintic (5th order) spline with zero velocity and acceleration at endpoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint
            
        Returns:
            Array of interpolated poses
        """
        # For quintic spline, we need to ensure zero velocity and acceleration
        # at the endpoints for smooth motion
        return self.generate_cubic_spline(
            waypoints, 
            timestamps,
            velocity_start=[0, 0, 0],
            velocity_end=[0, 0, 0]
        )

class MotionBlender:
    """Blend between different motion segments for smooth transitions"""
    
    def __init__(self, blend_time: float = 0.5):
        self.blend_time = blend_time
        
    def blend_trajectories(self, traj1, traj2, blend_samples=50):
        """Blend two trajectory segments with improved velocity continuity"""
        
        if blend_samples < 4:
            return np.vstack([traj1, traj2])
        
        # Use more samples for smoother blending
        blend_samples = max(blend_samples, 20)  # Minimum 20 samples for smooth blend
        
        # Calculate overlap region more carefully
        overlap_start = max(0, len(traj1) - blend_samples // 3)
        overlap_end = min(len(traj2), blend_samples // 3)
        
        # Extract blend region
        blend_start_pose = traj1[overlap_start] if overlap_start < len(traj1) else traj1[-1]
        blend_end_pose = traj2[overlap_end] if overlap_end < len(traj2) else traj2[0]
        
        # Generate smooth transition using S-curve
        blended = []
        for i in range(blend_samples):
            t = i / (blend_samples - 1)
            # Use smoothstep function for smoother acceleration
            s = t * t * (3 - 2 * t)  # Smoothstep
            
            # Blend position
            pos_blend = blend_start_pose * (1 - s) + blend_end_pose * s
            
            # For orientation, use SLERP
            r1 = Rotation.from_euler('xyz', blend_start_pose[3:], degrees=True)
            r2 = Rotation.from_euler('xyz', blend_end_pose[3:], degrees=True)
            key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
            slerp = Slerp([0, 1], key_rots)
            orient_blend = slerp(s).as_euler('xyz', degrees=True)
            
            pos_blend[3:] = orient_blend
            blended.append(pos_blend)
        
        # Combine with better overlap handling
        result = np.vstack([
            traj1[:overlap_start],
            np.array(blended),
            traj2[overlap_end:]
        ])
        
        return result

class SmoothMotionCommand:
    """Command class for executing smooth motions on PAROL6"""
    
    def __init__(self, trajectory: np.ndarray, speed_factor: float = 1.0):
        """
        Initialize smooth motion command
        
        Args:
            trajectory: Pre-computed trajectory array
            speed_factor: Speed scaling factor (1.0 = normal speed)
        """
        self.trajectory = trajectory
        self.speed_factor = speed_factor
        self.current_index = 0
        self.is_finished = False
        self.is_valid = True
        
    def prepare_for_execution(self, current_position_in):
        """Validate trajectory is reachable from current position"""
        # Check if IK solver is available
        if solve_ik_with_adaptive_tol_subdivision is None:
            print("Warning: IK solver not available, skipping validation")
            self.is_valid = True
            return True
            
        try:
            # Convert current position to radians
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(current_position_in)])
            
            # Check first waypoint is reachable
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
            )
            
            if not ik_result.success:
                print(f"Smooth motion validation failed: Cannot reach first waypoint")
                self.is_valid = False
                return False
                
            print(f"Smooth motion prepared with {len(self.trajectory)} waypoints")
            return True
            
        except Exception as e:
            print(f"Smooth motion preparation error: {e}")
            self.is_valid = False
            return False
    
    def execute_step(self, Position_in, Speed_out, Command_out, **kwargs):
        """Execute one step of the smooth motion"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Check if required modules are available
        if PAROL6_ROBOT is None or solve_ik_with_adaptive_tol_subdivision is None:
            print("Error: Required PAROL6 modules not available")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Apply speed scaling
        step_increment = max(1, int(self.speed_factor))
        self.current_index += step_increment
        
        if self.current_index >= len(self.trajectory):
            print("Smooth motion completed")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get current target pose
        target_pose = self.trajectory[self.current_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
        )
        
        if not ik_result.success:
            print(f"IK failed at trajectory point {self.current_index}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps and send
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                       for i, q in enumerate(ik_result.q)]
        
        # Calculate velocities for smooth following
        for i in range(6):
            Speed_out[i] = int((target_steps[i] - Position_in[i]) * 10)  # P-control factor
        
        Command_out.value = 156  # Smooth motion command
        return False

# Helper functions for integration with robot_api.py

def execute_circle(center: List[float], 
                  radius: float, 
                  duration: float = 4.0,
                  normal: List[float] = [0, 0, 1]) -> str:
    """
    Execute a circular motion on PAROL6
    
    Args:
        center: Center point [x, y, z] in mm
        radius: Circle radius in mm
        duration: Time to complete circle
        normal: Normal vector to circle plane
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_circle_3d(center, radius, normal, 0, duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|CIRCLE|{traj_str}"
    
    return command

def execute_arc(start_pose: List[float],
               end_pose: List[float],
               center: List[float],
               clockwise: bool = True,
               duration: float = 2.0) -> str:
    """
    Execute an arc motion on PAROL6
    
    Args:
        start_pose: Starting pose [x, y, z, rx, ry, rz]
        end_pose: Ending pose [x, y, z, rx, ry, rz]
        center: Arc center point [x, y, z]
        clockwise: Direction of rotation
        duration: Time to complete arc
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_arc_3d(start_pose, end_pose, center, 
                                           clockwise=clockwise, duration=duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|ARC|{traj_str}"
    
    return command

def execute_spline(waypoints: List[List[float]], 
                  total_time: Optional[float] = None) -> str:
    """
    Execute a spline motion through waypoints
    
    Args:
        waypoints: List of poses [x, y, z, rx, ry, rz]
        total_time: Total time for motion (auto-calculated if None)
        
    Returns:
        Command string for robot_api
    """
    motion_gen = SplineMotion()
    
    # Generate timestamps if total_time is provided
    timestamps = None
    if total_time:
        timestamps = np.linspace(0, total_time, len(waypoints))
    
    trajectory = motion_gen.generate_cubic_spline(waypoints, timestamps)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|SPLINE|{traj_str}"
    
    return command

# Example usage
if __name__ == "__main__":
    # Example: Generate a circle trajectory
    circle_gen = CircularMotion()
    circle_traj = circle_gen.generate_circle_3d(
        center=[200, 0, 200],  # mm
        radius=50,  # mm
        duration=4.0  # seconds
    )
    print(f"Generated circle with {len(circle_traj)} points")
    
    # Example: Generate arc trajectory
    arc_traj = circle_gen.generate_arc_3d(
        start_pose=[250, 0, 200, 0, 0, 0],
        end_pose=[200, 50, 200, 0, 0, 90],
        center=[200, 0, 200],
        duration=2.0
    )
    print(f"Generated arc with {len(arc_traj)} points")
    
    # Example: Generate spline through waypoints
    spline_gen = SplineMotion()
    waypoints = [
        [200, 0, 100, 0, 0, 0],
        [250, 50, 150, 0, 15, 45],
        [200, 100, 200, 0, 30, 90],
        [150, 50, 150, 0, 15, 45],
        [200, 0, 100, 0, 0, 0]
    ]
    spline_traj = spline_gen.generate_cubic_spline(waypoints)
    print(f"Generated spline with {len(spline_traj)} points")
````

## File: start_parol6.sh
````bash
#!/bin/bash
# PAROL6 å¯åŠ¨è„šæœ¬

echo "=================================================="
echo "ğŸ¤– PAROL6 æœºæ¢°è‡‚æ§åˆ¶ç³»ç»Ÿå¯åŠ¨è„šæœ¬"
echo "=================================================="

# æ¿€æ´»condaç¯å¢ƒ
echo "ğŸ”§ æ¿€æ´»Pythonç¯å¢ƒ..."
source ~/anaconda3/bin/activate
conda activate parol

# åˆ‡æ¢åˆ°å·¥ä½œç›®å½•
cd ~/PAROL-commander-software/PAROL6-python-API

# æ£€æŸ¥ä¾èµ–
echo "ğŸ“¦ æ£€æŸ¥ä¾èµ–..."
python -c "import serial; import roboticstoolbox; import numpy" 2>/dev/null
if [ $? -ne 0 ]; then
    echo "âŒ ç¼ºå°‘ä¾èµ–ï¼Œæ­£åœ¨å®‰è£…..."
    pip install pyserial roboticstoolbox-python numpy
fi

# æµ‹è¯•ä¸²å£è¿æ¥
echo "ğŸ” æµ‹è¯•ä¸²å£è¿æ¥..."
python test_serial.py

if [ $? -eq 0 ]; then
    echo ""
    echo "âœ… ä¸²å£æµ‹è¯•é€šè¿‡"
    echo ""
    echo "ğŸš€ å¯åŠ¨PAROL6æ§åˆ¶ç¨‹åº..."
    echo "=================================================="
    python run_parol6_fixed.py
else
    echo ""
    echo "âŒ ä¸²å£è¿æ¥å¤±è´¥"
    echo ""
    echo "æ•…éšœæ’é™¤ï¼š"
    echo "1. æ£€æŸ¥æœºæ¢°è‡‚æ˜¯å¦è¿æ¥å¹¶ä¸Šç”µ"
    echo "2. æ£€æŸ¥USBçº¿ç¼†"
    echo "3. è¿è¡Œ: sudo usermod -a -G dialout \$USER"
    echo "4. æˆ–ä½¿ç”¨: sudo bash start_parol6.sh"
    exit 1
fi
````

## File: STATUS_REPORT.md
````markdown
# PAROL6 Linuxä¿®å¤å®ŒæˆæŠ¥å‘Š

## âœ… å·²å®Œæˆçš„å·¥ä½œ

### 1. **é—®é¢˜ä¿®å¤**
- âœ… ä¿®å¤äº†Linuxç¯å¢ƒä¸‹ä¸²å£åˆå§‹åŒ–é—®é¢˜
- âœ… è§£å†³äº†GUIæ¨¡å—å¯¼å…¥é”™è¯¯
- âœ… æ·»åŠ äº†ä¸²å£è‡ªåŠ¨æ£€æµ‹åŠŸèƒ½
- âœ… å®ç°äº†ä¸²å£æƒé™æ£€æŸ¥
- âœ… åˆ›å»ºäº†é”™è¯¯æ¢å¤æœºåˆ¶

### 2. **æ–°å¢æ–‡ä»¶**
| æ–‡ä»¶å | åŠŸèƒ½æè¿° |
|--------|----------|
| `run_parol6_fixed.py` | ä¸»ç¨‹åºå¯åŠ¨å™¨ï¼ˆä¿®å¤ç‰ˆï¼‰|
| `test_serial.py` | ä¸²å£è¿æ¥æµ‹è¯•å·¥å…· |
| `parol6_controller.py` | PAROL6æ§åˆ¶å™¨ç±»ï¼ˆROS2å‡†å¤‡ï¼‰|
| `start_parol6.sh` | ä¸€é”®å¯åŠ¨è„šæœ¬ |
| `README_FIXED.md` | ä½¿ç”¨æ–‡æ¡£ |
| `.gitignore` | Gitå¿½ç•¥æ–‡ä»¶é…ç½® |

### 3. **Gitæäº¤å†å²**
```
2e47273 æ·»åŠ ä¸€é”®å¯åŠ¨è„šæœ¬
ec0dfe6 ä¿®å¤Linuxä¸²å£è¿æ¥é—®é¢˜ï¼Œæ·»åŠ æµ‹è¯•å·¥å…·å’ŒROS2å‡†å¤‡
```

## ğŸš€ å¦‚ä½•ä½¿ç”¨

### æ–¹æ³•1ï¼šä¸€é”®å¯åŠ¨ï¼ˆæ¨èï¼‰
```bash
cd ~/PAROL-commander-software/PAROL6-python-API
./start_parol6.sh
```

### æ–¹æ³•2ï¼šæ‰‹åŠ¨å¯åŠ¨
```bash
# 1. æ¿€æ´»ç¯å¢ƒ
source ~/anaconda3/bin/activate
conda activate parol

# 2. è¿›å…¥ç›®å½•
cd ~/PAROL-commander-software/PAROL6-python-API

# 3. æµ‹è¯•è¿æ¥
python test_serial.py

# 4. è¿è¡Œç¨‹åº
python run_parol6_fixed.py
```

## ğŸ“¡ å½“å‰çŠ¶æ€

### âœ… æ­£å¸¸å·¥ä½œ
- ä¸²å£è¿æ¥å’Œæ£€æµ‹
- æƒé™æ£€æŸ¥
- åŸºæœ¬é€šä¿¡æµ‹è¯•

### âš ï¸ å·²çŸ¥é—®é¢˜
1. **UDPç«¯å£å†²çª**ï¼ˆ5001ç«¯å£ï¼‰
   - åŸå› ï¼šheadless_commander.pyå°è¯•ç»‘å®šUDPç«¯å£
   - è§£å†³ï¼šéœ€è¦æ£€æŸ¥ç«¯å£æ˜¯å¦è¢«å ç”¨

2. **æœºæ¢°è‡‚å“åº”**
   - è®¾å¤‡è¿æ¥æˆåŠŸä½†æœªæ”¶åˆ°å“åº”
   - å¯èƒ½éœ€è¦è°ƒæ•´é€šä¿¡åè®®

## ğŸ”„ ä¸‹ä¸€æ­¥ï¼šROS2é›†æˆ

### 1. åˆ›å»ºROS2åŒ…
```bash
# åˆ›å»ºå·¥ä½œç©ºé—´
mkdir -p ~/parol6_ws/src
cd ~/parol6_ws/src

# åˆ›å»ºåŒ…
ros2 pkg create parol6_controller \
  --build-type ament_python \
  --dependencies rclpy sensor_msgs trajectory_msgs
```

### 2. å®ç°æ§åˆ¶å™¨èŠ‚ç‚¹
- å°†`parol6_controller.py`è½¬æ¢ä¸ºROS2èŠ‚ç‚¹
- å®ç°JointTrajectoryæ¥å£
- æ·»åŠ çŠ¶æ€å‘å¸ƒå™¨

### 3. MoveIté…ç½®
- åˆ›å»ºURDFæ¨¡å‹
- ç”ŸæˆMoveIté…ç½®åŒ…
- é…ç½®æ§åˆ¶å™¨

### 4. æµ‹è¯•é›†æˆ
- å¯åŠ¨MoveIt
- æµ‹è¯•è½¨è¿¹æ‰§è¡Œ
- éªŒè¯è¿åŠ¨æ§åˆ¶

## ğŸ“‹ å¾…åŠäº‹é¡¹

- [ ] è§£å†³UDPç«¯å£å†²çªé—®é¢˜
- [ ] å®Œå–„é€šä¿¡åè®®
- [ ] åˆ›å»ºROS2åŒ…
- [ ] å®ç°MoveItæ¥å£
- [ ] æ·»åŠ URDFæ¨¡å‹
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] åˆ›å»ºDockeré•œåƒ

## ğŸ› ï¸ æŠ€æœ¯ç»†èŠ‚

### ä¸²å£é…ç½®
- æ³¢ç‰¹ç‡ï¼š3000000
- é»˜è®¤ç«¯å£ï¼š/dev/ttyACM0
- è¶…æ—¶ï¼š0.1ç§’

### ä¾èµ–åŒ…
- pyserial
- numpy
- roboticstoolbox-python
- scipy

### Pythonç‰ˆæœ¬
- Python 3.10ï¼ˆcondaç¯å¢ƒï¼šparolï¼‰

## ğŸ“ æ”¯æŒ

å¦‚æœ‰é—®é¢˜ï¼Œè¯·æ£€æŸ¥ï¼š
1. æœºæ¢°è‡‚ç”µæºå’Œè¿æ¥
2. ç”¨æˆ·æƒé™ï¼ˆdialoutç»„ï¼‰
3. ä¸²å£è®¾å¤‡å­˜åœ¨æ€§
4. Pythonç¯å¢ƒæ¿€æ´»

---
**æ›´æ–°æ—¶é—´**: 2024-09-01
**ç»´æŠ¤è€…**: wzy
````

## File: test_basic.py
````python
#!/usr/bin/env python3
"""
PAROL6 ç®€å•åŠŸèƒ½æµ‹è¯•
æµ‹è¯•åŸºæœ¬çš„ä¸²å£é€šä¿¡å’Œæœºæ¢°è‡‚æ§åˆ¶
"""
import sys
import os
import time
import serial
import socket
import threading

# æ·»åŠ ä¸Šçº§ç›®å½•åˆ°Pythonè·¯å¾„
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def test_basic_functions():
    """æµ‹è¯•åŸºæœ¬åŠŸèƒ½"""
    print("=" * 60)
    print("PAROL6 åŸºæœ¬åŠŸèƒ½æµ‹è¯•")
    print("=" * 60)
    
    # 1. æµ‹è¯•ä¸²å£è¿æ¥
    print("\n1ï¸âƒ£ æµ‹è¯•ä¸²å£è¿æ¥...")
    try:
        ser = serial.Serial(
            port='/dev/ttyACM0',
            baudrate=3000000,
            timeout=0.5
        )
        print(f"   âœ… ä¸²å£æ‰“å¼€æˆåŠŸ: {ser.port}")
        
        # å°è¯•å‘é€ä¸€äº›åŸºæœ¬å‘½ä»¤
        test_commands = [
            b"READY\n",
            b"HOME\n",
            b"STATUS\n"
        ]
        
        for cmd in test_commands:
            print(f"   ğŸ“¤ å‘é€: {cmd.decode().strip()}")
            ser.write(cmd)
            time.sleep(0.1)
            
            if ser.in_waiting > 0:
                response = ser.read(ser.in_waiting)
                print(f"   ğŸ“¥ å“åº”: {response}")
            else:
                print(f"   âš ï¸  æ— å“åº”")
        
        ser.close()
        print("   âœ… ä¸²å£æµ‹è¯•å®Œæˆ")
        
    except Exception as e:
        print(f"   âŒ ä¸²å£é”™è¯¯: {e}")
        return False
    
    # 2. æµ‹è¯•UDPç«¯å£
    print("\n2ï¸âƒ£ æµ‹è¯•UDPç«¯å£...")
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(1.0)
        sock.bind(('0.0.0.0', 5001))
        print(f"   âœ… UDPç«¯å£5001ç»‘å®šæˆåŠŸ")
        
        # å°è¯•æ¥æ”¶æ•°æ®ï¼ˆ1ç§’è¶…æ—¶ï¼‰
        print("   â³ ç­‰å¾…UDPæ•°æ®ï¼ˆ1ç§’ï¼‰...")
        try:
            data, addr = sock.recvfrom(1024)
            print(f"   ğŸ“¥ æ”¶åˆ°æ•°æ®: {data} from {addr}")
        except socket.timeout:
            print("   âš ï¸  æ— UDPæ•°æ®ï¼ˆæ­£å¸¸ï¼‰")
        
        sock.close()
        print("   âœ… UDPæµ‹è¯•å®Œæˆ")
        
    except Exception as e:
        print(f"   âŒ UDPé”™è¯¯: {e}")
    
    # 3. æµ‹è¯•å¯¼å…¥æ¨¡å—
    print("\n3ï¸âƒ£ æµ‹è¯•å¯¼å…¥æ¨¡å—...")
    try:
        from GUI.files import PAROL6_ROBOT
        print("   âœ… PAROL6_ROBOTæ¨¡å—å¯¼å…¥æˆåŠŸ")
        
        import robot_api
        print("   âœ… robot_apiæ¨¡å—å¯¼å…¥æˆåŠŸ")
        
        import smooth_motion
        print("   âœ… smooth_motionæ¨¡å—å¯¼å…¥æˆåŠŸ")
        
    except Exception as e:
        print(f"   âŒ æ¨¡å—å¯¼å…¥é”™è¯¯: {e}")
    
    print("\n" + "=" * 60)
    print("æµ‹è¯•å®Œæˆ")
    print("=" * 60)
    return True

if __name__ == "__main__":
    test_basic_functions()
````

## File: test_script.py
````python
from robot_api import move_robot_joints, home_robot, delay_robot, get_robot_joint_angles, control_pneumatic_gripper,get_robot_pose, control_electric_gripper, move_robot_pose,move_robot_cartesian,get_electric_gripper_status,get_robot_io
import time
print("Homing robot...") 
time.sleep(2)
control_electric_gripper(action = "calibrate")
time.sleep(2)
control_electric_gripper(action='move', position=100, speed=150, current = 200) 
time.sleep(2)
control_electric_gripper(action='move', position=200, speed=150, current = 200) 
time.sleep(2)
print(get_robot_joint_angles())
print(get_robot_pose())
print("Moving to new position...") 
control_pneumatic_gripper("open",1)
time.sleep(0.3)
control_pneumatic_gripper("close",1)
time.sleep(0.3)
control_pneumatic_gripper("open",1)
time.sleep(0.3)
control_pneumatic_gripper("close",1)
time.sleep(0.3)
move_robot_joints([90, -90, 160, 12, 12, 180], duration=5.5)
time.sleep(6)
move_robot_joints([50, -60, 180, -12, 32, 0], duration=5.5)
time.sleep(6)
move_robot_joints([90, -90, 160, 12, 12, 180], duration=5.5)
time.sleep(6)
move_robot_pose([7, 250, 200, -100, 0, -90], duration=5.5) 
time.sleep(6)
move_robot_cartesian([7, 250, 150, -100, 0, -90], speed_percentage=50) 
delay_robot(0.2)
print(get_electric_gripper_status())
print(get_robot_io())
````

## File: test_serial.py
````python
#!/usr/bin/env python3
"""
PAROL6 ä¸²å£è¿æ¥æµ‹è¯•è„šæœ¬
ç”¨äºéªŒè¯ä¸²å£é€šä¿¡æ˜¯å¦æ­£å¸¸
"""
import serial
import serial.tools.list_ports
import time
import sys
import os

def test_serial_connection():
    """æµ‹è¯•ä¸²å£è¿æ¥"""
    print("ğŸ” PAROL6 ä¸²å£è¿æ¥æµ‹è¯•")
    print("-" * 40)
    
    # åˆ—å‡ºæ‰€æœ‰å¯ç”¨ä¸²å£
    print("\nğŸ“¡ å¯ç”¨çš„ä¸²å£:")
    ports = serial.tools.list_ports.comports()
    
    if not ports:
        print("  âŒ æœªæ£€æµ‹åˆ°ä»»ä½•ä¸²å£è®¾å¤‡")
        return False
    
    for port in ports:
        print(f"  â€¢ {port.device} - {port.description}")
    
    # æµ‹è¯•ä¸²å£æƒé™
    print("\nğŸ”‘ æ£€æŸ¥ä¸²å£æƒé™:")
    test_ports = ["/dev/ttyACM0", "/dev/ttyUSB0"]
    
    for port_name in test_ports:
        if os.path.exists(port_name):
            # æ£€æŸ¥æ–‡ä»¶æƒé™
            import stat
            st = os.stat(port_name)
            mode = st.st_mode
            
            # æ£€æŸ¥æ˜¯å¦å¯è¯»å†™
            if os.access(port_name, os.R_OK | os.W_OK):
                print(f"  âœ… {port_name} - å¯è¯»å†™")
            else:
                print(f"  âŒ {port_name} - æƒé™ä¸è¶³")
                print(f"     è¿è¡Œ: sudo chmod 666 {port_name}")
                print(f"     æˆ–: sudo usermod -a -G dialout $USER")
    
    # å°è¯•è¿æ¥
    print("\nğŸ”Œ å°è¯•è¿æ¥ä¸²å£:")
    
    for port in ports:
        if "ACM" in port.device or "USB" in port.device:
            print(f"\nå°è¯•è¿æ¥ {port.device}...")
            try:
                ser = serial.Serial(
                    port=port.device,
                    baudrate=3000000,
                    timeout=1,
                    write_timeout=1
                )
                
                print(f"  âœ… æˆåŠŸæ‰“å¼€ {port.device}")
                
                # å‘é€æµ‹è¯•å‘½ä»¤
                print("  ğŸ“¤ å‘é€æµ‹è¯•å‘½ä»¤...")
                ser.write(b"READY\n")
                time.sleep(0.5)
                
                # è¯»å–å“åº”
                if ser.in_waiting > 0:
                    response = ser.read(ser.in_waiting)
                    print(f"  ğŸ“¥ æ”¶åˆ°å“åº”: {response}")
                else:
                    print("  âš ï¸  æœªæ”¶åˆ°å“åº”ï¼ˆè®¾å¤‡å¯èƒ½æœªå‡†å¤‡å¥½ï¼‰")
                
                ser.close()
                print(f"  âœ… ä¸²å£æµ‹è¯•æˆåŠŸ!")
                return True
                
            except serial.SerialException as e:
                print(f"  âŒ è¿æ¥å¤±è´¥: {e}")
            except PermissionError as e:
                print(f"  âŒ æƒé™é”™è¯¯: {e}")
                print(f"     è¯·è¿è¡Œ: sudo chmod 666 {port.device}")
                print(f"     æˆ–ä½¿ç”¨: sudo python {sys.argv[0]}")
    
    print("\nâŒ æ— æ³•è¿æ¥åˆ°ä»»ä½•ä¸²å£")
    return False

if __name__ == "__main__":
    print("=" * 50)
    print("PAROL6 ä¸²å£è¯Šæ–­å·¥å…·")
    print("=" * 50)
    
    success = test_serial_connection()
    
    print("\n" + "=" * 50)
    if success:
        print("âœ… æµ‹è¯•é€šè¿‡ï¼å¯ä»¥è¿è¡Œä¸»ç¨‹åº:")
        print("   python run_parol6_fixed.py")
    else:
        print("âŒ æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥:")
        print("   1. æœºæ¢°è‡‚æ˜¯å¦è¿æ¥å¹¶ä¸Šç”µ")
        print("   2. USBçº¿ç¼†æ˜¯å¦æ­£å¸¸")
        print("   3. ç”¨æˆ·æƒé™æ˜¯å¦æ­£ç¡®")
        print("   4. å°è¯•ä½¿ç”¨sudoè¿è¡Œ")
    print("=" * 50)
````

## File: test_smooth_motion.py
````python
import time
import robot_api
import numpy as np

# Define the safe starting joint configuration for all smooth motion tests.
# This ensures consistency and repeatability for each test.
# Angles: [J1, J2, J3, J4, J5, J6] in degrees.
SAFE_SMOOTH_START_JOINTS = [42.697,-89.381,144.831,-0.436,31.528,180.0]

def initialize_test_position():
    """
    Moves the robot to the predefined safe starting joint angles and waits.
    This function is called before every smooth motion test.

    Returns:
        list: The robot's Cartesian pose [x, y, z, rx, ry, rz] after moving,
              or None if the move fails or the pose cannot be retrieved.
    """
    print("\n" + "="*60)
    print(f"MOVING TO SAFE STARTING POSITION: {SAFE_SMOOTH_START_JOINTS}")
    print("="*60)
    
    # Move to the joint position with a 4-second duration and wait for acknowledgment.
    result = robot_api.move_robot_joints(
        SAFE_SMOOTH_START_JOINTS, 
        duration=4, 
        wait_for_ack=True,
        timeout=5
    )
    print(f"--> Move command result: {result}")

    # Wait until the robot has physically stopped moving.
    if robot_api.wait_for_robot_stopped(timeout=10):
        print("--> Robot has reached the starting position.")
        time.sleep(1)
        start_pose = robot_api.get_robot_pose()
        if start_pose:
            print(f"--> Starting Pose confirmed at: {[round(p, 2) for p in start_pose]}")
            return start_pose
        else:
            print("--> ERROR: Could not retrieve robot pose after moving.")
            return None
    else:
        print("--> ERROR: Robot did not stop in time. Aborting test.")
        return None

def test_smooth_circle_basic(start_pose):
    """Tests the smooth_circle command with different planes, directions, and timing modes."""
    print("\n--- TESTING SMOOTH CIRCLE (BASIC) ---")
    
    # Define a center point relative to the starting Z-height
    radius = 30.0  # 30mm radius

    center_point = [start_pose[0], start_pose[1] + radius, start_pose[2]]  # Changed from +50 to +radius

    # Test 1: XY plane, counter-clockwise with DURATION
    print("\n[1/4] Testing Circle: XY Plane, Counter-Clockwise (Duration mode)")
    result = robot_api.smooth_circle(
        center=center_point,
        radius=radius,
        plane='XY',
        duration=5.0,  # Using duration
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)

    # Test 1: XY plane, counter-clockwise with DURATION in TRF
    print("\n[2/4] Testing Circle: XY Plane, Counter-Clockwise (Duration mode)")
    result = robot_api.smooth_circle(
        center=center_point,
        radius=radius,
        frame='TRF',  # NEW: Test in TRF
        plane='XY',
        duration=5.0,  # Using duration
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)

    # Test 2: XZ plane, clockwise with SPEED PERCENTAGE
    print("\n[3/4] Testing Circle: XZ Plane, Clockwise (Speed percentage mode)")
    result = robot_api.smooth_circle(
        center=center_point,
        radius=radius,
        plane='XZ',
        speed_percentage=30,  # Using speed percentage (30% speed)
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)
    
    # Test 3: YZ plane with specified start position (NEW)
    print("\n[4/4] Testing Circle: YZ Plane with SPECIFIED START POSITION")
    # Define a start position slightly offset from current
    specified_start = [start_pose[0] + 10, start_pose[1] + 10, start_pose[2], 
                      start_pose[3], start_pose[4], start_pose[5]]
    result = robot_api.smooth_circle(
        center=center_point,
        radius=radius,
        plane='YZ',
        start_pose=specified_start,  # NEW: Will transition here first
        duration=5.0,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)

def test_smooth_arc_with_start_positions(start_pose):
    """Tests smooth arc commands with specified start positions and transitions."""
    print("\n--- TESTING SMOOTH ARC WITH START POSITIONS ---")

    # Test 1: Arc with FAR start position (should see smooth transition)
    print("\n[1/4] Testing Arc with FAR START POSITION (big transition)")
    far_start = [start_pose[0] + 40, start_pose[1] - 20, start_pose[2] + 10,
                 start_pose[3], start_pose[4], start_pose[5]]
    arc_center = [far_start[0] - 20, far_start[1], far_start[2]]
    end_pose_arc = [arc_center[0], arc_center[1] + 20, far_start[2],
                   far_start[3], far_start[4], far_start[5] + 45]
    
    print(f"  Current position: {[round(p, 1) for p in start_pose[:3]]}")
    print(f"  Transition to: {[round(p, 1) for p in far_start[:3]]}")
    print(f"  Then arc to: {[round(p, 1) for p in end_pose_arc[:3]]}")
    
    result = robot_api.smooth_arc_center(
        end_pose=end_pose_arc,
        center=arc_center,
        start_pose=far_start,  # Will transition here first
        duration=6.0,
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=12)
    time.sleep(2)

    # Re-initialize for next test
    current_pose = initialize_test_position()
    if not current_pose: return

    # Test 2: Arc with CLOSE start position (minimal transition)
    print("\n[2/4] Testing Arc with CLOSE START POSITION (minimal transition)")
    close_start = [current_pose[0] + 2, current_pose[1] + 2, current_pose[2],
                   current_pose[3], current_pose[4], current_pose[5]]
    arc_center = [close_start[0] - 15, close_start[1], close_start[2]]
    end_pose_arc = [arc_center[0], arc_center[1] + 15, close_start[2],
                   close_start[3], close_start[4], close_start[5] + 30]
    
    print(f"  Current position: {[round(p, 1) for p in current_pose[:3]]}")
    print(f"  Transition to: {[round(p, 1) for p in close_start[:3]]}")
    print(f"  Then arc to: {[round(p, 1) for p in end_pose_arc[:3]]}")
    
    result = robot_api.smooth_arc_center(
        end_pose=end_pose_arc,
        center=arc_center,
        start_pose=close_start,  # Very close, minimal transition
        speed_percentage=40,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)

    # Test 3: Parametric arc with specified start
    print("\n[3/4] Testing PARAMETRIC Arc with specified start")
    param_start = [current_pose[0] - 10, current_pose[1] + 5, current_pose[2],
                   current_pose[3], current_pose[4], current_pose[5]]
    end_pose_param = [param_start[0] + 20, param_start[1] - 10, param_start[2],
                     param_start[3], param_start[4], param_start[5]]
    
    result = robot_api.smooth_arc_parametric(
        end_pose=end_pose_param,
        radius=20.0,
        arc_angle=60.0,
        start_pose=param_start,
        duration=4.0,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)

    # Test 4: Arc in TRF - arc plane follows tool orientation
    print("\n[4/4] Testing Arc in TOOL REFERENCE FRAME (TRF)")
    # In TRF, the arc is defined relative to the tool's coordinate system
    trf_start = [10, 10, 10, 0, 0, 0]  # Position relative to tool
    trf_center = [0, 0, 0]  # Center at tool origin
    trf_end = [10, -10, 10, 0, 0, 45]  # End position in tool frame
    
    print(f"  TRF Arc - all coordinates relative to tool position/orientation")
    print(f"  If tool is tilted, the arc plane will be tilted too!")
    
    result = robot_api.smooth_arc_center(
        end_pose=trf_end,
        center=trf_center,
        frame='TRF',  # NEW: Using Tool Reference Frame
        start_pose=trf_start,
        duration=5.0,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)

def test_motion_chaining(start_pose):
    """Tests precise motion chaining using end pose of one motion as start of next."""
    print("\n--- TESTING MOTION CHAINING (NEW) ---")
    print("This tests using the exact end pose of one motion as the start of the next")
    
    # Motion 1: Arc to a specific end pose
    print("\n[1/4] First Motion: Arc")
    arc_center = [start_pose[0] - 20, start_pose[1], start_pose[2]]
    arc_end = [arc_center[0], arc_center[1] + 30, start_pose[2],
               start_pose[3], start_pose[4] + 15, start_pose[5] + 45]
    
    result = robot_api.smooth_arc_center(
        end_pose=arc_end,
        center=arc_center,
        duration=4.0,
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Arc ended at: {[round(p, 1) for p in arc_end[:3]]}")
    robot_api.wait_for_robot_stopped(timeout=8)
    time.sleep(1)
    
    # Motion 2: Circle in TRF starting exactly where arc ended
    print("\n[2/4] Second Motion: Circle in TRF starting at arc's end position")
    # In TRF, center is relative to current tool position
    trf_circle_center = [0, 25, 0]  # 25mm forward in tool Y-axis
    
    result = robot_api.smooth_circle(
        center=trf_circle_center,
        radius=25.0,
        plane='XY',  # This is the tool's XY plane, not world XY!
        frame='TRF',  # NEW: Circle plane follows tool orientation
        start_pose=arc_end,  # Start exactly where arc ended
        speed_percentage=35,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Circle in TRF completed (plane followed tool orientation)")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(1)
    
    # Since circle returns to start, we know where we are
    circle_end = arc_end  # Circle returns to its start point
    
    # Motion 3: Helix starting where circle ended
    print("\n[3/4] Third Motion: Helix starting at circle's position")
    # Calculate actual radius from circle end position
    helix_center = [circle_end[0], circle_end[1], circle_end[2] - 30]
    # Use the actual distance as radius
    actual_radius = np.sqrt((circle_end[0] - helix_center[0])**2 + 
                        (circle_end[1] - helix_center[1])**2)
    radius = max(actual_radius, 1.0)  # Use actual distance, minimum 1mm
    
    result = robot_api.smooth_helix(
        center=helix_center,
        radius=15.0,
        pitch=10.0,
        height=30.0,
        start_pose=circle_end,  # Start where circle ended
        duration=6.0,
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Helix completed")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(1)
    
    # Calculate helix end position (approximately)
    helix_end = [helix_center[0] + 15, helix_center[1], helix_center[2] + 30,
                 circle_end[3], circle_end[4], circle_end[5]]
    
    # Motion 4: Spline back to near start
    print("\n[4/4] Fourth Motion: Spline path back near start")
    waypoints = [
        helix_end,  # Start from helix end
        [helix_end[0] - 10, helix_end[1] - 10, helix_end[2] - 10,
         helix_end[3], helix_end[4], helix_end[5] - 20],
        [start_pose[0] + 5, start_pose[1] + 5, start_pose[2],
         start_pose[3], start_pose[4], start_pose[5]]
    ]
    
    result = robot_api.smooth_spline(
        waypoints=waypoints[1:],  # Skip first since we specify start_pose
        start_pose=waypoints[0],  # Explicitly start from helix end
        speed_percentage=30,
        wait_for_ack=True
    )
    print(f"--> Spline completed - returned near start")
    robot_api.wait_for_robot_stopped(timeout=10)

def test_smooth_spline_with_starts(start_pose):
    """Tests smooth_spline with various start position scenarios."""
    print("\n--- TESTING SMOOTH SPLINE WITH START POSITIONS ---")
    
    # Test 1: Spline with default start (current position)
    print("\n[1/4] Spline with DEFAULT start (from current position)")
    waypoints = []
    for i in range(4):
        x = start_pose[0] + i * 15
        y = start_pose[1] + (15 if i % 2 else -15)
        z = start_pose[2]
        waypoints.append([x, y, z, start_pose[3], start_pose[4], start_pose[5]])
    
    result = robot_api.smooth_spline(
        waypoints=waypoints,
        # No start_pose specified - uses current
        duration=5.0,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)
    
    # Re-initialize
    current_pose = initialize_test_position()
    if not current_pose: return
    
    # Test 2: Spline with specified start far from first waypoint
    print("\n[2/4] Spline with SPECIFIED start (different from first waypoint)")
    specified_start = [current_pose[0] - 20, current_pose[1] + 15, current_pose[2],
                      current_pose[3], current_pose[4], current_pose[5]]
    
    waypoints = [
        [specified_start[0] + 30, specified_start[1], specified_start[2],
         specified_start[3], specified_start[4], specified_start[5]],
        [specified_start[0] + 40, specified_start[1] + 20, specified_start[2],
         specified_start[3], specified_start[4], specified_start[5]],
        [specified_start[0] + 20, specified_start[1] + 30, specified_start[2],
         specified_start[3], specified_start[4], specified_start[5]]
    ]
    
    print(f"  Current: {[round(p, 1) for p in current_pose[:3]]}")
    print(f"  Will transition to: {[round(p, 1) for p in specified_start[:3]]}")
    print(f"  Then follow spline through waypoints")
    
    result = robot_api.smooth_spline(
        waypoints=waypoints,
        start_pose=specified_start,  # Will transition here first
        speed_percentage=40,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=12)
    time.sleep(2)
    
    # Re-initialize
    current_pose = initialize_test_position()
    if not current_pose: return
    
    # Test 3: Spline with start matching first waypoint (no transition needed)
    print("\n[3/4] Spline with start MATCHING first waypoint (no transition)")
    first_waypoint = [current_pose[0] + 5, current_pose[1] + 5, current_pose[2],
                     current_pose[3], current_pose[4], current_pose[5]]
    
    waypoints = [
        first_waypoint,  # Same as start_pose
        [first_waypoint[0] + 20, first_waypoint[1] + 10, first_waypoint[2],
         first_waypoint[3], first_waypoint[4], first_waypoint[5]],
        [first_waypoint[0] + 10, first_waypoint[1] + 25, first_waypoint[2],
         first_waypoint[3], first_waypoint[4], first_waypoint[5]]
    ]
    
    result = robot_api.smooth_spline(
        waypoints=waypoints[1:],  # Skip first since we use it as start_pose
        start_pose=first_waypoint,  # Same as would-be first waypoint
        duration=4.0,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=8)

    # Test 4: Spline in TRF - waypoints relative to tool
    print("\n[4/4] Spline in TOOL REFERENCE FRAME (TRF)")
    # In TRF, all waypoints are relative to the tool's coordinate system
    trf_waypoints = [
        [20, 0, 0, 0, 0, 0],     # 20mm forward in tool X
        [20, 20, 0, 0, 0, 15],   # Add 20mm in tool Y
        [0, 20, 10, 0, 0, 30],   # Move to tool Y=20, Z=10
        [0, 0, 0, 0, 0, 0]       # Return to tool origin
    ]
    
    print(f"  TRF Spline - all waypoints relative to tool coordinate system")
    print(f"  If tool is rotated, entire spline path rotates with it!")
    
    result = robot_api.smooth_spline(
        waypoints=trf_waypoints,
        frame='TRF',  # NEW: Waypoints interpreted in tool frame
        duration=6.0,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)

def test_smooth_helix_with_starts(start_pose):
    """Tests smooth_helix with specified start positions."""
    print("\n--- TESTING SMOOTH HELIX WITH START POSITIONS ---")
    
    # Test 1: Helix with default start
    print("\n[1/3] Helix with DEFAULT start (from current position)")
    center = [start_pose[0], start_pose[1] + 30, start_pose[2] - 40]
    
    result = robot_api.smooth_helix(
        center=center,
        radius=30.0,
        pitch=12.0,
        height=36.0,  # 3 revolutions
        # No start_pose - uses current
        duration=10.0,
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)
    
    # Re-initialize
    current_pose = initialize_test_position()
    if not current_pose: return
    
    # Test 2: Helix with specified start on the helix perimeter
    print("\n[2/3] Helix with SPECIFIED start on perimeter")
    center = [current_pose[0], current_pose[1] + 30, current_pose[2] - 40]
    # Start position on the helix perimeter (different angle)
    start_on_perimeter = [
        center[0] + 20,  # radius * cos(0)
        center[1],       # radius * sin(0)
        center[2],       # Starting height
        current_pose[3], current_pose[4], current_pose[5]
    ]
    
    print(f"  Current: {[round(p, 1) for p in current_pose[:3]]}")
    print(f"  Will transition to helix start: {[round(p, 1) for p in start_on_perimeter[:3]]}")
    
    result = robot_api.smooth_helix(
        center=center,
        radius=20.0,
        pitch=12.0,
        height=36.0,
        start_pose=start_on_perimeter,
        speed_percentage=30,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=12)

    # Test 3: Helix in TRF - helix axis follows tool Z-axis
    print("\n[3/3] Helix in TOOL REFERENCE FRAME (TRF)")
    # In TRF, the helix rises along the tool's Z-axis, not world Z
    trf_center = [0, 30, -40]  # Center relative to tool
    trf_start = [20, 30, -40, 0, 0, 0]  # Start on perimeter
    
    print(f"  TRF Helix - rises along TOOL'S Z-axis")
    print(f"  If tool is horizontal, helix will be horizontal too!")
    
    result = robot_api.smooth_helix(
        center=trf_center,
        radius=20.0,
        pitch=12.0,
        height=36.0,
        frame='TRF',  # NEW: Helix axis follows tool orientation
        start_pose=trf_start,
        duration=8.0,
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=12)

def test_smooth_blend_with_starts(start_pose):
    """Tests smooth_blend with specified start position for first segment."""
    print("\n--- TESTING SMOOTH BLEND WITH START POSITIONS ---")
    
    # Test 1: Blend with default start
    print("\n[1/4] Blend with DEFAULT start")
    p1 = start_pose
    p2 = [p1[0] + 25, p1[1] + 10, p1[2], p1[3], p1[4], p1[5] + 20]
    arc_center = [p2[0] - 10, p2[1] + 10, p2[2]]
    p3 = [arc_center[0], arc_center[1] + 15, arc_center[2], p1[3], p1[4], p1[5] + 40]
    
    segments = [
        {'type': 'LINE', 'end': p2, 'duration': 2.0},
        {'type': 'ARC', 'end': p3, 'center': arc_center, 'duration': 3.0, 'clockwise': False},
    ]
    
    result = robot_api.smooth_blend(
        segments=segments,
        blend_time=0.5,
        # No start_pose - uses current
        duration=6.0,
        wait_for_ack=True,
        timeout=15
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=15)
    time.sleep(2)
    
    # Re-initialize
    current_pose = initialize_test_position()
    if not current_pose: return
    
    # Test 2: Blend with specified start for first segment
    print("\n[2/4] Blend with SPECIFIED start (adds transition)")
    specified_start = [current_pose[0] + 15, current_pose[1] - 10, current_pose[2],
                      current_pose[3], current_pose[4], current_pose[5]]
    p2 = [specified_start[0] + 20, specified_start[1] + 15, specified_start[2],
          specified_start[3], specified_start[4], specified_start[5] + 30]
    circle_center = [p2[0], p2[1] + 20, p2[2]]
    
    segments = [
        {'type': 'LINE', 'end': p2, 'duration': 2.5},
        {'type': 'CIRCLE', 'center': circle_center, 'radius': 20, 'plane': 'XY', 
         'duration': 4.0, 'clockwise': True},
    ]
    
    print(f"  Current: {[round(p, 1) for p in current_pose[:3]]}")
    print(f"  Will transition to: {[round(p, 1) for p in specified_start[:3]]}")
    print(f"  Then execute blend segments")
    
    result = robot_api.smooth_blend(
        segments=segments,
        blend_time=0.75,
        start_pose=specified_start,  # First segment starts here
        speed_percentage=35,
        wait_for_ack=True,
        timeout=20
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=20)
    time.sleep(2)
    
    # Re-initialize
    current_pose = initialize_test_position()
    if not current_pose: return
    
    # Test 3: Complex blend with spline segment and specified start
    print("\n[3/4] Complex blend with SPLINE segment and specified start")
    blend_start = [current_pose[0] - 10, current_pose[1] + 10, current_pose[2],
                   current_pose[3], current_pose[4], current_pose[5]]
    
    # Define waypoints for spline segment
    spline_waypoints = [
        [blend_start[0] + 30, blend_start[1], blend_start[2],
         blend_start[3], blend_start[4], blend_start[5]],
        [blend_start[0] + 35, blend_start[1] + 15, blend_start[2],
         blend_start[3], blend_start[4], blend_start[5] + 15],
        [blend_start[0] + 25, blend_start[1] + 25, blend_start[2],
         blend_start[3], blend_start[4], blend_start[5] + 30]
    ]
    
    segments = [
        {'type': 'LINE', 'end': spline_waypoints[0], 'duration': 2.0},
        {'type': 'SPLINE', 'waypoints': spline_waypoints, 'duration': 4.0},
        {'type': 'LINE', 'end': [blend_start[0], blend_start[1] + 20, blend_start[2],
                                 blend_start[3], blend_start[4], blend_start[5]], 
         'duration': 2.0}
    ]
    
    result = robot_api.smooth_blend(
        segments=segments,
        blend_time=0.5,
        start_pose=blend_start,
        duration=10.0,  # Overall duration
        wait_for_ack=True,
        timeout=20
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=20)

    # Test 4: Blend in TRF - all segments relative to tool
    print("\n[4/4] Blend in TOOL REFERENCE FRAME (TRF)")
    # All segment coordinates are relative to tool position/orientation
    trf_segments = [
        {'type': 'LINE', 'end': [30, 0, 0, 0, 0, 0], 'duration': 2.0},
        {'type': 'CIRCLE', 'center': [30, 20, 0], 'radius': 20, 'plane': 'XY', 
         'duration': 4.0, 'clockwise': False},  # Tool's XY plane
        {'type': 'LINE', 'end': [0, 20, 0, 0, 0, 0], 'duration': 2.0}
    ]
    
    print(f"  TRF Blend - all segments in tool coordinate system")
    print(f"  Circle plane is tool's XY, not world XY!")
    
    result = robot_api.smooth_blend(
        segments=trf_segments,
        blend_time=0.5,
        frame='TRF',  # NEW: All segments in tool frame
        duration=10.0,
        wait_for_ack=True,
        timeout=20
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=20)

def test_transition_distances():
    """Test transitions with various distances to verify smooth transition behavior."""
    print("\n--- TESTING TRANSITION DISTANCES ---")
    
    # Get current position
    start_pose = initialize_test_position()
    if not start_pose: return
    
    # Define test distances: very close, medium, far
    test_cases = [
        ("Very Close (3mm)", 3),
        ("Close (10mm)", 10),
        ("Medium (30mm)", 30),
        ("Far (50mm)", 50)
    ]
    
    for description, distance in test_cases:
        print(f"\n[{test_cases.index((description, distance)) + 1}/{len(test_cases)}] Testing transition: {description}")
        
        # Create a start position at the specified distance
        transition_start = [
            start_pose[0] + distance,
            start_pose[1],
            start_pose[2],
            start_pose[3], start_pose[4], start_pose[5]
        ]
        
        # Use a simple circle to observe the transition
        circle_center = [transition_start[0], transition_start[1] + 30, transition_start[2]]
        
        print(f"  Current position: {[round(p, 1) for p in start_pose[:3]]}")
        print(f"  Transition to: {[round(p, 1) for p in transition_start[:3]]}")
        print(f"  Distance: {distance}mm")
        
        start_time = time.time()
        result = robot_api.smooth_circle(
            center=circle_center,
            radius=30.0,
            plane='XY',
            start_pose=transition_start,
            duration=5.0,
            clockwise=False,
            wait_for_ack=True
        )
        
        # Note the transition time
        robot_api.wait_for_robot_stopped(timeout=10)
        total_time = time.time() - start_time
        
        print(f"  Total execution time: {total_time:.2f}s")
        if distance <= 5:
            print(f"  -> Minimal transition expected and observed")
        else:
            transition_time = distance / 30.0  # Assuming 30mm/s transition speed
            print(f"  -> Estimated transition time: {transition_time:.2f}s")
        
        time.sleep(2)
        
        # Return to start for next test
        if test_cases.index((description, distance)) < len(test_cases) - 1:
            initialize_test_position()

    # Additional test: Transition in TRF
    print("\n[BONUS] Testing transition in TRF")
    print("In TRF, transition is relative to tool, not world")
    
    # TRF start position (30mm forward in tool X)
    trf_transition_start = [30, 0, 0, 0, 0, 0]
    trf_circle_center = [30, 30, 0]  # Center in tool frame
    
    result = robot_api.smooth_circle(
        center=trf_circle_center,
        radius=30.0,
        plane='XY',  # Tool's XY plane
        frame='TRF',  # NEW: Transition happens in tool space
        start_pose=trf_transition_start,
        duration=5.0,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"  -> TRF transition completed")
    robot_api.wait_for_robot_stopped(timeout=10)

def test_timing_comparison_with_starts():
    """Compare timing modes with specified start positions."""
    print("\n--- TESTING TIMING MODES WITH START POSITIONS ---")
    
    # Initialize
    start_pose = initialize_test_position()
    if not start_pose: return
    
    # Define a specific start position for both tests
    test_start = [start_pose[0] + 20, start_pose[1] - 10, start_pose[2],
                  start_pose[3], start_pose[4], start_pose[5]]
    center = [test_start[0], test_start[1] + 30, test_start[2]]
    radius = 30.0
    
    print("\n[1/3] Circle with specified start + 5-second DURATION")
    print(f"  Transition from: {[round(p, 1) for p in start_pose[:3]]}")
    print(f"  To start position: {[round(p, 1) for p in test_start[:3]]}")
    
    start_time = time.time()
    result = robot_api.smooth_circle(
        center=center,
        radius=radius,
        plane='XY',
        start_pose=test_start,
        duration=5.0,
        clockwise=False,
        wait_for_ack=True
    )
    robot_api.wait_for_robot_stopped(timeout=12)
    elapsed = time.time() - start_time
    print(f"--> Total execution time (including transition): {elapsed:.2f}s")
    time.sleep(2)
    
    # Return to start
    initialize_test_position()
    
    print("\n[2/3] Same circle with specified start + 40% SPEED")
    print(f"  Same transition and circle path")
    
    start_time = time.time()
    result = robot_api.smooth_circle(
        center=center,
        radius=radius,
        plane='XY',
        start_pose=test_start,
        speed_percentage=40,
        clockwise=False,
        wait_for_ack=True
    )
    robot_api.wait_for_robot_stopped(timeout=12)
    elapsed = time.time() - start_time
    print(f"--> Total execution time (including transition): {elapsed:.2f}s")

    print("\n[3/3] Same circle in TRF with 40% SPEED")
    print(f"  Testing how TRF affects timing with transitions")
    
    # TRF coordinates (relative to tool)
    trf_start = [20, -10, 0, 0, 0, 0]
    trf_center = [20, 20, 0]  # 30mm forward in tool Y from start
    
    start_time = time.time()
    result = robot_api.smooth_circle(
        center=trf_center,
        radius=30.0,
        plane='XY',  # Tool's XY plane
        frame='TRF',  # NEW: Using tool reference frame
        start_pose=trf_start,
        speed_percentage=40,
        clockwise=False,
        wait_for_ack=True
    )
    robot_api.wait_for_robot_stopped(timeout=12)
    elapsed = time.time() - start_time
    print(f"--> TRF execution time: {elapsed:.2f}s")
    print(f"  Note: TRF doesn't change timing, just coordinate interpretation")
    
    # Calculate expected times
    circumference = 2 * np.pi * radius
    transition_dist = np.sqrt((test_start[0] - start_pose[0])**2 + 
                              (test_start[1] - start_pose[1])**2 + 
                              (test_start[2] - start_pose[2])**2)
    print(f"\nAnalysis:")
    print(f"  Transition distance: {transition_dist:.1f}mm")
    print(f"  Circle circumference: {circumference:.1f}mm")
    print(f"  At 40% speed (~40mm/s), circle should take ~{circumference/40:.1f}s")
    print(f"  Transition at ~30mm/s should take ~{transition_dist/30:.1f}s")

if __name__ == "__main__":
    print("="*70)
    print("COMPREHENSIVE SMOOTH MOTION TEST SUITE")
    print("Testing NEW features: Start Positions & Automatic Transitions")
    print("="*70)
    
    
    # Test 1: Basic tests with new start position feature
    print("\n[TEST GROUP 1: BASIC COMMANDS WITH START POSITIONS]")
    start_pose = initialize_test_position()
    if start_pose:
        test_smooth_circle_basic(start_pose)
    
    # Test 2: Arc commands with various start positions
    print("\n[TEST GROUP 2: ARC COMMANDS WITH TRANSITIONS]")
    start_pose = initialize_test_position()
    if start_pose:
        test_smooth_arc_with_start_positions(start_pose)
    
    # Test 3: Motion chaining - using end of one as start of next
    print("\n[TEST GROUP 3: PRECISE MOTION CHAINING]")
    start_pose = initialize_test_position()
    if start_pose:
        test_motion_chaining(start_pose)
    
    # Test 4: Spline with various start scenarios
    print("\n[TEST GROUP 4: SPLINE WITH START POSITIONS]")
    start_pose = initialize_test_position()
    if start_pose:
        test_smooth_spline_with_starts(start_pose)
    
    # Test 5: Helix with start positions
    print("\n[TEST GROUP 5: HELIX WITH START POSITIONS]")
    start_pose = initialize_test_position()
    if start_pose:
        test_smooth_helix_with_starts(start_pose)
    
    # Test 6: Blend with start positions
    print("\n[TEST GROUP 6: BLEND WITH START POSITIONS]")
    start_pose = initialize_test_position()
    if start_pose:
        test_smooth_blend_with_starts(start_pose)
    
    # Test 7: Transition distance testing
    print("\n[TEST GROUP 7: TRANSITION DISTANCE BEHAVIOR]")
    test_transition_distances()
    
    # Test 8: Timing comparison with transitions
    print("\n[TEST GROUP 8: TIMING MODES WITH TRANSITIONS]")
    test_timing_comparison_with_starts()
    
    print("\n" + "="*70)
    print("COMPREHENSIVE TEST SUITE COMPLETE")
    print("Tested features:")
    print("  âœ“ All commands with duration mode")
    print("  âœ“ All commands with speed percentage mode")
    print("  âœ“ Default start positions (current position)")
    print("  âœ“ Specified start positions with automatic transitions")
    print("  âœ“ Motion chaining with precise continuity")
    print("  âœ“ Transition behavior for various distances")
    print("  âœ“ Blend segments with overall timing control")
    print("="*70)
    
    # Final return to safe position
    print("\nReturning to safe position...")
    initialize_test_position()
    print("\n===== All Tests Finished =====")
````

## File: test/all-test.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 API å…¨åŠŸèƒ½å®‰å…¨æµ‹è¯•ç¨‹åº
ç³»ç»Ÿæ€§æµ‹è¯•æ‰€æœ‰å¯ç”¨çš„APIåŠŸèƒ½
"""
import sys
import os

# è·å–å½“å‰æ–‡ä»¶çš„ç»å¯¹è·¯å¾„
current_dir = os.path.dirname(os.path.abspath(__file__))

# è·å–çˆ¶ç›®å½•è·¯å¾„
parent_dir = os.path.dirname(current_dir)

# å°†çˆ¶ç›®å½•æ·»åŠ åˆ°æ¨¡å—æœç´¢è·¯å¾„ä¸­
sys.path.append(parent_dir)

# ç°åœ¨å¯ä»¥å¯¼å…¥çˆ¶ç›®å½•ä¸­çš„æ¨¡å—
from robot_api import *
import time
import traceback
from robot_api import *

class PAROL6APITester:
    def __init__(self):
        """åˆå§‹åŒ–APIæµ‹è¯•å™¨"""
        self.test_results = {}
        self.safe_pose = [200, 0, 200, 180, 0, 90]  # å®‰å…¨çš„æµ‹è¯•ä½å§¿
        self.safe_joints = [0, -45, 90, 0, 45, 90]  # å®‰å…¨çš„å…³èŠ‚è§’åº¦
        self.test_count = 0
        self.passed_count = 0
        self.failed_count = 0
        self.skipped_count = 0
        
        print("ğŸ”¬ PAROL6 API å…¨åŠŸèƒ½æµ‹è¯•å™¨å·²åˆå§‹åŒ–")
        print("âš ï¸  æ³¨æ„ï¼šæœ¬ç¨‹åºå°†æµ‹è¯•æ‰€æœ‰APIåŠŸèƒ½ï¼Œè¯·ç¡®ä¿:")
        print("   1. æœºå™¨äººå‘¨å›´å®‰å…¨æ— éšœç¢ç‰©")
        print("   2. æ€¥åœæŒ‰é’®éšæ—¶å¯ç”¨")
        print("   3. æœ‰è¶³å¤Ÿçš„å·¥ä½œç©ºé—´")
        print("   4. å·²è¿æ¥å¤¹å…·ï¼ˆå¦‚éœ€æµ‹è¯•å¤¹å…·åŠŸèƒ½ï¼‰")

    def log_test(self, test_name, result, details=""):
        """è®°å½•æµ‹è¯•ç»“æœ"""
        self.test_count += 1
        status = "âœ… é€šè¿‡" if result == "PASS" else "âŒ å¤±è´¥" if result == "FAIL" else "â­ï¸ è·³è¿‡"
        
        if result == "PASS":
            self.passed_count += 1
        elif result == "FAIL":
            self.failed_count += 1
        else:
            self.skipped_count += 1
            
        self.test_results[test_name] = {"status": result, "details": details}
        print(f"{status} {test_name}: {details}")

    def safe_execute(self, func, *args, **kwargs):
        """å®‰å…¨æ‰§è¡Œå‡½æ•°"""
        try:
            result = func(*args, **kwargs)
            return result, None
        except Exception as e:
            return None, str(e)

    def user_confirm(self, message, default="y"):
        """ç”¨æˆ·ç¡®è®¤"""
        choice = input(f"{message} ({default}/n/s=è·³è¿‡): ").lower() or default
        if choice == 's':
            return "skip"
        return choice == 'y'

    # ================================
    # 1. çŠ¶æ€æŸ¥è¯¢APIæµ‹è¯•
    # ================================
    
    def test_status_apis(self):
        """æµ‹è¯•æ‰€æœ‰çŠ¶æ€æŸ¥è¯¢API"""
        print("\n" + "="*50)
        print("ğŸ” æµ‹è¯•çŠ¶æ€æŸ¥è¯¢API")
        print("="*50)
        
        # 1. è·å–å…³èŠ‚è§’åº¦
        result, error = self.safe_execute(get_robot_joint_angles)
        if result is not None:
            self.log_test("get_robot_joint_angles", "PASS", f"å…³èŠ‚è§’åº¦: {[round(a,2) for a in result]}")
        else:
            self.log_test("get_robot_joint_angles", "FAIL", f"é”™è¯¯: {error}")
        
        # 2. è·å–æœºå™¨äººä½å§¿
        result, error = self.safe_execute(get_robot_pose)
        if result is not None:
            self.log_test("get_robot_pose", "PASS", f"ä½å§¿: {[round(p,2) for p in result]}")
        else:
            self.log_test("get_robot_pose", "FAIL", f"é”™è¯¯: {error}")
        
        # 3. è·å–å…³èŠ‚é€Ÿåº¦
        result, error = self.safe_execute(get_robot_joint_speeds)
        if result is not None:
            self.log_test("get_robot_joint_speeds", "PASS", f"é€Ÿåº¦: {result}")
        else:
            self.log_test("get_robot_joint_speeds", "FAIL", f"é”™è¯¯: {error}")
        
        # 4. è·å–IOçŠ¶æ€
        # result, error = self.safe_execute(get_io_status)
        # if result is not None:
        #     self.log_test("get_io_status", "PASS", f"IOçŠ¶æ€: {result}")
        # else:
        #     self.log_test("get_io_status", "FAIL", f"é”™è¯¯: {error}")
        
        # 5. è·å–ç”µåŠ¨å¤¹å…·çŠ¶æ€
        result, error = self.safe_execute(get_electric_gripper_status)
        if result is not None:
            self.log_test("get_electric_gripper_status", "PASS", f"å¤¹å…·çŠ¶æ€: {result}")
        else:
            self.log_test("get_electric_gripper_status", "FAIL", f"é”™è¯¯: {error}")
        
        # 6. è·å–å˜æ¢çŸ©é˜µ
        result, error = self.safe_execute(get_robot_pose_matrix)
        if result is not None:
            self.log_test("get_robot_pose_matrix", "PASS", "çŸ©é˜µè·å–æˆåŠŸ")
        else:
            self.log_test("get_robot_pose_matrix", "FAIL", f"é”™è¯¯: {error}")
        
        # 7. æ£€æŸ¥æ˜¯å¦åœæ­¢
        result, error = self.safe_execute(is_robot_stopped)
        if result is not None:
            self.log_test("is_robot_stopped", "PASS", f"åœæ­¢çŠ¶æ€: {result}")
        else:
            self.log_test("is_robot_stopped", "FAIL", f"é”™è¯¯: {error}")
        
        # 8. è·å–ç»¼åˆçŠ¶æ€
        result, error = self.safe_execute(get_robot_status)
        if result is not None:
            self.log_test("get_robot_status", "PASS", "ç»¼åˆçŠ¶æ€è·å–æˆåŠŸ")
        else:
            self.log_test("get_robot_status", "FAIL", f"é”™è¯¯: {error}")

    # ================================
    # 2. åŸºç¡€ç§»åŠ¨APIæµ‹è¯•
    # ================================
    
    def test_basic_movement_apis(self):
        """æµ‹è¯•åŸºç¡€ç§»åŠ¨API"""
        print("\n" + "="*50)
        print("ğŸ¤– æµ‹è¯•åŸºç¡€ç§»åŠ¨API")
        print("="*50)
        
        # 1. å½’é›¶æµ‹è¯•
        if self.user_confirm("æµ‹è¯•æœºå™¨äººå½’é›¶?") == "skip":
            self.log_test("home_robot", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            result, error = self.safe_execute(home_robot, wait_for_ack=True, timeout=30)
            if result and result.get('status') == 'COMPLETED':
                self.log_test("home_robot", "PASS", "å½’é›¶æˆåŠŸ")
                time.sleep(2)
            else:
                self.log_test("home_robot", "FAIL", f"å½’é›¶å¤±è´¥: {error or result}")
        
        # 2. å…³èŠ‚ç§»åŠ¨æµ‹è¯•
        if self.user_confirm("æµ‹è¯•å…³èŠ‚ç§»åŠ¨åˆ°å®‰å…¨ä½ç½®?") == "skip":
            self.log_test("move_robot_joints", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            result, error = self.safe_execute(
                move_robot_joints, 
                self.safe_joints, 
                speed_percentage=20, 
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("move_robot_joints", "PASS", f"ç§»åŠ¨åˆ°: {self.safe_joints}")
                time.sleep(1)
            else:
                self.log_test("move_robot_joints", "FAIL", f"å¤±è´¥: {error or result}")
        
        # 3. ä½å§¿ç§»åŠ¨æµ‹è¯•
        if self.user_confirm("æµ‹è¯•ä½å§¿ç§»åŠ¨?") == "skip":
            self.log_test("move_robot_pose", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            result, error = self.safe_execute(
                move_robot_pose, 
                self.safe_pose, 
                speed_percentage=20, 
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("move_robot_pose", "PASS", f"ç§»åŠ¨åˆ°: {self.safe_pose}")
                time.sleep(1)
            else:
                self.log_test("move_robot_pose", "FAIL", f"å¤±è´¥: {error or result}")
        
        # 4. ç›´çº¿ç§»åŠ¨æµ‹è¯•
        if self.user_confirm("æµ‹è¯•ç¬›å¡å°”ç›´çº¿ç§»åŠ¨?") == "skip":
            self.log_test("move_robot_cartesian", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            target_pose = self.safe_pose.copy()
            target_pose[2] += 20  # Zè½´ä¸Šç§»20mm
            result, error = self.safe_execute(
                move_robot_cartesian, 
                target_pose, 
                speed_percentage=15, 
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("move_robot_cartesian", "PASS", "ç›´çº¿ç§»åŠ¨æˆåŠŸ")
                time.sleep(1)
            else:
                self.log_test("move_robot_cartesian", "FAIL", f"å¤±è´¥: {error or result}")

    # ================================
    # 3. ç‚¹åŠ¨APIæµ‹è¯•
    # ================================
    
    def test_jog_apis(self):
        """æµ‹è¯•ç‚¹åŠ¨API"""
        print("\n" + "="*50)
        print("ğŸ•¹ï¸ æµ‹è¯•ç‚¹åŠ¨API")
        print("="*50)
        
        # 1. å•å…³èŠ‚ç‚¹åŠ¨
        if self.user_confirm("æµ‹è¯•å•å…³èŠ‚ç‚¹åŠ¨(åº•åº§+2åº¦)?") == "skip":
            self.log_test("jog_robot_joint", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            result, error = self.safe_execute(
                jog_robot_joint,
                joint_index=0,
                speed_percentage=15,
                distance_deg=2.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("jog_robot_joint", "PASS", "åº•åº§ç‚¹åŠ¨+2åº¦æˆåŠŸ")
                time.sleep(1)
            else:
                self.log_test("jog_robot_joint", "FAIL", f"å¤±è´¥: {error or result}")
        
        # 2. å¤šå…³èŠ‚ç‚¹åŠ¨
        if self.user_confirm("æµ‹è¯•å¤šå…³èŠ‚åŒæ—¶ç‚¹åŠ¨?") == "skip":
            self.log_test("jog_multiple_joints", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            result, error = self.safe_execute(
                jog_multiple_joints,
                joints=[0, 1],  # åº•åº§å’Œè‚©éƒ¨
                speeds=[10, 10],
                duration=1.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("jog_multiple_joints", "PASS", "å¤šå…³èŠ‚ç‚¹åŠ¨æˆåŠŸ")
                time.sleep(1)
            else:
                self.log_test("jog_multiple_joints", "FAIL", f"å¤±è´¥: {error or result}")
        
        # 3. ç¬›å¡å°”ç‚¹åŠ¨
        if self.user_confirm("æµ‹è¯•ç¬›å¡å°”ç‚¹åŠ¨(Zè½´å‘ä¸Š)?") == "skip":
            self.log_test("jog_cartesian", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            result, error = self.safe_execute(
                jog_cartesian,
                frame='WRF',
                axis='Z+',
                speed_percentage=15,
                duration=1.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("jog_cartesian", "PASS", "ç¬›å¡å°”ç‚¹åŠ¨æˆåŠŸ")
                time.sleep(1)
            else:
                self.log_test("jog_cartesian", "FAIL", f"å¤±è´¥: {error or result}")

    # ================================
    # 4. å¹³æ»‘è¿åŠ¨APIæµ‹è¯•
    # ================================
    
    def test_smooth_motion_apis(self):
        """æµ‹è¯•å¹³æ»‘è¿åŠ¨API"""
        print("\n" + "="*50)
        print("ğŸŒŠ æµ‹è¯•å¹³æ»‘è¿åŠ¨API")
        print("="*50)
        
        # 1. åœ†å½¢è¿åŠ¨
        if self.user_confirm("æµ‹è¯•åœ†å½¢è¿åŠ¨(å°åŠå¾„)?") == "skip":
            self.log_test("smooth_circle", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            result, error = self.safe_execute(
                smooth_circle,
                center=[200, 0, 200],
                radius=20,
                plane='XY',
                duration=5.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("smooth_circle", "PASS", "åœ†å½¢è¿åŠ¨æˆåŠŸ")
                time.sleep(1)
            else:
                self.log_test("smooth_circle", "FAIL", f"å¤±è´¥: {error or result}")
        
        # 2. åœ†å¼§è¿åŠ¨(ä¸­å¿ƒç‚¹)
        if self.user_confirm("æµ‹è¯•åœ†å¼§è¿åŠ¨?") == "skip":
            self.log_test("smooth_arc_center", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            result, error = self.safe_execute(
                smooth_arc_center,
                end_pose=[220, 20, 200, 180, 0, 90],
                center=[210, 10, 200],
                duration=3.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("smooth_arc_center", "PASS", "åœ†å¼§è¿åŠ¨æˆåŠŸ")
                time.sleep(1)
            else:
                self.log_test("smooth_arc_center", "FAIL", f"å¤±è´¥: {error or result}")
        
        # 3. å‚æ•°åŒ–åœ†å¼§
        if self.user_confirm("æµ‹è¯•å‚æ•°åŒ–åœ†å¼§?") == "skip":
            self.log_test("smooth_arc_parametric", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            result, error = self.safe_execute(
                smooth_arc_parametric,
                end_pose=[200, 20, 200, 180, 0, 90],
                radius=15,
                arc_angle=90,
                duration=3.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("smooth_arc_parametric", "PASS", "å‚æ•°åŒ–åœ†å¼§æˆåŠŸ")
                time.sleep(1)
            else:
                self.log_test("smooth_arc_parametric", "FAIL", f"å¤±è´¥: {error or result}")
        
        # 4. æ ·æ¡æ›²çº¿
        if self.user_confirm("æµ‹è¯•æ ·æ¡æ›²çº¿è¿åŠ¨?") == "skip":
            self.log_test("smooth_spline", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            waypoints = [
                [200, 0, 200, 180, 0, 90],
                [210, 10, 210, 180, 0, 90],
                [220, 0, 200, 180, 0, 90]
            ]
            result, error = self.safe_execute(
                smooth_spline,
                waypoints=waypoints,
                duration=5.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("smooth_spline", "PASS", "æ ·æ¡æ›²çº¿è¿åŠ¨æˆåŠŸ")
                time.sleep(1)
            else:
                self.log_test("smooth_spline", "FAIL", f"å¤±è´¥: {error or result}")
        
        # 5. èºæ—‹è¿åŠ¨
        if self.user_confirm("æµ‹è¯•èºæ—‹è¿åŠ¨?") == "skip":
            self.log_test("smooth_helix", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            result, error = self.safe_execute(
                smooth_helix,
                center=[200, 0, 180],
                radius=15,
                pitch=10,
                height=30,
                duration=6.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("smooth_helix", "PASS", "èºæ—‹è¿åŠ¨æˆåŠŸ")
                time.sleep(1)
            else:
                self.log_test("smooth_helix", "FAIL", f"å¤±è´¥: {error or result}")

    # ================================
    # 5. å¤¹å…·æ§åˆ¶APIæµ‹è¯•
    # ================================
    
    def test_gripper_apis(self):
        """æµ‹è¯•å¤¹å…·æ§åˆ¶API"""
        print("\n" + "="*50)
        print("ğŸ¤ æµ‹è¯•å¤¹å…·æ§åˆ¶API")
        print("="*50)
        
        # 1. æ°”åŠ¨å¤¹å…·æ§åˆ¶
        if self.user_confirm("æµ‹è¯•æ°”åŠ¨å¤¹å…·æ§åˆ¶?") == "skip":
            self.log_test("control_pneumatic_gripper", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            # æ‰“å¼€å¤¹å…·
            result, error = self.safe_execute(
                control_pneumatic_gripper,
                action='open',
                port=1,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("control_pneumatic_gripper(open)", "PASS", "æ°”åŠ¨å¤¹å…·æ‰“å¼€æˆåŠŸ")
                time.sleep(1)
                
                # å…³é—­å¤¹å…·
                result, error = self.safe_execute(
                    control_pneumatic_gripper,
                    action='close',
                    port=1,
                    wait_for_ack=True
                )
                if result and result.get('status') == 'COMPLETED':
                    self.log_test("control_pneumatic_gripper(close)", "PASS", "æ°”åŠ¨å¤¹å…·å…³é—­æˆåŠŸ")
                else:
                    self.log_test("control_pneumatic_gripper(close)", "FAIL", f"å¤±è´¥: {error or result}")
            else:
                self.log_test("control_pneumatic_gripper(open)", "FAIL", f"å¤±è´¥: {error or result}")
        
        # 2. ç”µåŠ¨å¤¹å…·æ§åˆ¶
        if self.user_confirm("æµ‹è¯•ç”µåŠ¨å¤¹å…·æ§åˆ¶?") == "skip":
            self.log_test("control_electric_gripper", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            # æ ¡å‡†å¤¹å…·
            result, error = self.safe_execute(
                control_electric_gripper,
                action='calibrate',
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("control_electric_gripper(calibrate)", "PASS", "ç”µåŠ¨å¤¹å…·æ ¡å‡†æˆåŠŸ")
                time.sleep(2)
                
                # ç§»åŠ¨å¤¹å…·
                result, error = self.safe_execute(
                    control_electric_gripper,
                    action='move',
                    position=200,
                    speed=100,
                    wait_for_ack=True
                )
                if result and result.get('status') == 'COMPLETED':
                    self.log_test("control_electric_gripper(move)", "PASS", "ç”µåŠ¨å¤¹å…·ç§»åŠ¨æˆåŠŸ")
                else:
                    self.log_test("control_electric_gripper(move)", "FAIL", f"å¤±è´¥: {error or result}")
            else:
                self.log_test("control_electric_gripper(calibrate)", "FAIL", f"å¤±è´¥: {error or result}")

    # ================================
    # 6. ç³»ç»Ÿæ§åˆ¶APIæµ‹è¯•
    # ================================
    
    def test_system_apis(self):
        """æµ‹è¯•ç³»ç»Ÿæ§åˆ¶API"""
        print("\n" + "="*50)
        print("âš™ï¸ æµ‹è¯•ç³»ç»Ÿæ§åˆ¶API")
        print("="*50)
        
        # 1. å»¶è¿Ÿå‘½ä»¤
        print("æµ‹è¯•å»¶è¿Ÿå‘½ä»¤(2ç§’)...")
        start_time = time.time()
        result, error = self.safe_execute(delay_robot, duration=2.0, wait_for_ack=True)
        elapsed = time.time() - start_time
        
        if result and result.get('status') == 'COMPLETED' and 1.8 <= elapsed <= 2.5:
            self.log_test("delay_robot", "PASS", f"å»¶è¿Ÿ{elapsed:.1f}ç§’æˆåŠŸ")
        else:
            self.log_test("delay_robot", "FAIL", f"å¤±è´¥: {error or result}, ç”¨æ—¶{elapsed:.1f}ç§’")
        
        # 2. åœæ­¢è¿åŠ¨(éœ€è¦æœ‰è¿åŠ¨æ—¶æµ‹è¯•)
        print("æµ‹è¯•åœæ­¢å‘½ä»¤...")
        result, error = self.safe_execute(stop_robot_movement, wait_for_ack=True)
        if result and result.get('status') == 'COMPLETED':
            self.log_test("stop_robot_movement", "PASS", "åœæ­¢å‘½ä»¤æˆåŠŸ")
        else:
            self.log_test("stop_robot_movement", "FAIL", f"å¤±è´¥: {error or result}")

    # ================================
    # 7. é«˜çº§åŠŸèƒ½APIæµ‹è¯•
    # ================================
    
    def test_advanced_apis(self):
        """æµ‹è¯•é«˜çº§åŠŸèƒ½API"""
        print("\n" + "="*50)
        print("ğŸš€ æµ‹è¯•é«˜çº§åŠŸèƒ½API")
        print("="*50)
        
        # 1. è½¨è¿¹æ‰§è¡Œ
        if self.user_confirm("æµ‹è¯•è½¨è¿¹æ‰§è¡Œ?") == "skip":
            self.log_test("execute_trajectory", "SKIP", "ç”¨æˆ·è·³è¿‡")
        else:
            trajectory = [
                [200, 0, 200, 180, 0, 90],
                [210, 10, 200, 180, 0, 90],
                [200, 20, 200, 180, 0, 90]
            ]
            result, error = self.safe_execute(
                execute_trajectory,
                trajectory=trajectory,
                timing_mode='duration',
                timing_value=5.0,
                motion_type='spline',
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("execute_trajectory", "PASS", "è½¨è¿¹æ‰§è¡ŒæˆåŠŸ")
            else:
                self.log_test("execute_trajectory", "FAIL", f"å¤±è´¥: {error or result}")
        
        # 2. ç­‰å¾…åœæ­¢
        # result, error = self.safe_execute(wait_for_robot_stop, timeout=5.0)
        # if result is True:
        #     self.log_test("wait_for_robot_stop", "PASS", "ç­‰å¾…åœæ­¢æˆåŠŸ")
        # else:
        #     self.log_test("wait_for_robot_stop", "FAIL", f"å¤±è´¥: {error}")
        
        # 3. æ£€æŸ¥è·Ÿè¸ªçŠ¶æ€
        result, error = self.safe_execute(is_tracking_active)
        if result is not None:
            self.log_test("is_tracking_active", "PASS", f"è·Ÿè¸ªçŠ¶æ€: {result}")
        else:
            self.log_test("is_tracking_active", "FAIL", f"å¤±è´¥: {error}")
        
        # 4. è·å–è·Ÿè¸ªç»Ÿè®¡
        result, error = self.safe_execute(get_tracking_stats)
        if result is not None:
            self.log_test("get_tracking_stats", "PASS", f"è·Ÿè¸ªç»Ÿè®¡è·å–æˆåŠŸ")
        else:
            self.log_test("get_tracking_stats", "FAIL", f"å¤±è´¥: {error}")

    # ================================
    # ä¸»æµ‹è¯•æµç¨‹
    # ================================
    
    def run_all_tests(self):
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        print("\nğŸš€ å¼€å§‹PAROL6 APIå…¨åŠŸèƒ½æµ‹è¯•")
        print("æµ‹è¯•å°†åˆ†ä¸º7ä¸ªç±»åˆ«è¿›è¡Œ...")
        
        start_time = time.time()
        
        try:
            # 1. çŠ¶æ€æŸ¥è¯¢æµ‹è¯•(å®‰å…¨ï¼Œæ€»æ˜¯æ‰§è¡Œ)
            self.test_status_apis()
            
            # 2. åŸºç¡€ç§»åŠ¨æµ‹è¯•
            if self.user_confirm("\næ˜¯å¦æµ‹è¯•åŸºç¡€ç§»åŠ¨API?") != False:
                self.test_basic_movement_apis()
            else:
                print("â­ï¸ è·³è¿‡åŸºç¡€ç§»åŠ¨æµ‹è¯•")
            
            # 3. ç‚¹åŠ¨æµ‹è¯•
            if self.user_confirm("\næ˜¯å¦æµ‹è¯•ç‚¹åŠ¨API?") != False:
                self.test_jog_apis()
            else:
                print("â­ï¸ è·³è¿‡ç‚¹åŠ¨æµ‹è¯•")
            
            # 4. å¹³æ»‘è¿åŠ¨æµ‹è¯•
            if self.user_confirm("\næ˜¯å¦æµ‹è¯•å¹³æ»‘è¿åŠ¨API?") != False:
                self.test_smooth_motion_apis()
            else:
                print("â­ï¸ è·³è¿‡å¹³æ»‘è¿åŠ¨æµ‹è¯•")
            
            # 5. å¤¹å…·æ§åˆ¶æµ‹è¯•
            if self.user_confirm("\næ˜¯å¦æµ‹è¯•å¤¹å…·æ§åˆ¶API?") != False:
                self.test_gripper_apis()
            else:
                print("â­ï¸ è·³è¿‡å¤¹å…·æ§åˆ¶æµ‹è¯•")
            
            # 6. ç³»ç»Ÿæ§åˆ¶æµ‹è¯•
            if self.user_confirm("\næ˜¯å¦æµ‹è¯•ç³»ç»Ÿæ§åˆ¶API?") != False:
                self.test_system_apis()
            else:
                print("â­ï¸ è·³è¿‡ç³»ç»Ÿæ§åˆ¶æµ‹è¯•")
            
            # 7. é«˜çº§åŠŸèƒ½æµ‹è¯•
            if self.user_confirm("\næ˜¯å¦æµ‹è¯•é«˜çº§åŠŸèƒ½API?") != False:
                self.test_advanced_apis()
            else:
                print("â­ï¸ è·³è¿‡é«˜çº§åŠŸèƒ½æµ‹è¯•")
                
        except KeyboardInterrupt:
            print("\nğŸ›‘ æµ‹è¯•è¢«ç”¨æˆ·ä¸­æ–­")
        except Exception as e:
            print(f"\nâŒ æµ‹è¯•è¿‡ç¨‹å‘ç”Ÿé”™è¯¯: {e}")
            traceback.print_exc()
        
        finally:
            # ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
            self.generate_report(time.time() - start_time)

    def generate_report(self, total_time):
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        print("\n" + "="*60)
        print("ğŸ“Š PAROL6 API æµ‹è¯•æŠ¥å‘Š")
        print("="*60)
        
        print(f"ğŸ• æ€»æµ‹è¯•æ—¶é—´: {total_time:.1f}ç§’")
        print(f"ğŸ“ˆ æµ‹è¯•ç»Ÿè®¡:")
        print(f"   æ€»æµ‹è¯•æ•°: {self.test_count}")
        print(f"   âœ… é€šè¿‡: {self.passed_count}")
        print(f"   âŒ å¤±è´¥: {self.failed_count}")
        print(f"   â­ï¸ è·³è¿‡: {self.skipped_count}")
        
        if self.test_count > 0:
            success_rate = (self.passed_count / (self.test_count - self.skipped_count)) * 100 if (self.test_count - self.skipped_count) > 0 else 0
            print(f"   ğŸ“Š æˆåŠŸç‡: {success_rate:.1f}%")
        
        # è¯¦ç»†ç»“æœ
        print(f"\nğŸ“‹ è¯¦ç»†æµ‹è¯•ç»“æœ:")
        for test_name, result in self.test_results.items():
            status_icon = {"PASS": "âœ…", "FAIL": "âŒ", "SKIP": "â­ï¸"}[result["status"]]
            print(f"   {status_icon} {test_name}: {result['details']}")
        
        # å¤±è´¥åˆ†æ
        if self.failed_count > 0:
            print(f"\nâš ï¸ å¤±è´¥çš„æµ‹è¯•:")
            for test_name, result in self.test_results.items():
                if result["status"] == "FAIL":
                    print(f"   âŒ {test_name}: {result['details']}")
        
        print(f"\nğŸ¯ æµ‹è¯•å»ºè®®:")
        if self.failed_count == 0:
            print("   ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼APIåŠŸèƒ½æ­£å¸¸")
        else:
            print("   ğŸ”§ è¯·æ£€æŸ¥å¤±è´¥çš„APIåŠŸèƒ½")
            print("   ğŸ“– å‚è€ƒæ–‡æ¡£ç¡®è®¤ä½¿ç”¨æ–¹æ³•")
            print("   ğŸ”— æ£€æŸ¥æœºå™¨äººè¿æ¥å’ŒçŠ¶æ€")
        
        print("="*60)

def main():
    """ä¸»ç¨‹åº"""
    print("ğŸ”¬ PAROL6 API å…¨åŠŸèƒ½å®‰å…¨æµ‹è¯•ç¨‹åº")
    print("="*50)
    
    # åˆ›å»ºæµ‹è¯•å™¨
    tester = PAROL6APITester()
    
    # å®‰å…¨ç¡®è®¤
    print("\nâš ï¸ å®‰å…¨æ£€æŸ¥æ¸…å•:")
    print("â–¡ æœºå™¨äººå‘¨å›´å®‰å…¨æ— éšœç¢")
    print("â–¡ æ€¥åœæŒ‰é’®å¯éšæ—¶æŒ‰ä¸‹")
    print("â–¡ å·¥ä½œç©ºé—´è¶³å¤Ÿå¤§")
    print("â–¡ å·²åšå¥½åº”æ€¥å‡†å¤‡")
    
    if not tester.user_confirm("\nç¡®è®¤ä»¥ä¸Šå®‰å…¨æ¡ä»¶å·²æ»¡è¶³ï¼Œå¼€å§‹æµ‹è¯•?"):
        print("âŒ ç”¨æˆ·å–æ¶ˆæµ‹è¯•")
        return
    
    try:
        # è¿è¡Œæ‰€æœ‰æµ‹è¯•
        tester.run_all_tests()
        
    except KeyboardInterrupt:
        print("\nğŸ›‘ ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­")
    except Exception as e:
        print(f"\nâŒ ç¨‹åºé”™è¯¯: {e}")
        traceback.print_exc()
    finally:
        print("\nğŸ‘‹ æµ‹è¯•ç¨‹åºç»“æŸ")

if __name__ == "__main__":
    main()
````

## File: test/base01.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 ç®€å•åº•åº§æ—‹è½¬æ§åˆ¶ç¨‹åºï¼ˆç®€åŒ–ç‰ˆï¼‰
åªæ§åˆ¶åº•åº§å…³èŠ‚ï¼Œå°è§’åº¦æ…¢é€Ÿæ—‹è½¬
"""

import time
from robot_api import *

class SimpleBaseController:
    def __init__(self):
        """åˆå§‹åŒ–åº•åº§æ§åˆ¶å™¨"""
        self.base_joint_index = 0  # åº•åº§æ˜¯ç¬¬1ä¸ªå…³èŠ‚ï¼ˆç´¢å¼•0ï¼‰
        self.max_angle_step = 5.0  # æ¯æ¬¡æœ€å¤§æ—‹è½¬è§’åº¦ï¼ˆåº¦ï¼‰
        self.slow_speed = 15       # æ…¢é€Ÿåº¦ï¼ˆç™¾åˆ†æ¯”ï¼‰
        
        print("ğŸ¤– åº•åº§æ§åˆ¶å™¨å·²åˆå§‹åŒ–")
        print(f"ğŸ“Š è®¾ç½®ï¼šæœ€å¤§æ­¥é•¿{self.max_angle_step}Â°ï¼Œé€Ÿåº¦{self.slow_speed}%")

    def rotate_base(self, angle_degrees):
        """
        æ—‹è½¬åº•åº§æŒ‡å®šè§’åº¦
        
        å‚æ•°:
        angle_degrees: æ—‹è½¬è§’åº¦ï¼ˆæ­£æ•°é¡ºæ—¶é’ˆï¼Œè´Ÿæ•°é€†æ—¶é’ˆï¼‰
        """
        try:
            # é™åˆ¶è§’åº¦èŒƒå›´
            if abs(angle_degrees) > self.max_angle_step:
                print(f"âš ï¸ è§’åº¦é™åˆ¶ä¸ºÂ±{self.max_angle_step}Â°")
                angle_degrees = self.max_angle_step if angle_degrees > 0 else -self.max_angle_step
            
            print(f"ğŸ”„ åº•åº§æ—‹è½¬ {angle_degrees}Â°...")
            
            # ç¡®å®šæ–¹å‘
            if angle_degrees > 0:
                joint_index = self.base_joint_index  # æ­£æ–¹å‘ (0)
            else:
                joint_index = self.base_joint_index + 6  # è´Ÿæ–¹å‘ (6)
                angle_degrees = abs(angle_degrees)
            
            # æ‰§è¡Œæ—‹è½¬
            result = jog_robot_joint(
                joint_index=joint_index,
                speed_percentage=self.slow_speed,
                distance_deg=angle_degrees,
                wait_for_ack=True,
                timeout=10.0
            )
            
            if result and result.get('status') == 'COMPLETED':
                print("âœ… åº•åº§æ—‹è½¬å®Œæˆ")
                return True
            else:
                print("âŒ åº•åº§æ—‹è½¬å¤±è´¥")
                print(f"   ç»“æœ: {result}")
                return False
                
        except Exception as e:
            print(f"âŒ æ—‹è½¬é”™è¯¯: {e}")
            return False

    def get_base_angle(self):
        """è·å–å½“å‰åº•åº§è§’åº¦"""
        try:
            angles = get_robot_joint_angles()
            if angles:
                base_angle = angles[0]
                print(f"ğŸ“ å½“å‰åº•åº§è§’åº¦: {base_angle:.2f}Â°")
                return base_angle
            else:
                print("âŒ æ— æ³•è·å–è§’åº¦ä¿¡æ¯")
                return None
        except Exception as e:
            print(f"âŒ è·å–è§’åº¦é”™è¯¯: {e}")
            return None

def main():
    """ä¸»ç¨‹åº"""
    print("=" * 40)
    print("ğŸ¤– PAROL6 ç®€å•åº•åº§æ§åˆ¶")
    print("=" * 40)
    
    controller = SimpleBaseController()
    
    try:
        # è¯¢é—®æ˜¯å¦éœ€è¦å½’é›¶
        home_choice = input("æ˜¯å¦éœ€è¦æœºå™¨äººå½’é›¶? (y/N): ").lower()
        if home_choice == 'y':
            print("ğŸ  æœºå™¨äººå½’é›¶...")
            result = home_robot(wait_for_ack=True, timeout=30)
            if result:
                print("âœ… å½’é›¶å®Œæˆ")
            else:
                print("âš ï¸ å½’é›¶å¯èƒ½æœªå®Œæˆï¼Œè¯·æ£€æŸ¥")
            
            # ç­‰å¾…ç¨³å®š
            time.sleep(2)
        
        # æ˜¾ç¤ºå½“å‰è§’åº¦
        controller.get_base_angle()
        
        while True:
            print("\n" + "-" * 30)
            print("é€‰æ‹©æ“ä½œ:")
            print("1. é¡ºæ—¶é’ˆæ—‹è½¬")
            print("2. é€†æ—¶é’ˆæ—‹è½¬")
            print("3. æŸ¥çœ‹å½“å‰è§’åº¦")
            print("4. æŸ¥çœ‹æ‰€æœ‰å…³èŠ‚è§’åº¦")
            print("5. é€€å‡º")
            print("-" * 30)
            
            choice = input("è¯·é€‰æ‹© (1-5): ").strip()
            
            if choice == '1':
                # é¡ºæ—¶é’ˆæ—‹è½¬
                try:
                    angle = float(input(f"è¾“å…¥è§’åº¦ (1-{controller.max_angle_step}): ") or "2")
                    controller.rotate_base(abs(angle))
                except ValueError:
                    print("âŒ è¾“å…¥æ— æ•ˆ")
                    
            elif choice == '2':
                # é€†æ—¶é’ˆæ—‹è½¬
                try:
                    angle = float(input(f"è¾“å…¥è§’åº¦ (1-{controller.max_angle_step}): ") or "2")
                    controller.rotate_base(-abs(angle))
                except ValueError:
                    print("âŒ è¾“å…¥æ— æ•ˆ")
                    
            elif choice == '3':
                # æŸ¥çœ‹åº•åº§è§’åº¦
                controller.get_base_angle()
                
            elif choice == '4':
                # æŸ¥çœ‹æ‰€æœ‰å…³èŠ‚è§’åº¦
                try:
                    angles = get_robot_joint_angles()
                    if angles:
                        print("ğŸ”§ æ‰€æœ‰å…³èŠ‚è§’åº¦:")
                        joint_names = ["åº•åº§", "è‚©éƒ¨", "è‚˜éƒ¨", "è…•1", "è…•2", "è…•3"]
                        for i, angle in enumerate(angles):
                            print(f"   {joint_names[i]}: {angle:.2f}Â°")
                    else:
                        print("âŒ æ— æ³•è·å–å…³èŠ‚è§’åº¦")
                except Exception as e:
                    print(f"âŒ è·å–è§’åº¦é”™è¯¯: {e}")
                    
            elif choice == '5':
                # é€€å‡º
                print("ğŸ‘‹ ç¨‹åºé€€å‡º")
                break
                
            else:
                print("âŒ æ— æ•ˆé€‰æ‹©ï¼Œè¯·è¾“å…¥1-5")
                
    except KeyboardInterrupt:
        print("\nğŸ›‘ ç¨‹åºä¸­æ–­")
    except Exception as e:
        print(f"âŒ ç¨‹åºé”™è¯¯: {e}")

if __name__ == "__main__":
    main()
````

## File: test/base02.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 å®‰å…¨åº•åº§æ—‹è½¬æ§åˆ¶ç¨‹åº
é€šè¿‡å‘½ä»¤ç»“æœæ£€æµ‹å¼‚å¸¸çŠ¶æ€
"""
import sys
import os

# è·å–å½“å‰æ–‡ä»¶çš„ç»å¯¹è·¯å¾„
current_dir = os.path.dirname(os.path.abspath(__file__))

# è·å–çˆ¶ç›®å½•è·¯å¾„
parent_dir = os.path.dirname(current_dir)

# å°†çˆ¶ç›®å½•æ·»åŠ åˆ°æ¨¡å—æœç´¢è·¯å¾„ä¸­
sys.path.append(parent_dir)

# ç°åœ¨å¯ä»¥å¯¼å…¥çˆ¶ç›®å½•ä¸­çš„æ¨¡å—
from robot_api import *
import time


class SafeBaseController:
    def __init__(self):
        """åˆå§‹åŒ–åº•åº§æ§åˆ¶å™¨"""
        self.base_joint_index = 0  # åº•åº§æ˜¯ç¬¬1ä¸ªå…³èŠ‚ï¼ˆç´¢å¼•0ï¼‰
        self.max_angle_step = 3.0  # å‡å°æœ€å¤§è§’åº¦ä¸º3åº¦ï¼Œæ›´å®‰å…¨
        self.slow_speed = 10       # è¿›ä¸€æ­¥é™ä½é€Ÿåº¦åˆ°10%
        self.last_successful_angles = None
        
        print("ğŸ›¡ï¸ å®‰å…¨åº•åº§æ§åˆ¶å™¨å·²åˆå§‹åŒ–")
        print(f"ğŸ“Š å®‰å…¨è®¾ç½®ï¼šæœ€å¤§æ­¥é•¿{self.max_angle_step}Â°ï¼Œé€Ÿåº¦{self.slow_speed}%")
        print("âš ï¸ æ³¨æ„ï¼šæ€¥åœæ—¶è¯·æ‰‹åŠ¨åœæ­¢ç¨‹åºï¼")

    def safety_check_by_status(self):
        """é€šè¿‡çŠ¶æ€æŸ¥è¯¢è¿›è¡Œå®‰å…¨æ£€æŸ¥"""
        try:
            # å°è¯•è·å–å½“å‰è§’åº¦ä½œä¸ºé€šä¿¡æµ‹è¯•
            angles = get_robot_joint_angles()
            if angles is None:
                print("âš ï¸ è­¦å‘Šï¼šæ— æ³•è·å–æœºå™¨äººçŠ¶æ€ï¼Œå¯èƒ½å­˜åœ¨é—®é¢˜")
                return False
            
            # æ£€æŸ¥è§’åº¦æ˜¯å¦åˆç†ï¼ˆä¸æ˜¯å¼‚å¸¸å€¼ï¼‰
            base_angle = angles[0]
            if abs(base_angle) > 180:
                print(f"âš ï¸ è­¦å‘Šï¼šåº•åº§è§’åº¦å¼‚å¸¸ {base_angle}Â°")
                return False
            
            self.last_successful_angles = angles
            return True
            
        except Exception as e:
            print(f"âš ï¸ çŠ¶æ€æ£€æŸ¥å¤±è´¥: {e}")
            return False

    def safe_rotate_base(self, angle_degrees):
        """
        å®‰å…¨æ—‹è½¬åº•åº§ï¼ŒåŒ…å«å¤šé‡æ£€æŸ¥
        """
        # é¢„æ£€æŸ¥
        if not self.safety_check_by_status():
            print("âŒ å®‰å…¨æ£€æŸ¥å¤±è´¥ï¼Œå–æ¶ˆç§»åŠ¨")
            return False
        
        try:
            # é™åˆ¶è§’åº¦
            if abs(angle_degrees) > self.max_angle_step:
                print(f"âš ï¸ è§’åº¦é™åˆ¶ä¸ºÂ±{self.max_angle_step}Â°")
                angle_degrees = self.max_angle_step if angle_degrees > 0 else -self.max_angle_step
            
            # è·å–ç§»åŠ¨å‰çŠ¶æ€
            before_angles = get_robot_joint_angles()
            if not before_angles:
                print("âŒ æ— æ³•è·å–ç§»åŠ¨å‰çŠ¶æ€")
                return False
            
            print(f"ğŸ”„ å‡†å¤‡åº•åº§æ—‹è½¬ {angle_degrees}Â°...")
            print(f"   å½“å‰è§’åº¦: {before_angles[0]:.2f}Â°")
            
            # ç”¨æˆ·ç¡®è®¤ï¼ˆå¯¹äºå¤§è§’åº¦ï¼‰
            if abs(angle_degrees) > 2.0:
                confirm = input(f"ç¡®è®¤æ—‹è½¬ {angle_degrees}Â°? (y/N): ").lower()
                if confirm != 'y':
                    print("âŒ ç”¨æˆ·å–æ¶ˆæ“ä½œ")
                    return False
            
            # ç¡®å®šæ–¹å‘
            if angle_degrees > 0:
                joint_index = self.base_joint_index  # æ­£æ–¹å‘
            else:
                joint_index = self.base_joint_index + 6  # è´Ÿæ–¹å‘
                angle_degrees = abs(angle_degrees)
            
            # æ‰§è¡Œæ—‹è½¬
            print(f"ğŸ”„ æ‰§è¡Œæ—‹è½¬...")
            result = jog_robot_joint(
                joint_index=joint_index,
                speed_percentage=self.slow_speed,
                distance_deg=angle_degrees,
                wait_for_ack=True,
                timeout=15.0  # å¢åŠ è¶…æ—¶æ—¶é—´
            )
            
            # æ£€æŸ¥ç»“æœ
            if not result:
                print("âŒ æ—‹è½¬å‘½ä»¤æ— å“åº”ï¼Œå¯èƒ½æœºå™¨äººè¢«æ€¥åœ")
                return False
                
            if result.get('status') != 'COMPLETED':
                print(f"âŒ æ—‹è½¬å¤±è´¥: {result.get('status', 'æœªçŸ¥é”™è¯¯')}")
                print(f"   è¯¦æƒ…: {result}")
                return False
            
            # ç§»åŠ¨åéªŒè¯
            time.sleep(1)  # ç­‰å¾…ç¨³å®š
            after_angles = get_robot_joint_angles()
            if not after_angles:
                print("âš ï¸ ç§»åŠ¨åæ— æ³•è·å–çŠ¶æ€ï¼Œè¯·æ£€æŸ¥æœºå™¨äºº")
                return False
            
            # éªŒè¯ç§»åŠ¨æ˜¯å¦æˆåŠŸ
            angle_change = after_angles[0] - before_angles[0]
            expected_change = angle_degrees if joint_index == 0 else -angle_degrees
            
            if abs(angle_change - expected_change) > 1.0:  # å…è®¸1åº¦è¯¯å·®
                print(f"âš ï¸ ç§»åŠ¨ç»“æœå¼‚å¸¸:")
                print(f"   æœŸæœ›å˜åŒ–: {expected_change:.2f}Â°")
                print(f"   å®é™…å˜åŒ–: {angle_change:.2f}Â°")
            else:
                print("âœ… åº•åº§æ—‹è½¬å®Œæˆå¹¶éªŒè¯æˆåŠŸ")
                print(f"   æ–°è§’åº¦: {after_angles[0]:.2f}Â°")
            
            return True
                
        except Exception as e:
            print(f"âŒ æ—‹è½¬é”™è¯¯: {e}")
            return False

    def get_base_status(self):
        """è·å–è¯¦ç»†çš„åº•åº§çŠ¶æ€"""
        try:
            angles = get_robot_joint_angles()
            if angles:
                print(f"ğŸ“ åº•åº§çŠ¶æ€:")
                print(f"   å½“å‰è§’åº¦: {angles[0]:.2f}Â°")
                print(f"   æ‰€æœ‰å…³èŠ‚: {[round(a, 2) for a in angles]}")
                
                # æ˜¾ç¤ºå˜åŒ–ï¼ˆå¦‚æœæœ‰ä¹‹å‰çš„æ•°æ®ï¼‰
                if self.last_successful_angles:
                    change = angles[0] - self.last_successful_angles[0]
                    if abs(change) > 0.1:
                        print(f"   è§’åº¦å˜åŒ–: {change:.2f}Â°")
                
                return angles[0]
            else:
                print("âŒ æ— æ³•è·å–çŠ¶æ€")
                return None
                
        except Exception as e:
            print(f"âŒ çŠ¶æ€è·å–é”™è¯¯: {e}")
            return None

def main():
    """ä¸»ç¨‹åº"""
    print("=" * 50)
    print("ğŸ›¡ï¸ PAROL6 å®‰å…¨åº•åº§æ§åˆ¶ç¨‹åº")
    print("=" * 50)
    print("âš ï¸ å®‰å…¨æé†’:")
    print("   1. æ€¥åœæŒ‰é’®éšæ—¶å¯ç”¨")
    print("   2. å¦‚æŒ‰æ€¥åœï¼Œè¯·æ‰‹åŠ¨åœæ­¢ç¨‹åº(Ctrl+C)")
    print("   3. æ¯æ¬¡ç§»åŠ¨éƒ½ä¼šè¿›è¡Œå®‰å…¨æ£€æŸ¥")
    print("   4. å¤§è§’åº¦ç§»åŠ¨éœ€è¦ç¡®è®¤")
    print("=" * 50)
    
    controller = SafeBaseController()
    
    try:
        # åˆå§‹çŠ¶æ€æ£€æŸ¥
        if not controller.safety_check_by_status():
            print("âŒ åˆå§‹å®‰å…¨æ£€æŸ¥å¤±è´¥ï¼Œç¨‹åºé€€å‡º")
            return
        
        # è¯¢é—®æ˜¯å¦éœ€è¦å½’é›¶
        home_choice = input("\næ˜¯å¦éœ€è¦æœºå™¨äººå½’é›¶? (y/N): ").lower()
        if home_choice == 'y':
            print("ğŸ  æœºå™¨äººå½’é›¶...")
            result = home_robot(wait_for_ack=True, timeout=30)
            time.sleep(2)
            
        # æ˜¾ç¤ºå½“å‰çŠ¶æ€
        controller.get_base_status()
        
        while True:
            print("\n" + "=" * 30)
            print("ğŸ® æ§åˆ¶é€‰é¡¹:")
            print("1. å°è§’åº¦é¡ºæ—¶é’ˆ (+1Â°)")
            print("2. å°è§’åº¦é€†æ—¶é’ˆ (-1Â°)")
            print("3. ä¸­è§’åº¦é¡ºæ—¶é’ˆ (+3Â°)")
            print("4. ä¸­è§’åº¦é€†æ—¶é’ˆ (-3Â°)")
            print("5. è‡ªå®šä¹‰è§’åº¦")
            print("6. æŸ¥çœ‹çŠ¶æ€")
            print("7. å®‰å…¨æ£€æŸ¥")
            print("8. é€€å‡º")
            print("=" * 30)
            
            choice = input("è¯·é€‰æ‹© (1-8): ").strip()
            
            if choice == '1':
                controller.safe_rotate_base(1.0)
            elif choice == '2':
                controller.safe_rotate_base(-1.0)
            elif choice == '3':
                controller.safe_rotate_base(3.0)
            elif choice == '4':
                controller.safe_rotate_base(-3.0)
            elif choice == '5':
                try:
                    angle = float(input(f"è¾“å…¥è§’åº¦ (Â±{controller.max_angle_step}): "))
                    controller.safe_rotate_base(angle)
                except ValueError:
                    print("âŒ è¾“å…¥æ— æ•ˆ")
            elif choice == '6':
                controller.get_base_status()
            elif choice == '7':
                if controller.safety_check_by_status():
                    print("âœ… å®‰å…¨æ£€æŸ¥é€šè¿‡")
                else:
                    print("âŒ å®‰å…¨æ£€æŸ¥å¤±è´¥")
            elif choice == '8':
                print("ğŸ‘‹ ç¨‹åºå®‰å…¨é€€å‡º")
                break
            else:
                print("âŒ æ— æ•ˆé€‰æ‹©")
                
            # æ¯æ¬¡æ“ä½œåçŸ­æš‚æš‚åœ
            time.sleep(0.5)
                
    except KeyboardInterrupt:
        print("\nğŸ›‘ ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­")
        print("âœ… å®‰å…¨é€€å‡º")
    except Exception as e:
        print(f"\nâŒ ç¨‹åºé”™è¯¯: {e}")
        print("ğŸ›‘ å»ºè®®æ£€æŸ¥æœºå™¨äººçŠ¶æ€")

if __name__ == "__main__":
    main()
````

## File: test/testik.py
````python
# d:/Onedrive/p/09-PAROL6-python-API/test/testik.py
import numpy as np
import spatialmath as sm
from roboticstoolbox.models.DH import Puma560

r = Puma560()  # DHRobot

# ç›®æ ‡ä½å§¿ï¼š0.5m, 0.1m, 0.2mï¼Œå§¿æ€ç”¨RPY(åº¦)
T = sm.SE3(0.5, 0.1, 0.2) * sm.SE3.RPY([0, 90, 0], unit='deg')

# åˆå§‹çŒœæµ‹ï¼ˆç»™ä¸ªåˆç†çš„åˆå€¼æ›´å®¹æ˜“æ”¶æ•›ï¼‰
q0 = r.qz  # é›¶å§¿ï¼›ä¹Ÿå¯ä»¥ç”¨å½“å‰å…³èŠ‚è§’

# ç”¨ ikine_LMï¼ˆ1.0.3 ç‰ˆæœ¬æ­£ç¡®æ–¹æ³•åï¼‰
sol = r.ikine_LM(T, q0=q0)  # å¯åŠ  ilimit=100, slimit=100 è°ƒå‚

if sol.success:
    print("IK æˆåŠŸï¼å…³èŠ‚è§’(åº¦)ï¼š", np.rad2deg(sol.q))
else:
    print("IK å¤±è´¥ï¼š", sol.reason)
````

## File: PAROL6_ROBOT.py
````python
# This file acts as configuration file for robot you are using
# It works in conjustion with configuration file from robotics toolbox

from swift import Swift
import spatialmath.base.symbolic as sym
from roboticstoolbox import ETS as ET
from roboticstoolbox import *
import roboticstoolbox as rtb
from spatialmath import *
from spatialgeometry import *
from math import pi
import numpy as np
import time
import random

Joint_num = 6 # Number of joints
Microstep = 32
steps_per_revolution=200
degree_per_step_constant = 360/(32*200) 
radian_per_step_constant = (2*pi) / (32*200)
radian_per_sec_2_deg_per_sec_const = 360/ (2*np.pi)
deg_per_sec_2_radian_per_sec_const = (2*np.pi) / 360

# robot length values (metres)
a1 = 110.50 / 1000
a2 = 23.42 / 1000
a3 = 180 / 1000
a4 = 43.5 / 1000
a5 = 176.35 / 1000
a6 = 62.8 / 1000
a7 = 45.25 / 1000

alpha_DH = [-pi / 2,pi,pi/2,-pi/2,pi/2,pi]

robot = DHRobot(
    [
        RevoluteDH(d=a1, a=a2, alpha=alpha_DH[0]),
        RevoluteDH(a=a3,d = 0,alpha=alpha_DH[1]),
        RevoluteDH(alpha= alpha_DH[2], a= -a4),
        RevoluteDH(d=-a5, a=0, alpha=alpha_DH[3]),
        RevoluteDH(a=0,d=0,alpha=alpha_DH[4]),
        RevoluteDH(alpha=alpha_DH[5], a = -a7,d = -a6),
    ],
    name="PAROL6",
)
#print(robot.isspherical())
#pyplot = rtb.backends.PyPlot()

# in degrees
Joints_standby_position_degree = np.array([0,-90,180,0,0,180]) 
# in radians
Joints_standby_position_radian = [np.deg2rad(angle) for angle in Joints_standby_position_degree]

# values you get after homing robot and moving it to its most left and right sides
# In degrees
Joint_limits_degree =[[-123.046875,123.046875], [-145.0088,-3.375], [107.866,287.8675], [-105.46975,105.46975], [-90,90], [0,360]] 

# in radians
Joint_limits_radian = []
for limits in Joint_limits_degree:
    radian_limits = [np.deg2rad(angle) for angle in limits]
    Joint_limits_radian.append(radian_limits)

# Reduction ratio we have on our joints
Joint_reduction_ratio = [6.4, 20, 20*(38/42) , 4, 4, 10] 

# min and max jog speeds. Usually slower from real maximal speeds
Joint_max_jog_speed = [1500, 3000, 3600, 7000, 7000, 18000]
Joint_min_jog_speed = [100,100,100,100,100,100]

# LINEAR CARTESIAN JOG MAX MIN SPEED IN METERS PER SECOND
Cartesian_linear_velocity_min_JOG = 0.002
Cartesian_linear_velocity_max_JOG = 0.06

# LINEAR CARTESIAN MAX MIN SPEED IN METERS PER SECOND
Cartesian_linear_velocity_min = 0.002
Cartesian_linear_velocity_max = 0.06

# LINEAR CARTESIAN MAX MIN ACC IN METERS PER SECONDÂ²
Cartesian_linear_acc_min = 0.002
Cartesian_linear_acc_max = 0.06

# ANGULAR CARTESIAN JOG MAX MIN SPEED IN DEGREES PER SECOND
Cartesian_angular_velocity_min = 0.7
Cartesian_angular_velocity_max = 25

Joint_max_speed = [6500,18000,20000,20000,22000,22000] # max speed in STEP/S used
Joint_min_speed = [100,100,100,100,100,100] # min speed in STEP/S used 

Joint_max_acc = 32000 # max acceleration in RAD/SÂ²
Joint_min_acc = 100 # min acceleration in RAD/SÂ²

Cart_lin_velocity_limits = [[-100,100],[-100,100],[-100,100]]
Cart_ang_velocity_limits = [[-100,100],[-100,100],[-100,100]]


Commands_list = [ "Input","Output","Dummy","Begin","Home","Delay","End","Loop","MoveJoint","MovePose","SpeedJoint","MoveCart",
                 "MoveCart","MoveCartRelTRF","Gripper","Gripper_cal"]

Commands_list_true = [item + "()" for item in Commands_list]

# 360 / (200 * 32) = 0.05625
def DEG2STEPS(Degrees, index):
    Steps = Degrees / degree_per_step_constant * Joint_reduction_ratio[index]
    return Steps

Joint_limits_steps =[[DEG2STEPS(Joint_limits_degree[0][0],0),DEG2STEPS(Joint_limits_degree[0][1],0)],
                      [DEG2STEPS(Joint_limits_degree[1][0],1),DEG2STEPS(Joint_limits_degree[1][1],1)],
                      [DEG2STEPS(Joint_limits_degree[2][0],2),DEG2STEPS(Joint_limits_degree[2][1],2)],
                      [DEG2STEPS(Joint_limits_degree[3][0],3),DEG2STEPS(Joint_limits_degree[3][1],3)],
                      [DEG2STEPS(Joint_limits_degree[4][0],4),DEG2STEPS(Joint_limits_degree[4][1],4)],
                      [DEG2STEPS(Joint_limits_degree[5][0],5),DEG2STEPS(Joint_limits_degree[5][1],5)]]
Joint_limits_steps = [[int(i[0]),int(i[1])] for i in Joint_limits_steps]


def STEPS2DEG(Steps,index):
    Degrees = Steps * degree_per_step_constant / Joint_reduction_ratio[index]
    return Degrees

def RAD2STEPS(Rads,index):
    deg = np.rad2deg(Rads)
    steps = DEG2STEPS(deg,index)
    return steps

def STEPS2RADS(Steps,index):
    deg = STEPS2DEG(Steps,index)
    rads = np.deg2rad(deg)
    return rads

def RAD2DEG(radian):
    return np.rad2deg(radian)

def DEG2RAD(degree):
    return np.deg2rad(degree)

def SPEED_STEPS2DEG(Steps_per_second,index):

    '''     Transform true RADS/S to true RPM.
    Both these values are true values at witch MOTORS SPIN  '''

    degrees_per_step = degree_per_step_constant / Joint_reduction_ratio[index]
    degrees_per_second = Steps_per_second * degrees_per_step
    return degrees_per_second

def SPEED_DEG2STEPS(Deg_per_second,index):
    steps_per_second = Deg_per_second / degree_per_step_constant * Joint_reduction_ratio[index]
    return steps_per_second

def SPEED_STEP2RAD(Steps_per_second,index):
    degrees_per_step = radian_per_step_constant / Joint_reduction_ratio[index]
    rad_per_second = Steps_per_second * degrees_per_step
    return rad_per_second

def SPEED_RAD2STEP(Rad_per_second,index):
    steps_per_second = Rad_per_second / radian_per_step_constant * Joint_reduction_ratio[index]
    return steps_per_second

def RAD_SEC_2_DEG_SEC(rad_per_sec):
    return rad_per_sec * radian_per_sec_2_deg_per_sec_const

def DEG_SEC_2_RAD_SEC(deg_per_sec):
    return deg_per_sec * deg_per_sec_2_radian_per_sec_const


def check_joint_limits(q, target_q=None, allow_recovery=True):
    """
    Check if joint angles are within their limits, with support for recovery movements.
    
    Parameters
    ----------
    q : array_like
        Current joint angles in radians
    target_q : array_like, optional
        Target joint angles in radians. If provided, recovery logic is applied.
    allow_recovery : bool, optional
        Whether to allow recovery movements when current position violates limits
        
    Returns
    -------
    bool
        True if movement is allowed (within limits or valid recovery), False otherwise
    dict
        Dictionary with joint limit violation details and recovery information
    """
    q_array = np.array(q)
    target_array = np.array(target_q) if target_q is not None else None
    violations = {}
    all_valid = True
    
    for i in range(min(len(q_array), len(Joint_limits_radian))):
        min_limit = Joint_limits_radian[i][0]
        max_limit = Joint_limits_radian[i][1]
        current_pos = q_array[i]
        
        # Check if current position violates limits
        current_violates = current_pos < min_limit or current_pos > max_limit
        
        if current_violates:
            violation_type = 'below_min' if current_pos < min_limit else 'above_max'
            
            # If we have a target and recovery is enabled, check if it's a recovery movement
            if target_array is not None and allow_recovery:
                target_pos = target_array[i]
                is_recovery = False
                
                if current_pos > max_limit:  # Past upper limit
                    # Recovery means moving towards or below the upper limit
                    is_recovery = target_pos <= current_pos
                    recovery_direction = "move joint towards negative direction"
                elif current_pos < min_limit:  # Past lower limit
                    # Recovery means moving towards or above the lower limit  
                    is_recovery = target_pos >= current_pos
                    recovery_direction = "move joint towards positive direction"
                
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': target_pos if target_array is not None else None,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': violation_type,
                    'is_recovery': is_recovery,
                    'recovery_direction': recovery_direction if not is_recovery else None,
                    'movement_allowed': is_recovery
                }
                
                # Only flag as invalid if it's not a recovery movement
                if not is_recovery:
                    all_valid = False
            else:
                # No target provided or recovery disabled - flag as violation
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': None,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': violation_type,
                    'is_recovery': False,
                    'recovery_direction': None,
                    'movement_allowed': False
                }
                all_valid = False
        elif target_array is not None:
            # Current is within limits, check if target would violate
            target_pos = target_array[i]
            target_violates = target_pos < min_limit or target_pos > max_limit
            
            if target_violates:
                target_violation_type = 'below_min' if target_pos < min_limit else 'above_max'
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': target_pos,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': f'target_{target_violation_type}',
                    'is_recovery': False,
                    'recovery_direction': None,
                    'movement_allowed': False
                }
                all_valid = False
    
    return all_valid, violations

def extract_from_can_id(can_id):
    # Extracting ID2 (first 4 MSB)
    id2 = (can_id >> 7) & 0xF

    # Extracting CAN Command (next 6 bits)
    can_command = (can_id >> 1) & 0x3F

    # Extracting Error Bit (last bit)
    error_bit = can_id & 0x1
    
    return id2, can_command, error_bit


def combine_2_can_id(id2, can_command, error_bit):
    # Combine components into an 11-bit CAN ID
    can_id = 0

    # Add ID2 (first 4 MSB)
    can_id |= (id2 & 0xF) << 7

    # Add CAN Command (next 6 bits)
    can_id |= (can_command & 0x3F) << 1

    # Add Error Bit (last bit)
    can_id |= (error_bit & 0x1)

    return can_id

# Fuse bitfield list to byte
def fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Splits byte to bitfield list
def split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]


if __name__ == "__main__":
    """
    print(DEG2STEPS(180,2))
    print(STEPS2DEG(57905,2))
    print(RAD2STEPS(pi,5))
    print(STEPS2RADS(32000,5))
    print(SPEED_STEPS2DEG(1000,5))
    print(SPEED_STEP2RAD(1000,5))
    print(Joint_limits_radian)
    print(Joints_standby_position_radian)
    print(Joint_limits_steps)
    print(Joint_limits_radian)
    print(DEG2STEPS(-62.5,1))
    """

    J0_var = STEPS2RADS(1,0)
    J1_var = STEPS2RADS(1,1)
    J2_var = STEPS2RADS(1,2)
    J3_var = STEPS2RADS(1,3)
    J4_var = STEPS2RADS(1,4)
    J5_var = STEPS2RADS(1,5)


    print("Joint 1 smallest step:",RAD2DEG(J0_var))
    print("Joint 2 smallest step:",RAD2DEG(J1_var))
    print("Joint 3 smallest step:",RAD2DEG(J2_var))
    print("Joint 4 smallest step:",RAD2DEG(J3_var))
    print("Joint 5 smallest step:",RAD2DEG(J4_var))
    print("Joint 6 smallest step:",RAD2DEG(J5_var))
    print("rad 2 step:",SPEED_RAD2STEP(-2.948504399390715 / 2,5))
    print("standby radian is",Joints_standby_position_radian)

    test = RAD2STEPS(0.0001,5)
    print(test)

    #robot.ikine_LM()
````

## File: headless_commander.py
````python
'''
A full fledged "API" for the PAROL6 robot. To use this, you should pair it with the "robot_api.py" where you can import commands
from said file and use them anywhere within your code. This Python script will handle sending and performing all the commands
to the PAROL6 robot, as well as E-Stop functionality and safety limitations.

To run this program, you must use the "experimental-kinematics" branch of the "PAROL-commander-software" on GitHub
which can be found through this link: https://github.com/PCrnjak/PAROL-commander-software/tree/experimental_kinematics.
You must also save these files into the following folder: "Project Files\PAROL-commander-software\GUI\files".
'''

# * If you press estop robot will stop and you need to enable it by pressing e

from roboticstoolbox import DHRobot, RevoluteDH, ERobot, ELink, ETS, trapezoidal, quintic
import roboticstoolbox as rp
from math import pi, sin, cos
import numpy as np
from oclock import Timer, loop, interactiveloop
import time
import socket
from spatialmath import SE3
import select
import serial
import platform
import os
import re
import logging
import struct
import keyboard
from typing import Optional, Tuple
from spatialmath.base import trinterp
from collections import namedtuple, deque
import GUI.files.PAROL6_ROBOT as PAROL6_ROBOT
from smooth_motion import CircularMotion, SplineMotion, MotionBlender

# Set interval
INTERVAL_S = 0.01
prev_time = 0

logging.basicConfig(level = logging.DEBUG,
    format='%(asctime)s.%(msecs)03d %(levelname)s:\t%(message)s',
    datefmt='%H:%M:%S'
)
logging.disable(logging.DEBUG)


my_os = platform.system()
if my_os == "Windows":
    # Try to read the COM port from a file
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved COM port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        # If the file doesn't exist or the port is invalid, ask the user
        while True:
            try:
                com_port = input("Enter the COM port (e.g., COM9): ")
                ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                print(f"Successfully connected to {com_port}")
                # Save the successful port to the file
                with open("com_port.txt", "w") as f:
                    f.write(com_port)
                break
            except serial.SerialException:
                print(f"Could not open port {com_port}. Please try again.")

# in big endian machines, first byte of binary representation of the multibyte data-type is stored first. 
int_to_3_bytes = struct.Struct('>I').pack # BIG endian order

# data for output string (data that is being sent to the robot)
#######################################################################################
#######################################################################################
start_bytes =  [0xff,0xff,0xff] 
start_bytes = bytes(start_bytes)

end_bytes =  [0x01,0x02] 
end_bytes = bytes(end_bytes)


# data for input string (Data that is being sent by the robot)
#######################################################################################
#######################################################################################
input_byte = 0 # Here save incoming bytes from serial

start_cond1_byte = bytes([0xff])
start_cond2_byte = bytes([0xff])
start_cond3_byte = bytes([0xff])

end_cond1_byte = bytes([0x01])
end_cond2_byte = bytes([0x02])

start_cond1 = 0 #Flag if start_cond1_byte is received
start_cond2 = 0 #Flag if start_cond2_byte is received
start_cond3 = 0 #Flag if start_cond3_byte is received

good_start = 0 #Flag if we got all 3 start condition bytes
data_len = 0 #Length of the data after -3 start condition bytes and length byte, so -4 bytes

data_buffer = [None]*255 #Here save all data after data length byte
data_counter = 0 #Data counter for incoming bytes; compared to data length to see if we have correct length
#######################################################################################
#######################################################################################
prev_positions = [0,0,0,0,0,0]
prev_speed = [0,0,0,0,0,0]
robot_pose = [0,0,0,0,0,0] #np.array([0,0,0,0,0,0])
#######################################################################################
#######################################################################################

# --- Wrapper class to make integers mutable when passed to functions ---
class CommandValue:
    def __init__(self, value):
        self.value = value

#######################################################################################
#######################################################################################
Position_out = [1,11,111,1111,11111,10]
Speed_out = [2,21,22,23,24,25]
Command_out = CommandValue(255)
Affected_joint_out = [1,1,1,1,1,1,1,1]
InOut_out = [0,0,0,0,0,0,0,0]
Timeout_out = 0
#Positon,speed,current,command,mode,ID
Gripper_data_out = [1,1,1,1,0,0]
#######################################################################################
#######################################################################################
# Data sent from robot to PC
Position_in = [31,32,33,34,35,36]
Speed_in = [41,42,43,44,45,46]
Homed_in = [0,0,0,0,0,0,0,0]
InOut_in = [1,1,1,1,1,1,1,1]
Temperature_error_in = [1,1,1,1,1,1,1,1]
Position_error_in = [1,1,1,1,1,1,1,1]
Timeout_error = 0
# how much time passed between 2 sent commands (2byte value, last 2 digits are decimal so max value is 655.35ms?)
Timing_data_in = [0]
XTR_data =   0

# --- State variables for program execution ---
Robot_mode = "Dummy"  # Start in an idle state
Program_step = 0      # Which line of the program to run
Command_step = 0      # The current step within a single command
Command_len = 0       # The total steps for the current command
ik_error = 0          # Flag for inverse kinematics errors
error_state = 0       # General error flag
program_running = False # A flag to start and stop the program

# This will be your "program"
command_list = []

#ID,Position,speed,current,status,obj_detection
Gripper_data_in = [1,1,1,1,1,1] 

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179Â° and 181Â° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    
    Parameters
    ----------
    robot : DHRobot
        Robot model
    q : array_like
        Joint configuration
    strict_tol : float
        Strict tolerance away from singularities (default: 1e-10)
    loose_tol : float
        Loose tolerance near singularities (1e-7)
        
    Returns
    -------
    float
        Adaptive tolerance value
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    
    Parameters
    ----------
    q_seed : array_like
        Current joint configuration in radians
        
    Returns
    -------
    float
        Configuration-dependent maximum reach threshold
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90Â°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 | None = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities:
    - Near singularities: looser tolerance for easier convergence
    - Away from singularities: stricter tolerance for precise solutions
    If necessary, recursively subdivide the motion until ikine_LM converges
    on every segment. Finally check that solution respects joint limits. From experimentation,
    jogging with lower tolerances often produces q_paths that do not differ from current_q,
    essentially freezing the robot.

    Parameters
    ----------
    robot : DHRobot
        Robot model
    target_pose : SE3
        Target pose to reach
    current_q : array_like
        Current joint configuration
    current_pose : SE3, optional
        Current pose (computed if None)
    max_depth : int, optional
        Maximum subdivision depth (default: 8)
    ilimit : int, optional
        Maximum iterations for IK solver (default: 100)

    Returns
    -------
    IKResult
        success  - True/False
        q_path   - (mxn) array of the final joint configuration 
        iterations, residual  - aggregated diagnostics
        tolerance_used - which tolerance was used
        violations - joint limit violations (if any)
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # â”€â”€ inner recursive solverâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            # print(f"current_reach:{current_reach:.3f}, max_reach_threshold:{max_reach_threshold:.3f}")
            if not is_recovery and target_reach > max_reach_threshold:
                print(f"Target reach limit exceeded: {target_reach:.3f} > {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LM(Tb, q0=q_seed, ilimit=ilimit, tol=tol)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # â”€â”€ kick-off with adaptive tolerance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    # Check if solution respects joint limits
    target_q = path[-1] if len(path) != 0 else None
    solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
    if ok and solution_valid:
        return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
    else:
        return IKResult(False, None, its, resid, adaptive_tol, violations)

#Setup IP address and Simulator port
ip = "127.0.0.1" #Loopback address
port = 5001
# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((ip, port))
print(f'Start listening to {ip}:{port}')

def Unpack_data(data_buffer_list, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):

    Joints = []
    Speed = []

    for i in range(0,18, 3):
        variable = data_buffer_list[i:i+3]
        Joints.append(variable)

    for i in range(18,36, 3):
        variable = data_buffer_list[i:i+3]
        Speed.append(variable)


    for i in range(6):
        var =  b'\x00' + b''.join(Joints[i])
        Position_in[i] = Fuse_3_bytes(var)
        var =  b'\x00' + b''.join(Speed[i])
        Speed_in[i] = Fuse_3_bytes(var)

    Homed = data_buffer_list[36]
    IO_var = data_buffer_list[37]
    temp_error = data_buffer_list[38]
    position_error = data_buffer_list[39]
    timing_data = data_buffer_list[40:42]
    Timeout_error_var = data_buffer_list[42]
    xtr2 = data_buffer_list[43]
    device_ID = data_buffer_list[44]
    Gripper_position = data_buffer_list[45:47]
    Gripper_speed = data_buffer_list[47:49]
    Gripper_current = data_buffer_list[49:51]
    Status = data_buffer_list[51]
    # The original object_detection byte at index 52 is ignored as it is not reliable.
    CRC_byte = data_buffer_list[53]
    endy_byte1 = data_buffer_list[54]
    endy_byte2 = data_buffer_list[55]

    # ... (Code for Homed, IO_var, temp_error, etc. remains the same) ...

    temp = Split_2_bitfield(int.from_bytes(Homed,"big"))
    for i in range(8):
        Homed_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(IO_var,"big"))
    for i in range(8):
        InOut_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(temp_error,"big"))
    for i in range(8):
        Temperature_error_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(position_error,"big"))
    for i in range(8):
        Position_error_in[i] = temp[i]

    var = b'\x00' + b'\x00' + b''.join(timing_data)
    Timing_data_in[0] = Fuse_3_bytes(var)
    Timeout_error = int.from_bytes(Timeout_error_var,"big")
    XTR_data = int.from_bytes(xtr2,"big")

    # --- Gripper Data Unpacking ---
    Gripper_data_in[0] = int.from_bytes(device_ID,"big")

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_position)
    Gripper_data_in[1] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_speed)
    Gripper_data_in[2] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_current)
    Gripper_data_in[3] = Fuse_2_bytes(var)

    # --- Start of Corrected Logic ---
    # This section now mirrors the working logic from GUI_PAROL_latest.py
    
    # 1. Store the raw status byte (from index 51)
    status_byte = int.from_bytes(Status,"big")
    Gripper_data_in[4] = status_byte

    # 2. Split the status byte into a list of 8 individual bits
    status_bits = Split_2_bitfield(status_byte)
    
    # 3. Combine the 3rd and 4th bits (at indices 2 and 3) to get the true object detection status
    # This creates a 2-bit number (0-3) which represents the full state.
    object_detection_status = (status_bits[2] << 1) | status_bits[3]
    Gripper_data_in[5] = object_detection_status
    # --- End of Corrected Logic ---

def Pack_data(Position_out,Speed_out,Command_out,Affected_joint_out,InOut_out,Timeout_out,Gripper_data_out):

    # Len is defined by all bytes EXCEPT start bytes and len
    # Start bytes = 3
    len = 52 #1
    Position = [Position_out[0],Position_out[1],Position_out[2],Position_out[3],Position_out[4],Position_out[5]]  #18
    Speed = [Speed_out[0], Speed_out[1], Speed_out[2], Speed_out[3], Speed_out[4], Speed_out[5],] #18
    Command = Command_out#1
    Affected_joint = Affected_joint_out
    InOut = InOut_out #1
    Timeout = Timeout_out #1
    Gripper_data = Gripper_data_out #9
    CRC_byte = 228 #1
    # End bytes = 2


    test_list = []
    #print(test_list)

    #x = bytes(start_bytes)
    test_list.append((start_bytes))
    
    test_list.append(bytes([len]))


    # Position data
    for i in range(6):
        position_split = Split_2_3_bytes(Position[i])
        test_list.append(position_split[1:4])

    # Speed data
    for i in range(6):
        speed_split = Split_2_3_bytes(Speed[i])
        test_list.append(speed_split[1:4])

    # Command data
    test_list.append(bytes([Command]))

    # Affected joint data
    Affected_list = Fuse_bitfield_2_bytearray(Affected_joint[:])
    test_list.append(Affected_list)

    # Inputs outputs data
    InOut_list = Fuse_bitfield_2_bytearray(InOut[:])
    test_list.append(InOut_list)

    # Timeout data
    test_list.append(bytes([Timeout]))

    # Gripper position
    Gripper_position = Split_2_3_bytes(Gripper_data[0])
    test_list.append(Gripper_position[2:4])

    # Gripper speed
    Gripper_speed = Split_2_3_bytes(Gripper_data[1])
    test_list.append(Gripper_speed[2:4])

    # Gripper current
    Gripper_current = Split_2_3_bytes(Gripper_data[2])
    test_list.append(Gripper_current[2:4])  

    # Gripper command
    test_list.append(bytes([Gripper_data[3]]))
    # Gripper mode
    test_list.append(bytes([Gripper_data[4]]))
    
    # ==========================================================
    # === FIX: Make sure calibrate is a one-shot command      ====
    # ==========================================================
    # If the mode was set to calibrate (1) or clear_error (2), reset it
    # back to normal (0) for the next cycle. This prevents an endless loop.
    if Gripper_data_out[4] == 1 or Gripper_data_out[4] == 2:
        Gripper_data_out[4] = 0
    # ==========================================================
    
    # Gripper ID
    test_list.append(bytes([Gripper_data[5]]))
 
    # CRC byte
    test_list.append(bytes([CRC_byte]))

    # END bytes
    test_list.append((end_bytes))
    
    #print(test_list)
    return test_list

def Get_data(Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):
    global input_byte 

    global start_cond1_byte 
    global start_cond2_byte 
    global start_cond3_byte 

    global end_cond1_byte 
    global end_cond2_byte 

    global start_cond1 
    global start_cond2 
    global start_cond3 

    global good_start 
    global data_len 

    global data_buffer 
    global data_counter

    while (ser.inWaiting() > 0):
        input_byte = ser.read()

        #UNCOMMENT THIS TO GET ALL DATA FROM THE ROBOT PRINTED
        #print(input_byte) 

        # When data len is received start is good and after that put all data in receive buffer
        # Data len is ALL data after it; that includes input buffer, end bytes and CRC
        if (good_start != 1):
            # All start bytes are good and next byte is data len
            if (start_cond1 == 1 and start_cond2 == 1 and start_cond3 == 1):
                good_start = 1
                data_len = input_byte
                data_len = struct.unpack('B', data_len)[0]
                logging.debug("data len we got from robot packet= ")
                logging.debug(input_byte)
                logging.debug("good start for DATA that we received at PC")
            # Third start byte is good
            if (input_byte == start_cond3_byte and start_cond2 == 1 and start_cond1 == 1):
                start_cond3 = 1
                #print("good cond 3 PC")
            #Third start byte is bad, reset all flags
            elif (start_cond2 == 1 and start_cond1 == 1):
                #print("bad cond 3 PC")
                start_cond1 = 0
                start_cond2 = 0
            # Second start byte is good
            if (input_byte == start_cond2_byte and start_cond1 == 1):
                start_cond2 = 1
                #print("good cond 2 PC ")
            #Second start byte is bad, reset all flags   
            elif (start_cond1 == 1):
                #print("Bad cond 2 PC")
                start_cond1 = 0
            # First start byte is good
            if (input_byte == start_cond1_byte):
                start_cond1 = 1
                #print("good cond 1 PC")
        else:
            # Here data goes after good  start
            data_buffer[data_counter] = input_byte
            if (data_counter == data_len - 1):

                logging.debug("Data len PC")
                logging.debug(data_len)
                logging.debug("End bytes are:")
                logging.debug(data_buffer[data_len -1])
                logging.debug(data_buffer[data_len -2])

                # Here if last 2 bytes are end condition bytes we process the data 
                if (data_buffer[data_len -1] == end_cond2_byte and data_buffer[data_len - 2] == end_cond1_byte):

                    logging.debug("GOOD END CONDITION PC")
                    logging.debug("I UNPACKED RAW DATA RECEIVED FROM THE ROBOT")
                    Unpack_data(data_buffer, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
                    XTR_data,Gripper_data_in)
                    logging.debug("DATA UNPACK FINISHED")
                    # ako su dobri izraÄunaj crc
                    # if crc dobar raspakiraj podatke
                    # ako je dobar paket je dobar i spremi ga u nove variable!
                
                # Print every byte
                #print("podaci u data bufferu su:")
                #for i in range(data_len):
                    #print(data_buffer[i])

                good_start = 0
                start_cond1 = 0
                start_cond3 = 0
                start_cond2 = 0
                data_len = 0
                data_counter = 0
            else:
                data_counter = data_counter + 1

# Split data to 3 bytes 
def Split_2_3_bytes(var_in):
    y = int_to_3_bytes(var_in & 0xFFFFFF) # converts my int value to bytes array
    return y

# Splits byte to bitfield list
def Split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]

# Fuses 3 bytes to 1 signed int
def Fuse_3_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<23:
        value -= 1<<24

    return value

# Fuses 2 bytes to 1 signed int
def Fuse_2_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<15:
        value -= 1<<16

    return value

# Fuse bitfield list to byte
def Fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Check if there is element 1 in the list. 
# If yes return its index, if no element is 1 return -1
def check_elements(lst):
    for i, element in enumerate(lst):
        if element == 1:
            return i
    return -1  # Return -1 if no element is 1

def quintic_scaling(s: float) -> float:
    """
    Calculates a smooth 0-to-1 scaling factor for progress 's'
    using a quintic polynomial, ensuring smooth start/end accelerations.
    """
    return 6 * (s**5) - 15 * (s**4) + 10 * (s**3)

#########################################################################
# Robot Commands Start Here
#########################################################################

class HomeCommand:
    """
    A non-blocking command that tells the robot to perform its internal homing sequence.
    This version uses a state machine to allow re-homing even if the robot is already homed.
    """
    def __init__(self):
        self.is_valid = True
        self.is_finished = False
        # State machine: START -> WAIT_FOR_UNHOMED -> WAIT_FOR_HOMED -> FINISHED
        self.state = "START"
        # Counter to send the home command for multiple cycles
        self.start_cmd_counter = 10  # Send command 100 for 10 cycles (0.1s)
        # Safety timeout (20 seconds at 0.01s interval)
        self.timeout_counter = 2000
        print("Initializing Home command...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Manages the homing command and monitors for completion using a state machine.
        """
        if self.is_finished:
            return True

        # --- State: START ---
        # On the first few executions, continuously send the 'home' (100) command.
        if self.state == "START":
            print(f"  -> Sending home signal (100)... Countdown: {self.start_cmd_counter}")
            Command_out.value = 100
            self.start_cmd_counter -= 1
            if self.start_cmd_counter <= 0:
                # Once sent for enough cycles, move to the next state
                self.state = "WAITING_FOR_UNHOMED"
            return False

        # --- State: WAITING_FOR_UNHOMED ---
        # The robot's firmware should reset the homed status. We wait to see that happen.
        # During this time, we send 'idle' (255) to let the robot's controller take over.
        if self.state == "WAITING_FOR_UNHOMED":
            Command_out.value = 255
            # Check if at least one joint has started homing (is no longer homed)
            if any(h == 0 for h in Homed_in[:6]):
                print("  -> Homing sequence initiated by robot.")
                self.state = "WAITING_FOR_HOMED"
            # Check for timeout
            self.timeout_counter -= 1
            if self.timeout_counter <= 0:
                print("  -> ERROR: Timeout waiting for robot to start homing sequence.")
                self.is_finished = True
            return self.is_finished

        # --- State: WAITING_FOR_HOMED ---
        # Now we wait for all joints to report that they are homed (all flags are 1).
        if self.state == "WAITING_FOR_HOMED":
            Command_out.value = 255
            # Check if all joints have finished homing
            if all(h == 1 for h in Homed_in[:6]):
                print("Homing sequence complete. All joints reported home.")
                self.is_finished = True
                Speed_out[:] = [0] * 6 # Ensure robot is stopped

        return self.is_finished

class JogCommand:
    """
    A non-blocking command to jog a joint for a specific duration or distance.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joint, speed_percentage=None, duration=None, distance_deg=None):
        """
        Initializes and validates the jog command. This is the SETUP phase.
        """
        self.is_valid = False
        self.is_finished = False
        self.mode = None
        self.command_step = 0

        # --- 1. Parameter Validation and Mode Selection ---
        if duration and distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Distance {distance_deg} deg, Duration {duration}s.")
        elif duration:
            self.mode = 'time'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Duration {duration}s.")
        elif distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Distance {distance_deg} deg.")
        else:
            print("Error: JogCommand requires either 'duration', 'distance_deg', or both.")
            return

        # --- 2. Store parameters for deferred calculation ---
        self.joint = joint
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.distance_deg = distance_deg

        # --- These will be calculated later ---
        self.direction = 1
        self.joint_index = 0
        self.speed_out = 0
        self.command_len = 0
        self.target_position = 0

        self.is_valid = True # Mark as valid for now; preparation step will confirm.


    def prepare_for_execution(self, current_position_in):
        """Pre-computes speeds and target positions using live data."""
        print(f"  -> Preparing for Jog command...")

        # Determine direction and joint index
        self.direction = 1 if 0 <= self.joint <= 5 else -1
        self.joint_index = self.joint if self.direction == 1 else self.joint - 6
        
        distance_steps = 0
        if self.distance_deg:
            distance_steps = int(PAROL6_ROBOT.DEG2STEPS(abs(self.distance_deg), self.joint_index))
            # --- MOVED LOGIC: Calculate target using the LIVE position ---
            self.target_position = current_position_in[self.joint_index] + (distance_steps * self.direction)
            
            min_limit, max_limit = PAROL6_ROBOT.Joint_limits_steps[self.joint_index]
            if not (min_limit <= self.target_position <= max_limit):
                print(f"  -> VALIDATION FAILED: Target position {self.target_position} is out of joint limits ({min_limit}, {max_limit}).")
                self.is_valid = False
                return

        # Calculate speed and duration
        speed_steps_per_sec = 0
        if self.mode == 'distance' and self.duration:
            speed_steps_per_sec = int(distance_steps / self.duration) if self.duration > 0 else 0
            max_joint_speed = PAROL6_ROBOT.Joint_max_speed[self.joint_index]
            if speed_steps_per_sec > max_joint_speed:
                print(f"  -> VALIDATION FAILED: Required speed ({speed_steps_per_sec} steps/s) exceeds joint's max speed ({max_joint_speed} steps/s).")
                self.is_valid = False
                return
        else:
            if self.speed_percentage is None:
                print("Error: 'speed_percentage' must be provided if not calculating automatically.")
                self.is_valid = False
                return
            speed_steps_per_sec = int(np.interp(abs(self.speed_percentage), [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[self.joint_index] * 2]))

        self.speed_out = speed_steps_per_sec * self.direction
        self.command_len = int(self.duration / INTERVAL_S) if self.duration else float('inf')
        print("  -> Jog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        stop_reason = None
        current_pos = Position_in[self.joint_index]

        if self.mode == 'time':
            if self.command_step >= self.command_len:
                stop_reason = "Timed jog finished."
        elif self.mode == 'distance':
            if (self.direction == 1 and current_pos >= self.target_position) or \
               (self.direction == -1 and current_pos <= self.target_position):
                stop_reason = "Distance jog finished."
        
        if not stop_reason:
            if (self.direction == 1 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][1]) or \
               (self.direction == -1 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][0]):
                stop_reason = f"Limit reached on joint {self.joint_index + 1}."

        if stop_reason:
            print(stop_reason)
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            Speed_out[:] = [0] * 6
            Speed_out[self.joint_index] = self.speed_out
            Command_out.value = 123
            self.command_step += 1
            return False
        
class MultiJogCommand:
    """
    A non-blocking command to jog multiple joints simultaneously for a specific duration.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joints, speed_percentages, duration):
        """
        Initializes and validates the multi-jog command.
        """
        self.is_valid = False
        self.is_finished = False
        self.command_step = 0

        # --- 1. Parameter Validation ---
        if not isinstance(joints, list) or not isinstance(speed_percentages, list):
            print("Error: MultiJogCommand requires 'joints' and 'speed_percentages' to be lists.")
            return

        if len(joints) != len(speed_percentages):
            print("Error: The number of joints must match the number of speed percentages.")
            return

        if not duration or duration <= 0:
            print("Error: MultiJogCommand requires a positive 'duration'.")
            return

        # ==========================================================
        # === NEW: Check for conflicting joint commands          ===
        # ==========================================================
        base_joints = set()
        for joint in joints:
            # Normalize the joint index to its base (0-5)
            base_joint = joint % 6
            # If the base joint is already in our set, it's a conflict.
            if base_joint in base_joints:
                print(f"  -> VALIDATION FAILED: Conflicting commands for Joint {base_joint + 1} (e.g., J1+ and J1-).")
                self.is_valid = False
                return
            base_joints.add(base_joint)
        # ==========================================================

        print(f"Initializing MultiJog for joints {joints} with speeds {speed_percentages}% for {duration}s.")

        # --- 2. Store parameters ---
        self.joints = joints
        self.speed_percentages = speed_percentages
        self.duration = duration
        self.command_len = int(self.duration / INTERVAL_S)

        # --- This will be calculated in the prepare step ---
        self.speeds_out = [0] * 6

        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Pre-computes the speeds for each joint."""
        print(f"  -> Preparing for MultiJog command...")

        for i, joint in enumerate(self.joints):
            # Determine direction and joint index (0-5 for positive, 6-11 for negative)
            direction = 1 if 0 <= joint <= 5 else -1
            joint_index = joint if direction == 1 else joint - 6
            speed_percentage = self.speed_percentages[i]

            # Check for joint index validity
            if not (0 <= joint_index < 6):
                print(f"  -> VALIDATION FAILED: Invalid joint index {joint_index}.")
                self.is_valid = False
                return

            # Calculate speed in steps/sec
            speed_steps_per_sec = int(np.interp(speed_percentage, [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[joint_index]]))
            self.speeds_out[joint_index] = speed_steps_per_sec * direction

        print("  -> MultiJog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        # Stop if the duration has elapsed
        if self.command_step >= self.command_len:
            print("Timed multi-jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            # Continuously check for joint limits during the jog
            for i in range(6):
                if self.speeds_out[i] != 0:
                    current_pos = Position_in[i]
                    # Hitting positive limit while moving positively
                    if self.speeds_out[i] > 0 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[i][1]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True
                    # Hitting negative limit while moving negatively
                    elif self.speeds_out[i] < 0 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[i][0]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True

            # If no limits are hit, apply the speeds
            Speed_out[:] = self.speeds_out
            Command_out.value = 123 # Jog command
            self.command_step += 1
            return False # Command is still running
        
# This dictionary maps descriptive axis names to movement vectors, which is cleaner.
# Format: ([x, y, z], [rx, ry, rz])
AXIS_MAP = {
    'X+': ([1, 0, 0], [0, 0, 0]), 'X-': ([-1, 0, 0], [0, 0, 0]),
    'Y+': ([0, 1, 0], [0, 0, 0]), 'Y-': ([0, -1, 0], [0, 0, 0]),
    'Z+': ([0, 0, 1], [0, 0, 0]), 'Z-': ([0, 0, -1], [0, 0, 0]),
    'RX+': ([0, 0, 0], [1, 0, 0]), 'RX-': ([0, 0, 0], [-1, 0, 0]),
    'RY+': ([0, 0, 0], [0, 1, 0]), 'RY-': ([0, 0, 0], [0, -1, 0]),
    'RZ+': ([0, 0, 0], [0, 0, 1]), 'RZ-': ([0, 0, 0], [0, 0, -1]),
}

class CartesianJogCommand:
    """
    A non-blocking command to jog the robot's end-effector in Cartesian space.
    This is the final, refactored version using clean, standard spatial math
    operations now that the core unit bug has been fixed.
    """
    def __init__(self, frame, axis, speed_percentage=50, duration=1.5, **kwargs):
        """
        Initializes and validates the Cartesian jog command.
        """
        self.is_valid = False
        self.is_finished = False
        print(f"Initializing CartesianJog: Frame {frame}, Axis {axis}...")

        if axis not in AXIS_MAP:
            print(f"  -> VALIDATION FAILED: Invalid axis '{axis}'.")
            return
        
        # Store all necessary parameters for use in execute_step
        self.frame = frame
        self.axis_vectors = AXIS_MAP[axis]
        self.is_rotation = any(self.axis_vectors[1])
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.end_time = time.time() + self.duration
        
        self.is_valid = True
        print("  -> Command is valid and ready.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Check for completion ---
        if time.time() >= self.end_time:
            print("Cartesian jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- B. Calculate Target Pose using clean vector math ---
        Command_out.value = 123 # Set jog command
        
        q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        T_current = PAROL6_ROBOT.robot.fkine(q_current)

        if not isinstance(T_current, SE3):
            return False # Wait for valid pose data

        # Calculate speed and displacement for this cycle
        linear_speed_ms = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min_JOG, PAROL6_ROBOT.Cartesian_linear_velocity_max_JOG]))
        angular_speed_degs = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max]))

        delta_linear = linear_speed_ms * INTERVAL_S
        delta_angular_rad = np.deg2rad(angular_speed_degs * INTERVAL_S)

        # Create the small incremental transformation (delta_pose)
        trans_vec = np.array(self.axis_vectors[0]) * delta_linear
        rot_vec = np.array(self.axis_vectors[1]) * delta_angular_rad
        delta_pose = SE3.Rt(SE3.Eul(rot_vec).R, trans_vec)

        # Apply the transformation in the correct reference frame
        if self.frame == 'WRF':
            # Pre-multiply to apply the change in the World Reference Frame
            target_pose = delta_pose * T_current
        else: # TRF
            # Post-multiply to apply the change in the Tool Reference Frame
            target_pose = T_current * delta_pose
        
        # --- C. Solve IK and Calculate Velocities ---
        var = solve_ik_with_adaptive_tol_subdivision(PAROL6_ROBOT.robot, target_pose, q_current, jogging=True)

        if var.success:
            q_velocities = (var.q - q_current) / INTERVAL_S
            for i in range(6):
                Speed_out[i] = int(PAROL6_ROBOT.SPEED_RAD2STEP(q_velocities[i], i))
        else:
            print("IK Warning: Could not find solution for jog step. Stopping.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- D. Speed Scaling ---
        max_scale_factor = 1.0
        for i in range(6):
            if abs(Speed_out[i]) > PAROL6_ROBOT.Joint_max_speed[i]:
                scale = abs(Speed_out[i]) / PAROL6_ROBOT.Joint_max_speed[i]
                if scale > max_scale_factor:
                    max_scale_factor = scale
        
        if max_scale_factor > 1.0:
            for i in range(6):
                Speed_out[i] = int(Speed_out[i] / max_scale_factor)

        return False # Command is still running

class MovePoseCommand:
    """
    A non-blocking command to move the robot to a specific Cartesian pose.
    The movement itself is a joint-space interpolation.
    """
    def __init__(self, pose, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = True  # Assume valid; preparation step will confirm.
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MovePose to {pose}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.pose = pose
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

    """
        Initializes, validates, and pre-computes the trajectory for a move-to-pose command.

        Args:
            pose (list): A list of 6 values [x, y, z, r, p, y] for the target pose.
                         Positions are in mm, rotations are in degrees.
            duration (float, optional): The total time for the movement in seconds.
            velocity_percent (float, optional): The target velocity as a percentage (0-100).
            accel_percent (float, optional): The target acceleration as a percentage (0-100).
            trajectory_type (str, optional): The type of trajectory ('poly' or 'trap').
        """
    
    def prepare_for_execution(self, current_position_in):
        """Calculates the full trajectory just-in-time before execution."""
        print(f"  -> Preparing trajectory for MovePose to {self.pose}...")

        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pose = SE3(self.pose[0] / 1000.0, self.pose[1] / 1000.0, self.pose[2] / 1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')
        
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_pose, initial_pos_rad, ilimit=100)

        if not ik_solution.success:
            print("  -> VALIDATION FAILED: Inverse kinematics failed at execution time.")
            self.is_valid = False
            return

        target_pos_rad = ik_solution.q

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])

                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue
                    
                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)
            
                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                self.is_valid = False
                return

        else:
            print("  -> Using conservative values for MovePose.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveJointCommand:
    """
    A non-blocking command to move the robot's joints to a specific configuration.
    It pre-calculates the entire trajectory upon initialization.
    """
    def __init__(self, target_angles, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = False  # Will be set to True after basic validation
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MoveJoint to {target_angles}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.target_angles = target_angles
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

        # --- Perform only state-independent validation ---
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])
        for i in range(6):
            min_rad, max_rad = PAROL6_ROBOT.Joint_limits_radian[i]
            if not (min_rad <= target_pos_rad[i] <= max_rad):
                print(f"  -> VALIDATION FAILED: Target for Joint {i+1} ({self.target_angles[i]} deg) is out of range.")
                return
        
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Calculates the trajectory just before execution begins."""
        print(f"  -> Preparing trajectory for MoveJoint to {self.target_angles}...")
        
        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])
                
                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue

                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)

                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                print(f"  -> Please check Joint_min/max_speed and Joint_min/max_acc values in PAROL6_ROBOT.py.")
                self.is_valid = False
                return
        
        else:
            print("  -> Using conservative values for MoveJoint.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveCartCommand:
    """
    A non-blocking command to move the robot's end-effector in a straight line
    in Cartesian space, completing the move in an exact duration.

    It works by:
    1. Pre-validating the final target pose.
    2. Interpolating the pose in Cartesian space in real-time.
    3. Solving Inverse Kinematics for each intermediate step to ensure path validity.
    """
    def __init__(self, pose, duration=None, velocity_percent=None):
        self.is_valid = False
        self.is_finished = False

        # --- MODIFICATION: Validate that at least one timing parameter is given ---
        if duration is None and velocity_percent is None:
            print("  -> VALIDATION FAILED: MoveCartCommand requires either 'duration' or 'velocity_percent'.")
            return
        if duration is not None and velocity_percent is not None:
            print("  -> INFO: Both duration and velocity_percent provided. Using duration.")
            self.velocity_percent = None # Prioritize duration
        else:
            self.velocity_percent = velocity_percent

        # --- Store parameters and set placeholders ---
        self.duration = duration
        self.pose = pose
        self.start_time = None
        self.initial_pose = None
        self.target_pose = None
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Captures the initial state and validates the path just before execution."""
        print(f"  -> Preparing for MoveCart to {self.pose}...")
        
        # --- MOVED LOGIC: Capture initial state from live data ---
        initial_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        self.initial_pose = PAROL6_ROBOT.robot.fkine(initial_q_rad)
        self.target_pose = SE3(self.pose[0]/1000.0, self.pose[1]/1000.0, self.pose[2]/1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')

        print("  -> Pre-validating final target pose...")
        ik_check = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, self.target_pose, initial_q_rad
        )

        if not ik_check.success:
            print("  -> VALIDATION FAILED: The final target pose is unreachable.")
            if ik_check.violations:
                print(f"     Reason: Solution violates joint limits: {ik_check.violations}")
            self.is_valid = False # Mark as invalid if path fails
            return

        # --- NEW BLOCK: Calculate duration from velocity if needed ---
        if self.velocity_percent is not None:
            print(f"  -> Calculating duration for {self.velocity_percent}% speed...")
            # Calculate the total distance for translation and rotation
            linear_distance = np.linalg.norm(self.target_pose.t - self.initial_pose.t)
            angular_distance_rad = self.initial_pose.angdist(self.target_pose)

            # Interpolate the target speeds from percentages, assuming constants exist in PAROL6_ROBOT
            target_linear_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min, PAROL6_ROBOT.Cartesian_linear_velocity_max])
            target_angular_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max])
            target_angular_speed_rad = np.deg2rad(target_angular_speed)

            # Calculate time required for each component of the movement
            time_linear = linear_distance / target_linear_speed if target_linear_speed > 0 else 0
            time_angular = angular_distance_rad / target_angular_speed_rad if target_angular_speed_rad > 0 else 0

            # The total duration is the longer of the two times to ensure synchronization
            calculated_duration = max(time_linear, time_angular)

            if calculated_duration <= 0:
                print("  -> INFO: MoveCart has zero duration. Marking as finished.")
                self.is_finished = True
                self.is_valid = True # It's valid, just already done.
                return

            self.duration = calculated_duration
            print(f"  -> Calculated MoveCart duration: {self.duration:.2f}s")

        print("  -> Command is valid and ready for execution.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        if self.start_time is None:
            self.start_time = time.time()

        elapsed_time = time.time() - self.start_time
        s = min(elapsed_time / self.duration, 1.0)
        s_scaled = quintic_scaling(s)

        current_target_pose = self.initial_pose.interp(self.target_pose, s_scaled)

        current_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, current_target_pose, current_q_rad
        )

        if not ik_solution.success:
            print("  -> ERROR: MoveCart failed. An intermediate point on the path is unreachable.")
            if ik_solution.violations:
                 print(f"     Reason: Path violates joint limits: {ik_solution.violations}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        current_pos_rad = ik_solution.q

        # --- MODIFIED BLOCK ---
        # Send only the target position and let the firmware's P-controller handle speed.
        Position_out[:] = [int(PAROL6_ROBOT.RAD2STEPS(p, i)) for i, p in enumerate(current_pos_rad)]
        Speed_out[:] = [0] * 6 # Set feed-forward velocity to zero for smooth P-control.
        Command_out.value = 156
        # --- END MODIFIED BLOCK ---

        if s >= 1.0:
            print(f"MoveCart finished in ~{elapsed_time:.2f}s.")
            self.is_finished = True
            # The main loop will handle holding the final position.

        return self.is_finished
        
class GripperCommand:
    """
    A single, unified, non-blocking command to control all gripper functions.
    It internally selects the correct logic (position-based waiting, timed delay,
    or instantaneous) based on the specified action.
    """
    def __init__(self, gripper_type, action=None, position=100, speed=100, current=500, output_port=1):
        """
        Initializes the Gripper command and configures its internal state machine
        based on the requested action.
        """
        self.is_valid = True
        self.is_finished = False
        self.gripper_type = gripper_type.lower()
        self.action = action.lower() if action else 'move'
        self.state = "START"
        self.timeout_counter = 1000 # 10-second safety timeout for all waiting states

        # --- Configure based on Gripper Type and Action ---
        if self.gripper_type == 'electric':
            if self.action == 'move':
                self.target_position = position
                self.speed = speed
                self.current = current
                if not (0 <= position <= 255 and 0 <= speed <= 255 and 100 <= current <= 1000):
                    self.is_valid = False
            elif self.action == 'calibrate':
                self.wait_counter = 200 # 2-second fixed delay for calibration
            else:
                self.is_valid = False # Invalid action

        elif self.gripper_type == 'pneumatic':
            if self.action not in ['open', 'close']:
                self.is_valid = False
            self.state_to_set = 1 if self.action == 'open' else 0
            self.port_index = 2 if output_port == 1 else 3
        else:
            self.is_valid = False

        if not self.is_valid:
            print(f"  -> VALIDATION FAILED for GripperCommand with action: '{self.action}'")

    def execute_step(self, Gripper_data_out, InOut_out, Gripper_data_in, InOut_in, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        self.timeout_counter -= 1
        if self.timeout_counter <= 0:
            print(f"  -> ERROR: Gripper command timed out in state {self.state}.")
            self.is_finished = True
            return True

        # --- Pneumatic Logic (Instantaneous) ---
        if self.gripper_type == 'pneumatic':
            InOut_out[self.port_index] = self.state_to_set
            print("  -> Pneumatic gripper command sent.")
            self.is_finished = True
            return True

        # --- Electric Gripper Logic ---
        if self.gripper_type == 'electric':
            # On the first run, transition to the correct state for the action
            if self.state == "START":
                if self.action == 'calibrate':
                    self.state = "SEND_CALIBRATE"
                else: # 'move'
                    self.state = "WAIT_FOR_POSITION"
            
            # --- Calibrate Logic (Timed Delay) ---
            if self.state == "SEND_CALIBRATE":
                print("  -> Sending one-shot calibrate command...")
                Gripper_data_out[4] = 1 # Set mode to calibrate
                self.state = "WAITING_CALIBRATION"
                return False

            if self.state == "WAITING_CALIBRATION":
                self.wait_counter -= 1
                if self.wait_counter <= 0:
                    print("  -> Calibration delay finished.")
                    Gripper_data_out[4] = 0 # Reset to operation mode
                    self.is_finished = True
                    return True
                return False

            # --- Move Logic (Position-Based) ---
            if self.state == "WAIT_FOR_POSITION":
                # Persistently send the move command
                Gripper_data_out[0], Gripper_data_out[1], Gripper_data_out[2] = self.target_position, self.speed, self.current
                Gripper_data_out[4] = 0 # Operation mode
                bitfield = [1, 1, not InOut_in[4], 1, 0, 0, 0, 0]
                fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                Gripper_data_out[3] = int(fused.hex(), 16)

                # Check for completion
                current_position = Gripper_data_in[1]
                if abs(current_position - self.target_position) <= 5:
                    print(f"  -> Gripper move complete.")
                    self.is_finished = True
                    # Set command back to idle
                    bitfield = [1, 0, not InOut_in[4], 1, 0, 0, 0, 0]
                    fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                    Gripper_data_out[3] = int(fused.hex(), 16)
                    return True
                return False
        
        return self.is_finished

class DelayCommand:
    """
    A non-blocking command that pauses execution for a specified duration.
    During the delay, it ensures the robot remains idle by sending the
    appropriate commands.
    """
    def __init__(self, duration):
        """
        Initializes and validates the Delay command.

        Args:
            duration (float): The delay time in seconds.
        """
        self.is_valid = False
        self.is_finished = False

        # --- 1. Parameter Validation ---
        if not isinstance(duration, (int, float)) or duration <= 0:
            print(f"  -> VALIDATION FAILED: Delay duration must be a positive number, but got {duration}.")
            return

        print(f"Initializing Delay for {duration} seconds...")
        
        self.duration = duration
        self.end_time = None  # Will be set in prepare_for_execution
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Set the end time when the command actually starts."""
        self.end_time = time.time() + self.duration
        print(f"  -> Delay starting for {self.duration} seconds...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Checks if the delay duration has passed and keeps the robot idle.
        This method is called on every loop cycle (~0.01s).
        """
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Keep the robot idle during the delay ---
        Command_out.value = 255  # Set command to idle
        Speed_out[:] = [0] * 6   # Set all speeds to zero

        # --- B. Check for completion ---
        if self.end_time and time.time() >= self.end_time:
            print(f"Delay finished after {self.duration} seconds.")
            self.is_finished = True
        
        return self.is_finished
    
#########################################################################
# Smooth Motion Commands Start Here
#########################################################################
    
class BaseSmoothMotionCommand:
    """
    Base class for all smooth motion commands with proper error tracking.
    """
    
    def __init__(self, description="smooth motion"):
        self.description = description
        self.trajectory = None
        self.trajectory_command = None
        self.transition_command = None
        self.is_valid = True
        self.is_finished = False
        self.specified_start_pose = None
        self.transition_complete = False
        self.trajectory_prepared = False
        self.error_state = False
        self.error_message = ""
        self.trajectory_generated = False  # NEW: Track if trajectory is generated
        
    def create_transition_command(self, current_pose, target_pose):
        """Create a MovePose command for smooth transition to start position."""
        pos_error = np.linalg.norm(
            np.array(target_pose[:3]) - np.array(current_pose[:3])
        )
        
        # Lower threshold to 2mm for more aggressive transition generation
        if pos_error < 2.0:  # Changed from 5.0mm to 2.0mm
            print(f"  -> Already near start position (error: {pos_error:.1f}mm)")
            return None
        
        print(f"  -> Creating smooth transition to start ({pos_error:.1f}mm away)")
        
        # Calculate transition speed based on distance
        # Slower for short distances, faster for long distances
        if pos_error < 10:
            transition_speed = 20.0  # mm/s for short distances
        elif pos_error < 30:
            transition_speed = 30.0  # mm/s for medium distances
        else:
            transition_speed = 40.0  # mm/s for long distances
        
        transition_duration = max(pos_error / transition_speed, 0.5)  # Minimum 0.5s
        
        transition_cmd = MovePoseCommand(
            pose=target_pose,
            duration=transition_duration
        )
        
        return transition_cmd
    
    def get_current_pose_from_position(self, position_in):
        """Convert current position to pose [x,y,z,rx,ry,rz]"""
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(position_in)])
        current_pose_se3 = PAROL6_ROBOT.robot.fkine(current_q)
        
        current_xyz = current_pose_se3.t * 1000  # Convert to mm
        current_rpy = current_pose_se3.rpy(unit='deg', order='xyz')
        return np.concatenate([current_xyz, current_rpy]).tolist()
        
    def prepare_for_execution(self, current_position_in):
        """Minimal preparation - just check if we need a transition."""
        print(f"  -> Preparing {self.description}...")
        
        # If there's a specified start pose, prepare transition
        if self.specified_start_pose:
            actual_current_pose = self.get_current_pose_from_position(current_position_in)
            self.transition_command = self.create_transition_command(
                actual_current_pose, self.specified_start_pose
            )
            
            if self.transition_command:
                self.transition_command.prepare_for_execution(current_position_in)
                if not self.transition_command.is_valid:
                    print(f"  -> ERROR: Cannot reach specified start position")
                    self.is_valid = False
                    self.error_state = True
                    self.error_message = "Cannot reach specified start position"
                    return
        else:
            self.transition_command = None
            
        # DON'T generate trajectory yet - wait until execution
        self.trajectory_generated = False
        self.trajectory_prepared = False
        print(f"  -> {self.description} preparation complete (trajectory will be generated at execution)")
            
    def generate_main_trajectory(self, effective_start_pose):
        """Override this in subclasses to generate the specific motion trajectory."""
        raise NotImplementedError("Subclasses must implement generate_main_trajectory")
        
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """Execute transition first if needed, then generate and execute trajectory."""
        if self.is_finished or not self.is_valid:
            return True
        
        # Execute transition first if needed
        if self.transition_command and not self.transition_complete:
            is_done = self.transition_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            if is_done:
                print(f"  -> Transition complete")
                self.transition_complete = True
            return False
        
        # Generate trajectory on first execution step (not during preparation!)
        if not self.trajectory_generated:
            # Get ACTUAL current position NOW
            actual_current_pose = self.get_current_pose_from_position(Position_in)
            print(f"  -> Generating {self.description} from ACTUAL position: {[round(p, 1) for p in actual_current_pose[:3]]}")
            
            # Generate trajectory from where we ACTUALLY are
            self.trajectory = self.generate_main_trajectory(actual_current_pose)
            self.trajectory_command = SmoothTrajectoryCommand(
                self.trajectory, self.description
            )
            
            # Quick validation of first point only
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(Position_in)])
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
            )
            
            if not ik_result.success:
                print(f"  -> ERROR: Cannot reach first trajectory point")
                self.is_finished = True
                self.error_state = True
                self.error_message = "Cannot reach trajectory start"
                Speed_out[:] = [0] * 6
                Command_out.value = 255
                return True
                
            self.trajectory_generated = True
            self.trajectory_prepared = True
            
            # Verify first point is close to current
            distance = np.linalg.norm(first_pose[:3] - np.array(actual_current_pose[:3]))
            if distance > 5.0:
                print(f"  -> WARNING: First trajectory point {distance:.1f}mm from current!")
        
        # Execute main trajectory
        if self.trajectory_command and self.trajectory_prepared:
            is_done = self.trajectory_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            # Check for errors in trajectory execution
            if hasattr(self.trajectory_command, 'error_state') and self.trajectory_command.error_state:
                self.error_state = True
                self.error_message = self.trajectory_command.error_message
            
            if is_done:
                self.is_finished = True
            
            return is_done
        else:
            self.is_finished = True
            return True

class SmoothTrajectoryCommand:
    """Command class for executing pre-generated smooth trajectories."""
    
    def __init__(self, trajectory, description="smooth motion"):
        self.trajectory = np.array(trajectory)
        self.description = description
        self.trajectory_index = 0
        self.is_valid = True
        self.is_finished = False
        self.first_step = True
        self.error_state = False
        self.error_message = ""
        
        print(f"Initializing smooth {description} with {len(trajectory)} points")
    
    def prepare_for_execution(self, current_position_in):
        """Skip validation - trajectory is already generated from correct position"""
        # No validation needed since trajectory was just generated from current position
        self.is_valid = True
        return
    
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, Position_out=None, **kwargs):
        """Execute one step of the smooth trajectory"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Get Position_out from kwargs if not provided
        if Position_out is None:
            Position_out = kwargs.get('Position_out', Position_in)
        
        if self.trajectory_index >= len(self.trajectory):
            print(f"Smooth {self.description} finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get target pose for this step
        target_pose = self.trajectory[self.trajectory_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                            for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
        )
        
        if not ik_result.success:
            print(f"  -> IK failed at trajectory point {self.trajectory_index}")
            self.is_finished = True
            self.error_state = True
            self.error_message = f"IK failed at point {self.trajectory_index}/{len(self.trajectory)}"
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                    for i, q in enumerate(ik_result.q)]
        
        # ADD VELOCITY LIMITING - This prevents violent movements
        if self.trajectory_index > 0:
            for i in range(6):
                step_diff = abs(target_steps[i] - Position_in[i])
                max_step_diff = PAROL6_ROBOT.Joint_max_speed[i] * 0.01  # Max steps in 10ms
                
                # Use 1.2x safety margin (not 2x as before)
                if step_diff > max_step_diff * 1.2:
                    #print(f"  -> WARNING: Joint {i+1} velocity limit exceeded at point {self.trajectory_index}")
                    #print(f"     Step difference: {step_diff}, Max allowed: {max_step_diff * 1.2:.1f}")
                    
                    # Clamp the motion
                    sign = 1 if target_steps[i] > Position_in[i] else -1
                    target_steps[i] = Position_in[i] + sign * int(max_step_diff)
        
        # Send position command
        Position_out[:] = target_steps
        Speed_out[:] = [0] * 6
        Command_out.value = 156
        
        # Advance to next point
        self.trajectory_index += 1
        
        return False

class SmoothCircleCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, plane, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"circle (r={radius}mm, {frame})")
        self.center = center
        self.radius = radius
        self.plane = plane
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame  # Store reference frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None  # Store for TRF transformation
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        # Store current position for potential use in generate_main_trajectory
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'center': self.center,
                'plane': self.plane
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_CIRCLE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Circle: center {self.center[:3]} (WRF), normal {self.normal_vector}")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_CIRCLE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        # Now do normal preparation with transformed parameters
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate circle starting from the actual start position."""
        motion_gen = CircularMotion()
        
        # Use transformed normal for TRF, or standard for WRF
        if self.normal_vector is not None:
            # TRF - use the transformed normal vector
            normal = np.array(self.normal_vector)
            print(f"    Using transformed normal: {normal.round(3)}")
        else:
            # WRF - use standard plane definition
            plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
            normal = np.array(plane_normals.get(self.plane, [0, 0, 1]))  # Convert to numpy array
            print(f"    Using WRF plane {self.plane} with normal: {normal}")
        
        print(f"    Generating circle from position: {[round(p, 1) for p in effective_start_pose[:3]]}")
        print(f"    Circle center: {[round(c, 1) for c in self.center]}")
        
        # Add geometry validation
        center_np = np.array(self.center)
        start_np = np.array(effective_start_pose[:3])
        
        # Project start point onto circle plane to check distance
        to_start = start_np - center_np
        to_start_plane = to_start - np.dot(to_start, normal) * normal
        distance_to_center = np.linalg.norm(to_start_plane)
        
        if abs(distance_to_center - self.radius) > self.radius * 0.3:
            print(f"    WARNING: Robot is {distance_to_center:.1f}mm from center, but radius is {self.radius:.1f}mm")
            print(f"    Circle geometry will be auto-corrected")
        
        # Generate circle that starts at effective_start_pose
        trajectory = motion_gen.generate_circle_3d(
            self.center, 
            self.radius, 
            normal,  # This normal now correctly represents the plane
            start_point=effective_start_pose[:3],
            duration=self.duration
        )
        
        if self.clockwise:
            trajectory = trajectory[::-1]
        
        # Update orientations to match start pose
        for i in range(len(trajectory)):
            trajectory[i][3:] = effective_start_pose[3:]
        
        return trajectory
    
class SmoothArcCenterCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, center, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"arc (center-based, {frame})")
        self.end_pose = end_pose
        self.center = center
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {
                'end_pose': self.end_pose,
                'center': self.center
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
            )
            self.end_pose = transformed['end_pose']
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc from actual start to end."""
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, self.center,
            normal=self.normal_vector,  # Use transformed normal if TRF
            clockwise=self.clockwise, duration=self.duration
        )
    
class SmoothArcParamCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, radius, arc_angle, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"parametric arc (r={radius}mm, Î¸={arc_angle}Â°, {frame})")
        self.end_pose = end_pose
        self.radius = radius
        self.arc_angle = arc_angle
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'end_pose': self.end_pose,
                'plane': 'XY'  # Default plane for parametric arc
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.end_pose = transformed['end_pose']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Parametric Arc: end {self.end_pose[:3]} (WRF)")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc based on radius and angle from actual start."""
        # Get start and end positions
        start_xyz = np.array(effective_start_pose[:3])
        end_xyz = np.array(self.end_pose[:3])
        
        # If we have a transformed normal (TRF), use it to define the arc plane
        if self.normal_vector is not None:
            normal = np.array(self.normal_vector)
            
            # Project start and end onto the plane perpendicular to normal
            # This ensures the arc stays in the correct plane for TRF
            
            # Find center of arc using radius and angle
            chord_vec = end_xyz - start_xyz
            chord_length = np.linalg.norm(chord_vec)
            
            if chord_length > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({chord_length:.1f}mm) for radius {self.radius}mm")
                self.radius = chord_length / 2 + 1
            
            # Calculate center position using the normal vector
            chord_mid = (start_xyz + end_xyz) / 2
            
            # Height from chord midpoint to arc center
            if chord_length > 0:
                h = np.sqrt(max(0, self.radius**2 - (chord_length/2)**2))
                
                # Find perpendicular in the plane defined by normal
                chord_dir = chord_vec / chord_length
                perp_in_plane = np.cross(normal, chord_dir)
                if np.linalg.norm(perp_in_plane) > 0.001:
                    perp_in_plane = perp_in_plane / np.linalg.norm(perp_in_plane)
                else:
                    # Chord is parallel to normal (shouldn't happen)
                    perp_in_plane = np.array([1, 0, 0])
                
                # Arc center
                if self.clockwise:
                    center_3d = chord_mid - h * perp_in_plane
                else:
                    center_3d = chord_mid + h * perp_in_plane
            else:
                center_3d = start_xyz
            
        else:
            # WRF - use XY plane (standard behavior)
            normal = np.array([0, 0, 1])
            
            # Calculate arc center in XY plane
            start_xy = start_xyz[:2]
            end_xy = end_xyz[:2]
            
            # Midpoint
            mid = (start_xy + end_xy) / 2
            
            # Distance between points
            d = np.linalg.norm(end_xy - start_xy)
            
            if d > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({d:.1f}mm) for radius {self.radius}mm")
                self.radius = d / 2 + 1
            
            # Height of arc center from midpoint
            h = np.sqrt(max(0, self.radius**2 - (d/2)**2))
            
            # Perpendicular direction
            if d > 0:
                perp = np.array([-(end_xy[1] - start_xy[1]), end_xy[0] - start_xy[0]])
                perp = perp / np.linalg.norm(perp)
            else:
                perp = np.array([1, 0])
            
            # Arc center (choose based on clockwise)
            if self.clockwise:
                center_2d = mid - h * perp
            else:
                center_2d = mid + h * perp
            
            # Use average Z for center
            center_3d = [center_2d[0], center_2d[1], (start_xyz[2] + end_xyz[2]) / 2]
        
        # Generate arc trajectory from actual start
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, center_3d.tolist(),
            normal=normal if self.normal_vector is not None else None,
            clockwise=self.clockwise, duration=self.duration
        )

class SmoothHelixCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, pitch, height, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"helix (h={height}mm, {frame})")
        self.center = center
        self.radius = radius
        self.pitch = pitch
        self.height = height
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.helix_axis = None
        self.up_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {'center': self.center}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_HELIX', params, 'TRF', current_position_in
            )
            self.center = transformed['center']
            self.helix_axis = transformed.get('helix_axis', [0, 0, 1])
            self.up_vector = transformed.get('up_vector', [0, 1, 0])
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_HELIX', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate helix with proper axis orientation."""
        num_revolutions = self.height / self.pitch if self.pitch > 0 else 1
        num_points = int(self.duration * 100)  # 100Hz
        
        # Get helix axis (default Z for WRF, transformed for TRF)
        if self.helix_axis is not None:
            axis = np.array(self.helix_axis)
        else:
            axis = np.array([0, 0, 1])  # Default vertical
        
        # Create orthonormal basis for helix
        if self.up_vector is not None:
            up = np.array(self.up_vector)
        else:
            # Find perpendicular to axis
            if abs(axis[2]) < 0.9:
                up = np.array([0, 0, 1])
            else:
                up = np.array([1, 0, 0])
        
        # Ensure up is perpendicular to axis
        up = up - np.dot(up, axis) * axis
        up = up / np.linalg.norm(up)
        
        # Create right vector
        right = np.cross(axis, up)
        
        # Calculate starting angle based on actual start position
        to_start = np.array(effective_start_pose[:3]) - np.array(self.center)
        # Project onto plane perpendicular to axis
        to_start_plane = to_start - np.dot(to_start, axis) * axis
        
        if np.linalg.norm(to_start_plane) > 0.001:
            to_start_normalized = to_start_plane / np.linalg.norm(to_start_plane)
            start_angle = np.arctan2(np.dot(to_start_normalized, up), 
                                    np.dot(to_start_normalized, right))
        else:
            start_angle = 0
        
        trajectory = []
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            
            angle = start_angle + 2 * np.pi * num_revolutions * t
            if self.clockwise:
                angle = start_angle - 2 * np.pi * num_revolutions * t
            
            # Position on helix
            pos = np.array(self.center) + \
                  self.radius * (np.cos(angle) * right + np.sin(angle) * up) + \
                  self.height * t * axis
            
            # Use orientation from effective start
            trajectory.append(np.concatenate([pos, effective_start_pose[3:]]))
        
        return np.array(trajectory)

class SmoothSplineCommand(BaseSmoothMotionCommand):
    def __init__(self, waypoints, duration, frame='WRF', start_pose=None):
        super().__init__(f"spline ({len(waypoints)} points, {frame})")
        self.waypoints = waypoints
        self.duration = duration
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform waypoints to WRF
            params = {'waypoints': self.waypoints}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_SPLINE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.waypoints = transformed['waypoints']
            
            print(f"  -> TRF Spline: transformed {len(self.waypoints)} waypoints to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_SPLINE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate spline starting from actual position."""
        motion_gen = SplineMotion()
        
        # Always start from the effective start pose
        first_wp_error = np.linalg.norm(
            np.array(self.waypoints[0][:3]) - np.array(effective_start_pose[:3])
        )
        
        if first_wp_error > 5.0:
            # First waypoint is far, prepend the start position
            modified_waypoints = [effective_start_pose] + self.waypoints
            print(f"    Added start position as first waypoint (distance: {first_wp_error:.1f}mm)")
        else:
            # Replace first waypoint with actual start to ensure continuity
            modified_waypoints = [effective_start_pose] + self.waypoints[1:]
            print(f"    Replaced first waypoint with actual start position")
        
        timestamps = np.linspace(0, self.duration, len(modified_waypoints))
        
        # Generate the spline trajectory
        trajectory = motion_gen.generate_cubic_spline(modified_waypoints, timestamps)
        
        print(f"    Generated spline with {len(trajectory)} points")
        
        return trajectory

class SmoothBlendCommand(BaseSmoothMotionCommand):
    def __init__(self, segment_definitions, blend_time, frame='WRF', start_pose=None):
        super().__init__(f"blended ({len(segment_definitions)} segments, {frame})")
        self.segment_definitions = segment_definitions
        self.blend_time = blend_time
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform all segment definitions to WRF
            params = {'segments': self.segment_definitions}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_BLEND', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.segment_definitions = transformed['segments']
            
            print(f"  -> TRF Blend: transformed {len(self.segment_definitions)} segments to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_BLEND', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate blended trajectory starting from actual position."""
        trajectories = []
        motion_gen_circle = CircularMotion()
        motion_gen_spline = SplineMotion()
        
        # Always start from effective start pose
        last_end_pose = effective_start_pose
        
        for i, seg_def in enumerate(self.segment_definitions):
            seg_type = seg_def['type']
            
            # First segment always starts from effective_start_pose
            segment_start = effective_start_pose if i == 0 else last_end_pose
            
            if seg_type == 'LINE':
                end = seg_def['end']
                duration = seg_def['duration']
                
                # Generate line segment from actual position
                num_points = int(duration * 100)
                timestamps = np.linspace(0, duration, num_points)
                
                traj = []
                for t in timestamps:
                    s = t / duration if duration > 0 else 1
                    # Interpolate position
                    pos = [
                        segment_start[j] * (1-s) + end[j] * s
                        for j in range(3)
                    ]
                    # Interpolate orientation
                    orient = [
                        segment_start[j+3] * (1-s) + end[j+3] * s
                        for j in range(3)
                    ]
                    traj.append(pos + orient)
                
                trajectories.append(np.array(traj))
                last_end_pose = end
                
            elif seg_type == 'ARC':
                end = seg_def['end']
                center = seg_def['center']
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Check if we have a transformed normal (from TRF)
                normal = seg_def.get('normal_vector', None)
                
                traj = motion_gen_circle.generate_arc_3d(
                    segment_start, end, center, 
                    normal=normal,  # Use transformed normal if available
                    clockwise=clockwise, duration=duration
                )
                trajectories.append(traj)
                last_end_pose = end
                
            elif seg_type == 'CIRCLE':
                center = seg_def['center']
                radius = seg_def['radius']
                plane = seg_def.get('plane', 'XY')
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Use transformed normal if available (from TRF)
                if 'normal_vector' in seg_def:
                    normal = seg_def['normal_vector']
                else:
                    plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
                    normal = plane_normals.get(plane, [0, 0, 1])
                
                traj = motion_gen_circle.generate_circle_3d(
                    center, radius, normal, 
                    start_point=segment_start[:3],
                    duration=duration
                )
                
                if clockwise:
                    traj = traj[::-1]
                    
                # Update orientations
                for j in range(len(traj)):
                    traj[j][3:] = segment_start[3:]
                    
                trajectories.append(traj)
                # Circle returns to start, so last pose is last point of trajectory
                last_end_pose = traj[-1].tolist()
                
            elif seg_type == 'SPLINE':
                waypoints = seg_def['waypoints']
                duration = seg_def['duration']
                
                # Check if first waypoint is close to segment start
                wp_error = np.linalg.norm(
                    np.array(waypoints[0][:3]) - np.array(segment_start[:3])
                )
                
                if wp_error > 5.0:
                    full_waypoints = [segment_start] + waypoints
                else:
                    full_waypoints = [segment_start] + waypoints[1:]
                
                timestamps = np.linspace(0, duration, len(full_waypoints))
                traj = motion_gen_spline.generate_cubic_spline(full_waypoints, timestamps)
                trajectories.append(traj)
                last_end_pose = waypoints[-1]
        
        # Blend all trajectories
        if len(trajectories) > 1:
            blender = MotionBlender(self.blend_time)
            blended = trajectories[0]
            blend_samples = int(self.blend_time * 100)
            
            for i in range(1, len(trajectories)):
                blended = blender.blend_trajectories(blended, trajectories[i], blend_samples)
            
            print(f"    Blended {len(trajectories)} segments into {len(blended)} points")
            return blended
        elif trajectories:
            return trajectories[0]
        else:
            raise ValueError("No trajectories generated in blend")
        
def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
    """
    Calculate duration based on trajectory length and speed percentage.
    
    Args:
        trajectory_length: Total path length in mm
        speed_percentage: Speed as percentage (1-100)
        
    Returns:
        Duration in seconds
    """
    # Map speed percentage to mm/s (adjustable based on robot capabilities)
    # For example: 100% = 100mm/s, 50% = 50mm/s
    speed_mm_s = np.interp(speed_percentage, [0, 100], 
                          [PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000,
                           PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000])
    
    if speed_mm_s > 0:
        return trajectory_length / speed_mm_s
    else:
        return 5.0  # Default fallback
    
def parse_smooth_motion_commands(parts):
    """
    Parse smooth motion commands received via UDP and create appropriate command objects.
    All commands support:
    - Reference frame selection (WRF or TRF)
    - Optional start position (CURRENT or specified pose)
    - Both DURATION and SPEED timing modes
    
    Args:
        parts: List of command parts split by '|'
        
    Returns:
        Command object or None if parsing fails
    """
    command_type = parts[0]
    
    # Helper function for parsing optional start pose
    def parse_start_pose(start_str):
        """Parse start pose - returns None for CURRENT, or list of floats for specified pose."""
        if start_str == 'CURRENT' or start_str == 'NONE':
            return None
        else:
            try:
                return list(map(float, start_str.split(',')))
            except:
                print(f"Warning: Invalid start pose format: {start_str}")
                return None
    
    # Helper function for calculating duration from speed
    def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
        """Calculate duration based on trajectory length and speed percentage."""
        # Map speed percentage to mm/s
        min_speed = PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000  # Convert to mm/s
        max_speed = PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000  # Convert to mm/s
        speed_mm_s = np.interp(speed_percentage, [0, 100], [min_speed, max_speed])
        
        if speed_mm_s > 0:
            return trajectory_length / speed_mm_s
        else:
            return 5.0  # Default fallback
    
    try:
        if command_type == 'SMOOTH_CIRCLE':
            # Format: SMOOTH_CIRCLE|center_x,center_y,center_z|radius|plane|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            plane = parts[3]
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Circle circumference
                path_length = 2 * np.pi * radius
                duration = calculate_duration_from_speed(path_length, timing_value)
            
            print(f"  -> Parsed circle: r={radius}mm, plane={plane}, frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command object with frame parameter
            return SmoothCircleCommand(center, radius, plane, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_CENTER':
            # Format: SMOOTH_ARC_CENTER|end_pose|center|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            center = list(map(float, parts[2].split(',')))
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[6])
            clockwise = parts[7] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Estimate arc length (will be more accurate when we have actual positions)
                # Use a conservative estimate based on radius
                radius_estimate = np.linalg.norm(np.array(center) - np.array(end_pose[:3]))
                estimated_arc_angle = np.pi / 2  # 90 degrees estimate
                arc_length = radius_estimate * estimated_arc_angle
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (center): frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command with frame
            return SmoothArcCenterCommand(end_pose, center, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_PARAM':
            # Format: SMOOTH_ARC_PARAM|end_pose|radius|angle|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            arc_angle = float(parts[3])
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Arc length = radius * angle (in radians)
                arc_length = radius * np.deg2rad(arc_angle)
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (param): r={radius}mm, Î¸={arc_angle}Â°, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothArcParamCommand(end_pose, radius, arc_angle, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_SPLINE':
            # Format: SMOOTH_SPLINE|num_waypoints|frame|start_pose|timing_type|timing_value|waypoint1|waypoint2|...
            num_waypoints = int(parts[1])
            frame = parts[2]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[3])
            timing_type = parts[4]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[5])
            
            # Parse waypoints
            waypoints = []
            idx = 6
            for i in range(num_waypoints):
                wp = []
                for j in range(6):  # Each waypoint has 6 values (x,y,z,rx,ry,rz)
                    wp.append(float(parts[idx]))
                    idx += 1
                waypoints.append(wp)
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate total path length
                total_dist = 0
                for i in range(1, len(waypoints)):
                    dist = np.linalg.norm(np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3]))
                    total_dist += dist
                
                duration = calculate_duration_from_speed(total_dist, timing_value)
            
            print(f"  -> Parsed spline: {num_waypoints} points, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothSplineCommand(waypoints, duration, frame, start_pose)
            
        elif command_type == 'SMOOTH_HELIX':
            # Format: SMOOTH_HELIX|center|radius|pitch|height|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            pitch = float(parts[3])
            height = float(parts[4])
            frame = parts[5]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[6])
            timing_type = parts[7]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[8])
            clockwise = parts[9] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate helix path length
                num_revolutions = height / pitch if pitch > 0 else 1
                horizontal_length = 2 * np.pi * radius * num_revolutions
                helix_length = np.sqrt(horizontal_length**2 + height**2)
                duration = calculate_duration_from_speed(helix_length, timing_value)
            
            print(f"  -> Parsed helix: h={height}mm, pitch={pitch}mm, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothHelixCommand(center, radius, pitch, height, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_BLEND':
            # Format: SMOOTH_BLEND|num_segments|blend_time|frame|start_pose|timing_type|timing_value|segment1||segment2||...
            num_segments = int(parts[1])
            blend_time = float(parts[2])
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DEFAULT', 'DURATION', or 'SPEED'
            
            # Parse overall timing
            if timing_type == 'DEFAULT':
                # Use individual segment durations as-is
                overall_duration = None
                overall_speed = None
                segments_start_idx = 6
            else:
                timing_value = float(parts[6])
                if timing_type == 'DURATION':
                    overall_duration = timing_value
                    overall_speed = None
                else:  # SPEED
                    overall_speed = timing_value
                    overall_duration = None
                segments_start_idx = 7
            
            # Parse segments (separated by ||)
            segments_data = '|'.join(parts[segments_start_idx:])
            segment_strs = segments_data.split('||')
            
            # Parse segment definitions
            segment_definitions = []
            total_original_duration = 0
            total_estimated_length = 0
            
            for seg_str in segment_strs:
                if not seg_str:  # Skip empty segments
                    continue
                    
                seg_parts = seg_str.split('|')
                seg_type = seg_parts[0]
                
                if seg_type == 'LINE':
                    # Format: LINE|end_x,end_y,end_z,end_rx,end_ry,end_rz|duration
                    end = list(map(float, seg_parts[1].split(',')))
                    segment_duration = float(seg_parts[2])
                    total_original_duration += segment_duration
                    
                    # Estimate length (will be refined when we have actual start)
                    estimated_length = 100  # mm, conservative estimate
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'LINE',
                        'end': end,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
                    
                elif seg_type == 'CIRCLE':
                    # Format: CIRCLE|center_x,center_y,center_z|radius|plane|duration|clockwise
                    center = list(map(float, seg_parts[1].split(',')))
                    radius = float(seg_parts[2])
                    plane = seg_parts[3]
                    segment_duration = float(seg_parts[4])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[5] == '1'
                    
                    # Circle circumference
                    estimated_length = 2 * np.pi * radius
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'CIRCLE',
                        'center': center,
                        'radius': radius,
                        'plane': plane,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'ARC':
                    # Format: ARC|end_x,end_y,end_z,end_rx,end_ry,end_rz|center_x,center_y,center_z|duration|clockwise
                    end = list(map(float, seg_parts[1].split(',')))
                    center = list(map(float, seg_parts[2].split(',')))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[4] == '1'
                    
                    # Estimate arc length
                    estimated_radius = 50  # mm
                    estimated_arc_angle = np.pi / 2  # 90 degrees
                    estimated_length = estimated_radius * estimated_arc_angle
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'ARC',
                        'end': end,
                        'center': center,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'SPLINE':
                    # Format: SPLINE|num_points|waypoint1;waypoint2;...|duration
                    num_points = int(seg_parts[1])
                    waypoints = []
                    wp_strs = seg_parts[2].split(';')
                    for wp_str in wp_strs:
                        waypoints.append(list(map(float, wp_str.split(','))))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    
                    # Estimate spline length
                    estimated_length = 0
                    for i in range(1, len(waypoints)):
                        estimated_length += np.linalg.norm(
                            np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3])
                        )
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'SPLINE',
                        'waypoints': waypoints,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
            
            # Adjust segment durations if overall timing is specified
            if overall_duration is not None:
                # Scale all segment durations proportionally
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Scaled blend segments to total duration: {overall_duration:.2f}s")
                        
            elif overall_speed is not None:
                # Calculate duration from speed and estimated path length
                overall_duration = calculate_duration_from_speed(total_estimated_length, overall_speed)
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Calculated blend duration from speed: {overall_duration:.2f}s")
            else:
                print(f"  -> Using original segment durations (total: {total_original_duration:.2f}s)")
            
            print(f"  -> Parsed blend: {num_segments} segments, frame={frame}, blend_time={blend_time}s")
            
            # Return command with frame
            return SmoothBlendCommand(segment_definitions, blend_time, frame, start_pose)
            
    except Exception as e:
        print(f"Error parsing smooth motion command: {e}")
        print(f"Command parts: {parts}")
        import traceback
        traceback.print_exc()
        return None
    
    print(f"Warning: Unknown smooth motion command type: {command_type}")
    return None

def transform_command_params_to_wrf(command_type: str, params: dict, frame: str, current_position_in) -> dict:
    """
    Transform command parameters from TRF to WRF.
    Handles position, orientation, and directional vectors correctly.
    """
    if frame == 'WRF':
        return params
    
    # Get current tool pose
    current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                         for i, p in enumerate(current_position_in)])
    tool_pose = PAROL6_ROBOT.robot.fkine(current_q)
    
    transformed = params.copy()
    
    # SMOOTH_CIRCLE - Transform center and plane normal
    if command_type == 'SMOOTH_CIRCLE':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'plane' in params:
            plane_normals_trf = {
                'XY': [0, 0, 1],   # Tool's Z-axis
                'XZ': [0, 1, 0],   # Tool's Y-axis  
                'YZ': [1, 0, 0]    # Tool's X-axis
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
            print(f"  -> TRF circle plane {params['plane']} transformed to WRF")
    
    # SMOOTH_ARC_CENTER - Transform center, end_pose, and implied plane
    elif command_type == 'SMOOTH_ARC_CENTER':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # Arc plane is determined by start, end, and center points
        # But we should transform any specified plane normal
        if 'plane' in params:
            # Similar to circle plane transformation
            plane_normals_trf = {
                'XY': [0, 0, 1],
                'XZ': [0, 1, 0],
                'YZ': [1, 0, 0]
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_ARC_PARAM - Transform end_pose and arc plane
    elif command_type == 'SMOOTH_ARC_PARAM':
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # For parametric arc, the plane is usually XY of the tool
        # Transform the assumed plane normal
        if 'plane' not in params:
            params['plane'] = 'XY'  # Default to XY plane
        
        plane_normals_trf = {
            'XY': [0, 0, 1],
            'XZ': [0, 1, 0],
            'YZ': [1, 0, 0]
        }
        normal_trf = np.array(plane_normals_trf[params.get('plane', 'XY')])
        normal_wrf = tool_pose.R @ normal_trf
        transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_HELIX - Transform center and helix axis
    elif command_type == 'SMOOTH_HELIX':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        # Helix axis - default is Z-axis (vertical in TRF)
        # In TRF, helix rises along tool's Z-axis
        helix_axis_trf = np.array([0, 0, 1])  # Tool's Z-axis
        helix_axis_wrf = tool_pose.R @ helix_axis_trf
        transformed['helix_axis'] = helix_axis_wrf.tolist()
        
        # Also need to transform the "up" direction for proper orientation
        up_vector_trf = np.array([0, 1, 0])  # Tool's Y-axis
        up_vector_wrf = tool_pose.R @ up_vector_trf
        transformed['up_vector'] = up_vector_wrf.tolist()
    
    # SMOOTH_SPLINE - Transform all waypoints
    elif command_type == 'SMOOTH_SPLINE':
        if 'waypoints' in params:
            transformed_waypoints = []
            for wp in params['waypoints']:
                wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                         SE3.RPY(wp[3:], unit='deg', order='xyz')
                wp_wrf = tool_pose * wp_trf
                wp_transformed = np.concatenate([
                    wp_wrf.t * 1000,
                    wp_wrf.rpy(unit='deg', order='xyz')
                ]).tolist()
                transformed_waypoints.append(wp_transformed)
            transformed['waypoints'] = transformed_waypoints
    
    # SMOOTH_BLEND - Transform all segments recursively
    elif command_type == 'SMOOTH_BLEND':
        if 'segments' in params:
            transformed_segments = []
            for seg in params['segments']:
                seg_copy = seg.copy()
                seg_type = seg['type']
                
                if seg_type == 'LINE':
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'CIRCLE':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'plane' in seg:
                        plane_normals_trf = {
                            'XY': [0, 0, 1],
                            'XZ': [0, 1, 0],
                            'YZ': [1, 0, 0]
                        }
                        normal_trf = np.array(plane_normals_trf[seg['plane']])
                        normal_wrf = tool_pose.R @ normal_trf
                        seg_copy['normal_vector'] = normal_wrf.tolist()
                
                elif seg_type == 'ARC':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'SPLINE':
                    if 'waypoints' in seg:
                        transformed_waypoints = []
                        for wp in seg['waypoints']:
                            wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                                     SE3.RPY(wp[3:], unit='deg', order='xyz')
                            wp_wrf = tool_pose * wp_trf
                            wp_transformed = np.concatenate([
                                wp_wrf.t * 1000,
                                wp_wrf.rpy(unit='deg', order='xyz')
                            ]).tolist()
                            transformed_waypoints.append(wp_transformed)
                        seg_copy['waypoints'] = transformed_waypoints
                
                transformed_segments.append(seg_copy)
            transformed['segments'] = transformed_segments
    
    # Transform start_pose if specified (common to all commands)
    if 'start_pose' in params and params['start_pose'] is not None:
        start_trf = SE3(params['start_pose'][0]/1000, 
                       params['start_pose'][1]/1000, 
                       params['start_pose'][2]/1000) * \
                    SE3.RPY(params['start_pose'][3:], unit='deg', order='xyz')
        start_wrf = tool_pose * start_trf
        transformed['start_pose'] = np.concatenate([
            start_wrf.t * 1000,
            start_wrf.rpy(unit='deg', order='xyz')
        ]).tolist()
    
    return transformed

#########################################################################
# Smooth Motion Commands and Robot Commands End Here
#########################################################################

# Acknowledgment system configuration
CLIENT_ACK_PORT = 5002  # Port where clients listen for acknowledgments
ack_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Command tracking
active_command_id = None
command_id_map = {}  # Maps command objects to their IDs

def send_acknowledgment(cmd_id: str, status: str, details: str = "", addr=None):
    """Send acknowledgment back to client"""
    if not cmd_id:
        return
        
    ack_message = f"ACK|{cmd_id}|{status}|{details}"
    
    # Send to the original sender if we have their address
    if addr:
        try:
            ack_socket.sendto(ack_message.encode('utf-8'), (addr[0], CLIENT_ACK_PORT))
        except Exception as e:
            print(f"Failed to send ack to {addr}: {e}")
    
    # Also broadcast to localhost in case the client is local
    try:
        ack_socket.sendto(ack_message.encode('utf-8'), ('127.0.0.1', CLIENT_ACK_PORT))
    except:
        pass

def parse_command_with_id(message: str) -> Tuple[Optional[str], str]:
    """
    Parse command ID if present.
    Format: [cmd_id|]COMMAND|params...
    Returns: (cmd_id or None, command_string)
    """
    # Clean up any logging artifacts
    if "ID:" in message or "):" in message:
        # Extract the actual command after these artifacts
        if "):" in message:
            message = message[message.rindex("):")+2:].strip()
        elif "ID:" in message:
            message = message[message.index("ID:")+3:].strip()
            # Remove any trailing parentheses or colons
            message = message.lstrip('):').strip()
    
    parts = message.split('|', 1)
    
    # Check if first part looks like a valid command ID (8 chars, alphanumeric)
    # IMPORTANT: Command IDs from uuid.uuid4()[:8] will contain lowercase letters/numbers
    # Actual commands are all uppercase, so exclude all-uppercase strings
    if (len(parts) > 1 and 
        len(parts[0]) == 8 and 
        parts[0].replace('-', '').isalnum() and 
        not parts[0].isupper()):  # This prevents "MOVEPOSE" from being treated as an ID
        return parts[0], parts[1]
    else:
        return None, message


# Create a new, empty command queue
command_queue = deque()

# --------------------------------------------------------------------------
# --- Test 1: Homing and Initial Setup
# --------------------------------------------------------------------------

# 1. Start with the mandatory Home command.
command_queue.append(HomeCommand())

# --- State variable for the currently running command ---
active_command = None
e_stop_active = False

# Use deque for an efficient FIFO queue
incoming_command_buffer = deque()
# Timestamp of the last processed network command
last_command_time = 0
# Cooldown period in seconds to prevent command flooding
COMMAND_COOLDOWN_S = 0.1 # 100ms

# Set interval
timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)

# ============================================================================
# MODIFIED MAIN LOOP WITH ACKNOWLEDGMENTS
# ============================================================================

timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)
prev_time = 0

while timer.elapsed_time < 1100000:
    
    # --- Connection Handling ---
    if ser is None or not ser.is_open:
        print("Serial port not open. Attempting to reconnect...")
        try:
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            if ser.is_open:
                print(f"Successfully reconnected to {com_port_str}")
        except serial.SerialException as e:
            ser = None
            time.sleep(1) 
        continue

    # =======================================================================
    # === NETWORK COMMAND RECEPTION WITH ID PARSING ===
    # =======================================================================
    try:
        while sock in select.select([sock], [], [], 0)[0]:
            data, addr = sock.recvfrom(1024)
            raw_message = data.decode('utf-8').strip()
            if raw_message:
                # Parse command ID if present
                cmd_id, message = parse_command_with_id(raw_message)
                
                parts = message.split('|')
                command_name = parts[0].upper()

                # Handle immediate response commands
                if command_name == 'STOP':
                    print("Received STOP command. Halting all motion and clearing queue.")
                    
                    # Cancel active command
                    if active_command and active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "Stopped by user", addr)
                    active_command = None
                    active_command_id = None
                    
                    # Clear queue and notify about cancelled commands
                    for queued_cmd in command_id_map.keys():
                        if queued_cmd != active_command:
                            if queued_cmd in command_id_map:
                                send_acknowledgment(command_id_map[queued_cmd], 
                                                  "CANCELLED", "Queue cleared by STOP", addr)
                    
                    command_queue.clear()
                    command_id_map.clear()
                    
                    # Stop robot
                    Command_out.value = 255
                    Speed_out[:] = [0] * 6
                    
                    # Send acknowledgment for STOP command itself
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Emergency stop executed", addr)

                elif command_name == 'GET_POSE':
                    q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
                    current_pose_matrix = PAROL6_ROBOT.robot.fkine(q_current).A
                    pose_flat = current_pose_matrix.flatten()
                    pose_str = ",".join(map(str, pose_flat))
                    response_message = f"POSE|{pose_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Pose data sent", addr)

                elif command_name == 'GET_ANGLES':
                    angles_rad = [PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)]
                    angles_deg = np.rad2deg(angles_rad)
                    angles_str = ",".join(map(str, angles_deg))
                    response_message = f"ANGLES|{angles_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Angles data sent", addr)

                elif command_name == 'GET_IO':
                    io_status_str = ",".join(map(str, InOut_in[:5]))
                    response_message = f"IO|{io_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "IO data sent", addr)

                elif command_name == 'GET_GRIPPER':
                    gripper_status_str = ",".join(map(str, Gripper_data_in))
                    response_message = f"GRIPPER|{gripper_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Gripper data sent", addr)

                elif command_name == 'GET_SPEEDS':
                    speeds_str = ",".join(map(str, Speed_in))
                    response_message = f"SPEEDS|{speeds_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Speed data sent", addr)

                else:
                    # Queue command for processing
                    incoming_command_buffer.append((raw_message, addr))

    except Exception as e:
        print(f"Network receive error: {e}")

    # =======================================================================
    # === PROCESS COMMANDS FROM BUFFER WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    current_time = time.time()
    if incoming_command_buffer and (current_time - last_command_time) > COMMAND_COOLDOWN_S and not e_stop_active:
        raw_message, addr = incoming_command_buffer.popleft()
        last_command_time = current_time
        
        # Parse command ID
        cmd_id, message = parse_command_with_id(raw_message)
        print(f"Processing command{' (ID: ' + cmd_id + ')' if cmd_id else ''}: {message[:50]}...")
        
        parts = message.split('|')
        command_name = parts[0].upper()
        
        # Variable to track if command was successfully queued
        command_queued = False
        command_obj = None
        error_details = ""

        # Parse and create command objects
        try:
            if command_name == 'MOVEPOSE' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MovePoseCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
                
            elif command_name == 'MOVEJOINT' and len(parts) == 9:
                joint_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveJointCommand(target_angles=joint_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name in ['SMOOTH_CIRCLE', 'SMOOTH_ARC_CENTER', 'SMOOTH_ARC_PARAM', 
                                 'SMOOTH_SPLINE', 'SMOOTH_HELIX', 'SMOOTH_BLEND']:
                command_obj = parse_smooth_motion_commands(parts)
                if command_obj:
                    command_queued = True
                else:
                    error_details = "Failed to parse smooth motion parameters"
            
            elif command_name == 'MOVECART' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveCartCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name == 'DELAY' and len(parts) == 2:
                duration = float(parts[1])
                command_obj = DelayCommand(duration=duration)
                command_queued = True
            
            elif command_name == 'HOME':
                command_obj = HomeCommand()
                command_queued = True
                
            elif command_name == 'CARTJOG' and len(parts) == 5:
                frame, axis, speed, duration = parts[1].upper(), parts[2], float(parts[3]), float(parts[4])
                command_obj = CartesianJogCommand(frame=frame, axis=axis, speed_percentage=speed, duration=duration)
                command_queued = True
                
            elif command_name == 'JOG' and len(parts) == 5:
                joint_idx, speed = int(parts[1]), float(parts[2])
                duration = None if parts[3].upper() == 'NONE' else float(parts[3])
                distance = None if parts[4].upper() == 'NONE' else float(parts[4])
                command_obj = JogCommand(joint=joint_idx, speed_percentage=speed, duration=duration, distance_deg=distance)
                command_queued = True
            
            elif command_name == 'MULTIJOG' and len(parts) == 4:
                joint_indices = [int(j) for j in parts[1].split(',')]
                speeds = [float(s) for s in parts[2].split(',')]
                duration = float(parts[3])
                command_obj = MultiJogCommand(joints=joint_indices, speed_percentages=speeds, duration=duration)
                command_queued = True
                
            elif command_name == 'PNEUMATICGRIPPER' and len(parts) == 3:
                action, port = parts[1].lower(), int(parts[2])
                command_obj = GripperCommand(gripper_type='pneumatic', action=action, output_port=port)
                command_queued = True
                
            elif command_name == 'ELECTRICGRIPPER' and len(parts) == 5:
                action = None if parts[1].upper() == 'NONE' or parts[1].upper() == 'MOVE' else parts[1].lower()
                pos, spd, curr = int(parts[2]), int(parts[3]), int(parts[4])
                command_obj = GripperCommand(gripper_type='electric', action=action, position=pos, speed=spd, current=curr)
                command_queued = True
            
            else:
                error_details = f"Unknown or malformed command: {command_name}"
                
        except Exception as e:
            error_details = f"Error parsing command: {str(e)}"
            command_queued = False
        
        # Handle command queueing and acknowledgments
        if command_queued and command_obj:
            # Check if command is initially valid
            if hasattr(command_obj, 'is_valid') and not command_obj.is_valid:
                if cmd_id:
                    send_acknowledgment(cmd_id, "INVALID", 
                                       "Command failed validation", addr)
            else:
                # Add to queue
                command_queue.append(command_obj)
                if cmd_id:
                    command_id_map[command_obj] = (cmd_id, addr)
                    send_acknowledgment(cmd_id, "QUEUED", 
                                       f"Position {len(command_queue)} in queue", addr)
        else:
            # Command was not queued
            if cmd_id:
                send_acknowledgment(cmd_id, "INVALID", error_details, addr)
            print(f"Warning: {error_details}")

    # =======================================================================
    # === MAIN EXECUTION LOGIC WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    try:
        # --- E-Stop Handling ---
        if InOut_in[4] == 0:  # E-Stop pressed
            if not e_stop_active:
                cancelled_command_info = "None"
                if active_command is not None:
                    cancelled_command_info = type(active_command).__name__
                    if active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "E-Stop activated")
                
                # Cancel all queued commands
                for cmd_obj in command_queue:
                    if cmd_obj in command_id_map:
                        cmd_id, addr = command_id_map[cmd_obj]
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated", addr)
                
                # Cancel all buffered but unprocessed commands
                for raw_message, addr in incoming_command_buffer:
                    cmd_id, _ = parse_command_with_id(raw_message)
                    if cmd_id:
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated - command not processed", addr)
                
                print(f"E-STOP TRIGGERED! Active command '{cancelled_command_info}' cancelled.")
                print("Release E-Stop and press 'e' to re-enable.")
                e_stop_active = True
            
            Command_out.value = 102
            Speed_out[:] = [0] * 6
            Gripper_data_out[3] = 0
            active_command = None
            active_command_id = None
            command_queue.clear()
            command_id_map.clear()
            incoming_command_buffer.clear()
            
        elif e_stop_active:
            # Waiting for re-enable
            if keyboard.is_pressed('e'):
                print("Re-enabling robot...")
                Command_out.value = 101
                e_stop_active = False
            else:
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]
                
        else:
            # --- Normal Command Processing ---
            
            # Start new command if none active
            if active_command is None and command_queue:
                new_command = command_queue.popleft()
                
                # Get command ID and address if tracked
                cmd_info = command_id_map.get(new_command, (None, None))
                new_cmd_id, new_addr = cmd_info
                
                # Initial validation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Command was invalid from the start
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "INVALID", 
                                        "Initial validation failed", new_addr)
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                    continue  # Skip to next command
                
                # Prepare command
                if hasattr(new_command, 'prepare_for_execution'):
                    try:
                        new_command.prepare_for_execution(current_position_in=Position_in)
                    except Exception as e:
                        print(f"Command preparation failed: {e}")
                        if hasattr(new_command, 'is_valid'):
                            new_command.is_valid = False
                        if hasattr(new_command, 'error_message'):
                            new_command.error_message = str(e)
                
                # Check if still valid after preparation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Failed during preparation
                    error_msg = "Failed during preparation"
                    if hasattr(new_command, 'error_message'):
                        error_msg = new_command.error_message
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "FAILED", error_msg, new_addr)
                    
                    # Clean up
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                else:
                    # Command is valid, make it active
                    active_command = new_command
                    active_command_id = new_cmd_id
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "EXECUTING", 
                                        f"Starting {type(new_command).__name__}", new_addr)
            
            # Execute active command
            if active_command:
                try:
                    is_done = active_command.execute_step(
                        Position_in=Position_in,
                        Homed_in=Homed_in,
                        Speed_out=Speed_out,
                        Command_out=Command_out,
                        Gripper_data_out=Gripper_data_out,
                        InOut_out=InOut_out,
                        InOut_in=InOut_in,
                        Gripper_data_in=Gripper_data_in,
                        Position_out=Position_out  # Add this if needed
                    )
                    
                    if is_done:
                        # Command completed
                        if active_command_id:
                            # Check for error state in smooth motion commands
                            if hasattr(active_command, 'error_state') and active_command.error_state:
                                error_msg = getattr(active_command, 'error_message', 'Command failed during execution')
                                send_acknowledgment(active_command_id, "FAILED", error_msg)
                            else:
                                send_acknowledgment(active_command_id, "COMPLETED", 
                                                f"{type(active_command).__name__} finished successfully")
                        
                        # Clean up
                        if active_command in command_id_map:
                            del command_id_map[active_command]
                        
                        active_command = None
                        active_command_id = None
                        
                except Exception as e:
                    # Command execution error
                    print(f"Command execution error: {e}")
                    if active_command_id:
                        send_acknowledgment(active_command_id, "FAILED", 
                                          f"Execution error: {str(e)}")
                    
                    # Clean up
                    if active_command in command_id_map:
                        del command_id_map[active_command]
                    
                    active_command = None
                    active_command_id = None
                    
            else:
                # No active command - idle
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]

        # --- Communication with Robot ---
        s = Pack_data(Position_out, Speed_out, Command_out.value, 
                     Affected_joint_out, InOut_out, Timeout_out, Gripper_data_out)
        for chunk in s:
            ser.write(chunk)
            
        Get_data(Position_in, Speed_in, Homed_in, InOut_in, Temperature_error_in, 
                Position_error_in, Timeout_error, Timing_data_in, XTR_data, Gripper_data_in)

    except serial.SerialException as e:
        print(f"Serial communication error: {e}")
        
        # Send failure acknowledgments for active command
        if active_command_id:
            send_acknowledgment(active_command_id, "FAILED", "Serial communication lost")
        
        if ser:
            ser.close()
        ser = None
        active_command = None
        active_command_id = None

    timer.checkpt()
````

## File: safe_home_client.py
````python
# safe_home_client.py
import time
from robot_api import (
    connect, disconnect, is_connected,
    stop_robot, clear_queue, home_robot, get_state
)

def main():
    # 1) è¿æ¥ï¼ˆå¦‚æœ robot_api éœ€è¦ IP/ç«¯å£ï¼Œæ›¿æ¢ connect(host, port) ç‰ˆæœ¬ï¼‰
    connect()
    assert is_connected(), "è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ headless_commander æ˜¯å¦åœ¨è¿è¡Œ"

    # 2) å®‰å…¨ï¼šåœæ­¢å¹¶æ¸…é˜Ÿåˆ—
    try:
        stop_robot()    # æŸäº›å®ç°æ˜¯è½¯åœï¼›è‹¥æ— è¯¥å‡½æ•°å¯å¿½ç•¥
    except Exception:
        pass
    try:
        clear_queue()
    except Exception:
        pass

    # 3) è¯»å–å½“å‰çŠ¶æ€å¹¶æ‰“å°ï¼ˆç¡®è®¤æœªåœ¨è¿åŠ¨ï¼‰
    try:
        s = get_state()
        print("å½“å‰çŠ¶æ€ï¼š", s)
    except Exception as e:
        print("è¯»å–çŠ¶æ€å¤±è´¥ï¼Œä¸å½±å“ Homeï¼š", e)

    # 4) ä½é€Ÿ Homeï¼ˆå…³é”®ï¼ï¼‰
    print("å¼€å§‹ä½é€Ÿ Home ...")
    home_robot(speed_percentage=10, wait_for_ack=True, timeout=120)

    # 5) ç­‰å¾…ç¨³å®š
    time.sleep(1.0)
    print("Home æŒ‡ä»¤å®Œæˆã€‚å†æ¬¡è¯»å–çŠ¶æ€ï¼š")
    try:
        s2 = get_state()
        print("çŠ¶æ€ï¼š", s2)
    except Exception:
        pass

    # 6) æ–­å¼€
    disconnect()
    print("å®Œæˆ")

if __name__ == "__main__":
    main()
````

## File: smooth_motion.py
````python
"""
Smooth Motion Module for PAROL6 Robotic Arm
============================================
This module provides advanced trajectory generation capabilities including:
- Circular and arc movements
- Cubic spline trajectories
- Motion blending
- Pre-computed and real-time trajectory generation

Compatible with:
- numpy==1.23.4
- scipy==1.11.4
- roboticstoolbox-python==1.0.3
"""

import sys
import warnings
from collections import namedtuple
from roboticstoolbox import DHRobot
from spatialmath.base import trinterp

# Version compatibility check
try:
    import numpy as np
    # Check numpy version
    np_version = tuple(map(int, np.__version__.split('.')[:2]))
    if np_version < (1, 23):
        warnings.warn(f"NumPy version {np.__version__} detected. Recommended: 1.23.4")
    
    from scipy.interpolate import CubicSpline
    from scipy.spatial.transform import Rotation, Slerp
    import scipy
    # Check scipy version
    scipy_version = tuple(map(int, scipy.__version__.split('.')[:2]))
    if scipy_version < (1, 11):
        warnings.warn(f"SciPy version {scipy.__version__} detected. Recommended: 1.11.4")
        
except ImportError as e:
    print(f"Error importing required packages: {e}")
    print("Please install: pip3 install numpy==1.23.4 scipy==1.11.4")
    sys.exit(1)

from spatialmath import SE3
import time
from typing import List, Tuple, Optional, Dict, Union
from collections import deque

# Import PAROL6 specific modules (these should be in your path)
try:
    import GUI.files.PAROL6_ROBOT
except ImportError:
    print("Warning: PAROL6 modules not found. Some functions may not work.")
    PAROL6_ROBOT = None

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

# IK Result structure
IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179Â° and 181Â° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90Â°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities.
    If necessary, recursively subdivide the motion until ikine_LM converges
    on every segment. Finally check that solution respects joint limits.
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # â”€â”€ inner recursive solverâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            if current_reach >= max_reach_threshold:
                print(f"Reach limit exceeded: {current_reach:.3f} >= {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LM(Tb, q0=q_seed, ilimit=ilimit, tol=tol)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # â”€â”€ kick-off with adaptive tolerance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    
    # Check if solution respects joint limits
    if PAROL6_ROBOT is not None:
        target_q = path[-1] if len(path) != 0 else None
        solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
        if ok and solution_valid:
            return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, violations)
    else:
        # If PAROL6_ROBOT not available, skip joint limit checking
        if ok and len(path) > 0:
            return IKResult(True, path[-1], its, resid, adaptive_tol, None)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, None)

# ============================================================================
# END OF IK SOLVER FUNCTIONS
# ============================================================================

class TrajectoryGenerator:
    """Base class for trajectory generation with caching support"""
    
    def __init__(self, control_rate: float = 100.0):
        """
        Initialize trajectory generator
        
        Args:
            control_rate: Control loop frequency in Hz (default 100Hz for PAROL6)
        """
        self.control_rate = control_rate
        self.dt = 1.0 / control_rate
        self.trajectory_cache = {}
        
    def generate_timestamps(self, duration: float) -> np.ndarray:
        """Generate evenly spaced timestamps for trajectory"""
        num_points = int(duration * self.control_rate)
        return np.linspace(0, duration, num_points)

class CircularMotion(TrajectoryGenerator):
    """Generate circular and arc trajectories in 3D space"""
    
    def generate_arc_3d(self, 
                       start_pose: List[float], 
                       end_pose: List[float], 
                       center: List[float], 
                       normal: Optional[List[float]] = None,
                       clockwise: bool = True,
                       duration: float = 2.0) -> np.ndarray:
        """
        Generate a 3D circular arc trajectory
        
        Args:
            start_pose: Starting pose [x, y, z, rx, ry, rz] (mm and degrees)
            end_pose: Ending pose [x, y, z, rx, ry, rz] (mm and degrees)
            center: Center point of arc [x, y, z] (mm)
            normal: Normal vector to arc plane (default: z-axis)
            clockwise: Direction of rotation
            duration: Time to complete arc (seconds)
            
        Returns:
            Array of poses along the arc trajectory
        """
        # Convert to numpy arrays
        start_pos = np.array(start_pose[:3])
        end_pos = np.array(end_pose[:3])
        center_pt = np.array(center)
        
        # Calculate radius vectors
        r1 = start_pos - center_pt
        r2 = end_pos - center_pt
        radius = np.linalg.norm(r1)
        
        # Determine arc plane normal if not provided
        if normal is None:
            normal = np.cross(r1, r2)
            if np.linalg.norm(normal) < 1e-6:  # Points are collinear
                normal = np.array([0, 0, 1])  # Default to XY plane
        normal = normal / np.linalg.norm(normal)
        
        # Calculate arc angle
        r1_norm = r1 / np.linalg.norm(r1)
        r2_norm = r2 / np.linalg.norm(r2)
        cos_angle = np.clip(np.dot(r1_norm, r2_norm), -1, 1)
        arc_angle = np.arccos(cos_angle)
        
        # Check direction using cross product
        cross = np.cross(r1_norm, r2_norm)
        if np.dot(cross, normal) < 0:
            arc_angle = 2 * np.pi - arc_angle
            
        if clockwise:
            arc_angle = -arc_angle
            
        # Generate trajectory points
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        for i, t in enumerate(timestamps):
            # Interpolation factor
            s = t / duration
            
            # For first point, use exact start position
            if i == 0:
                current_pos = start_pos
            else:
                # Rotate radius vector
                angle = s * arc_angle
                rot_matrix = self._rotation_matrix_from_axis_angle(normal, angle)
                current_pos = center_pt + rot_matrix @ r1
            
            # Interpolate orientation (SLERP)
            current_orient = self._slerp_orientation(start_pose[3:], end_pose[3:], s)
            
            # Combine position and orientation
            pose = np.concatenate([current_pos, current_orient])
            trajectory.append(pose)
            
        return np.array(trajectory)
    
    def generate_circle_3d(self,
                      center: List[float],
                      radius: float,
                      normal: List[float] = [0, 0, 1],
                      start_angle: float = None,
                      duration: float = 4.0,
                      start_point: List[float] = None) -> np.ndarray:
        """
        Generate a complete circle trajectory that starts at start_point
        """
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        # Create orthonormal basis for circle plane
        normal = np.array(normal) / np.linalg.norm(normal)
        u = self._get_perpendicular_vector(normal)
        v = np.cross(normal, u)
        
        center_np = np.array(center)
        
        # CRITICAL FIX: Validate and handle geometry
        if start_point is not None:
            start_pos = np.array(start_point[:3])
            
            # Project start point onto the circle plane
            to_start = start_pos - center_np
            to_start_plane = to_start - np.dot(to_start, normal) * normal
            
            # Get distance from center in the plane
            dist_in_plane = np.linalg.norm(to_start_plane)
            
            if dist_in_plane < 0.001:
                # Start point is at center - can't determine angle
                print(f"    WARNING: Start point is at circle center, using default position")
                start_angle = 0
                actual_start = center_np + radius * u
            else:
                # Calculate the angle of the start point
                to_start_normalized = to_start_plane / dist_in_plane
                u_comp = np.dot(to_start_normalized, u)
                v_comp = np.dot(to_start_normalized, v)
                start_angle = np.arctan2(v_comp, u_comp)
                
                # CHECK FOR INVALID GEOMETRY
                radius_error = abs(dist_in_plane - radius)
                if radius_error > radius * 0.3:  # More than 30% off
                    print(f"    WARNING: Start point is {dist_in_plane:.1f}mm from center,")
                    print(f"             but circle radius is {radius:.1f}mm!")
                    
                    # AUTO-CORRECT: Adjust center to make geometry valid
                    print(f"    AUTO-CORRECTING: Moving center to maintain {radius}mm radius from start")
                    direction = to_start_plane / dist_in_plane
                    center_np = start_pos - direction * radius
                    print(f"    New center: {center_np.round(1)}")
                    
                    # Recalculate with new center
                    to_start = start_pos - center_np
                    to_start_plane = to_start - np.dot(to_start, normal) * normal
                    dist_in_plane = np.linalg.norm(to_start_plane)
                
                actual_start = start_pos
        else:
            start_angle = 0 if start_angle is None else start_angle
            actual_start = None
        
        # Generate the circle 
        for i, t in enumerate(timestamps):
            if i == 0 and actual_start is not None:
                # First point MUST be exactly the start point
                pos = actual_start
            else:
                # Generate circle points
                angle = start_angle + (2 * np.pi * t / duration)
                pos = center_np + radius * (np.cos(angle) * u + np.sin(angle) * v)
            
            # Placeholder orientation (will be overridden)
            orient = [0, 0, 0]
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def _rotation_matrix_from_axis_angle(self, axis: np.ndarray, angle: float) -> np.ndarray:
        """Generate rotation matrix using Rodrigues' formula"""
        axis = axis / np.linalg.norm(axis)
        cos_a = np.cos(angle)
        sin_a = np.sin(angle)
        
        # Cross-product matrix
        K = np.array([[0, -axis[2], axis[1]],
                     [axis[2], 0, -axis[0]],
                     [-axis[1], axis[0], 0]])
        
        # Rodrigues' formula
        R = np.eye(3) + sin_a * K + (1 - cos_a) * K @ K
        return R
    
    def _get_perpendicular_vector(self, v: np.ndarray) -> np.ndarray:
        """Find a vector perpendicular to the given vector"""
        v = np.array(v)  # Ensure it's a numpy array
        if abs(v[0]) < 0.9:
            return np.cross(v, [1, 0, 0]) / np.linalg.norm(np.cross(v, [1, 0, 0]))
        else:
            return np.cross(v, [0, 1, 0]) / np.linalg.norm(np.cross(v, [0, 1, 0]))
    
    def _slerp_orientation(self, start_orient: List[float], 
                          end_orient: List[float], 
                          t: float) -> np.ndarray:
        """Spherical linear interpolation for orientation"""
        # Convert to quaternions
        r1 = Rotation.from_euler('xyz', start_orient, degrees=True)
        r2 = Rotation.from_euler('xyz', end_orient, degrees=True)
        
        # Create slerp object - compatible with scipy 1.11.4
        # Stack rotations into a single Rotation object
        key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
        slerp = Slerp([0, 1], key_rots)
        
        # Interpolate
        interp_rot = slerp(t)
        return interp_rot.as_euler('xyz', degrees=True)

class SplineMotion(TrajectoryGenerator):
    """Generate smooth spline trajectories through waypoints"""
    
    def generate_cubic_spline(self,
                             waypoints: List[List[float]],
                             timestamps: Optional[List[float]] = None,
                             velocity_start: Optional[List[float]] = None,
                             velocity_end: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate cubic spline trajectory through waypoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint (auto-generated if None)
            velocity_start: Initial velocity (zero if None)
            velocity_end: Final velocity (zero if None)
            
        Returns:
            Array of interpolated poses
        """
        waypoints = np.array(waypoints)
        num_waypoints = len(waypoints)
        
        # Auto-generate timestamps if not provided
        if timestamps is None:
            # Estimate based on distance
            total_dist = 0
            for i in range(1, num_waypoints):
                dist = np.linalg.norm(waypoints[i, :3] - waypoints[i-1, :3])
                total_dist += dist
            
            # Assume average speed of 50 mm/s
            total_time = total_dist / 50.0
            timestamps = np.linspace(0, total_time, num_waypoints)
        
        # Create splines for position
        pos_splines = []
        for i in range(3):
            bc_type = 'not-a-knot'  # Default boundary condition
            
            # Apply velocity boundary conditions if specified
            if velocity_start is not None and velocity_end is not None:
                bc_type = ((1, velocity_start[i]), (1, velocity_end[i]))
            
            spline = CubicSpline(timestamps, waypoints[:, i], bc_type=bc_type)
            pos_splines.append(spline)
        
        # Create splines for orientation (convert to quaternions for smooth interpolation)
        rotations = [Rotation.from_euler('xyz', wp[3:], degrees=True) for wp in waypoints]
        # Stack quaternions for scipy 1.11.4 compatibility
        quats = np.array([r.as_quat() for r in rotations])
        key_rots = Rotation.from_quat(quats)
        slerp = Slerp(timestamps, key_rots)
        
        # Generate dense trajectory
        t_eval = self.generate_timestamps(timestamps[-1])
        trajectory = []
        
        for t in t_eval:
            # Evaluate position splines
            pos = [spline(t) for spline in pos_splines]
            
            # Evaluate orientation
            rot = slerp(t)
            orient = rot.as_euler('xyz', degrees=True)
            
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def generate_quintic_spline(self,
                               waypoints: List[List[float]],
                               timestamps: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate quintic (5th order) spline with zero velocity and acceleration at endpoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint
            
        Returns:
            Array of interpolated poses
        """
        # For quintic spline, we need to ensure zero velocity and acceleration
        # at the endpoints for smooth motion
        return self.generate_cubic_spline(
            waypoints, 
            timestamps,
            velocity_start=[0, 0, 0],
            velocity_end=[0, 0, 0]
        )

class MotionBlender:
    """Blend between different motion segments for smooth transitions"""
    
    def __init__(self, blend_time: float = 0.5):
        self.blend_time = blend_time
        
    def blend_trajectories(self, traj1, traj2, blend_samples=50):
        """Blend two trajectory segments with improved velocity continuity"""
        
        if blend_samples < 4:
            return np.vstack([traj1, traj2])
        
        # Use more samples for smoother blending
        blend_samples = max(blend_samples, 20)  # Minimum 20 samples for smooth blend
        
        # Calculate overlap region more carefully
        overlap_start = max(0, len(traj1) - blend_samples // 3)
        overlap_end = min(len(traj2), blend_samples // 3)
        
        # Extract blend region
        blend_start_pose = traj1[overlap_start] if overlap_start < len(traj1) else traj1[-1]
        blend_end_pose = traj2[overlap_end] if overlap_end < len(traj2) else traj2[0]
        
        # Generate smooth transition using S-curve
        blended = []
        for i in range(blend_samples):
            t = i / (blend_samples - 1)
            # Use smoothstep function for smoother acceleration
            s = t * t * (3 - 2 * t)  # Smoothstep
            
            # Blend position
            pos_blend = blend_start_pose * (1 - s) + blend_end_pose * s
            
            # For orientation, use SLERP
            r1 = Rotation.from_euler('xyz', blend_start_pose[3:], degrees=True)
            r2 = Rotation.from_euler('xyz', blend_end_pose[3:], degrees=True)
            key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
            slerp = Slerp([0, 1], key_rots)
            orient_blend = slerp(s).as_euler('xyz', degrees=True)
            
            pos_blend[3:] = orient_blend
            blended.append(pos_blend)
        
        # Combine with better overlap handling
        result = np.vstack([
            traj1[:overlap_start],
            np.array(blended),
            traj2[overlap_end:]
        ])
        
        return result

class SmoothMotionCommand:
    """Command class for executing smooth motions on PAROL6"""
    
    def __init__(self, trajectory: np.ndarray, speed_factor: float = 1.0):
        """
        Initialize smooth motion command
        
        Args:
            trajectory: Pre-computed trajectory array
            speed_factor: Speed scaling factor (1.0 = normal speed)
        """
        self.trajectory = trajectory
        self.speed_factor = speed_factor
        self.current_index = 0
        self.is_finished = False
        self.is_valid = True
        
    def prepare_for_execution(self, current_position_in):
        """Validate trajectory is reachable from current position"""
        # Check if IK solver is available
        if solve_ik_with_adaptive_tol_subdivision is None:
            print("Warning: IK solver not available, skipping validation")
            self.is_valid = True
            return True
            
        try:
            # Convert current position to radians
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(current_position_in)])
            
            # Check first waypoint is reachable
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
            )
            
            if not ik_result.success:
                print(f"Smooth motion validation failed: Cannot reach first waypoint")
                self.is_valid = False
                return False
                
            print(f"Smooth motion prepared with {len(self.trajectory)} waypoints")
            return True
            
        except Exception as e:
            print(f"Smooth motion preparation error: {e}")
            self.is_valid = False
            return False
    
    def execute_step(self, Position_in, Speed_out, Command_out, **kwargs):
        """Execute one step of the smooth motion"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Check if required modules are available
        if PAROL6_ROBOT is None or solve_ik_with_adaptive_tol_subdivision is None:
            print("Error: Required PAROL6 modules not available")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Apply speed scaling
        step_increment = max(1, int(self.speed_factor))
        self.current_index += step_increment
        
        if self.current_index >= len(self.trajectory):
            print("Smooth motion completed")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get current target pose
        target_pose = self.trajectory[self.current_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
        )
        
        if not ik_result.success:
            print(f"IK failed at trajectory point {self.current_index}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps and send
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                       for i, q in enumerate(ik_result.q)]
        
        # Calculate velocities for smooth following
        for i in range(6):
            Speed_out[i] = int((target_steps[i] - Position_in[i]) * 10)  # P-control factor
        
        Command_out.value = 156  # Smooth motion command
        return False

# Helper functions for integration with robot_api.py

def execute_circle(center: List[float], 
                  radius: float, 
                  duration: float = 4.0,
                  normal: List[float] = [0, 0, 1]) -> str:
    """
    Execute a circular motion on PAROL6
    
    Args:
        center: Center point [x, y, z] in mm
        radius: Circle radius in mm
        duration: Time to complete circle
        normal: Normal vector to circle plane
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_circle_3d(center, radius, normal, 0, duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|CIRCLE|{traj_str}"
    
    return command

def execute_arc(start_pose: List[float],
               end_pose: List[float],
               center: List[float],
               clockwise: bool = True,
               duration: float = 2.0) -> str:
    """
    Execute an arc motion on PAROL6
    
    Args:
        start_pose: Starting pose [x, y, z, rx, ry, rz]
        end_pose: Ending pose [x, y, z, rx, ry, rz]
        center: Arc center point [x, y, z]
        clockwise: Direction of rotation
        duration: Time to complete arc
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_arc_3d(start_pose, end_pose, center, 
                                           clockwise=clockwise, duration=duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|ARC|{traj_str}"
    
    return command

def execute_spline(waypoints: List[List[float]], 
                  total_time: Optional[float] = None) -> str:
    """
    Execute a spline motion through waypoints
    
    Args:
        waypoints: List of poses [x, y, z, rx, ry, rz]
        total_time: Total time for motion (auto-calculated if None)
        
    Returns:
        Command string for robot_api
    """
    motion_gen = SplineMotion()
    
    # Generate timestamps if total_time is provided
    timestamps = None
    if total_time:
        timestamps = np.linspace(0, total_time, len(waypoints))
    
    trajectory = motion_gen.generate_cubic_spline(waypoints, timestamps)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|SPLINE|{traj_str}"
    
    return command

# Example usage
if __name__ == "__main__":
    # Example: Generate a circle trajectory
    circle_gen = CircularMotion()
    circle_traj = circle_gen.generate_circle_3d(
        center=[200, 0, 200],  # mm
        radius=50,  # mm
        duration=4.0  # seconds
    )
    print(f"Generated circle with {len(circle_traj)} points")
    
    # Example: Generate arc trajectory
    arc_traj = circle_gen.generate_arc_3d(
        start_pose=[250, 0, 200, 0, 0, 0],
        end_pose=[200, 50, 200, 0, 0, 90],
        center=[200, 0, 200],
        duration=2.0
    )
    print(f"Generated arc with {len(arc_traj)} points")
    
    # Example: Generate spline through waypoints
    spline_gen = SplineMotion()
    waypoints = [
        [200, 0, 100, 0, 0, 0],
        [250, 50, 150, 0, 15, 45],
        [200, 100, 200, 0, 30, 90],
        [150, 50, 150, 0, 15, 45],
        [200, 0, 100, 0, 0, 0]
    ]
    spline_traj = spline_gen.generate_cubic_spline(waypoints)
    print(f"Generated spline with {len(spline_traj)} points")
````
