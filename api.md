This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.repomixignore
01-safe_base_test.py
01-start-home.bat
com_port.txt
example_client.py
headless_commander_fixed.py
headless_commander_patched.py
headless_commander.py
headless_commander.py.backup_1757427986
headless_commander.py.backup_wN_1757428702
LICENSE
linux_serial_patch.py
parol6_controller.py
parol6_ik_fix.py
PAROL6_ROBOT.py
PAROL6_ROBOT.py.backup_1757427986
python quick_fix.py
README_FIXED.md
README.md
replace_ikine_LMS.py
repomix.config.json
robot_api.py
run_headless_complete_fix.py
run_headless_fixed.py
run_headless_linux.py
run_minimal.py
run_parol6_fixed.py
run_patched.py
safe_home_client.py
smooth_motion.py
smooth_motion.py.backup_1757427986
smooth_motion.py.backup_wN_1757428702
start_parol6.sh
STATUS_REPORT.md
test_basic.py
test_script.py
test_serial.py
test_smooth_motion.py
test/测试发现的问题总结
test/可用api测试.py
test/你运动学求解器测试.py
test/一键移动到安全位置.py
test/all-test.py
test/base01.py
test/base02.py
test/emergency_stop_cli.py
test/requirements.txt
test/testik.py
test/wn快速修复脚本.py
```

# Files

## File: .repomixignore
````
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
````

## File: 01-start-home.bat
````
call "C:\Users\q4423\miniconda3\Scripts\activate.bat" parol
python D:\Onedrive\p\09-PAROL6-python-API\headless_commander.py
````

## File: repomix.config.json
````json
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "api.md",
    "style": "markdown",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "truncateBase64": false,
    "copyToClipboard": false,
    "tokenCountTree": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false,
      "includeLogs": false,
      "includeLogsCount": 50
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
````

## File: test/测试发现的问题总结
````
通过这一系列的测试，我们发现了问题并进行了修复。让我总结一下：

## 📊 **测试发现的问题总结**

### ✅ **已确认可用的API**
```python
# 状态查询API - 100%可用
- get_robot_joint_angles()      # 获取关节角度
- get_robot_pose()              # 获取位姿
- get_robot_joint_speeds()      # 获取关节速度
- get_robot_status()            # 获取综合状态
- is_robot_stopped()            # 检查停止状态

# 关节控制API - 100%可用  
- home_robot()                  # 机器人归零
- jog_robot_joint()            # 单关节点动
- jog_multiple_joints()        # 多关节点动

# 夹具控制API - 部分可用
- control_pneumatic_gripper()   # 气动夹具控制
- control_electric_gripper()    # 电动夹具（需更长等待时间）

# 系统控制API - 部分可用
- stop_robot_movement()         # 停止运动
- delay_robot()                # 延迟命令
```

### ❌ **发现的主要问题**

#### 1. **逆运动学求解器问题** 
```bash
# 原始错误
'DHRobot' object has no attribute 'ikine_LMS'

# 第一次修复：ikine_LMS -> ikine_LM
# 新错误  
IKMixin.ikine_LM() got an unexpected keyword argument 'wN'
```

#### 2. **安全位置问题**
```bash
# 机器人位置不在安全工作空间
⚠️ 当前位置可能不安全，请手动移动到安全位置
```

#### 3. **参数超限问题**
```bash
# 关节角度超出限制
VALIDATION FAILED: Target for Joint 3 (90.0 deg) is out of range
```

## 🔧 **已完成的修改**

### 1. **文件替换修改**
```python
# 在以下文件中进行替换：
- headless_commander.py
- PAROL6_ROBOT.py  
- smooth_motion.py

# 替换内容：
ikine_LMS -> ikine_LM
```

### 2. **创建的工具程序**
```python
- api_test_fixed.py           # API功能测试程序
- safe_position_mover.py      # 安全位置移动程序  
- quick_safe_move.py          # 快速安全移动
- fix_ikine_parameters.py     # 参数修复程序
- quick_fix_wN.py            # 快速参数修复
```

## 🎯 **需要进行的修改**

### 1. **立即需要修复**

#### A. 修复 `wN` 参数问题
```python
# 在所有文件中找到并修复：
# 错误用法：
sol = robot.ikine_LM(T, q0=q0, wN=None)
sol = robot.ikine_LM(T, q0=q0, wN=np.eye(6))

# 正确用法：
sol = robot.ikine_LM(T, q0=q0)
sol = robot.ikine_LM(T, q0=q0, ilimit=100, slimit=100)
```

#### B. 移动到安全位置
```python
# 使用我们创建的程序：
python safe_position_mover.py
# 或
python quick_safe_move.py
```

### 2. **需要系统性修改的文件**

#### A. `headless_commander.py`
```python
# 需要修改的内容：
1. 删除所有 ikine_LM 调用中的 wN 参数
2. 可能需要调整 IK 求解的超时和容差参数
3. 检查关节限制验证逻辑
```

#### B. `smooth_motion.py`
```python
# 需要修改的内容：
1. 修复所有平滑运动函数中的 ikine_LM 调用
2. 删除 wN 参数
3. 可能需要调整轨迹生成的参数
4. 修复除零错误（RuntimeWarning: invalid value encountered in divide）
```

#### C. `PAROL6_ROBOT.py`
```python
# 需要修改的内容：
1. 检查机器人运动学模型定义
2. 确保关节限制正确设置
3. 修复任何 ikine_LM 参数问题
```

### 3. **建议的改进**

#### A. 参数配置文件
```python
# 创建 config.py
JOINT_LIMITS = {
    0: (-170, 170),   # Base
    1: (-135, 0),     # Shoulder  
    2: (0, 180),      # Elbow
    3: (-180, 180),   # Wrist1
    4: (-120, 120),   # Wrist2  
    5: (-360, 360),   # Wrist3
}

SAFE_POSITIONS = {
    "home": [0, -90, 180, 0, 0, 180],
    "center": [0, -60, 150, 0, 30, 180],
}

IK_PARAMETERS = {
    "ilimit": 100,     # 最大迭代次数
    "slimit": 100,     # 搜索限制
    "tol": 1e-6,       # 收敛容差
}
```

#### B. 错误处理改进
```python
# 在所有 ikine_LM 调用周围添加：
try:
    sol = robot.ikine_LM(T, q0=q0, **IK_PARAMETERS)
    if not sol.success:
        print(f"IK failed: {sol.reason}")
        return None
except Exception as e:
    print(f"IK error: {e}")
    return None
```

## 📋 **完整修复计划**

### 步骤1：参数修复（立即执行）
```bash
python fix_ikine_parameters.py  # 或 python quick_fix_wN.py
```

### 步骤2：移动到安全位置
```bash  
python safe_position_mover.py
```

### 步骤3：重启服务器
```bash
python headless_commander.py
```

### 步骤4：验证修复效果
```bash
python safe_api_test.py
```

### 步骤5：如果仍有问题，手动检查
```python
# 检查这些文件中的所有 ikine_LM 调用：
grep -n "ikine_LM" headless_commander.py
grep -n "ikine_LM" smooth_motion.py  
grep -n "ikine_LM" PAROL6_ROBOT.py

# 确保参数格式正确：
robot.ikine_LM(T, q0=q0)                    # ✅ 正确
robot.ikine_LM(T, q0=q0, ilimit=100)       # ✅ 正确
robot.ikine_LM(T, q0=q0, wN=None)          # ❌ 错误
```

## 🎯 **预期结果**

完成所有修复后，应该看到：
```
✅ move_robot_pose: 成功
✅ move_robot_cartesian: 成功
✅ jog_cartesian: 成功  
✅ smooth_circle: 成功
✅ smooth_arc_center: 成功
✅ smooth_spline: 成功
✅ smooth_helix: 成功

📊 成功率: 90%+
```

**关键是先修复 `wN` 参数问题，这是当前阻止所有位姿相关API工作的根本原因！**
````

## File: test/可用api测试.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 API 修复版测试程序
根据实际错误分析修复的版本
"""
import sys
import os

# 获取当前文件的绝对路径
current_dir = os.path.dirname(os.path.abspath(__file__))

# 获取父目录路径
parent_dir = os.path.dirname(current_dir)

# 将父目录添加到模块搜索路径中
sys.path.append(parent_dir)

# 现在可以导入父目录中的模块
from robot_api import *
import time

import time
import traceback
from robot_api import *

class PAROL6FixedTester:
    def __init__(self):
        """初始化修复版测试器"""
        self.test_results = {}
        self.test_count = 0
        self.passed_count = 0
        self.failed_count = 0
        self.skipped_count = 0
        
        # 动态获取当前位置作为安全基准
        self.current_pose = None
        self.current_joints = None
        self.safe_joint_limits = {
            0: (-170, 170),   # Base: ±170°
            1: (-135, 0),     # Shoulder: -135° to 0°  
            2: (0, 180),      # Elbow: 0° to 180°
            3: (-180, 180),   # Wrist1: ±180°
            4: (-120, 120),   # Wrist2: ±120°
            5: (-360, 360),   # Wrist3: ±360°
        }
        
        print("🔧 PAROL6 修复版API测试器")
        print("📋 修复内容:")
        print("   ✅ 使用当前位置作为安全基准")
        print("   ✅ 避免逆运动学问题的API")
        print("   ✅ 合理的关节角度限制")
        print("   ✅ 改进超时处理")

    def initialize_safe_positions(self):
        """初始化安全位置"""
        try:
            self.current_pose = get_robot_pose()
            self.current_joints = get_robot_joint_angles()
            
            if self.current_pose:
                print(f"📍 当前位姿: {[round(p, 2) for p in self.current_pose]}")
            if self.current_joints:
                print(f"🔧 当前关节: {[round(a, 2) for a in self.current_joints]}")
                
            return self.current_pose is not None and self.current_joints is not None
        except Exception as e:
            print(f"❌ 初始化失败: {e}")
            return False

    def is_joint_angle_safe(self, joint_index, angle):
        """检查关节角度是否安全"""
        if joint_index in self.safe_joint_limits:
            min_angle, max_angle = self.safe_joint_limits[joint_index]
            return min_angle <= angle <= max_angle
        return False

    def get_safe_joint_angles(self):
        """获取基于当前位置的安全关节角度"""
        if not self.current_joints:
            return None
        
        safe_joints = self.current_joints.copy()
        
        # 只对底座做小幅调整（最安全）
        if self.is_joint_angle_safe(0, safe_joints[0] + 10):
            safe_joints[0] += 10
        elif self.is_joint_angle_safe(0, safe_joints[0] - 10):
            safe_joints[0] -= 10
        
        return safe_joints

    def get_safe_pose_offset(self, offset_x=0, offset_y=0, offset_z=0):
        """获取基于当前位置的安全位姿偏移"""
        if not self.current_pose:
            return None
        
        safe_pose = self.current_pose.copy()
        safe_pose[0] += offset_x  # X轴偏移
        safe_pose[1] += offset_y  # Y轴偏移  
        safe_pose[2] += offset_z  # Z轴偏移
        
        return safe_pose

    def log_test(self, test_name, result, details=""):
        """记录测试结果"""
        self.test_count += 1
        status = "✅ 通过" if result == "PASS" else "❌ 失败" if result == "FAIL" else "⏭️ 跳过"
        
        if result == "PASS":
            self.passed_count += 1
        elif result == "FAIL":
            self.failed_count += 1
        else:
            self.skipped_count += 1
            
        self.test_results[test_name] = {"status": result, "details": details}
        print(f"{status} {test_name}: {details}")

    def safe_execute(self, func, *args, **kwargs):
        """安全执行函数"""
        try:
            result = func(*args, **kwargs)
            return result, None
        except Exception as e:
            return None, str(e)

    def wait_for_command_complete(self, result, timeout=10.0):
        """等待命令完成（改进版）"""
        if not result or not isinstance(result, dict):
            return False
            
        command_id = result.get('command_id')
        if not command_id:
            return result.get('status') == 'COMPLETED'
        
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                status = check_command_status(command_id)
                if status and status.get('completed'):
                    return status.get('status') == 'COMPLETED'
                time.sleep(0.2)
            except:
                pass
                
        return False

    # ================================
    # 修复后的测试函数
    # ================================
    
    def test_working_apis(self):
        """测试确认可用的API"""
        print("\n" + "="*50)
        print("✅ 测试已验证可用的API")
        print("="*50)
        
        # 1. 状态查询API - 全部可用
        apis_to_test = [
            ("get_robot_joint_angles", get_robot_joint_angles, []),
            ("get_robot_pose", get_robot_pose, []),
            ("get_robot_joint_speeds", get_robot_joint_speeds, []),
            ("get_electric_gripper_status", get_electric_gripper_status, []),
            ("get_robot_pose_matrix", get_robot_pose_matrix, []),
            ("is_robot_stopped", is_robot_stopped, []),
            ("get_robot_status", get_robot_status, []),
        ]
        
        for name, func, args in apis_to_test:
            result, error = self.safe_execute(func, *args)
            if result is not None:
                self.log_test(name, "PASS", f"结果类型: {type(result)}")
            else:
                self.log_test(name, "FAIL", f"错误: {error}")

    def test_joint_movement_apis(self):
        """测试关节移动API（使用安全角度）"""
        print("\n" + "="*50)
        print("🔧 测试关节移动API（安全版）")
        print("="*50)
        
        # 1. 单关节点动（已验证可用）
        if input("测试单关节点动（底座±2°）? (y/N): ").lower() == 'y':
            for direction, joint_idx in [("正向", 0), ("反向", 6)]:
                result, error = self.safe_execute(
                    jog_robot_joint,
                    joint_index=joint_idx,
                    speed_percentage=10,
                    distance_deg=2.0,
                    wait_for_ack=True,
                    timeout=10.0
                )
                
                if result and self.wait_for_command_complete(result, 10):
                    self.log_test(f"jog_robot_joint_{direction}", "PASS", f"底座{direction}点动2°成功")
                else:
                    self.log_test(f"jog_robot_joint_{direction}", "FAIL", f"失败: {error or result}")
                
                time.sleep(1)
        else:
            self.log_test("jog_robot_joint", "SKIP", "用户跳过")
        
        # 2. 多关节点动（已验证可用）
        if input("测试多关节同时点动? (y/N): ").lower() == 'y':
            result, error = self.safe_execute(
                jog_multiple_joints,
                joints=[0, 1],  # 底座和肩部
                speeds=[8, 8],  # 降低速度
                duration=1.5,   # 增加时间
                wait_for_ack=True,
                timeout=10.0
            )
            
            if result and self.wait_for_command_complete(result, 10):
                self.log_test("jog_multiple_joints", "PASS", "多关节点动成功")
            else:
                self.log_test("jog_multiple_joints", "FAIL", f"失败: {error or result}")
            
            time.sleep(1)
        else:
            self.log_test("jog_multiple_joints", "SKIP", "用户跳过")
        
        # 3. 安全关节移动（修复角度范围）
        if input("测试安全关节移动? (y/N): ").lower() == 'y':
            safe_joints = self.get_safe_joint_angles()
            if safe_joints:
                print(f"使用安全关节角度: {[round(a, 2) for a in safe_joints]}")
                result, error = self.safe_execute(
                    move_robot_joints,
                    safe_joints,
                    speed_percentage=15,  # 很慢的速度
                    wait_for_ack=True,
                    timeout=15.0
                )
                
                if result and self.wait_for_command_complete(result, 15):
                    self.log_test("move_robot_joints_safe", "PASS", "安全关节移动成功")
                else:
                    self.log_test("move_robot_joints_safe", "FAIL", f"失败: {error or result}")
            else:
                self.log_test("move_robot_joints_safe", "FAIL", "无法确定安全角度")
        else:
            self.log_test("move_robot_joints_safe", "SKIP", "用户跳过")

    def test_gripper_apis_fixed(self):
        """测试夹具API（修复超时问题）"""
        print("\n" + "="*50)
        print("🤏 测试夹具API（修复版）")
        print("="*50)
        
        # 1. 气动夹具（已验证可用）
        if input("测试气动夹具? (y/N): ").lower() == 'y':
            for action in ['open', 'close']:
                result, error = self.safe_execute(
                    control_pneumatic_gripper,
                    action=action,
                    port=1,
                    wait_for_ack=True,
                    timeout=5.0
                )
                
                if result and self.wait_for_command_complete(result, 5):
                    self.log_test(f"pneumatic_gripper_{action}", "PASS", f"气动夹具{action}成功")
                else:
                    self.log_test(f"pneumatic_gripper_{action}", "FAIL", f"失败: {error or result}")
                
                time.sleep(1)
        else:
            self.log_test("pneumatic_gripper", "SKIP", "用户跳过")
        
        # 2. 电动夹具（增加等待时间）
        if input("测试电动夹具（需要更长时间）? (y/N): ").lower() == 'y':
            print("开始电动夹具校准（请等待...）")
            result, error = self.safe_execute(
                control_electric_gripper,
                action='calibrate',
                wait_for_ack=True,
                timeout=30.0  # 增加到30秒
            )
            
            if result:
                # 等待校准完成
                time.sleep(5)  # 额外等待时间
                if self.wait_for_command_complete(result, 30):
                    self.log_test("electric_gripper_calibrate", "PASS", "电动夹具校准成功")
                    
                    # 测试移动
                    print("测试电动夹具移动...")
                    result2, error2 = self.safe_execute(
                        control_electric_gripper,
                        action='move',
                        position=150,
                        speed=80,
                        wait_for_ack=True,
                        timeout=15.0
                    )
                    
                    if result2 and self.wait_for_command_complete(result2, 15):
                        self.log_test("electric_gripper_move", "PASS", "电动夹具移动成功")
                    else:
                        self.log_test("electric_gripper_move", "FAIL", f"移动失败: {error2 or result2}")
                else:
                    self.log_test("electric_gripper_calibrate", "FAIL", "校准超时")
            else:
                self.log_test("electric_gripper_calibrate", "FAIL", f"校准失败: {error}")
        else:
            self.log_test("electric_gripper", "SKIP", "用户跳过")

    def test_system_apis_fixed(self):
        """测试系统API（修复版）"""
        print("\n" + "="*50)
        print("⚙️ 测试系统API（修复版）")
        print("="*50)
        
        # 1. 延迟命令（修复判断逻辑）
        print("测试延迟命令（3秒）...")
        start_time = time.time()
        result, error = self.safe_execute(
            delay_robot, 
            duration=3.0, 
            wait_for_ack=True, 
            timeout=10.0
        )
        
        if result:
            # 等待延迟完成
            completed = self.wait_for_command_complete(result, 10)
            elapsed = time.time() - start_time
            
            if completed and 2.8 <= elapsed <= 3.5:
                self.log_test("delay_robot", "PASS", f"延迟{elapsed:.1f}秒成功")
            else:
                self.log_test("delay_robot", "FAIL", f"延迟异常，用时{elapsed:.1f}秒，完成状态: {completed}")
        else:
            self.log_test("delay_robot", "FAIL", f"延迟失败: {error}")
        
        # 2. 停止命令（已验证可用）
        result, error = self.safe_execute(stop_robot_movement, wait_for_ack=True)
        if result and self.wait_for_command_complete(result, 5):
            self.log_test("stop_robot_movement", "PASS", "停止命令成功")
        else:
            self.log_test("stop_robot_movement", "FAIL", f"失败: {error or result}")

    def test_problematic_apis_analysis(self):
        """分析有问题的API"""
        print("\n" + "="*50)
        print("🔬 有问题的API分析")
        print("="*50)
        
        problematic_apis = {
            "move_robot_pose": "逆运动学求解器缺失(ikine_LMS)",
            "move_robot_cartesian": "逆运动学求解器缺失(ikine_LMS)", 
            "jog_cartesian": "逆运动学求解器缺失(ikine_LMS)",
            "smooth_circle": "逆运动学求解器缺失(ikine_LMS)",
            "smooth_arc_center": "逆运动学求解器缺失(ikine_LMS)",
            "smooth_arc_parametric": "数据类型转换问题(tolist)",
            "smooth_spline": "逆运动学求解器缺失(ikine_LMS)",
            "smooth_helix": "逆运动学求解器缺失(ikine_LMS)",
        }
        
        print("❌ 无法使用的API及原因:")
        for api, reason in problematic_apis.items():
            print(f"   • {api}: {reason}")
            self.log_test(api, "FAIL", f"已知问题: {reason}")
        
        print("\n💡 解决建议:")
        print("   1. 检查roboticstoolbox版本兼容性")
        print("   2. 更新PAROL机器人配置文件") 
        print("   3. 使用alternative逆运动学求解器")
        print("   4. 联系开发者获取修复版本")

    def run_fixed_tests(self):
        """运行修复版测试"""
        print("🚀 开始修复版API测试")
        
        # 初始化安全位置
        if not self.initialize_safe_positions():
            print("❌ 无法初始化，退出测试")
            return
        
        start_time = time.time()
        
        try:
            # 1. 测试可用API
            self.test_working_apis()
            
            # 2. 测试关节移动（修复版）
            self.test_joint_movement_apis()
            
            # 3. 测试夹具（修复版）
            self.test_gripper_apis_fixed()
            
            # 4. 测试系统API（修复版）
            self.test_system_apis_fixed()
            
            # 5. 分析有问题的API
            self.test_problematic_apis_analysis()
            
        except KeyboardInterrupt:
            print("\n🛑 测试被用户中断")
        except Exception as e:
            print(f"\n❌ 测试错误: {e}")
            traceback.print_exc()
        finally:
            self.generate_fixed_report(time.time() - start_time)

    def generate_fixed_report(self, total_time):
        """生成修复版报告"""
        print("\n" + "="*60)
        print("📊 PAROL6 API 修复版测试报告")
        print("="*60)
        
        print(f"🕐 总测试时间: {total_time:.1f}秒")
        print(f"📈 测试统计:")
        print(f"   总测试数: {self.test_count}")
        print(f"   ✅ 通过: {self.passed_count}")
        print(f"   ❌ 失败: {self.failed_count}")
        print(f"   ⏭️ 跳过: {self.skipped_count}")
        
        working_count = self.passed_count + self.skipped_count
        if self.test_count > 0:
            working_rate = (working_count / self.test_count) * 100
            print(f"   📊 可用率: {working_rate:.1f}%")
        
        print(f"\n✅ 确认可用的API类别:")
        print(f"   • 状态查询API: 100%可用")
        print(f"   • 单关节点动: 100%可用") 
        print(f"   • 多关节点动: 100%可用")
        print(f"   • 气动夹具控制: 100%可用")
        print(f"   • 系统控制: 部分可用")
        
        print(f"\n❌ 需要修复的API类别:")
        print(f"   • 位姿移动: 需要修复逆运动学")
        print(f"   • 笛卡尔移动: 需要修复逆运动学")
        print(f"   • 平滑运动: 需要修复逆运动学")
        print(f"   • 电动夹具: 需要更长等待时间")
        
        print("="*60)

def main():
    """主程序"""
    print("🔧 PAROL6 API 修复版测试程序")
    print("基于错误分析的改进版本")
    
    tester = PAROL6FixedTester()
    
    if input("\n确认开始修复版测试? (y/N): ").lower() == 'y':
        tester.run_fixed_tests()
    else:
        print("❌ 用户取消测试")

if __name__ == "__main__":
    main()
````

## File: test/你运动学求解器测试.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 修复后API安全测试程序
专门测试修复后的位姿和平滑运动API
"""
import sys
import os

# 获取当前文件的绝对路径
current_dir = os.path.dirname(os.path.abspath(__file__))

# 获取父目录路径
parent_dir = os.path.dirname(current_dir)

# 将父目录添加到模块搜索路径中
sys.path.append(parent_dir)

# 现在可以导入父目录中的模块
from robot_api import *
import time
import numpy as np
from robot_api import *

class SafeAPITester:
    def __init__(self):
        """初始化安全测试器"""
        self.current_pose = None
        self.current_joints = None
        self.safe_workspace_center = None
        self.test_results = {}
        
        print("🛡️ PAROL6 修复后API安全测试器")
        print("专门测试位姿移动和平滑运动API")

    def initialize_safe_baseline(self):
        """初始化安全基线"""
        print("\n📊 初始化安全测试基线")
        print("-" * 40)
        
        try:
            # 获取当前状态
            self.current_pose = get_robot_pose()
            self.current_joints = get_robot_joint_angles()
            
            if not self.current_pose or not self.current_joints:
                print("❌ 无法获取机器人当前状态")
                return False
            
            print(f"📍 当前位姿: {[round(p, 2) for p in self.current_pose]}")
            print(f"🔧 当前关节: {[round(a, 2) for a in self.current_joints]}")
            
            # 设置安全工作空间中心（使用当前位置）
            self.safe_workspace_center = self.current_pose[:3].copy()  # 只取XYZ
            print(f"🎯 安全工作空间中心: {[round(p, 2) for p in self.safe_workspace_center]}")
            
            # 检查当前位置是否安全
            if self.is_pose_safe(self.current_pose):
                print("✅ 当前位置安全，可以开始测试")
                return True
            else:
                print("⚠️ 当前位置可能不安全，请手动移动到安全位置")
                return False
                
        except Exception as e:
            print(f"❌ 初始化失败: {e}")
            return False

    def is_pose_safe(self, pose):
        """检查位姿是否安全"""
        if not pose or len(pose) < 3:
            return False
        
        x, y, z = pose[:3]
        
        # 基本安全检查（根据PAROL6工作空间调整）
        if (50 <= x <= 400 and 
            -300 <= y <= 300 and 
            50 <= z <= 400):
            return True
        
        return False

    def create_safe_target_pose(self, offset_x=0, offset_y=0, offset_z=0):
        """创建安全的目标位姿"""
        if not self.current_pose:
            return None
        
        target_pose = self.current_pose.copy()
        target_pose[0] += offset_x
        target_pose[1] += offset_y
        target_pose[2] += offset_z
        
        # 检查目标是否安全
        if self.is_pose_safe(target_pose):
            return target_pose
        else:
            print(f"⚠️ 目标位姿不安全: {[round(p, 2) for p in target_pose]}")
            return None

    def wait_for_completion(self, result, timeout=15):
        """等待命令完成"""
        if not result or not isinstance(result, dict):
            return False, "无效结果"
        
        command_id = result.get('command_id')
        if not command_id:
            status = result.get('status')
            return status == 'COMPLETED', f"状态: {status}"
        
        start_time = time.time()
        last_status = None
        
        while time.time() - start_time < timeout:
            try:
                status_info = check_command_status(command_id)
                if status_info:
                    current_status = status_info.get('status')
                    if current_status != last_status:
                        print(f"   状态更新: {current_status}")
                        last_status = current_status
                    
                    if status_info.get('completed'):
                        final_status = status_info.get('status')
                        return final_status == 'COMPLETED', f"最终状态: {final_status}"
                
                time.sleep(0.3)
            except Exception as e:
                print(f"   状态检查异常: {e}")
                
        return False, "超时"

    def log_test_result(self, api_name, success, details=""):
        """记录测试结果"""
        self.test_results[api_name] = {
            'success': success,
            'details': details,
            'timestamp': time.time()
        }
        
        status = "✅ 成功" if success else "❌ 失败"
        print(f"{status} {api_name}: {details}")

    def test_move_robot_pose(self):
        """测试 move_robot_pose"""
        print("\n🤖 测试 move_robot_pose")
        print("-" * 30)
        
        # 创建安全的小幅移动目标
        target_pose = self.create_safe_target_pose(offset_x=10, offset_z=5)
        
        if not target_pose:
            self.log_test_result("move_robot_pose", False, "无法创建安全目标位姿")
            return
        
        print(f"🎯 目标位姿: {[round(p, 2) for p in target_pose]}")
        
        try:
            result = move_robot_pose(
                target_pose,
                speed_percentage=5,  # 非常慢的速度
                wait_for_ack=True,
                timeout=20
            )
            
            success, details = self.wait_for_completion(result, timeout=20)
            self.log_test_result("move_robot_pose", success, details)
            
            if success:
                time.sleep(1)  # 等待稳定
                
        except Exception as e:
            self.log_test_result("move_robot_pose", False, f"异常: {e}")

    def test_move_robot_cartesian(self):
        """测试 move_robot_cartesian"""
        print("\n📏 测试 move_robot_cartesian")
        print("-" * 30)
        
        target_pose = self.create_safe_target_pose(offset_y=8, offset_z=-3)
        
        if not target_pose:
            self.log_test_result("move_robot_cartesian", False, "无法创建安全目标位姿")
            return
        
        print(f"🎯 直线移动目标: {[round(p, 2) for p in target_pose]}")
        
        try:
            result = move_robot_cartesian(
                target_pose,
                speed_percentage=5,  # 非常慢的速度
                wait_for_ack=True,
                timeout=20
            )
            
            success, details = self.wait_for_completion(result, timeout=20)
            self.log_test_result("move_robot_cartesian", success, details)
            
            if success:
                time.sleep(1)
                
        except Exception as e:
            self.log_test_result("move_robot_cartesian", False, f"异常: {e}")

    def test_jog_cartesian(self):
        """测试 jog_cartesian"""
        print("\n🕹️ 测试 jog_cartesian")
        print("-" * 30)
        
        # 测试多个轴向的小幅点动
        test_axes = [
            ('X+', 'X轴正向'),
            ('Y+', 'Y轴正向'), 
            ('Z+', 'Z轴正向'),
            ('Z-', 'Z轴负向')
        ]
        
        for axis, desc in test_axes:
            print(f"🎮 测试 {desc} 点动...")
            
            try:
                result = jog_cartesian(
                    frame='WRF',  # 世界坐标系
                    axis=axis,
                    speed_percentage=8,  # 很慢的速度
                    duration=1.0,  # 短时间
                    wait_for_ack=True,
                    timeout=10
                )
                
                success, details = self.wait_for_completion(result, timeout=10)
                self.log_test_result(f"jog_cartesian_{axis}", success, details)
                
                if success:
                    time.sleep(0.5)  # 短暂停顿
                else:
                    break  # 如果失败，停止后续测试
                    
            except Exception as e:
                self.log_test_result(f"jog_cartesian_{axis}", False, f"异常: {e}")
                break

    def test_smooth_circle(self):
        """测试 smooth_circle"""
        print("\n⭕ 测试 smooth_circle")
        print("-" * 30)
        
        if not self.safe_workspace_center:
            self.log_test_result("smooth_circle", False, "无安全工作空间中心")
            return
        
        # 在当前位置附近画小圆
        center = self.safe_workspace_center.copy()
        radius = 8  # 很小的半径
        
        print(f"🎯 圆心: {[round(c, 2) for c in center]}, 半径: {radius}mm")
        
        try:
            result = smooth_circle(
                center=center,
                radius=radius,
                plane='XY',
                frame='WRF',
                duration=8.0,  # 较长时间，慢速执行
                wait_for_ack=True,
                timeout=15
            )
            
            success, details = self.wait_for_completion(result, timeout=15)
            self.log_test_result("smooth_circle", success, details)
            
            if success:
                time.sleep(1)
                
        except Exception as e:
            self.log_test_result("smooth_circle", False, f"异常: {e}")

    def test_smooth_arc_center(self):
        """测试 smooth_arc_center"""
        print("\n🌙 测试 smooth_arc_center")
        print("-" * 30)
        
        if not self.current_pose or not self.safe_workspace_center:
            self.log_test_result("smooth_arc_center", False, "缺少基准位置")
            return
        
        # 创建弧形路径
        center = self.safe_workspace_center.copy()
        end_pose = self.current_pose.copy()
        end_pose[0] += 15  # X方向偏移
        end_pose[1] += 10  # Y方向偏移
        
        if not self.is_pose_safe(end_pose):
            self.log_test_result("smooth_arc_center", False, "弧形终点不安全")
            return
        
        print(f"🎯 弧形: 中心{[round(c, 2) for c in center]} -> 终点{[round(p, 2) for p in end_pose[:3]]}")
        
        try:
            result = smooth_arc_center(
                end_pose=end_pose,
                center=center,
                frame='WRF',
                duration=6.0,
                wait_for_ack=True,
                timeout=12
            )
            
            success, details = self.wait_for_completion(result, timeout=12)
            self.log_test_result("smooth_arc_center", success, details)
            
            if success:
                time.sleep(1)
                
        except Exception as e:
            self.log_test_result("smooth_arc_center", False, f"异常: {e}")

    def test_smooth_spline(self):
        """测试 smooth_spline"""
        print("\n🌊 测试 smooth_spline")
        print("-" * 30)
        
        if not self.current_pose:
            self.log_test_result("smooth_spline", False, "无当前位姿")
            return
        
        # 创建样条路径的路径点
        waypoints = []
        
        # 起始点（当前位置小幅偏移）
        wp1 = self.create_safe_target_pose(offset_x=5, offset_y=5)
        wp2 = self.create_safe_target_pose(offset_x=10, offset_y=-5)  
        wp3 = self.create_safe_target_pose(offset_x=15, offset_y=0)
        
        if not all([wp1, wp2, wp3]):
            self.log_test_result("smooth_spline", False, "无法创建安全路径点")
            return
        
        waypoints = [wp1, wp2, wp3]
        print(f"🎯 样条路径: {len(waypoints)} 个路径点")
        
        try:
            result = smooth_spline(
                waypoints=waypoints,
                frame='WRF',
                duration=8.0,  # 较长时间
                wait_for_ack=True,
                timeout=15
            )
            
            success, details = self.wait_for_completion(result, timeout=15)
            self.log_test_result("smooth_spline", success, details)
            
            if success:
                time.sleep(1)
                
        except Exception as e:
            self.log_test_result("smooth_spline", False, f"异常: {e}")

    def test_smooth_helix(self):
        """测试 smooth_helix"""
        print("\n🌀 测试 smooth_helix")
        print("-" * 30)
        
        if not self.safe_workspace_center:
            self.log_test_result("smooth_helix", False, "无安全工作空间中心")
            return
        
        # 小螺旋参数
        center = self.safe_workspace_center.copy()
        center[2] -= 10  # 稍微降低中心高度
        radius = 6
        pitch = 5  # 螺距
        height = 15  # 总高度
        
        print(f"🎯 螺旋: 中心{[round(c, 2) for c in center]}, r={radius}mm, h={height}mm")
        
        try:
            result = smooth_helix(
                center=center,
                radius=radius,
                pitch=pitch,
                height=height,
                frame='WRF',
                duration=10.0,  # 更长时间
                wait_for_ack=True,
                timeout=18
            )
            
            success, details = self.wait_for_completion(result, timeout=18)
            self.log_test_result("smooth_helix", success, details)
            
            if success:
                time.sleep(1)
                
        except Exception as e:
            self.log_test_result("smooth_helix", False, f"异常: {e}")

    def run_all_tests(self):
        """运行所有测试"""
        print("🚀 开始修复后API完整测试")
        print("=" * 50)
        
        # 初始化
        if not self.initialize_safe_baseline():
            print("❌ 初始化失败，无法继续测试")
            return
        
        print("\n⚠️ 安全提醒:")
        print("• 测试将使用很小的移动距离和很慢的速度")
        print("• 确保机器人周围安全无障碍")
        print("• 急停按钮随时可用")
        
        if input("\n确认开始测试? (y/N): ").lower() != 'y':
            print("❌ 用户取消测试")
            return
        
        start_time = time.time()
        
        try:
            # 依次测试每个API
            test_functions = [
                ("move_robot_pose", self.test_move_robot_pose),
                ("move_robot_cartesian", self.test_move_robot_cartesian), 
                ("jog_cartesian", self.test_jog_cartesian),
                ("smooth_circle", self.test_smooth_circle),
                ("smooth_arc_center", self.test_smooth_arc_center),
                ("smooth_spline", self.test_smooth_spline),
                ("smooth_helix", self.test_smooth_helix),
            ]
            
            for api_name, test_func in test_functions:
                print(f"\n{'='*20} {api_name.upper()} {'='*20}")
                
                if input(f"测试 {api_name}? (Y/n/s=跳过全部): ").lower() in ['n', 's']:
                    if input("跳过全部剩余测试? (y/N): ").lower() == 'y':
                        break
                    continue
                
                test_func()
                
                # 测试间短暂休息
                time.sleep(1)
                
        except KeyboardInterrupt:
            print("\n🛑 测试被用户中断")
        except Exception as e:
            print(f"\n❌ 测试异常: {e}")
        finally:
            self.generate_test_report(time.time() - start_time)

    def generate_test_report(self, total_time):
        """生成测试报告"""
        print("\n" + "=" * 60)
        print("📊 修复后API测试报告")
        print("=" * 60)
        
        successful_apis = []
        failed_apis = []
        
        for api_name, result in self.test_results.items():
            if result['success']:
                successful_apis.append(api_name)
            else:
                failed_apis.append((api_name, result['details']))
        
        print(f"🕐 总测试时间: {total_time:.1f}秒")
        print(f"📈 测试统计:")
        print(f"   总测试API: {len(self.test_results)}")
        print(f"   ✅ 成功: {len(successful_apis)}")
        print(f"   ❌ 失败: {len(failed_apis)}")
        
        if self.test_results:
            success_rate = len(successful_apis) / len(self.test_results) * 100
            print(f"   📊 成功率: {success_rate:.1f}%")
        
        if successful_apis:
            print(f"\n✅ 成功的API:")
            for api in successful_apis:
                print(f"   • {api}")
        
        if failed_apis:
            print(f"\n❌ 失败的API:")
            for api, details in failed_apis:
                print(f"   • {api}: {details}")
        
        print(f"\n💡 总结:")
        if len(successful_apis) >= 5:
            print("   🎉 大部分API修复成功！")
        elif len(successful_apis) >= 2:
            print("   👍 部分API修复成功，还需进一步调整")
        else:
            print("   🔧 仍需要更多修复工作")
        
        print("=" * 60)

def main():
    """主程序"""
    print("🛡️ PAROL6 修复后API安全测试程序")
    print("专门测试ikine_LM修复后的API功能")
    
    tester = SafeAPITester()
    tester.run_all_tests()

if __name__ == "__main__":
    main()
````

## File: test/一键移动到安全位置.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 快速安全移动脚本
一键移动到最安全的位置
"""
import sys
import os

# 获取当前文件的绝对路径
current_dir = os.path.dirname(os.path.abspath(__file__))

# 获取父目录路径
parent_dir = os.path.dirname(current_dir)

# 将父目录添加到模块搜索路径中
sys.path.append(parent_dir)

# 现在可以导入父目录中的模块
from robot_api import *
import time
from robot_api import *

def quick_safe_move():
    """快速移动到安全位置"""
    print("🚀 PAROL6 快速安全移动")
    print("=" * 30)
    
    # 获取当前状态
    try:
        current_pose = get_robot_pose()
        current_joints = get_robot_joint_angles()
        
        if not current_pose or not current_joints:
            print("❌ 无法获取机器人状态")
            return False
        
        print(f"📍 当前位姿: {[round(p, 2) for p in current_pose]}")
        print(f"🔧 当前关节: {[round(a, 2) for a in current_joints]}")
        
    except Exception as e:
        print(f"❌ 获取状态失败: {e}")
        return False
    
    # 定义最安全的位置（工作空间中心，中等高度）
    safe_joints = [0, -60, 150, 0, 30, 180]
    print(f"\n🎯 目标安全位置: {safe_joints}")
    
    # 确认移动
    if input("确认移动到安全位置? (y/N): ").lower() != 'y':
        print("❌ 用户取消")
        return False
    
    try:
        print("🚀 开始移动...")
        
        result = move_robot_joints(
            safe_joints,
            speed_percentage=8,  # 慢速
            wait_for_ack=True,
            timeout=20.0
        )
        
        if result:
            print("⏳ 等待移动完成...")
            
            # 等待完成
            start_time = time.time()
            while time.time() - start_time < 20:
                try:
                    if result.get('command_id'):
                        status = check_command_status(result['command_id'])
                        if status and status.get('completed'):
                            if status.get('status') == 'COMPLETED':
                                print("✅ 移动到安全位置成功！")
                                
                                # 显示新位置
                                time.sleep(1)
                                new_pose = get_robot_pose()
                                new_joints = get_robot_joint_angles()
                                if new_pose and new_joints:
                                    print(f"📍 新位姿: {[round(p, 2) for p in new_pose]}")
                                    print(f"🔧 新关节: {[round(a, 2) for a in new_joints]}")
                                
                                return True
                            else:
                                print(f"❌ 移动失败: {status.get('status')}")
                                return False
                    elif result.get('status') == 'COMPLETED':
                        print("✅ 移动完成！")
                        return True
                    
                    time.sleep(0.5)
                except:
                    pass
            
            print("⚠️ 移动可能超时")
            return False
        else:
            print("❌ 移动命令失败")
            return False
            
    except Exception as e:
        print(f"❌ 移动异常: {e}")
        return False

if __name__ == "__main__":
    if quick_safe_move():
        print("\n🎉 现在可以运行API测试程序了！")
        print("运行: python safe_api_test.py")
    else:
        print("\n❌ 移动失败，请检查机器人状态")
````

## File: test/emergency_stop_cli.py
````python
#!/usr/bin/env python3
"""
PAROL6快速急停命令行工具
"""
import sys
sys.path.append('09-PAROL6-python-API')

try:
    from robot_api import stop_robot_movement
    import rclpy
    from std_msgs.msg import String, Bool
    
    def emergency_stop():
        print("执行急停...")
        
        # 1. API直接停止
        try:
            result = stop_robot_movement(wait_for_ack=True, timeout=3)
            if result:
                print("✅ API急停成功")
            else:
                print("❌ API急停失败")
        except Exception as e:
            print(f"❌ API急停异常: {e}")
        
        # 2. ROS急停
        try:
            rclpy.init()
            node = rclpy.create_node('emergency_stop_cli')
            
            emergency_pub = node.create_publisher(Bool, '/parol6/emergency_stop', 10)
            cmd_pub = node.create_publisher(String, '/parol6/api_command', 10)
            
            # 发布急停信号
            emergency_msg = Bool()
            emergency_msg.data = True
            emergency_pub.publish(emergency_msg)
            
            cmd_msg = String()
            cmd_msg.data = 'emergency_stop'
            cmd_pub.publish(cmd_msg)
            
            print("✅ ROS急停信号已发送")
            
            node.destroy_node()
            rclpy.shutdown()
            
        except Exception as e:
            print(f"❌ ROS急停异常: {e}")
    
    if __name__ == "__main__":
        emergency_stop()
        
except ImportError as e:
    print(f"导入失败: {e}")
    print("请确保PAROL6 API和ROS2环境正确配置")
````

## File: test/requirements.txt
````
# requirements.txt  —— PAROL6-python-API 环境
numpy==1.23.4
scipy==1.11.4

# 机器人相关
roboticstoolbox-python==1.0.3
spatialmath-python==1.0.5

# 串口通信
pyserial>=3.5

# 键盘事件监听（headless_commander.py 用到）
keyboard>=0.13.5

# Windows 下用于计时的包（如果代码里真的 import oclock 才需要）
# oclock

# 其他工具库（根据 PAROL6 README，若用 get_robot_pose）
# 如果要使用 get_robot_pose() 还需安装 numpy, spatialmath 已包含
````

## File: test/wn快速修复脚本.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
快速修复 ikine_LM wN 参数问题
"""

import os
import re
import shutil
import time

def quick_fix_wN_parameter():
    """快速修复 wN 参数问题"""
    print("🚀 快速修复 ikine_LM wN 参数问题")
    print("="*40)
    
    files = ["headless_commander.py", "PAROL6_ROBOT.py", "smooth_motion.py"]
    
    for filename in files:
        if not os.path.exists(filename):
            print(f"⚠️ {filename}: 文件不存在")
            continue
        
        try:
            # 读取文件
            with open(filename, 'r', encoding='utf-8') as f:
                content = f.read()
            
            original_content = content
            
            # 检查是否有问题
            if 'wN' not in content:
                print(f"✅ {filename}: 无需修复")
                continue
            
            # 备份
            backup = f"{filename}.backup_wN_{int(time.time())}"
            shutil.copy2(filename, backup)
            
            # 修复所有 wN 参数相关问题
            fixes = [
                # 删除 wN=xxx 参数
                (r',\s*wN\s*=[^,)]*', ''),
                (r'wN\s*=[^,)]*,\s*', ''),
                # 删除单独的 wN 参数
                (r',\s*wN\s*,', ','),
                (r'\(\s*wN\s*,', '('),
                (r',\s*wN\s*\)', ')'),
            ]
            
            fixes_applied = 0
            for pattern, replacement in fixes:
                if re.search(pattern, content):
                    content = re.sub(pattern, replacement, content)
                    fixes_applied += 1
            
            # 清理多余的逗号
            content = re.sub(r',\s*,', ',', content)
            content = re.sub(r'\(\s*,', '(', content)
            content = re.sub(r',\s*\)', ')', content)
            
            # 写入修复后的内容
            if content != original_content:
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                print(f"✅ {filename}: 修复完成，备份到 {backup}")
                
                # 显示修复的内容
                lines = content.split('\n')
                for i, line in enumerate(lines, 1):
                    if 'ikine_LM' in line:
                        print(f"   行 {i}: {line.strip()}")
            else:
                print(f"📄 {filename}: 未发现具体问题")
                os.remove(backup)  # 删除不必要的备份
                
        except Exception as e:
            print(f"❌ {filename}: 修复失败 - {e}")
    
    print("\n🎉 快速修复完成！")
    print("📋 下一步:")
    print("1. 重启 headless_commander.py")  
    print("2. 运行 API 测试")

if __name__ == "__main__":
    if input("确认执行 wN 参数快速修复? (y/N): ").lower() == 'y':
        quick_fix_wN_parameter()
    else:
        print("❌ 取消修复")
````

## File: 01-safe_base_test.py
````python
# safe_base_test.py
import time
from robot_api import (
    connect, disconnect, is_connected,
    clear_queue, stop_robot, get_state,
    move_robot_joints, home_robot  # 若有 home_joint 可改用它
)

DEG2RAD = 3.141592653589793 / 180.0

def main():
    # 1) 连接
    connect()  # 若你的实现需要IP/端口，改成 connect("192.168.x.x", 5001)
    assert is_connected(), "连接失败，请检查 headless_commander 是否已运行"

    # 2) 安全：软停 + 清队列（如函数不存在可注释）
    try: stop_robot()
    except: pass
    try: clear_queue()
    except: pass

    # 3) 读取当前关节角（弧度）
    st = get_state()  # 期待返回有 joints 列表，单位通常为度或弧度，视实现而定
    joints = list(st["joints"] if isinstance(st, dict) else st.joints)

    # 4) 只改 J1（base）一点点：+5°
    # 如果 get_state 返回的是度，请去掉 *DEG2RAD；如果是弧度，保留如下：
    target = joints[:]
    target[0] = target[0] + 5.0 * DEG2RAD  # 基座 +5°

    print("准备以 5% 速度缓慢转动基座 +5° ...")
    move_robot_joints(
        target,
        speed_percentage=5,       # 很慢
        wait_for_ack=True,        # 等确认
        non_blocking=False        # 阻塞到完成（更安全）
    )

    time.sleep(0.5)
    print("基座小角度动作完成。开始回 Home（低速）...")
    # 若有按关节回零API，可替换为 home_joint(joint_index=0, speed_percentage=5, wait_for_ack=True)
    home_robot(speed_percentage=5, wait_for_ack=True, timeout=120)

    disconnect()
    print("完成。")

if __name__ == "__main__":
    main()
````

## File: com_port.txt
````
COM3
````

## File: example_client.py
````python
# safe_home_client.py
import time
from robot_api import (
    connect, disconnect, is_connected,
    stop_robot, clear_queue, home_robot, get_state
)

def main():
    # 1) 连接（如果 robot_api 需要 IP/端口，替换 connect(host, port) 版本）
    connect()
    assert is_connected(), "连接失败，请检查 headless_commander 是否在运行"

    # 2) 安全：停止并清队列
    try:
        stop_robot()    # 某些实现是软停；若无该函数可忽略
    except Exception:
        pass
    try:
        clear_queue()
    except Exception:
        pass

    # 3) 读取当前状态并打印（确认未在运动）
    try:
        s = get_state()
        print("当前状态：", s)
    except Exception as e:
        print("读取状态失败，不影响 Home：", e)

    # 4) 低速 Home（关键！）
    print("开始低速 Home ...")
    home_robot(speed_percentage=10, wait_for_ack=True, timeout=120)

    # 5) 等待稳定
    time.sleep(1.0)
    print("Home 指令完成。再次读取状态：")
    try:
        s2 = get_state()
        print("状态：", s2)
    except Exception:
        pass

    # 6) 断开
    disconnect()
    print("完成")

if __name__ == "__main__":
    main()
````

## File: headless_commander_fixed.py
````python
#!/usr/bin/env python3
"""
Fixed version of headless_commander.py with Linux serial port support
"""
import sys
import os
import platform

# Add serial port initialization for Linux
def initialize_serial():
    import serial
    import serial.tools.list_ports
    
    my_os = platform.system()
    ser = None
    
    if my_os == "Windows":
        # Try to read the COM port from a file
        try:
            with open("com_port.txt", "r") as f:
                com_port_str = f.read().strip()
                ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
                print(f"Connected to saved COM port: {com_port_str}")
        except (FileNotFoundError, serial.SerialException):
            # If the file doesn't exist or the port is invalid, ask the user
            while True:
                try:
                    com_port = input("Enter the COM port (e.g., COM9): ")
                    ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                    print(f"Successfully connected to {com_port}")
                    # Save the successful port to the file
                    with open("com_port.txt", "w") as f:
                        f.write(com_port)
                    break
                except serial.SerialException:
                    print(f"Could not open port {com_port}. Please try again.")
    else:
        # Linux/Mac system
        # Try to read the serial port from a file
        try:
            with open("com_port.txt", "r") as f:
                com_port_str = f.read().strip()
                ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
                print(f"Connected to saved serial port: {com_port_str}")
        except (FileNotFoundError, serial.SerialException):
            # If the file doesn't exist or the port is invalid, try default ports
            default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
            for port in default_ports:
                try:
                    ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                    print(f"Successfully connected to {port}")
                    # Save the successful port to the file
                    with open("com_port.txt", "w") as f:
                        f.write(port)
                    break
                except serial.SerialException:
                    continue
            
            if ser is None:
                print("Could not find any available serial ports. Available ports:")
                ports = serial.tools.list_ports.comports()
                for port in ports:
                    print(f"  {port.device}")
                
                while True:
                    try:
                        com_port = input("Enter the serial port (e.g., /dev/ttyACM0): ")
                        ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                        print(f"Successfully connected to {com_port}")
                        # Save the successful port to the file
                        with open("com_port.txt", "w") as f:
                            f.write(com_port)
                        break
                    except serial.SerialException:
                        print(f"Could not open port {com_port}. Please try again.")
    
    return ser

# Now run the original script with our serial initialization
if __name__ == "__main__":
    import subprocess
    
    # First initialize the serial port
    ser = initialize_serial()
    if ser:
        print(f"Serial port successfully initialized: {ser.port}")
        ser.close()  # Close it, let the main script handle it
    
    # Now we need to patch the original script
    print("Patching original script...")
````

## File: headless_commander_patched.py
````python
'''
A full fledged "API" for the PAROL6 robot. To use this, you should pair it with the "robot_api.py" where you can import commands
from said file and use them anywhere within your code. This Python script will handle sending and performing all the commands
to the PAROL6 robot, as well as E-Stop functionality and safety limitations.

To run this program, you must use the "experimental-kinematics" branch of the "PAROL-commander-software" on GitHub
which can be found through this link: https://github.com/PCrnjak/PAROL-commander-software/tree/experimental_kinematics.
You must also save these files into the following folder: "Project Files\PAROL-commander-software\GUI\files".
'''

# * If you press estop robot will stop and you need to enable it by pressing e

from roboticstoolbox import DHRobot, RevoluteDH, ERobot, ELink, ETS, trapezoidal, quintic
import roboticstoolbox as rp
from math import pi, sin, cos
import numpy as np
from oclock import Timer, loop, interactiveloop
import time
import socket
from spatialmath import SE3
import select
import serial
import platform
import os
import re
import logging
import struct
import keyboard
from typing import Optional, Tuple
from spatialmath.base import trinterp
from collections import namedtuple, deque
import GUI.files.PAROL6_ROBOT as PAROL6_ROBOT
from smooth_motion import CircularMotion, SplineMotion, MotionBlender

# Set interval
INTERVAL_S = 0.01
prev_time = 0

logging.basicConfig(level = logging.DEBUG,
    format='%(asctime)s.%(msecs)03d %(levelname)s:\t%(message)s',
    datefmt='%H:%M:%S'
)
logging.disable(logging.DEBUG)



my_os = platform.system()

# Initialize serial port based on OS
ser = None
com_port_str = None

if my_os == "Windows":
    # Windows serial port initialization
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved COM port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        while True:
            try:
                com_port = input("Enter the COM port (e.g., COM9): ")
                ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                com_port_str = com_port
                print(f"Successfully connected to {com_port}")
                with open("com_port.txt", "w") as f:
                    f.write(com_port)
                break
            except serial.SerialException:
                print(f"Could not open port {com_port}. Please try again.")

else:  # Linux/Mac
    # Linux serial port initialization
    print("🔧 Initializing serial port for Linux/Mac...")
    
    # Try to read saved port
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            if os.path.exists(com_port_str):
                ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
                print(f"✅ Connected to saved port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException) as e:
        print(f"⚠️ Could not connect to saved port: {e}")
        ser = None
    
    # If not connected, try default ports
    if ser is None:
        default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
        for port in default_ports:
            if os.path.exists(port):
                try:
                    ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                    com_port_str = port
                    print(f"✅ Connected to {port}")
                    with open("com_port.txt", "w") as f:
                        f.write(port)
                    break
                except serial.SerialException as e:
                    print(f"❌ Failed to connect to {port}: {e}")
    
    # If still not connected, list available ports
    if ser is None:
        print("\n📡 Available serial ports:")
        ports = serial.tools.list_ports.comports()
        for port in ports:
            print(f"  • {port.device} - {port.description}")
        
        # Try to connect to the first available ACM/USB port
        for port in ports:
            if "ACM" in port.device or "USB" in port.device:
                try:
                    ser = serial.Serial(port=port.device, baudrate=3000000, timeout=0)
                    com_port_str = port.device
                    print(f"✅ Connected to {port.device}")
                    with open("com_port.txt", "w") as f:
                        f.write(port.device)
                    break
                except Exception:
                    pass
        
        if ser is None:
            print("\n❌ Could not connect to any serial port!")
            print("Please check:")
            print("1. Robot is connected and powered on")
            print("2. User has permission (sudo usermod -a -G dialout $USER)")
            print("3. No other program is using the serial port")
            sys.exit(1)

print(f"📡 Using serial port: {com_port_str}")
print(f"⚡ Baudrate: 3000000")
print("🤖 PAROL6 Headless Commander Ready\n")

# in big endian machines, first byte of binary representation of the multibyte data-type is stored first. 
int_to_3_bytes = struct.Struct('>I').pack # BIG endian order

# data for output string (data that is being sent to the robot)
#######################################################################################
#######################################################################################
start_bytes =  [0xff,0xff,0xff] 
start_bytes = bytes(start_bytes)

end_bytes =  [0x01,0x02] 
end_bytes = bytes(end_bytes)


# data for input string (Data that is being sent by the robot)
#######################################################################################
#######################################################################################
input_byte = 0 # Here save incoming bytes from serial

start_cond1_byte = bytes([0xff])
start_cond2_byte = bytes([0xff])
start_cond3_byte = bytes([0xff])

end_cond1_byte = bytes([0x01])
end_cond2_byte = bytes([0x02])

start_cond1 = 0 #Flag if start_cond1_byte is received
start_cond2 = 0 #Flag if start_cond2_byte is received
start_cond3 = 0 #Flag if start_cond3_byte is received

good_start = 0 #Flag if we got all 3 start condition bytes
data_len = 0 #Length of the data after -3 start condition bytes and length byte, so -4 bytes

data_buffer = [None]*255 #Here save all data after data length byte
data_counter = 0 #Data counter for incoming bytes; compared to data length to see if we have correct length
#######################################################################################
#######################################################################################
prev_positions = [0,0,0,0,0,0]
prev_speed = [0,0,0,0,0,0]
robot_pose = [0,0,0,0,0,0] #np.array([0,0,0,0,0,0])
#######################################################################################
#######################################################################################

# --- Wrapper class to make integers mutable when passed to functions ---
class CommandValue:
    def __init__(self, value):
        self.value = value

#######################################################################################
#######################################################################################
Position_out = [1,11,111,1111,11111,10]
Speed_out = [2,21,22,23,24,25]
Command_out = CommandValue(255)
Affected_joint_out = [1,1,1,1,1,1,1,1]
InOut_out = [0,0,0,0,0,0,0,0]
Timeout_out = 0
#Positon,speed,current,command,mode,ID
Gripper_data_out = [1,1,1,1,0,0]
#######################################################################################
#######################################################################################
# Data sent from robot to PC
Position_in = [31,32,33,34,35,36]
Speed_in = [41,42,43,44,45,46]
Homed_in = [0,0,0,0,0,0,0,0]
InOut_in = [1,1,1,1,1,1,1,1]
Temperature_error_in = [1,1,1,1,1,1,1,1]
Position_error_in = [1,1,1,1,1,1,1,1]
Timeout_error = 0
# how much time passed between 2 sent commands (2byte value, last 2 digits are decimal so max value is 655.35ms?)
Timing_data_in = [0]
XTR_data =   0

# --- State variables for program execution ---
Robot_mode = "Dummy"  # Start in an idle state
Program_step = 0      # Which line of the program to run
Command_step = 0      # The current step within a single command
Command_len = 0       # The total steps for the current command
ik_error = 0          # Flag for inverse kinematics errors
error_state = 0       # General error flag
program_running = False # A flag to start and stop the program

# This will be your "program"
command_list = []

#ID,Position,speed,current,status,obj_detection
Gripper_data_in = [1,1,1,1,1,1] 

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179° and 181° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    
    Parameters
    ----------
    robot : DHRobot
        Robot model
    q : array_like
        Joint configuration
    strict_tol : float
        Strict tolerance away from singularities (default: 1e-10)
    loose_tol : float
        Loose tolerance near singularities (1e-7)
        
    Returns
    -------
    float
        Adaptive tolerance value
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    
    Parameters
    ----------
    q_seed : array_like
        Current joint configuration in radians
        
    Returns
    -------
    float
        Configuration-dependent maximum reach threshold
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 | None = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities:
    - Near singularities: looser tolerance for easier convergence
    - Away from singularities: stricter tolerance for precise solutions
    If necessary, recursively subdivide the motion until ikine_LMS converges
    on every segment. Finally check that solution respects joint limits. From experimentation,
    jogging with lower tolerances often produces q_paths that do not differ from current_q,
    essentially freezing the robot.

    Parameters
    ----------
    robot : DHRobot
        Robot model
    target_pose : SE3
        Target pose to reach
    current_q : array_like
        Current joint configuration
    current_pose : SE3, optional
        Current pose (computed if None)
    max_depth : int, optional
        Maximum subdivision depth (default: 8)
    ilimit : int, optional
        Maximum iterations for IK solver (default: 100)

    Returns
    -------
    IKResult
        success  - True/False
        q_path   - (mxn) array of the final joint configuration 
        iterations, residual  - aggregated diagnostics
        tolerance_used - which tolerance was used
        violations - joint limit violations (if any)
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # ── inner recursive solver───────────────────
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            # print(f"current_reach:{current_reach:.3f}, max_reach_threshold:{max_reach_threshold:.3f}")
            if not is_recovery and target_reach > max_reach_threshold:
                print(f"Target reach limit exceeded: {target_reach:.3f} > {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LMS(Tb, q0=q_seed, ilimit=ilimit, tol=tol, wN=damping)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # ── kick-off with adaptive tolerance ──────────────────────────────────
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    # Check if solution respects joint limits
    target_q = path[-1] if len(path) != 0 else None
    solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
    if ok and solution_valid:
        return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
    else:
        return IKResult(False, None, its, resid, adaptive_tol, violations)

#Setup IP address and Simulator port
ip = "127.0.0.1" #Loopback address
port = 5001
# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((ip, port))
print(f'Start listening to {ip}:{port}')

def Unpack_data(data_buffer_list, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):

    Joints = []
    Speed = []

    for i in range(0,18, 3):
        variable = data_buffer_list[i:i+3]
        Joints.append(variable)

    for i in range(18,36, 3):
        variable = data_buffer_list[i:i+3]
        Speed.append(variable)


    for i in range(6):
        var =  b'\x00' + b''.join(Joints[i])
        Position_in[i] = Fuse_3_bytes(var)
        var =  b'\x00' + b''.join(Speed[i])
        Speed_in[i] = Fuse_3_bytes(var)

    Homed = data_buffer_list[36]
    IO_var = data_buffer_list[37]
    temp_error = data_buffer_list[38]
    position_error = data_buffer_list[39]
    timing_data = data_buffer_list[40:42]
    Timeout_error_var = data_buffer_list[42]
    xtr2 = data_buffer_list[43]
    device_ID = data_buffer_list[44]
    Gripper_position = data_buffer_list[45:47]
    Gripper_speed = data_buffer_list[47:49]
    Gripper_current = data_buffer_list[49:51]
    Status = data_buffer_list[51]
    # The original object_detection byte at index 52 is ignored as it is not reliable.
    CRC_byte = data_buffer_list[53]
    endy_byte1 = data_buffer_list[54]
    endy_byte2 = data_buffer_list[55]

    # ... (Code for Homed, IO_var, temp_error, etc. remains the same) ...

    temp = Split_2_bitfield(int.from_bytes(Homed,"big"))
    for i in range(8):
        Homed_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(IO_var,"big"))
    for i in range(8):
        InOut_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(temp_error,"big"))
    for i in range(8):
        Temperature_error_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(position_error,"big"))
    for i in range(8):
        Position_error_in[i] = temp[i]

    var = b'\x00' + b'\x00' + b''.join(timing_data)
    Timing_data_in[0] = Fuse_3_bytes(var)
    Timeout_error = int.from_bytes(Timeout_error_var,"big")
    XTR_data = int.from_bytes(xtr2,"big")

    # --- Gripper Data Unpacking ---
    Gripper_data_in[0] = int.from_bytes(device_ID,"big")

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_position)
    Gripper_data_in[1] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_speed)
    Gripper_data_in[2] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_current)
    Gripper_data_in[3] = Fuse_2_bytes(var)

    # --- Start of Corrected Logic ---
    # This section now mirrors the working logic from GUI_PAROL_latest.py
    
    # 1. Store the raw status byte (from index 51)
    status_byte = int.from_bytes(Status,"big")
    Gripper_data_in[4] = status_byte

    # 2. Split the status byte into a list of 8 individual bits
    status_bits = Split_2_bitfield(status_byte)
    
    # 3. Combine the 3rd and 4th bits (at indices 2 and 3) to get the true object detection status
    # This creates a 2-bit number (0-3) which represents the full state.
    object_detection_status = (status_bits[2] << 1) | status_bits[3]
    Gripper_data_in[5] = object_detection_status
    # --- End of Corrected Logic ---

def Pack_data(Position_out,Speed_out,Command_out,Affected_joint_out,InOut_out,Timeout_out,Gripper_data_out):

    # Len is defined by all bytes EXCEPT start bytes and len
    # Start bytes = 3
    len = 52 #1
    Position = [Position_out[0],Position_out[1],Position_out[2],Position_out[3],Position_out[4],Position_out[5]]  #18
    Speed = [Speed_out[0], Speed_out[1], Speed_out[2], Speed_out[3], Speed_out[4], Speed_out[5],] #18
    Command = Command_out#1
    Affected_joint = Affected_joint_out
    InOut = InOut_out #1
    Timeout = Timeout_out #1
    Gripper_data = Gripper_data_out #9
    CRC_byte = 228 #1
    # End bytes = 2


    test_list = []
    #print(test_list)

    #x = bytes(start_bytes)
    test_list.append((start_bytes))
    
    test_list.append(bytes([len]))


    # Position data
    for i in range(6):
        position_split = Split_2_3_bytes(Position[i])
        test_list.append(position_split[1:4])

    # Speed data
    for i in range(6):
        speed_split = Split_2_3_bytes(Speed[i])
        test_list.append(speed_split[1:4])

    # Command data
    test_list.append(bytes([Command]))

    # Affected joint data
    Affected_list = Fuse_bitfield_2_bytearray(Affected_joint[:])
    test_list.append(Affected_list)

    # Inputs outputs data
    InOut_list = Fuse_bitfield_2_bytearray(InOut[:])
    test_list.append(InOut_list)

    # Timeout data
    test_list.append(bytes([Timeout]))

    # Gripper position
    Gripper_position = Split_2_3_bytes(Gripper_data[0])
    test_list.append(Gripper_position[2:4])

    # Gripper speed
    Gripper_speed = Split_2_3_bytes(Gripper_data[1])
    test_list.append(Gripper_speed[2:4])

    # Gripper current
    Gripper_current = Split_2_3_bytes(Gripper_data[2])
    test_list.append(Gripper_current[2:4])  

    # Gripper command
    test_list.append(bytes([Gripper_data[3]]))
    # Gripper mode
    test_list.append(bytes([Gripper_data[4]]))
    
    # ==========================================================
    # === FIX: Make sure calibrate is a one-shot command      ====
    # ==========================================================
    # If the mode was set to calibrate (1) or clear_error (2), reset it
    # back to normal (0) for the next cycle. This prevents an endless loop.
    if Gripper_data_out[4] == 1 or Gripper_data_out[4] == 2:
        Gripper_data_out[4] = 0
    # ==========================================================
    
    # Gripper ID
    test_list.append(bytes([Gripper_data[5]]))
 
    # CRC byte
    test_list.append(bytes([CRC_byte]))

    # END bytes
    test_list.append((end_bytes))
    
    #print(test_list)
    return test_list

def Get_data(Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):
    global input_byte 

    global start_cond1_byte 
    global start_cond2_byte 
    global start_cond3_byte 

    global end_cond1_byte 
    global end_cond2_byte 

    global start_cond1 
    global start_cond2 
    global start_cond3 

    global good_start 
    global data_len 

    global data_buffer 
    global data_counter

    while (ser.inWaiting() > 0):
        input_byte = ser.read()

        #UNCOMMENT THIS TO GET ALL DATA FROM THE ROBOT PRINTED
        #print(input_byte) 

        # When data len is received start is good and after that put all data in receive buffer
        # Data len is ALL data after it; that includes input buffer, end bytes and CRC
        if (good_start != 1):
            # All start bytes are good and next byte is data len
            if (start_cond1 == 1 and start_cond2 == 1 and start_cond3 == 1):
                good_start = 1
                data_len = input_byte
                data_len = struct.unpack('B', data_len)[0]
                logging.debug("data len we got from robot packet= ")
                logging.debug(input_byte)
                logging.debug("good start for DATA that we received at PC")
            # Third start byte is good
            if (input_byte == start_cond3_byte and start_cond2 == 1 and start_cond1 == 1):
                start_cond3 = 1
                #print("good cond 3 PC")
            #Third start byte is bad, reset all flags
            elif (start_cond2 == 1 and start_cond1 == 1):
                #print("bad cond 3 PC")
                start_cond1 = 0
                start_cond2 = 0
            # Second start byte is good
            if (input_byte == start_cond2_byte and start_cond1 == 1):
                start_cond2 = 1
                #print("good cond 2 PC ")
            #Second start byte is bad, reset all flags   
            elif (start_cond1 == 1):
                #print("Bad cond 2 PC")
                start_cond1 = 0
            # First start byte is good
            if (input_byte == start_cond1_byte):
                start_cond1 = 1
                #print("good cond 1 PC")
        else:
            # Here data goes after good  start
            data_buffer[data_counter] = input_byte
            if (data_counter == data_len - 1):

                logging.debug("Data len PC")
                logging.debug(data_len)
                logging.debug("End bytes are:")
                logging.debug(data_buffer[data_len -1])
                logging.debug(data_buffer[data_len -2])

                # Here if last 2 bytes are end condition bytes we process the data 
                if (data_buffer[data_len -1] == end_cond2_byte and data_buffer[data_len - 2] == end_cond1_byte):

                    logging.debug("GOOD END CONDITION PC")
                    logging.debug("I UNPACKED RAW DATA RECEIVED FROM THE ROBOT")
                    Unpack_data(data_buffer, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
                    XTR_data,Gripper_data_in)
                    logging.debug("DATA UNPACK FINISHED")
                    # ako su dobri izračunaj crc
                    # if crc dobar raspakiraj podatke
                    # ako je dobar paket je dobar i spremi ga u nove variable!
                
                # Print every byte
                #print("podaci u data bufferu su:")
                #for i in range(data_len):
                    #print(data_buffer[i])

                good_start = 0
                start_cond1 = 0
                start_cond3 = 0
                start_cond2 = 0
                data_len = 0
                data_counter = 0
            else:
                data_counter = data_counter + 1

# Split data to 3 bytes 
def Split_2_3_bytes(var_in):
    y = int_to_3_bytes(var_in & 0xFFFFFF) # converts my int value to bytes array
    return y

# Splits byte to bitfield list
def Split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]

# Fuses 3 bytes to 1 signed int
def Fuse_3_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<23:
        value -= 1<<24

    return value

# Fuses 2 bytes to 1 signed int
def Fuse_2_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<15:
        value -= 1<<16

    return value

# Fuse bitfield list to byte
def Fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Check if there is element 1 in the list. 
# If yes return its index, if no element is 1 return -1
def check_elements(lst):
    for i, element in enumerate(lst):
        if element == 1:
            return i
    return -1  # Return -1 if no element is 1

def quintic_scaling(s: float) -> float:
    """
    Calculates a smooth 0-to-1 scaling factor for progress 's'
    using a quintic polynomial, ensuring smooth start/end accelerations.
    """
    return 6 * (s**5) - 15 * (s**4) + 10 * (s**3)

#########################################################################
# Robot Commands Start Here
#########################################################################

class HomeCommand:
    """
    A non-blocking command that tells the robot to perform its internal homing sequence.
    This version uses a state machine to allow re-homing even if the robot is already homed.
    """
    def __init__(self):
        self.is_valid = True
        self.is_finished = False
        # State machine: START -> WAIT_FOR_UNHOMED -> WAIT_FOR_HOMED -> FINISHED
        self.state = "START"
        # Counter to send the home command for multiple cycles
        self.start_cmd_counter = 10  # Send command 100 for 10 cycles (0.1s)
        # Safety timeout (20 seconds at 0.01s interval)
        self.timeout_counter = 2000
        print("Initializing Home command...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Manages the homing command and monitors for completion using a state machine.
        """
        if self.is_finished:
            return True

        # --- State: START ---
        # On the first few executions, continuously send the 'home' (100) command.
        if self.state == "START":
            print(f"  -> Sending home signal (100)... Countdown: {self.start_cmd_counter}")
            Command_out.value = 100
            self.start_cmd_counter -= 1
            if self.start_cmd_counter <= 0:
                # Once sent for enough cycles, move to the next state
                self.state = "WAITING_FOR_UNHOMED"
            return False

        # --- State: WAITING_FOR_UNHOMED ---
        # The robot's firmware should reset the homed status. We wait to see that happen.
        # During this time, we send 'idle' (255) to let the robot's controller take over.
        if self.state == "WAITING_FOR_UNHOMED":
            Command_out.value = 255
            # Check if at least one joint has started homing (is no longer homed)
            if any(h == 0 for h in Homed_in[:6]):
                print("  -> Homing sequence initiated by robot.")
                self.state = "WAITING_FOR_HOMED"
            # Check for timeout
            self.timeout_counter -= 1
            if self.timeout_counter <= 0:
                print("  -> ERROR: Timeout waiting for robot to start homing sequence.")
                self.is_finished = True
            return self.is_finished

        # --- State: WAITING_FOR_HOMED ---
        # Now we wait for all joints to report that they are homed (all flags are 1).
        if self.state == "WAITING_FOR_HOMED":
            Command_out.value = 255
            # Check if all joints have finished homing
            if all(h == 1 for h in Homed_in[:6]):
                print("Homing sequence complete. All joints reported home.")
                self.is_finished = True
                Speed_out[:] = [0] * 6 # Ensure robot is stopped

        return self.is_finished

class JogCommand:
    """
    A non-blocking command to jog a joint for a specific duration or distance.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joint, speed_percentage=None, duration=None, distance_deg=None):
        """
        Initializes and validates the jog command. This is the SETUP phase.
        """
        self.is_valid = False
        self.is_finished = False
        self.mode = None
        self.command_step = 0

        # --- 1. Parameter Validation and Mode Selection ---
        if duration and distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Distance {distance_deg} deg, Duration {duration}s.")
        elif duration:
            self.mode = 'time'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Duration {duration}s.")
        elif distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Distance {distance_deg} deg.")
        else:
            print("Error: JogCommand requires either 'duration', 'distance_deg', or both.")
            return

        # --- 2. Store parameters for deferred calculation ---
        self.joint = joint
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.distance_deg = distance_deg

        # --- These will be calculated later ---
        self.direction = 1
        self.joint_index = 0
        self.speed_out = 0
        self.command_len = 0
        self.target_position = 0

        self.is_valid = True # Mark as valid for now; preparation step will confirm.


    def prepare_for_execution(self, current_position_in):
        """Pre-computes speeds and target positions using live data."""
        print(f"  -> Preparing for Jog command...")

        # Determine direction and joint index
        self.direction = 1 if 0 <= self.joint <= 5 else -1
        self.joint_index = self.joint if self.direction == 1 else self.joint - 6
        
        distance_steps = 0
        if self.distance_deg:
            distance_steps = int(PAROL6_ROBOT.DEG2STEPS(abs(self.distance_deg), self.joint_index))
            # --- MOVED LOGIC: Calculate target using the LIVE position ---
            self.target_position = current_position_in[self.joint_index] + (distance_steps * self.direction)
            
            min_limit, max_limit = PAROL6_ROBOT.Joint_limits_steps[self.joint_index]
            if not (min_limit <= self.target_position <= max_limit):
                print(f"  -> VALIDATION FAILED: Target position {self.target_position} is out of joint limits ({min_limit}, {max_limit}).")
                self.is_valid = False
                return

        # Calculate speed and duration
        speed_steps_per_sec = 0
        if self.mode == 'distance' and self.duration:
            speed_steps_per_sec = int(distance_steps / self.duration) if self.duration > 0 else 0
            max_joint_speed = PAROL6_ROBOT.Joint_max_speed[self.joint_index]
            if speed_steps_per_sec > max_joint_speed:
                print(f"  -> VALIDATION FAILED: Required speed ({speed_steps_per_sec} steps/s) exceeds joint's max speed ({max_joint_speed} steps/s).")
                self.is_valid = False
                return
        else:
            if self.speed_percentage is None:
                print("Error: 'speed_percentage' must be provided if not calculating automatically.")
                self.is_valid = False
                return
            speed_steps_per_sec = int(np.interp(abs(self.speed_percentage), [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[self.joint_index] * 2]))

        self.speed_out = speed_steps_per_sec * self.direction
        self.command_len = int(self.duration / INTERVAL_S) if self.duration else float('inf')
        print("  -> Jog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        stop_reason = None
        current_pos = Position_in[self.joint_index]

        if self.mode == 'time':
            if self.command_step >= self.command_len:
                stop_reason = "Timed jog finished."
        elif self.mode == 'distance':
            if (self.direction == 1 and current_pos >= self.target_position) or \
               (self.direction == -1 and current_pos <= self.target_position):
                stop_reason = "Distance jog finished."
        
        if not stop_reason:
            if (self.direction == 1 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][1]) or \
               (self.direction == -1 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][0]):
                stop_reason = f"Limit reached on joint {self.joint_index + 1}."

        if stop_reason:
            print(stop_reason)
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            Speed_out[:] = [0] * 6
            Speed_out[self.joint_index] = self.speed_out
            Command_out.value = 123
            self.command_step += 1
            return False
        
class MultiJogCommand:
    """
    A non-blocking command to jog multiple joints simultaneously for a specific duration.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joints, speed_percentages, duration):
        """
        Initializes and validates the multi-jog command.
        """
        self.is_valid = False
        self.is_finished = False
        self.command_step = 0

        # --- 1. Parameter Validation ---
        if not isinstance(joints, list) or not isinstance(speed_percentages, list):
            print("Error: MultiJogCommand requires 'joints' and 'speed_percentages' to be lists.")
            return

        if len(joints) != len(speed_percentages):
            print("Error: The number of joints must match the number of speed percentages.")
            return

        if not duration or duration <= 0:
            print("Error: MultiJogCommand requires a positive 'duration'.")
            return

        # ==========================================================
        # === NEW: Check for conflicting joint commands          ===
        # ==========================================================
        base_joints = set()
        for joint in joints:
            # Normalize the joint index to its base (0-5)
            base_joint = joint % 6
            # If the base joint is already in our set, it's a conflict.
            if base_joint in base_joints:
                print(f"  -> VALIDATION FAILED: Conflicting commands for Joint {base_joint + 1} (e.g., J1+ and J1-).")
                self.is_valid = False
                return
            base_joints.add(base_joint)
        # ==========================================================

        print(f"Initializing MultiJog for joints {joints} with speeds {speed_percentages}% for {duration}s.")

        # --- 2. Store parameters ---
        self.joints = joints
        self.speed_percentages = speed_percentages
        self.duration = duration
        self.command_len = int(self.duration / INTERVAL_S)

        # --- This will be calculated in the prepare step ---
        self.speeds_out = [0] * 6

        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Pre-computes the speeds for each joint."""
        print(f"  -> Preparing for MultiJog command...")

        for i, joint in enumerate(self.joints):
            # Determine direction and joint index (0-5 for positive, 6-11 for negative)
            direction = 1 if 0 <= joint <= 5 else -1
            joint_index = joint if direction == 1 else joint - 6
            speed_percentage = self.speed_percentages[i]

            # Check for joint index validity
            if not (0 <= joint_index < 6):
                print(f"  -> VALIDATION FAILED: Invalid joint index {joint_index}.")
                self.is_valid = False
                return

            # Calculate speed in steps/sec
            speed_steps_per_sec = int(np.interp(speed_percentage, [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[joint_index]]))
            self.speeds_out[joint_index] = speed_steps_per_sec * direction

        print("  -> MultiJog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        # Stop if the duration has elapsed
        if self.command_step >= self.command_len:
            print("Timed multi-jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            # Continuously check for joint limits during the jog
            for i in range(6):
                if self.speeds_out[i] != 0:
                    current_pos = Position_in[i]
                    # Hitting positive limit while moving positively
                    if self.speeds_out[i] > 0 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[i][1]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True
                    # Hitting negative limit while moving negatively
                    elif self.speeds_out[i] < 0 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[i][0]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True

            # If no limits are hit, apply the speeds
            Speed_out[:] = self.speeds_out
            Command_out.value = 123 # Jog command
            self.command_step += 1
            return False # Command is still running
        
# This dictionary maps descriptive axis names to movement vectors, which is cleaner.
# Format: ([x, y, z], [rx, ry, rz])
AXIS_MAP = {
    'X+': ([1, 0, 0], [0, 0, 0]), 'X-': ([-1, 0, 0], [0, 0, 0]),
    'Y+': ([0, 1, 0], [0, 0, 0]), 'Y-': ([0, -1, 0], [0, 0, 0]),
    'Z+': ([0, 0, 1], [0, 0, 0]), 'Z-': ([0, 0, -1], [0, 0, 0]),
    'RX+': ([0, 0, 0], [1, 0, 0]), 'RX-': ([0, 0, 0], [-1, 0, 0]),
    'RY+': ([0, 0, 0], [0, 1, 0]), 'RY-': ([0, 0, 0], [0, -1, 0]),
    'RZ+': ([0, 0, 0], [0, 0, 1]), 'RZ-': ([0, 0, 0], [0, 0, -1]),
}

class CartesianJogCommand:
    """
    A non-blocking command to jog the robot's end-effector in Cartesian space.
    This is the final, refactored version using clean, standard spatial math
    operations now that the core unit bug has been fixed.
    """
    def __init__(self, frame, axis, speed_percentage=50, duration=1.5, **kwargs):
        """
        Initializes and validates the Cartesian jog command.
        """
        self.is_valid = False
        self.is_finished = False
        print(f"Initializing CartesianJog: Frame {frame}, Axis {axis}...")

        if axis not in AXIS_MAP:
            print(f"  -> VALIDATION FAILED: Invalid axis '{axis}'.")
            return
        
        # Store all necessary parameters for use in execute_step
        self.frame = frame
        self.axis_vectors = AXIS_MAP[axis]
        self.is_rotation = any(self.axis_vectors[1])
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.end_time = time.time() + self.duration
        
        self.is_valid = True
        print("  -> Command is valid and ready.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Check for completion ---
        if time.time() >= self.end_time:
            print("Cartesian jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- B. Calculate Target Pose using clean vector math ---
        Command_out.value = 123 # Set jog command
        
        q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        T_current = PAROL6_ROBOT.robot.fkine(q_current)

        if not isinstance(T_current, SE3):
            return False # Wait for valid pose data

        # Calculate speed and displacement for this cycle
        linear_speed_ms = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min_JOG, PAROL6_ROBOT.Cartesian_linear_velocity_max_JOG]))
        angular_speed_degs = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max]))

        delta_linear = linear_speed_ms * INTERVAL_S
        delta_angular_rad = np.deg2rad(angular_speed_degs * INTERVAL_S)

        # Create the small incremental transformation (delta_pose)
        trans_vec = np.array(self.axis_vectors[0]) * delta_linear
        rot_vec = np.array(self.axis_vectors[1]) * delta_angular_rad
        delta_pose = SE3.Rt(SE3.Eul(rot_vec).R, trans_vec)

        # Apply the transformation in the correct reference frame
        if self.frame == 'WRF':
            # Pre-multiply to apply the change in the World Reference Frame
            target_pose = delta_pose * T_current
        else: # TRF
            # Post-multiply to apply the change in the Tool Reference Frame
            target_pose = T_current * delta_pose
        
        # --- C. Solve IK and Calculate Velocities ---
        var = solve_ik_with_adaptive_tol_subdivision(PAROL6_ROBOT.robot, target_pose, q_current, jogging=True)

        if var.success:
            q_velocities = (var.q - q_current) / INTERVAL_S
            for i in range(6):
                Speed_out[i] = int(PAROL6_ROBOT.SPEED_RAD2STEP(q_velocities[i], i))
        else:
            print("IK Warning: Could not find solution for jog step. Stopping.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- D. Speed Scaling ---
        max_scale_factor = 1.0
        for i in range(6):
            if abs(Speed_out[i]) > PAROL6_ROBOT.Joint_max_speed[i]:
                scale = abs(Speed_out[i]) / PAROL6_ROBOT.Joint_max_speed[i]
                if scale > max_scale_factor:
                    max_scale_factor = scale
        
        if max_scale_factor > 1.0:
            for i in range(6):
                Speed_out[i] = int(Speed_out[i] / max_scale_factor)

        return False # Command is still running

class MovePoseCommand:
    """
    A non-blocking command to move the robot to a specific Cartesian pose.
    The movement itself is a joint-space interpolation.
    """
    def __init__(self, pose, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = True  # Assume valid; preparation step will confirm.
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MovePose to {pose}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.pose = pose
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

    """
        Initializes, validates, and pre-computes the trajectory for a move-to-pose command.

        Args:
            pose (list): A list of 6 values [x, y, z, r, p, y] for the target pose.
                         Positions are in mm, rotations are in degrees.
            duration (float, optional): The total time for the movement in seconds.
            velocity_percent (float, optional): The target velocity as a percentage (0-100).
            accel_percent (float, optional): The target acceleration as a percentage (0-100).
            trajectory_type (str, optional): The type of trajectory ('poly' or 'trap').
        """
    
    def prepare_for_execution(self, current_position_in):
        """Calculates the full trajectory just-in-time before execution."""
        print(f"  -> Preparing trajectory for MovePose to {self.pose}...")

        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pose = SE3(self.pose[0] / 1000.0, self.pose[1] / 1000.0, self.pose[2] / 1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')
        
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_pose, initial_pos_rad, ilimit=100)

        if not ik_solution.success:
            print("  -> VALIDATION FAILED: Inverse kinematics failed at execution time.")
            self.is_valid = False
            return

        target_pos_rad = ik_solution.q

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])

                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue
                    
                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)
            
                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                self.is_valid = False
                return

        else:
            print("  -> Using conservative values for MovePose.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveJointCommand:
    """
    A non-blocking command to move the robot's joints to a specific configuration.
    It pre-calculates the entire trajectory upon initialization.
    """
    def __init__(self, target_angles, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = False  # Will be set to True after basic validation
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MoveJoint to {target_angles}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.target_angles = target_angles
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

        # --- Perform only state-independent validation ---
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])
        for i in range(6):
            min_rad, max_rad = PAROL6_ROBOT.Joint_limits_radian[i]
            if not (min_rad <= target_pos_rad[i] <= max_rad):
                print(f"  -> VALIDATION FAILED: Target for Joint {i+1} ({self.target_angles[i]} deg) is out of range.")
                return
        
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Calculates the trajectory just before execution begins."""
        print(f"  -> Preparing trajectory for MoveJoint to {self.target_angles}...")
        
        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])
                
                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue

                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)

                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                print(f"  -> Please check Joint_min/max_speed and Joint_min/max_acc values in PAROL6_ROBOT.py.")
                self.is_valid = False
                return
        
        else:
            print("  -> Using conservative values for MoveJoint.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveCartCommand:
    """
    A non-blocking command to move the robot's end-effector in a straight line
    in Cartesian space, completing the move in an exact duration.

    It works by:
    1. Pre-validating the final target pose.
    2. Interpolating the pose in Cartesian space in real-time.
    3. Solving Inverse Kinematics for each intermediate step to ensure path validity.
    """
    def __init__(self, pose, duration=None, velocity_percent=None):
        self.is_valid = False
        self.is_finished = False

        # --- MODIFICATION: Validate that at least one timing parameter is given ---
        if duration is None and velocity_percent is None:
            print("  -> VALIDATION FAILED: MoveCartCommand requires either 'duration' or 'velocity_percent'.")
            return
        if duration is not None and velocity_percent is not None:
            print("  -> INFO: Both duration and velocity_percent provided. Using duration.")
            self.velocity_percent = None # Prioritize duration
        else:
            self.velocity_percent = velocity_percent

        # --- Store parameters and set placeholders ---
        self.duration = duration
        self.pose = pose
        self.start_time = None
        self.initial_pose = None
        self.target_pose = None
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Captures the initial state and validates the path just before execution."""
        print(f"  -> Preparing for MoveCart to {self.pose}...")
        
        # --- MOVED LOGIC: Capture initial state from live data ---
        initial_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        self.initial_pose = PAROL6_ROBOT.robot.fkine(initial_q_rad)
        self.target_pose = SE3(self.pose[0]/1000.0, self.pose[1]/1000.0, self.pose[2]/1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')

        print("  -> Pre-validating final target pose...")
        ik_check = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, self.target_pose, initial_q_rad
        )

        if not ik_check.success:
            print("  -> VALIDATION FAILED: The final target pose is unreachable.")
            if ik_check.violations:
                print(f"     Reason: Solution violates joint limits: {ik_check.violations}")
            self.is_valid = False # Mark as invalid if path fails
            return

        # --- NEW BLOCK: Calculate duration from velocity if needed ---
        if self.velocity_percent is not None:
            print(f"  -> Calculating duration for {self.velocity_percent}% speed...")
            # Calculate the total distance for translation and rotation
            linear_distance = np.linalg.norm(self.target_pose.t - self.initial_pose.t)
            angular_distance_rad = self.initial_pose.angdist(self.target_pose)

            # Interpolate the target speeds from percentages, assuming constants exist in PAROL6_ROBOT
            target_linear_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min, PAROL6_ROBOT.Cartesian_linear_velocity_max])
            target_angular_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max])
            target_angular_speed_rad = np.deg2rad(target_angular_speed)

            # Calculate time required for each component of the movement
            time_linear = linear_distance / target_linear_speed if target_linear_speed > 0 else 0
            time_angular = angular_distance_rad / target_angular_speed_rad if target_angular_speed_rad > 0 else 0

            # The total duration is the longer of the two times to ensure synchronization
            calculated_duration = max(time_linear, time_angular)

            if calculated_duration <= 0:
                print("  -> INFO: MoveCart has zero duration. Marking as finished.")
                self.is_finished = True
                self.is_valid = True # It's valid, just already done.
                return

            self.duration = calculated_duration
            print(f"  -> Calculated MoveCart duration: {self.duration:.2f}s")

        print("  -> Command is valid and ready for execution.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        if self.start_time is None:
            self.start_time = time.time()

        elapsed_time = time.time() - self.start_time
        s = min(elapsed_time / self.duration, 1.0)
        s_scaled = quintic_scaling(s)

        current_target_pose = self.initial_pose.interp(self.target_pose, s_scaled)

        current_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, current_target_pose, current_q_rad
        )

        if not ik_solution.success:
            print("  -> ERROR: MoveCart failed. An intermediate point on the path is unreachable.")
            if ik_solution.violations:
                 print(f"     Reason: Path violates joint limits: {ik_solution.violations}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        current_pos_rad = ik_solution.q

        # --- MODIFIED BLOCK ---
        # Send only the target position and let the firmware's P-controller handle speed.
        Position_out[:] = [int(PAROL6_ROBOT.RAD2STEPS(p, i)) for i, p in enumerate(current_pos_rad)]
        Speed_out[:] = [0] * 6 # Set feed-forward velocity to zero for smooth P-control.
        Command_out.value = 156
        # --- END MODIFIED BLOCK ---

        if s >= 1.0:
            print(f"MoveCart finished in ~{elapsed_time:.2f}s.")
            self.is_finished = True
            # The main loop will handle holding the final position.

        return self.is_finished
        
class GripperCommand:
    """
    A single, unified, non-blocking command to control all gripper functions.
    It internally selects the correct logic (position-based waiting, timed delay,
    or instantaneous) based on the specified action.
    """
    def __init__(self, gripper_type, action=None, position=100, speed=100, current=500, output_port=1):
        """
        Initializes the Gripper command and configures its internal state machine
        based on the requested action.
        """
        self.is_valid = True
        self.is_finished = False
        self.gripper_type = gripper_type.lower()
        self.action = action.lower() if action else 'move'
        self.state = "START"
        self.timeout_counter = 1000 # 10-second safety timeout for all waiting states

        # --- Configure based on Gripper Type and Action ---
        if self.gripper_type == 'electric':
            if self.action == 'move':
                self.target_position = position
                self.speed = speed
                self.current = current
                if not (0 <= position <= 255 and 0 <= speed <= 255 and 100 <= current <= 1000):
                    self.is_valid = False
            elif self.action == 'calibrate':
                self.wait_counter = 200 # 2-second fixed delay for calibration
            else:
                self.is_valid = False # Invalid action

        elif self.gripper_type == 'pneumatic':
            if self.action not in ['open', 'close']:
                self.is_valid = False
            self.state_to_set = 1 if self.action == 'open' else 0
            self.port_index = 2 if output_port == 1 else 3
        else:
            self.is_valid = False

        if not self.is_valid:
            print(f"  -> VALIDATION FAILED for GripperCommand with action: '{self.action}'")

    def execute_step(self, Gripper_data_out, InOut_out, Gripper_data_in, InOut_in, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        self.timeout_counter -= 1
        if self.timeout_counter <= 0:
            print(f"  -> ERROR: Gripper command timed out in state {self.state}.")
            self.is_finished = True
            return True

        # --- Pneumatic Logic (Instantaneous) ---
        if self.gripper_type == 'pneumatic':
            InOut_out[self.port_index] = self.state_to_set
            print("  -> Pneumatic gripper command sent.")
            self.is_finished = True
            return True

        # --- Electric Gripper Logic ---
        if self.gripper_type == 'electric':
            # On the first run, transition to the correct state for the action
            if self.state == "START":
                if self.action == 'calibrate':
                    self.state = "SEND_CALIBRATE"
                else: # 'move'
                    self.state = "WAIT_FOR_POSITION"
            
            # --- Calibrate Logic (Timed Delay) ---
            if self.state == "SEND_CALIBRATE":
                print("  -> Sending one-shot calibrate command...")
                Gripper_data_out[4] = 1 # Set mode to calibrate
                self.state = "WAITING_CALIBRATION"
                return False

            if self.state == "WAITING_CALIBRATION":
                self.wait_counter -= 1
                if self.wait_counter <= 0:
                    print("  -> Calibration delay finished.")
                    Gripper_data_out[4] = 0 # Reset to operation mode
                    self.is_finished = True
                    return True
                return False

            # --- Move Logic (Position-Based) ---
            if self.state == "WAIT_FOR_POSITION":
                # Persistently send the move command
                Gripper_data_out[0], Gripper_data_out[1], Gripper_data_out[2] = self.target_position, self.speed, self.current
                Gripper_data_out[4] = 0 # Operation mode
                bitfield = [1, 1, not InOut_in[4], 1, 0, 0, 0, 0]
                fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                Gripper_data_out[3] = int(fused.hex(), 16)

                # Check for completion
                current_position = Gripper_data_in[1]
                if abs(current_position - self.target_position) <= 5:
                    print(f"  -> Gripper move complete.")
                    self.is_finished = True
                    # Set command back to idle
                    bitfield = [1, 0, not InOut_in[4], 1, 0, 0, 0, 0]
                    fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                    Gripper_data_out[3] = int(fused.hex(), 16)
                    return True
                return False
        
        return self.is_finished

class DelayCommand:
    """
    A non-blocking command that pauses execution for a specified duration.
    During the delay, it ensures the robot remains idle by sending the
    appropriate commands.
    """
    def __init__(self, duration):
        """
        Initializes and validates the Delay command.

        Args:
            duration (float): The delay time in seconds.
        """
        self.is_valid = False
        self.is_finished = False

        # --- 1. Parameter Validation ---
        if not isinstance(duration, (int, float)) or duration <= 0:
            print(f"  -> VALIDATION FAILED: Delay duration must be a positive number, but got {duration}.")
            return

        print(f"Initializing Delay for {duration} seconds...")
        
        self.duration = duration
        self.end_time = None  # Will be set in prepare_for_execution
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Set the end time when the command actually starts."""
        self.end_time = time.time() + self.duration
        print(f"  -> Delay starting for {self.duration} seconds...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Checks if the delay duration has passed and keeps the robot idle.
        This method is called on every loop cycle (~0.01s).
        """
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Keep the robot idle during the delay ---
        Command_out.value = 255  # Set command to idle
        Speed_out[:] = [0] * 6   # Set all speeds to zero

        # --- B. Check for completion ---
        if self.end_time and time.time() >= self.end_time:
            print(f"Delay finished after {self.duration} seconds.")
            self.is_finished = True
        
        return self.is_finished
    
#########################################################################
# Smooth Motion Commands Start Here
#########################################################################
    
class BaseSmoothMotionCommand:
    """
    Base class for all smooth motion commands with proper error tracking.
    """
    
    def __init__(self, description="smooth motion"):
        self.description = description
        self.trajectory = None
        self.trajectory_command = None
        self.transition_command = None
        self.is_valid = True
        self.is_finished = False
        self.specified_start_pose = None
        self.transition_complete = False
        self.trajectory_prepared = False
        self.error_state = False
        self.error_message = ""
        self.trajectory_generated = False  # NEW: Track if trajectory is generated
        
    def create_transition_command(self, current_pose, target_pose):
        """Create a MovePose command for smooth transition to start position."""
        pos_error = np.linalg.norm(
            np.array(target_pose[:3]) - np.array(current_pose[:3])
        )
        
        # Lower threshold to 2mm for more aggressive transition generation
        if pos_error < 2.0:  # Changed from 5.0mm to 2.0mm
            print(f"  -> Already near start position (error: {pos_error:.1f}mm)")
            return None
        
        print(f"  -> Creating smooth transition to start ({pos_error:.1f}mm away)")
        
        # Calculate transition speed based on distance
        # Slower for short distances, faster for long distances
        if pos_error < 10:
            transition_speed = 20.0  # mm/s for short distances
        elif pos_error < 30:
            transition_speed = 30.0  # mm/s for medium distances
        else:
            transition_speed = 40.0  # mm/s for long distances
        
        transition_duration = max(pos_error / transition_speed, 0.5)  # Minimum 0.5s
        
        transition_cmd = MovePoseCommand(
            pose=target_pose,
            duration=transition_duration
        )
        
        return transition_cmd
    
    def get_current_pose_from_position(self, position_in):
        """Convert current position to pose [x,y,z,rx,ry,rz]"""
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(position_in)])
        current_pose_se3 = PAROL6_ROBOT.robot.fkine(current_q)
        
        current_xyz = current_pose_se3.t * 1000  # Convert to mm
        current_rpy = current_pose_se3.rpy(unit='deg', order='xyz')
        return np.concatenate([current_xyz, current_rpy]).tolist()
        
    def prepare_for_execution(self, current_position_in):
        """Minimal preparation - just check if we need a transition."""
        print(f"  -> Preparing {self.description}...")
        
        # If there's a specified start pose, prepare transition
        if self.specified_start_pose:
            actual_current_pose = self.get_current_pose_from_position(current_position_in)
            self.transition_command = self.create_transition_command(
                actual_current_pose, self.specified_start_pose
            )
            
            if self.transition_command:
                self.transition_command.prepare_for_execution(current_position_in)
                if not self.transition_command.is_valid:
                    print(f"  -> ERROR: Cannot reach specified start position")
                    self.is_valid = False
                    self.error_state = True
                    self.error_message = "Cannot reach specified start position"
                    return
        else:
            self.transition_command = None
            
        # DON'T generate trajectory yet - wait until execution
        self.trajectory_generated = False
        self.trajectory_prepared = False
        print(f"  -> {self.description} preparation complete (trajectory will be generated at execution)")
            
    def generate_main_trajectory(self, effective_start_pose):
        """Override this in subclasses to generate the specific motion trajectory."""
        raise NotImplementedError("Subclasses must implement generate_main_trajectory")
        
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """Execute transition first if needed, then generate and execute trajectory."""
        if self.is_finished or not self.is_valid:
            return True
        
        # Execute transition first if needed
        if self.transition_command and not self.transition_complete:
            is_done = self.transition_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            if is_done:
                print(f"  -> Transition complete")
                self.transition_complete = True
            return False
        
        # Generate trajectory on first execution step (not during preparation!)
        if not self.trajectory_generated:
            # Get ACTUAL current position NOW
            actual_current_pose = self.get_current_pose_from_position(Position_in)
            print(f"  -> Generating {self.description} from ACTUAL position: {[round(p, 1) for p in actual_current_pose[:3]]}")
            
            # Generate trajectory from where we ACTUALLY are
            self.trajectory = self.generate_main_trajectory(actual_current_pose)
            self.trajectory_command = SmoothTrajectoryCommand(
                self.trajectory, self.description
            )
            
            # Quick validation of first point only
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(Position_in)])
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
            )
            
            if not ik_result.success:
                print(f"  -> ERROR: Cannot reach first trajectory point")
                self.is_finished = True
                self.error_state = True
                self.error_message = "Cannot reach trajectory start"
                Speed_out[:] = [0] * 6
                Command_out.value = 255
                return True
                
            self.trajectory_generated = True
            self.trajectory_prepared = True
            
            # Verify first point is close to current
            distance = np.linalg.norm(first_pose[:3] - np.array(actual_current_pose[:3]))
            if distance > 5.0:
                print(f"  -> WARNING: First trajectory point {distance:.1f}mm from current!")
        
        # Execute main trajectory
        if self.trajectory_command and self.trajectory_prepared:
            is_done = self.trajectory_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            # Check for errors in trajectory execution
            if hasattr(self.trajectory_command, 'error_state') and self.trajectory_command.error_state:
                self.error_state = True
                self.error_message = self.trajectory_command.error_message
            
            if is_done:
                self.is_finished = True
            
            return is_done
        else:
            self.is_finished = True
            return True

class SmoothTrajectoryCommand:
    """Command class for executing pre-generated smooth trajectories."""
    
    def __init__(self, trajectory, description="smooth motion"):
        self.trajectory = np.array(trajectory)
        self.description = description
        self.trajectory_index = 0
        self.is_valid = True
        self.is_finished = False
        self.first_step = True
        self.error_state = False
        self.error_message = ""
        
        print(f"Initializing smooth {description} with {len(trajectory)} points")
    
    def prepare_for_execution(self, current_position_in):
        """Skip validation - trajectory is already generated from correct position"""
        # No validation needed since trajectory was just generated from current position
        self.is_valid = True
        return
    
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, Position_out=None, **kwargs):
        """Execute one step of the smooth trajectory"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Get Position_out from kwargs if not provided
        if Position_out is None:
            Position_out = kwargs.get('Position_out', Position_in)
        
        if self.trajectory_index >= len(self.trajectory):
            print(f"Smooth {self.description} finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get target pose for this step
        target_pose = self.trajectory[self.trajectory_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                            for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
        )
        
        if not ik_result.success:
            print(f"  -> IK failed at trajectory point {self.trajectory_index}")
            self.is_finished = True
            self.error_state = True
            self.error_message = f"IK failed at point {self.trajectory_index}/{len(self.trajectory)}"
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                    for i, q in enumerate(ik_result.q)]
        
        # ADD VELOCITY LIMITING - This prevents violent movements
        if self.trajectory_index > 0:
            for i in range(6):
                step_diff = abs(target_steps[i] - Position_in[i])
                max_step_diff = PAROL6_ROBOT.Joint_max_speed[i] * 0.01  # Max steps in 10ms
                
                # Use 1.2x safety margin (not 2x as before)
                if step_diff > max_step_diff * 1.2:
                    #print(f"  -> WARNING: Joint {i+1} velocity limit exceeded at point {self.trajectory_index}")
                    #print(f"     Step difference: {step_diff}, Max allowed: {max_step_diff * 1.2:.1f}")
                    
                    # Clamp the motion
                    sign = 1 if target_steps[i] > Position_in[i] else -1
                    target_steps[i] = Position_in[i] + sign * int(max_step_diff)
        
        # Send position command
        Position_out[:] = target_steps
        Speed_out[:] = [0] * 6
        Command_out.value = 156
        
        # Advance to next point
        self.trajectory_index += 1
        
        return False

class SmoothCircleCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, plane, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"circle (r={radius}mm, {frame})")
        self.center = center
        self.radius = radius
        self.plane = plane
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame  # Store reference frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None  # Store for TRF transformation
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        # Store current position for potential use in generate_main_trajectory
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'center': self.center,
                'plane': self.plane
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_CIRCLE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Circle: center {self.center[:3]} (WRF), normal {self.normal_vector}")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_CIRCLE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        # Now do normal preparation with transformed parameters
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate circle starting from the actual start position."""
        motion_gen = CircularMotion()
        
        # Use transformed normal for TRF, or standard for WRF
        if self.normal_vector is not None:
            # TRF - use the transformed normal vector
            normal = np.array(self.normal_vector)
            print(f"    Using transformed normal: {normal.round(3)}")
        else:
            # WRF - use standard plane definition
            plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
            normal = np.array(plane_normals.get(self.plane, [0, 0, 1]))  # Convert to numpy array
            print(f"    Using WRF plane {self.plane} with normal: {normal}")
        
        print(f"    Generating circle from position: {[round(p, 1) for p in effective_start_pose[:3]]}")
        print(f"    Circle center: {[round(c, 1) for c in self.center]}")
        
        # Add geometry validation
        center_np = np.array(self.center)
        start_np = np.array(effective_start_pose[:3])
        
        # Project start point onto circle plane to check distance
        to_start = start_np - center_np
        to_start_plane = to_start - np.dot(to_start, normal) * normal
        distance_to_center = np.linalg.norm(to_start_plane)
        
        if abs(distance_to_center - self.radius) > self.radius * 0.3:
            print(f"    WARNING: Robot is {distance_to_center:.1f}mm from center, but radius is {self.radius:.1f}mm")
            print(f"    Circle geometry will be auto-corrected")
        
        # Generate circle that starts at effective_start_pose
        trajectory = motion_gen.generate_circle_3d(
            self.center, 
            self.radius, 
            normal,  # This normal now correctly represents the plane
            start_point=effective_start_pose[:3],
            duration=self.duration
        )
        
        if self.clockwise:
            trajectory = trajectory[::-1]
        
        # Update orientations to match start pose
        for i in range(len(trajectory)):
            trajectory[i][3:] = effective_start_pose[3:]
        
        return trajectory
    
class SmoothArcCenterCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, center, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"arc (center-based, {frame})")
        self.end_pose = end_pose
        self.center = center
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {
                'end_pose': self.end_pose,
                'center': self.center
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
            )
            self.end_pose = transformed['end_pose']
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc from actual start to end."""
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, self.center,
            normal=self.normal_vector,  # Use transformed normal if TRF
            clockwise=self.clockwise, duration=self.duration
        )
    
class SmoothArcParamCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, radius, arc_angle, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"parametric arc (r={radius}mm, θ={arc_angle}°, {frame})")
        self.end_pose = end_pose
        self.radius = radius
        self.arc_angle = arc_angle
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'end_pose': self.end_pose,
                'plane': 'XY'  # Default plane for parametric arc
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.end_pose = transformed['end_pose']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Parametric Arc: end {self.end_pose[:3]} (WRF)")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc based on radius and angle from actual start."""
        # Get start and end positions
        start_xyz = np.array(effective_start_pose[:3])
        end_xyz = np.array(self.end_pose[:3])
        
        # If we have a transformed normal (TRF), use it to define the arc plane
        if self.normal_vector is not None:
            normal = np.array(self.normal_vector)
            
            # Project start and end onto the plane perpendicular to normal
            # This ensures the arc stays in the correct plane for TRF
            
            # Find center of arc using radius and angle
            chord_vec = end_xyz - start_xyz
            chord_length = np.linalg.norm(chord_vec)
            
            if chord_length > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({chord_length:.1f}mm) for radius {self.radius}mm")
                self.radius = chord_length / 2 + 1
            
            # Calculate center position using the normal vector
            chord_mid = (start_xyz + end_xyz) / 2
            
            # Height from chord midpoint to arc center
            if chord_length > 0:
                h = np.sqrt(max(0, self.radius**2 - (chord_length/2)**2))
                
                # Find perpendicular in the plane defined by normal
                chord_dir = chord_vec / chord_length
                perp_in_plane = np.cross(normal, chord_dir)
                if np.linalg.norm(perp_in_plane) > 0.001:
                    perp_in_plane = perp_in_plane / np.linalg.norm(perp_in_plane)
                else:
                    # Chord is parallel to normal (shouldn't happen)
                    perp_in_plane = np.array([1, 0, 0])
                
                # Arc center
                if self.clockwise:
                    center_3d = chord_mid - h * perp_in_plane
                else:
                    center_3d = chord_mid + h * perp_in_plane
            else:
                center_3d = start_xyz
            
        else:
            # WRF - use XY plane (standard behavior)
            normal = np.array([0, 0, 1])
            
            # Calculate arc center in XY plane
            start_xy = start_xyz[:2]
            end_xy = end_xyz[:2]
            
            # Midpoint
            mid = (start_xy + end_xy) / 2
            
            # Distance between points
            d = np.linalg.norm(end_xy - start_xy)
            
            if d > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({d:.1f}mm) for radius {self.radius}mm")
                self.radius = d / 2 + 1
            
            # Height of arc center from midpoint
            h = np.sqrt(max(0, self.radius**2 - (d/2)**2))
            
            # Perpendicular direction
            if d > 0:
                perp = np.array([-(end_xy[1] - start_xy[1]), end_xy[0] - start_xy[0]])
                perp = perp / np.linalg.norm(perp)
            else:
                perp = np.array([1, 0])
            
            # Arc center (choose based on clockwise)
            if self.clockwise:
                center_2d = mid - h * perp
            else:
                center_2d = mid + h * perp
            
            # Use average Z for center
            center_3d = [center_2d[0], center_2d[1], (start_xyz[2] + end_xyz[2]) / 2]
        
        # Generate arc trajectory from actual start
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, center_3d.tolist(),
            normal=normal if self.normal_vector is not None else None,
            clockwise=self.clockwise, duration=self.duration
        )

class SmoothHelixCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, pitch, height, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"helix (h={height}mm, {frame})")
        self.center = center
        self.radius = radius
        self.pitch = pitch
        self.height = height
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.helix_axis = None
        self.up_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {'center': self.center}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_HELIX', params, 'TRF', current_position_in
            )
            self.center = transformed['center']
            self.helix_axis = transformed.get('helix_axis', [0, 0, 1])
            self.up_vector = transformed.get('up_vector', [0, 1, 0])
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_HELIX', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate helix with proper axis orientation."""
        num_revolutions = self.height / self.pitch if self.pitch > 0 else 1
        num_points = int(self.duration * 100)  # 100Hz
        
        # Get helix axis (default Z for WRF, transformed for TRF)
        if self.helix_axis is not None:
            axis = np.array(self.helix_axis)
        else:
            axis = np.array([0, 0, 1])  # Default vertical
        
        # Create orthonormal basis for helix
        if self.up_vector is not None:
            up = np.array(self.up_vector)
        else:
            # Find perpendicular to axis
            if abs(axis[2]) < 0.9:
                up = np.array([0, 0, 1])
            else:
                up = np.array([1, 0, 0])
        
        # Ensure up is perpendicular to axis
        up = up - np.dot(up, axis) * axis
        up = up / np.linalg.norm(up)
        
        # Create right vector
        right = np.cross(axis, up)
        
        # Calculate starting angle based on actual start position
        to_start = np.array(effective_start_pose[:3]) - np.array(self.center)
        # Project onto plane perpendicular to axis
        to_start_plane = to_start - np.dot(to_start, axis) * axis
        
        if np.linalg.norm(to_start_plane) > 0.001:
            to_start_normalized = to_start_plane / np.linalg.norm(to_start_plane)
            start_angle = np.arctan2(np.dot(to_start_normalized, up), 
                                    np.dot(to_start_normalized, right))
        else:
            start_angle = 0
        
        trajectory = []
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            
            angle = start_angle + 2 * np.pi * num_revolutions * t
            if self.clockwise:
                angle = start_angle - 2 * np.pi * num_revolutions * t
            
            # Position on helix
            pos = np.array(self.center) + \
                  self.radius * (np.cos(angle) * right + np.sin(angle) * up) + \
                  self.height * t * axis
            
            # Use orientation from effective start
            trajectory.append(np.concatenate([pos, effective_start_pose[3:]]))
        
        return np.array(trajectory)

class SmoothSplineCommand(BaseSmoothMotionCommand):
    def __init__(self, waypoints, duration, frame='WRF', start_pose=None):
        super().__init__(f"spline ({len(waypoints)} points, {frame})")
        self.waypoints = waypoints
        self.duration = duration
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform waypoints to WRF
            params = {'waypoints': self.waypoints}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_SPLINE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.waypoints = transformed['waypoints']
            
            print(f"  -> TRF Spline: transformed {len(self.waypoints)} waypoints to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_SPLINE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate spline starting from actual position."""
        motion_gen = SplineMotion()
        
        # Always start from the effective start pose
        first_wp_error = np.linalg.norm(
            np.array(self.waypoints[0][:3]) - np.array(effective_start_pose[:3])
        )
        
        if first_wp_error > 5.0:
            # First waypoint is far, prepend the start position
            modified_waypoints = [effective_start_pose] + self.waypoints
            print(f"    Added start position as first waypoint (distance: {first_wp_error:.1f}mm)")
        else:
            # Replace first waypoint with actual start to ensure continuity
            modified_waypoints = [effective_start_pose] + self.waypoints[1:]
            print(f"    Replaced first waypoint with actual start position")
        
        timestamps = np.linspace(0, self.duration, len(modified_waypoints))
        
        # Generate the spline trajectory
        trajectory = motion_gen.generate_cubic_spline(modified_waypoints, timestamps)
        
        print(f"    Generated spline with {len(trajectory)} points")
        
        return trajectory

class SmoothBlendCommand(BaseSmoothMotionCommand):
    def __init__(self, segment_definitions, blend_time, frame='WRF', start_pose=None):
        super().__init__(f"blended ({len(segment_definitions)} segments, {frame})")
        self.segment_definitions = segment_definitions
        self.blend_time = blend_time
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform all segment definitions to WRF
            params = {'segments': self.segment_definitions}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_BLEND', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.segment_definitions = transformed['segments']
            
            print(f"  -> TRF Blend: transformed {len(self.segment_definitions)} segments to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_BLEND', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate blended trajectory starting from actual position."""
        trajectories = []
        motion_gen_circle = CircularMotion()
        motion_gen_spline = SplineMotion()
        
        # Always start from effective start pose
        last_end_pose = effective_start_pose
        
        for i, seg_def in enumerate(self.segment_definitions):
            seg_type = seg_def['type']
            
            # First segment always starts from effective_start_pose
            segment_start = effective_start_pose if i == 0 else last_end_pose
            
            if seg_type == 'LINE':
                end = seg_def['end']
                duration = seg_def['duration']
                
                # Generate line segment from actual position
                num_points = int(duration * 100)
                timestamps = np.linspace(0, duration, num_points)
                
                traj = []
                for t in timestamps:
                    s = t / duration if duration > 0 else 1
                    # Interpolate position
                    pos = [
                        segment_start[j] * (1-s) + end[j] * s
                        for j in range(3)
                    ]
                    # Interpolate orientation
                    orient = [
                        segment_start[j+3] * (1-s) + end[j+3] * s
                        for j in range(3)
                    ]
                    traj.append(pos + orient)
                
                trajectories.append(np.array(traj))
                last_end_pose = end
                
            elif seg_type == 'ARC':
                end = seg_def['end']
                center = seg_def['center']
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Check if we have a transformed normal (from TRF)
                normal = seg_def.get('normal_vector', None)
                
                traj = motion_gen_circle.generate_arc_3d(
                    segment_start, end, center, 
                    normal=normal,  # Use transformed normal if available
                    clockwise=clockwise, duration=duration
                )
                trajectories.append(traj)
                last_end_pose = end
                
            elif seg_type == 'CIRCLE':
                center = seg_def['center']
                radius = seg_def['radius']
                plane = seg_def.get('plane', 'XY')
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Use transformed normal if available (from TRF)
                if 'normal_vector' in seg_def:
                    normal = seg_def['normal_vector']
                else:
                    plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
                    normal = plane_normals.get(plane, [0, 0, 1])
                
                traj = motion_gen_circle.generate_circle_3d(
                    center, radius, normal, 
                    start_point=segment_start[:3],
                    duration=duration
                )
                
                if clockwise:
                    traj = traj[::-1]
                    
                # Update orientations
                for j in range(len(traj)):
                    traj[j][3:] = segment_start[3:]
                    
                trajectories.append(traj)
                # Circle returns to start, so last pose is last point of trajectory
                last_end_pose = traj[-1].tolist()
                
            elif seg_type == 'SPLINE':
                waypoints = seg_def['waypoints']
                duration = seg_def['duration']
                
                # Check if first waypoint is close to segment start
                wp_error = np.linalg.norm(
                    np.array(waypoints[0][:3]) - np.array(segment_start[:3])
                )
                
                if wp_error > 5.0:
                    full_waypoints = [segment_start] + waypoints
                else:
                    full_waypoints = [segment_start] + waypoints[1:]
                
                timestamps = np.linspace(0, duration, len(full_waypoints))
                traj = motion_gen_spline.generate_cubic_spline(full_waypoints, timestamps)
                trajectories.append(traj)
                last_end_pose = waypoints[-1]
        
        # Blend all trajectories
        if len(trajectories) > 1:
            blender = MotionBlender(self.blend_time)
            blended = trajectories[0]
            blend_samples = int(self.blend_time * 100)
            
            for i in range(1, len(trajectories)):
                blended = blender.blend_trajectories(blended, trajectories[i], blend_samples)
            
            print(f"    Blended {len(trajectories)} segments into {len(blended)} points")
            return blended
        elif trajectories:
            return trajectories[0]
        else:
            raise ValueError("No trajectories generated in blend")
        
def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
    """
    Calculate duration based on trajectory length and speed percentage.
    
    Args:
        trajectory_length: Total path length in mm
        speed_percentage: Speed as percentage (1-100)
        
    Returns:
        Duration in seconds
    """
    # Map speed percentage to mm/s (adjustable based on robot capabilities)
    # For example: 100% = 100mm/s, 50% = 50mm/s
    speed_mm_s = np.interp(speed_percentage, [0, 100], 
                          [PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000,
                           PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000])
    
    if speed_mm_s > 0:
        return trajectory_length / speed_mm_s
    else:
        return 5.0  # Default fallback
    
def parse_smooth_motion_commands(parts):
    """
    Parse smooth motion commands received via UDP and create appropriate command objects.
    All commands support:
    - Reference frame selection (WRF or TRF)
    - Optional start position (CURRENT or specified pose)
    - Both DURATION and SPEED timing modes
    
    Args:
        parts: List of command parts split by '|'
        
    Returns:
        Command object or None if parsing fails
    """
    command_type = parts[0]
    
    # Helper function for parsing optional start pose
    def parse_start_pose(start_str):
        """Parse start pose - returns None for CURRENT, or list of floats for specified pose."""
        if start_str == 'CURRENT' or start_str == 'NONE':
            return None
        else:
            try:
                return list(map(float, start_str.split(',')))
            except:
                print(f"Warning: Invalid start pose format: {start_str}")
                return None
    
    # Helper function for calculating duration from speed
    def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
        """Calculate duration based on trajectory length and speed percentage."""
        # Map speed percentage to mm/s
        min_speed = PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000  # Convert to mm/s
        max_speed = PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000  # Convert to mm/s
        speed_mm_s = np.interp(speed_percentage, [0, 100], [min_speed, max_speed])
        
        if speed_mm_s > 0:
            return trajectory_length / speed_mm_s
        else:
            return 5.0  # Default fallback
    
    try:
        if command_type == 'SMOOTH_CIRCLE':
            # Format: SMOOTH_CIRCLE|center_x,center_y,center_z|radius|plane|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            plane = parts[3]
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Circle circumference
                path_length = 2 * np.pi * radius
                duration = calculate_duration_from_speed(path_length, timing_value)
            
            print(f"  -> Parsed circle: r={radius}mm, plane={plane}, frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command object with frame parameter
            return SmoothCircleCommand(center, radius, plane, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_CENTER':
            # Format: SMOOTH_ARC_CENTER|end_pose|center|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            center = list(map(float, parts[2].split(',')))
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[6])
            clockwise = parts[7] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Estimate arc length (will be more accurate when we have actual positions)
                # Use a conservative estimate based on radius
                radius_estimate = np.linalg.norm(np.array(center) - np.array(end_pose[:3]))
                estimated_arc_angle = np.pi / 2  # 90 degrees estimate
                arc_length = radius_estimate * estimated_arc_angle
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (center): frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command with frame
            return SmoothArcCenterCommand(end_pose, center, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_PARAM':
            # Format: SMOOTH_ARC_PARAM|end_pose|radius|angle|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            arc_angle = float(parts[3])
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Arc length = radius * angle (in radians)
                arc_length = radius * np.deg2rad(arc_angle)
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (param): r={radius}mm, θ={arc_angle}°, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothArcParamCommand(end_pose, radius, arc_angle, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_SPLINE':
            # Format: SMOOTH_SPLINE|num_waypoints|frame|start_pose|timing_type|timing_value|waypoint1|waypoint2|...
            num_waypoints = int(parts[1])
            frame = parts[2]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[3])
            timing_type = parts[4]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[5])
            
            # Parse waypoints
            waypoints = []
            idx = 6
            for i in range(num_waypoints):
                wp = []
                for j in range(6):  # Each waypoint has 6 values (x,y,z,rx,ry,rz)
                    wp.append(float(parts[idx]))
                    idx += 1
                waypoints.append(wp)
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate total path length
                total_dist = 0
                for i in range(1, len(waypoints)):
                    dist = np.linalg.norm(np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3]))
                    total_dist += dist
                
                duration = calculate_duration_from_speed(total_dist, timing_value)
            
            print(f"  -> Parsed spline: {num_waypoints} points, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothSplineCommand(waypoints, duration, frame, start_pose)
            
        elif command_type == 'SMOOTH_HELIX':
            # Format: SMOOTH_HELIX|center|radius|pitch|height|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            pitch = float(parts[3])
            height = float(parts[4])
            frame = parts[5]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[6])
            timing_type = parts[7]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[8])
            clockwise = parts[9] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate helix path length
                num_revolutions = height / pitch if pitch > 0 else 1
                horizontal_length = 2 * np.pi * radius * num_revolutions
                helix_length = np.sqrt(horizontal_length**2 + height**2)
                duration = calculate_duration_from_speed(helix_length, timing_value)
            
            print(f"  -> Parsed helix: h={height}mm, pitch={pitch}mm, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothHelixCommand(center, radius, pitch, height, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_BLEND':
            # Format: SMOOTH_BLEND|num_segments|blend_time|frame|start_pose|timing_type|timing_value|segment1||segment2||...
            num_segments = int(parts[1])
            blend_time = float(parts[2])
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DEFAULT', 'DURATION', or 'SPEED'
            
            # Parse overall timing
            if timing_type == 'DEFAULT':
                # Use individual segment durations as-is
                overall_duration = None
                overall_speed = None
                segments_start_idx = 6
            else:
                timing_value = float(parts[6])
                if timing_type == 'DURATION':
                    overall_duration = timing_value
                    overall_speed = None
                else:  # SPEED
                    overall_speed = timing_value
                    overall_duration = None
                segments_start_idx = 7
            
            # Parse segments (separated by ||)
            segments_data = '|'.join(parts[segments_start_idx:])
            segment_strs = segments_data.split('||')
            
            # Parse segment definitions
            segment_definitions = []
            total_original_duration = 0
            total_estimated_length = 0
            
            for seg_str in segment_strs:
                if not seg_str:  # Skip empty segments
                    continue
                    
                seg_parts = seg_str.split('|')
                seg_type = seg_parts[0]
                
                if seg_type == 'LINE':
                    # Format: LINE|end_x,end_y,end_z,end_rx,end_ry,end_rz|duration
                    end = list(map(float, seg_parts[1].split(',')))
                    segment_duration = float(seg_parts[2])
                    total_original_duration += segment_duration
                    
                    # Estimate length (will be refined when we have actual start)
                    estimated_length = 100  # mm, conservative estimate
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'LINE',
                        'end': end,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
                    
                elif seg_type == 'CIRCLE':
                    # Format: CIRCLE|center_x,center_y,center_z|radius|plane|duration|clockwise
                    center = list(map(float, seg_parts[1].split(',')))
                    radius = float(seg_parts[2])
                    plane = seg_parts[3]
                    segment_duration = float(seg_parts[4])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[5] == '1'
                    
                    # Circle circumference
                    estimated_length = 2 * np.pi * radius
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'CIRCLE',
                        'center': center,
                        'radius': radius,
                        'plane': plane,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'ARC':
                    # Format: ARC|end_x,end_y,end_z,end_rx,end_ry,end_rz|center_x,center_y,center_z|duration|clockwise
                    end = list(map(float, seg_parts[1].split(',')))
                    center = list(map(float, seg_parts[2].split(',')))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[4] == '1'
                    
                    # Estimate arc length
                    estimated_radius = 50  # mm
                    estimated_arc_angle = np.pi / 2  # 90 degrees
                    estimated_length = estimated_radius * estimated_arc_angle
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'ARC',
                        'end': end,
                        'center': center,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'SPLINE':
                    # Format: SPLINE|num_points|waypoint1;waypoint2;...|duration
                    num_points = int(seg_parts[1])
                    waypoints = []
                    wp_strs = seg_parts[2].split(';')
                    for wp_str in wp_strs:
                        waypoints.append(list(map(float, wp_str.split(','))))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    
                    # Estimate spline length
                    estimated_length = 0
                    for i in range(1, len(waypoints)):
                        estimated_length += np.linalg.norm(
                            np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3])
                        )
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'SPLINE',
                        'waypoints': waypoints,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
            
            # Adjust segment durations if overall timing is specified
            if overall_duration is not None:
                # Scale all segment durations proportionally
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Scaled blend segments to total duration: {overall_duration:.2f}s")
                        
            elif overall_speed is not None:
                # Calculate duration from speed and estimated path length
                overall_duration = calculate_duration_from_speed(total_estimated_length, overall_speed)
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Calculated blend duration from speed: {overall_duration:.2f}s")
            else:
                print(f"  -> Using original segment durations (total: {total_original_duration:.2f}s)")
            
            print(f"  -> Parsed blend: {num_segments} segments, frame={frame}, blend_time={blend_time}s")
            
            # Return command with frame
            return SmoothBlendCommand(segment_definitions, blend_time, frame, start_pose)
            
    except Exception as e:
        print(f"Error parsing smooth motion command: {e}")
        print(f"Command parts: {parts}")
        import traceback
        traceback.print_exc()
        return None
    
    print(f"Warning: Unknown smooth motion command type: {command_type}")
    return None

def transform_command_params_to_wrf(command_type: str, params: dict, frame: str, current_position_in) -> dict:
    """
    Transform command parameters from TRF to WRF.
    Handles position, orientation, and directional vectors correctly.
    """
    if frame == 'WRF':
        return params
    
    # Get current tool pose
    current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                         for i, p in enumerate(current_position_in)])
    tool_pose = PAROL6_ROBOT.robot.fkine(current_q)
    
    transformed = params.copy()
    
    # SMOOTH_CIRCLE - Transform center and plane normal
    if command_type == 'SMOOTH_CIRCLE':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'plane' in params:
            plane_normals_trf = {
                'XY': [0, 0, 1],   # Tool's Z-axis
                'XZ': [0, 1, 0],   # Tool's Y-axis  
                'YZ': [1, 0, 0]    # Tool's X-axis
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
            print(f"  -> TRF circle plane {params['plane']} transformed to WRF")
    
    # SMOOTH_ARC_CENTER - Transform center, end_pose, and implied plane
    elif command_type == 'SMOOTH_ARC_CENTER':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # Arc plane is determined by start, end, and center points
        # But we should transform any specified plane normal
        if 'plane' in params:
            # Similar to circle plane transformation
            plane_normals_trf = {
                'XY': [0, 0, 1],
                'XZ': [0, 1, 0],
                'YZ': [1, 0, 0]
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_ARC_PARAM - Transform end_pose and arc plane
    elif command_type == 'SMOOTH_ARC_PARAM':
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # For parametric arc, the plane is usually XY of the tool
        # Transform the assumed plane normal
        if 'plane' not in params:
            params['plane'] = 'XY'  # Default to XY plane
        
        plane_normals_trf = {
            'XY': [0, 0, 1],
            'XZ': [0, 1, 0],
            'YZ': [1, 0, 0]
        }
        normal_trf = np.array(plane_normals_trf[params.get('plane', 'XY')])
        normal_wrf = tool_pose.R @ normal_trf
        transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_HELIX - Transform center and helix axis
    elif command_type == 'SMOOTH_HELIX':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        # Helix axis - default is Z-axis (vertical in TRF)
        # In TRF, helix rises along tool's Z-axis
        helix_axis_trf = np.array([0, 0, 1])  # Tool's Z-axis
        helix_axis_wrf = tool_pose.R @ helix_axis_trf
        transformed['helix_axis'] = helix_axis_wrf.tolist()
        
        # Also need to transform the "up" direction for proper orientation
        up_vector_trf = np.array([0, 1, 0])  # Tool's Y-axis
        up_vector_wrf = tool_pose.R @ up_vector_trf
        transformed['up_vector'] = up_vector_wrf.tolist()
    
    # SMOOTH_SPLINE - Transform all waypoints
    elif command_type == 'SMOOTH_SPLINE':
        if 'waypoints' in params:
            transformed_waypoints = []
            for wp in params['waypoints']:
                wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                         SE3.RPY(wp[3:], unit='deg', order='xyz')
                wp_wrf = tool_pose * wp_trf
                wp_transformed = np.concatenate([
                    wp_wrf.t * 1000,
                    wp_wrf.rpy(unit='deg', order='xyz')
                ]).tolist()
                transformed_waypoints.append(wp_transformed)
            transformed['waypoints'] = transformed_waypoints
    
    # SMOOTH_BLEND - Transform all segments recursively
    elif command_type == 'SMOOTH_BLEND':
        if 'segments' in params:
            transformed_segments = []
            for seg in params['segments']:
                seg_copy = seg.copy()
                seg_type = seg['type']
                
                if seg_type == 'LINE':
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'CIRCLE':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'plane' in seg:
                        plane_normals_trf = {
                            'XY': [0, 0, 1],
                            'XZ': [0, 1, 0],
                            'YZ': [1, 0, 0]
                        }
                        normal_trf = np.array(plane_normals_trf[seg['plane']])
                        normal_wrf = tool_pose.R @ normal_trf
                        seg_copy['normal_vector'] = normal_wrf.tolist()
                
                elif seg_type == 'ARC':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'SPLINE':
                    if 'waypoints' in seg:
                        transformed_waypoints = []
                        for wp in seg['waypoints']:
                            wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                                     SE3.RPY(wp[3:], unit='deg', order='xyz')
                            wp_wrf = tool_pose * wp_trf
                            wp_transformed = np.concatenate([
                                wp_wrf.t * 1000,
                                wp_wrf.rpy(unit='deg', order='xyz')
                            ]).tolist()
                            transformed_waypoints.append(wp_transformed)
                        seg_copy['waypoints'] = transformed_waypoints
                
                transformed_segments.append(seg_copy)
            transformed['segments'] = transformed_segments
    
    # Transform start_pose if specified (common to all commands)
    if 'start_pose' in params and params['start_pose'] is not None:
        start_trf = SE3(params['start_pose'][0]/1000, 
                       params['start_pose'][1]/1000, 
                       params['start_pose'][2]/1000) * \
                    SE3.RPY(params['start_pose'][3:], unit='deg', order='xyz')
        start_wrf = tool_pose * start_trf
        transformed['start_pose'] = np.concatenate([
            start_wrf.t * 1000,
            start_wrf.rpy(unit='deg', order='xyz')
        ]).tolist()
    
    return transformed

#########################################################################
# Smooth Motion Commands and Robot Commands End Here
#########################################################################

# Acknowledgment system configuration
CLIENT_ACK_PORT = 5002  # Port where clients listen for acknowledgments
ack_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Command tracking
active_command_id = None
command_id_map = {}  # Maps command objects to their IDs

def send_acknowledgment(cmd_id: str, status: str, details: str = "", addr=None):
    """Send acknowledgment back to client"""
    if not cmd_id:
        return
        
    ack_message = f"ACK|{cmd_id}|{status}|{details}"
    
    # Send to the original sender if we have their address
    if addr:
        try:
            ack_socket.sendto(ack_message.encode('utf-8'), (addr[0], CLIENT_ACK_PORT))
        except Exception as e:
            print(f"Failed to send ack to {addr}: {e}")
    
    # Also broadcast to localhost in case the client is local
    try:
        ack_socket.sendto(ack_message.encode('utf-8'), ('127.0.0.1', CLIENT_ACK_PORT))
    except:
        pass

def parse_command_with_id(message: str) -> Tuple[Optional[str], str]:
    """
    Parse command ID if present.
    Format: [cmd_id|]COMMAND|params...
    Returns: (cmd_id or None, command_string)
    """
    # Clean up any logging artifacts
    if "ID:" in message or "):" in message:
        # Extract the actual command after these artifacts
        if "):" in message:
            message = message[message.rindex("):")+2:].strip()
        elif "ID:" in message:
            message = message[message.index("ID:")+3:].strip()
            # Remove any trailing parentheses or colons
            message = message.lstrip('):').strip()
    
    parts = message.split('|', 1)
    
    # Check if first part looks like a valid command ID (8 chars, alphanumeric)
    # IMPORTANT: Command IDs from uuid.uuid4()[:8] will contain lowercase letters/numbers
    # Actual commands are all uppercase, so exclude all-uppercase strings
    if (len(parts) > 1 and 
        len(parts[0]) == 8 and 
        parts[0].replace('-', '').isalnum() and 
        not parts[0].isupper()):  # This prevents "MOVEPOSE" from being treated as an ID
        return parts[0], parts[1]
    else:
        return None, message


# Create a new, empty command queue
command_queue = deque()

# --------------------------------------------------------------------------
# --- Test 1: Homing and Initial Setup
# --------------------------------------------------------------------------

# 1. Start with the mandatory Home command.
command_queue.append(HomeCommand())

# --- State variable for the currently running command ---
active_command = None
e_stop_active = False

# Use deque for an efficient FIFO queue
incoming_command_buffer = deque()
# Timestamp of the last processed network command
last_command_time = 0
# Cooldown period in seconds to prevent command flooding
COMMAND_COOLDOWN_S = 0.1 # 100ms

# Set interval
timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)

# ============================================================================
# MODIFIED MAIN LOOP WITH ACKNOWLEDGMENTS
# ============================================================================

timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)
prev_time = 0

while timer.elapsed_time < 1100000:
    
    # --- Connection Handling ---
    if ser is None or not ser.is_open:
        print("Serial port not open. Attempting to reconnect...")
        try:
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            if ser.is_open:
                print(f"Successfully reconnected to {com_port_str}")
        except serial.SerialException as e:
            ser = None
            time.sleep(1) 
        continue

    # =======================================================================
    # === NETWORK COMMAND RECEPTION WITH ID PARSING ===
    # =======================================================================
    try:
        while sock in select.select([sock], [], [], 0)[0]:
            data, addr = sock.recvfrom(1024)
            raw_message = data.decode('utf-8').strip()
            if raw_message:
                # Parse command ID if present
                cmd_id, message = parse_command_with_id(raw_message)
                
                parts = message.split('|')
                command_name = parts[0].upper()

                # Handle immediate response commands
                if command_name == 'STOP':
                    print("Received STOP command. Halting all motion and clearing queue.")
                    
                    # Cancel active command
                    if active_command and active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "Stopped by user", addr)
                    active_command = None
                    active_command_id = None
                    
                    # Clear queue and notify about cancelled commands
                    for queued_cmd in command_id_map.keys():
                        if queued_cmd != active_command:
                            if queued_cmd in command_id_map:
                                send_acknowledgment(command_id_map[queued_cmd], 
                                                  "CANCELLED", "Queue cleared by STOP", addr)
                    
                    command_queue.clear()
                    command_id_map.clear()
                    
                    # Stop robot
                    Command_out.value = 255
                    Speed_out[:] = [0] * 6
                    
                    # Send acknowledgment for STOP command itself
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Emergency stop executed", addr)

                elif command_name == 'GET_POSE':
                    q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
                    current_pose_matrix = PAROL6_ROBOT.robot.fkine(q_current).A
                    pose_flat = current_pose_matrix.flatten()
                    pose_str = ",".join(map(str, pose_flat))
                    response_message = f"POSE|{pose_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Pose data sent", addr)

                elif command_name == 'GET_ANGLES':
                    angles_rad = [PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)]
                    angles_deg = np.rad2deg(angles_rad)
                    angles_str = ",".join(map(str, angles_deg))
                    response_message = f"ANGLES|{angles_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Angles data sent", addr)

                elif command_name == 'GET_IO':
                    io_status_str = ",".join(map(str, InOut_in[:5]))
                    response_message = f"IO|{io_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "IO data sent", addr)

                elif command_name == 'GET_GRIPPER':
                    gripper_status_str = ",".join(map(str, Gripper_data_in))
                    response_message = f"GRIPPER|{gripper_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Gripper data sent", addr)

                elif command_name == 'GET_SPEEDS':
                    speeds_str = ",".join(map(str, Speed_in))
                    response_message = f"SPEEDS|{speeds_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Speed data sent", addr)

                else:
                    # Queue command for processing
                    incoming_command_buffer.append((raw_message, addr))

    except Exception as e:
        print(f"Network receive error: {e}")

    # =======================================================================
    # === PROCESS COMMANDS FROM BUFFER WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    current_time = time.time()
    if incoming_command_buffer and (current_time - last_command_time) > COMMAND_COOLDOWN_S and not e_stop_active:
        raw_message, addr = incoming_command_buffer.popleft()
        last_command_time = current_time
        
        # Parse command ID
        cmd_id, message = parse_command_with_id(raw_message)
        print(f"Processing command{' (ID: ' + cmd_id + ')' if cmd_id else ''}: {message[:50]}...")
        
        parts = message.split('|')
        command_name = parts[0].upper()
        
        # Variable to track if command was successfully queued
        command_queued = False
        command_obj = None
        error_details = ""

        # Parse and create command objects
        try:
            if command_name == 'MOVEPOSE' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MovePoseCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
                
            elif command_name == 'MOVEJOINT' and len(parts) == 9:
                joint_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveJointCommand(target_angles=joint_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name in ['SMOOTH_CIRCLE', 'SMOOTH_ARC_CENTER', 'SMOOTH_ARC_PARAM', 
                                 'SMOOTH_SPLINE', 'SMOOTH_HELIX', 'SMOOTH_BLEND']:
                command_obj = parse_smooth_motion_commands(parts)
                if command_obj:
                    command_queued = True
                else:
                    error_details = "Failed to parse smooth motion parameters"
            
            elif command_name == 'MOVECART' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveCartCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name == 'DELAY' and len(parts) == 2:
                duration = float(parts[1])
                command_obj = DelayCommand(duration=duration)
                command_queued = True
            
            elif command_name == 'HOME':
                command_obj = HomeCommand()
                command_queued = True
                
            elif command_name == 'CARTJOG' and len(parts) == 5:
                frame, axis, speed, duration = parts[1].upper(), parts[2], float(parts[3]), float(parts[4])
                command_obj = CartesianJogCommand(frame=frame, axis=axis, speed_percentage=speed, duration=duration)
                command_queued = True
                
            elif command_name == 'JOG' and len(parts) == 5:
                joint_idx, speed = int(parts[1]), float(parts[2])
                duration = None if parts[3].upper() == 'NONE' else float(parts[3])
                distance = None if parts[4].upper() == 'NONE' else float(parts[4])
                command_obj = JogCommand(joint=joint_idx, speed_percentage=speed, duration=duration, distance_deg=distance)
                command_queued = True
            
            elif command_name == 'MULTIJOG' and len(parts) == 4:
                joint_indices = [int(j) for j in parts[1].split(',')]
                speeds = [float(s) for s in parts[2].split(',')]
                duration = float(parts[3])
                command_obj = MultiJogCommand(joints=joint_indices, speed_percentages=speeds, duration=duration)
                command_queued = True
                
            elif command_name == 'PNEUMATICGRIPPER' and len(parts) == 3:
                action, port = parts[1].lower(), int(parts[2])
                command_obj = GripperCommand(gripper_type='pneumatic', action=action, output_port=port)
                command_queued = True
                
            elif command_name == 'ELECTRICGRIPPER' and len(parts) == 5:
                action = None if parts[1].upper() == 'NONE' or parts[1].upper() == 'MOVE' else parts[1].lower()
                pos, spd, curr = int(parts[2]), int(parts[3]), int(parts[4])
                command_obj = GripperCommand(gripper_type='electric', action=action, position=pos, speed=spd, current=curr)
                command_queued = True
            
            else:
                error_details = f"Unknown or malformed command: {command_name}"
                
        except Exception as e:
            error_details = f"Error parsing command: {str(e)}"
            command_queued = False
        
        # Handle command queueing and acknowledgments
        if command_queued and command_obj:
            # Check if command is initially valid
            if hasattr(command_obj, 'is_valid') and not command_obj.is_valid:
                if cmd_id:
                    send_acknowledgment(cmd_id, "INVALID", 
                                       "Command failed validation", addr)
            else:
                # Add to queue
                command_queue.append(command_obj)
                if cmd_id:
                    command_id_map[command_obj] = (cmd_id, addr)
                    send_acknowledgment(cmd_id, "QUEUED", 
                                       f"Position {len(command_queue)} in queue", addr)
        else:
            # Command was not queued
            if cmd_id:
                send_acknowledgment(cmd_id, "INVALID", error_details, addr)
            print(f"Warning: {error_details}")

    # =======================================================================
    # === MAIN EXECUTION LOGIC WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    try:
        # --- E-Stop Handling ---
        if InOut_in[4] == 0:  # E-Stop pressed
            if not e_stop_active:
                cancelled_command_info = "None"
                if active_command is not None:
                    cancelled_command_info = type(active_command).__name__
                    if active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "E-Stop activated")
                
                # Cancel all queued commands
                for cmd_obj in command_queue:
                    if cmd_obj in command_id_map:
                        cmd_id, addr = command_id_map[cmd_obj]
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated", addr)
                
                # Cancel all buffered but unprocessed commands
                for raw_message, addr in incoming_command_buffer:
                    cmd_id, _ = parse_command_with_id(raw_message)
                    if cmd_id:
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated - command not processed", addr)
                
                print(f"E-STOP TRIGGERED! Active command '{cancelled_command_info}' cancelled.")
                print("Release E-Stop and press 'e' to re-enable.")
                e_stop_active = True
            
            Command_out.value = 102
            Speed_out[:] = [0] * 6
            Gripper_data_out[3] = 0
            active_command = None
            active_command_id = None
            command_queue.clear()
            command_id_map.clear()
            incoming_command_buffer.clear()
            
        elif e_stop_active:
            # Waiting for re-enable
            if keyboard.is_pressed('e'):
                print("Re-enabling robot...")
                Command_out.value = 101
                e_stop_active = False
            else:
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]
                
        else:
            # --- Normal Command Processing ---
            
            # Start new command if none active
            if active_command is None and command_queue:
                new_command = command_queue.popleft()
                
                # Get command ID and address if tracked
                cmd_info = command_id_map.get(new_command, (None, None))
                new_cmd_id, new_addr = cmd_info
                
                # Initial validation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Command was invalid from the start
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "INVALID", 
                                        "Initial validation failed", new_addr)
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                    continue  # Skip to next command
                
                # Prepare command
                if hasattr(new_command, 'prepare_for_execution'):
                    try:
                        new_command.prepare_for_execution(current_position_in=Position_in)
                    except Exception as e:
                        print(f"Command preparation failed: {e}")
                        if hasattr(new_command, 'is_valid'):
                            new_command.is_valid = False
                        if hasattr(new_command, 'error_message'):
                            new_command.error_message = str(e)
                
                # Check if still valid after preparation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Failed during preparation
                    error_msg = "Failed during preparation"
                    if hasattr(new_command, 'error_message'):
                        error_msg = new_command.error_message
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "FAILED", error_msg, new_addr)
                    
                    # Clean up
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                else:
                    # Command is valid, make it active
                    active_command = new_command
                    active_command_id = new_cmd_id
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "EXECUTING", 
                                        f"Starting {type(new_command).__name__}", new_addr)
            
            # Execute active command
            if active_command:
                try:
                    is_done = active_command.execute_step(
                        Position_in=Position_in,
                        Homed_in=Homed_in,
                        Speed_out=Speed_out,
                        Command_out=Command_out,
                        Gripper_data_out=Gripper_data_out,
                        InOut_out=InOut_out,
                        InOut_in=InOut_in,
                        Gripper_data_in=Gripper_data_in,
                        Position_out=Position_out  # Add this if needed
                    )
                    
                    if is_done:
                        # Command completed
                        if active_command_id:
                            # Check for error state in smooth motion commands
                            if hasattr(active_command, 'error_state') and active_command.error_state:
                                error_msg = getattr(active_command, 'error_message', 'Command failed during execution')
                                send_acknowledgment(active_command_id, "FAILED", error_msg)
                            else:
                                send_acknowledgment(active_command_id, "COMPLETED", 
                                                f"{type(active_command).__name__} finished successfully")
                        
                        # Clean up
                        if active_command in command_id_map:
                            del command_id_map[active_command]
                        
                        active_command = None
                        active_command_id = None
                        
                except Exception as e:
                    # Command execution error
                    print(f"Command execution error: {e}")
                    if active_command_id:
                        send_acknowledgment(active_command_id, "FAILED", 
                                          f"Execution error: {str(e)}")
                    
                    # Clean up
                    if active_command in command_id_map:
                        del command_id_map[active_command]
                    
                    active_command = None
                    active_command_id = None
                    
            else:
                # No active command - idle
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]

        # --- Communication with Robot ---
        s = Pack_data(Position_out, Speed_out, Command_out.value, 
                     Affected_joint_out, InOut_out, Timeout_out, Gripper_data_out)
        for chunk in s:
            ser.write(chunk)
            
        Get_data(Position_in, Speed_in, Homed_in, InOut_in, Temperature_error_in, 
                Position_error_in, Timeout_error, Timing_data_in, XTR_data, Gripper_data_in)

    except serial.SerialException as e:
        print(f"Serial communication error: {e}")
        
        # Send failure acknowledgments for active command
        if active_command_id:
            send_acknowledgment(active_command_id, "FAILED", "Serial communication lost")
        
        if ser:
            ser.close()
        ser = None
        active_command = None
        active_command_id = None

    timer.checkpt()
````

## File: headless_commander.py.backup_1757427986
````
'''
A full fledged "API" for the PAROL6 robot. To use this, you should pair it with the "robot_api.py" where you can import commands
from said file and use them anywhere within your code. This Python script will handle sending and performing all the commands
to the PAROL6 robot, as well as E-Stop functionality and safety limitations.

To run this program, you must use the "experimental-kinematics" branch of the "PAROL-commander-software" on GitHub
which can be found through this link: https://github.com/PCrnjak/PAROL-commander-software/tree/experimental_kinematics.
You must also save these files into the following folder: "Project Files\PAROL-commander-software\GUI\files".
'''

# * If you press estop robot will stop and you need to enable it by pressing e

from roboticstoolbox import DHRobot, RevoluteDH, ERobot, ELink, ETS, trapezoidal, quintic
import roboticstoolbox as rp
from math import pi, sin, cos
import numpy as np
from oclock import Timer, loop, interactiveloop
import time
import socket
from spatialmath import SE3
import select
import serial
import platform
import os
import re
import logging
import struct
import keyboard
from typing import Optional, Tuple
from spatialmath.base import trinterp
from collections import namedtuple, deque
import GUI.files.PAROL6_ROBOT as PAROL6_ROBOT
from smooth_motion import CircularMotion, SplineMotion, MotionBlender

# Set interval
INTERVAL_S = 0.01
prev_time = 0

logging.basicConfig(level = logging.DEBUG,
    format='%(asctime)s.%(msecs)03d %(levelname)s:\t%(message)s',
    datefmt='%H:%M:%S'
)
logging.disable(logging.DEBUG)


my_os = platform.system()
if my_os == "Windows":
    # Try to read the COM port from a file
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved COM port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        # If the file doesn't exist or the port is invalid, ask the user
        while True:
            try:
                com_port = input("Enter the COM port (e.g., COM9): ")
                ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                print(f"Successfully connected to {com_port}")
                # Save the successful port to the file
                with open("com_port.txt", "w") as f:
                    f.write(com_port)
                break
            except serial.SerialException:
                print(f"Could not open port {com_port}. Please try again.")

# in big endian machines, first byte of binary representation of the multibyte data-type is stored first. 
int_to_3_bytes = struct.Struct('>I').pack # BIG endian order

# data for output string (data that is being sent to the robot)
#######################################################################################
#######################################################################################
start_bytes =  [0xff,0xff,0xff] 
start_bytes = bytes(start_bytes)

end_bytes =  [0x01,0x02] 
end_bytes = bytes(end_bytes)


# data for input string (Data that is being sent by the robot)
#######################################################################################
#######################################################################################
input_byte = 0 # Here save incoming bytes from serial

start_cond1_byte = bytes([0xff])
start_cond2_byte = bytes([0xff])
start_cond3_byte = bytes([0xff])

end_cond1_byte = bytes([0x01])
end_cond2_byte = bytes([0x02])

start_cond1 = 0 #Flag if start_cond1_byte is received
start_cond2 = 0 #Flag if start_cond2_byte is received
start_cond3 = 0 #Flag if start_cond3_byte is received

good_start = 0 #Flag if we got all 3 start condition bytes
data_len = 0 #Length of the data after -3 start condition bytes and length byte, so -4 bytes

data_buffer = [None]*255 #Here save all data after data length byte
data_counter = 0 #Data counter for incoming bytes; compared to data length to see if we have correct length
#######################################################################################
#######################################################################################
prev_positions = [0,0,0,0,0,0]
prev_speed = [0,0,0,0,0,0]
robot_pose = [0,0,0,0,0,0] #np.array([0,0,0,0,0,0])
#######################################################################################
#######################################################################################

# --- Wrapper class to make integers mutable when passed to functions ---
class CommandValue:
    def __init__(self, value):
        self.value = value

#######################################################################################
#######################################################################################
Position_out = [1,11,111,1111,11111,10]
Speed_out = [2,21,22,23,24,25]
Command_out = CommandValue(255)
Affected_joint_out = [1,1,1,1,1,1,1,1]
InOut_out = [0,0,0,0,0,0,0,0]
Timeout_out = 0
#Positon,speed,current,command,mode,ID
Gripper_data_out = [1,1,1,1,0,0]
#######################################################################################
#######################################################################################
# Data sent from robot to PC
Position_in = [31,32,33,34,35,36]
Speed_in = [41,42,43,44,45,46]
Homed_in = [0,0,0,0,0,0,0,0]
InOut_in = [1,1,1,1,1,1,1,1]
Temperature_error_in = [1,1,1,1,1,1,1,1]
Position_error_in = [1,1,1,1,1,1,1,1]
Timeout_error = 0
# how much time passed between 2 sent commands (2byte value, last 2 digits are decimal so max value is 655.35ms?)
Timing_data_in = [0]
XTR_data =   0

# --- State variables for program execution ---
Robot_mode = "Dummy"  # Start in an idle state
Program_step = 0      # Which line of the program to run
Command_step = 0      # The current step within a single command
Command_len = 0       # The total steps for the current command
ik_error = 0          # Flag for inverse kinematics errors
error_state = 0       # General error flag
program_running = False # A flag to start and stop the program

# This will be your "program"
command_list = []

#ID,Position,speed,current,status,obj_detection
Gripper_data_in = [1,1,1,1,1,1] 

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179° and 181° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    
    Parameters
    ----------
    robot : DHRobot
        Robot model
    q : array_like
        Joint configuration
    strict_tol : float
        Strict tolerance away from singularities (default: 1e-10)
    loose_tol : float
        Loose tolerance near singularities (1e-7)
        
    Returns
    -------
    float
        Adaptive tolerance value
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    
    Parameters
    ----------
    q_seed : array_like
        Current joint configuration in radians
        
    Returns
    -------
    float
        Configuration-dependent maximum reach threshold
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 | None = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities:
    - Near singularities: looser tolerance for easier convergence
    - Away from singularities: stricter tolerance for precise solutions
    If necessary, recursively subdivide the motion until ikine_LMS converges
    on every segment. Finally check that solution respects joint limits. From experimentation,
    jogging with lower tolerances often produces q_paths that do not differ from current_q,
    essentially freezing the robot.

    Parameters
    ----------
    robot : DHRobot
        Robot model
    target_pose : SE3
        Target pose to reach
    current_q : array_like
        Current joint configuration
    current_pose : SE3, optional
        Current pose (computed if None)
    max_depth : int, optional
        Maximum subdivision depth (default: 8)
    ilimit : int, optional
        Maximum iterations for IK solver (default: 100)

    Returns
    -------
    IKResult
        success  - True/False
        q_path   - (mxn) array of the final joint configuration 
        iterations, residual  - aggregated diagnostics
        tolerance_used - which tolerance was used
        violations - joint limit violations (if any)
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # ── inner recursive solver───────────────────
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            # print(f"current_reach:{current_reach:.3f}, max_reach_threshold:{max_reach_threshold:.3f}")
            if not is_recovery and target_reach > max_reach_threshold:
                print(f"Target reach limit exceeded: {target_reach:.3f} > {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LMS(Tb, q0=q_seed, ilimit=ilimit, tol=tol, wN=damping)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # ── kick-off with adaptive tolerance ──────────────────────────────────
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    # Check if solution respects joint limits
    target_q = path[-1] if len(path) != 0 else None
    solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
    if ok and solution_valid:
        return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
    else:
        return IKResult(False, None, its, resid, adaptive_tol, violations)

#Setup IP address and Simulator port
ip = "127.0.0.1" #Loopback address
port = 5001
# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((ip, port))
print(f'Start listening to {ip}:{port}')

def Unpack_data(data_buffer_list, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):

    Joints = []
    Speed = []

    for i in range(0,18, 3):
        variable = data_buffer_list[i:i+3]
        Joints.append(variable)

    for i in range(18,36, 3):
        variable = data_buffer_list[i:i+3]
        Speed.append(variable)


    for i in range(6):
        var =  b'\x00' + b''.join(Joints[i])
        Position_in[i] = Fuse_3_bytes(var)
        var =  b'\x00' + b''.join(Speed[i])
        Speed_in[i] = Fuse_3_bytes(var)

    Homed = data_buffer_list[36]
    IO_var = data_buffer_list[37]
    temp_error = data_buffer_list[38]
    position_error = data_buffer_list[39]
    timing_data = data_buffer_list[40:42]
    Timeout_error_var = data_buffer_list[42]
    xtr2 = data_buffer_list[43]
    device_ID = data_buffer_list[44]
    Gripper_position = data_buffer_list[45:47]
    Gripper_speed = data_buffer_list[47:49]
    Gripper_current = data_buffer_list[49:51]
    Status = data_buffer_list[51]
    # The original object_detection byte at index 52 is ignored as it is not reliable.
    CRC_byte = data_buffer_list[53]
    endy_byte1 = data_buffer_list[54]
    endy_byte2 = data_buffer_list[55]

    # ... (Code for Homed, IO_var, temp_error, etc. remains the same) ...

    temp = Split_2_bitfield(int.from_bytes(Homed,"big"))
    for i in range(8):
        Homed_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(IO_var,"big"))
    for i in range(8):
        InOut_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(temp_error,"big"))
    for i in range(8):
        Temperature_error_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(position_error,"big"))
    for i in range(8):
        Position_error_in[i] = temp[i]

    var = b'\x00' + b'\x00' + b''.join(timing_data)
    Timing_data_in[0] = Fuse_3_bytes(var)
    Timeout_error = int.from_bytes(Timeout_error_var,"big")
    XTR_data = int.from_bytes(xtr2,"big")

    # --- Gripper Data Unpacking ---
    Gripper_data_in[0] = int.from_bytes(device_ID,"big")

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_position)
    Gripper_data_in[1] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_speed)
    Gripper_data_in[2] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_current)
    Gripper_data_in[3] = Fuse_2_bytes(var)

    # --- Start of Corrected Logic ---
    # This section now mirrors the working logic from GUI_PAROL_latest.py
    
    # 1. Store the raw status byte (from index 51)
    status_byte = int.from_bytes(Status,"big")
    Gripper_data_in[4] = status_byte

    # 2. Split the status byte into a list of 8 individual bits
    status_bits = Split_2_bitfield(status_byte)
    
    # 3. Combine the 3rd and 4th bits (at indices 2 and 3) to get the true object detection status
    # This creates a 2-bit number (0-3) which represents the full state.
    object_detection_status = (status_bits[2] << 1) | status_bits[3]
    Gripper_data_in[5] = object_detection_status
    # --- End of Corrected Logic ---

def Pack_data(Position_out,Speed_out,Command_out,Affected_joint_out,InOut_out,Timeout_out,Gripper_data_out):

    # Len is defined by all bytes EXCEPT start bytes and len
    # Start bytes = 3
    len = 52 #1
    Position = [Position_out[0],Position_out[1],Position_out[2],Position_out[3],Position_out[4],Position_out[5]]  #18
    Speed = [Speed_out[0], Speed_out[1], Speed_out[2], Speed_out[3], Speed_out[4], Speed_out[5],] #18
    Command = Command_out#1
    Affected_joint = Affected_joint_out
    InOut = InOut_out #1
    Timeout = Timeout_out #1
    Gripper_data = Gripper_data_out #9
    CRC_byte = 228 #1
    # End bytes = 2


    test_list = []
    #print(test_list)

    #x = bytes(start_bytes)
    test_list.append((start_bytes))
    
    test_list.append(bytes([len]))


    # Position data
    for i in range(6):
        position_split = Split_2_3_bytes(Position[i])
        test_list.append(position_split[1:4])

    # Speed data
    for i in range(6):
        speed_split = Split_2_3_bytes(Speed[i])
        test_list.append(speed_split[1:4])

    # Command data
    test_list.append(bytes([Command]))

    # Affected joint data
    Affected_list = Fuse_bitfield_2_bytearray(Affected_joint[:])
    test_list.append(Affected_list)

    # Inputs outputs data
    InOut_list = Fuse_bitfield_2_bytearray(InOut[:])
    test_list.append(InOut_list)

    # Timeout data
    test_list.append(bytes([Timeout]))

    # Gripper position
    Gripper_position = Split_2_3_bytes(Gripper_data[0])
    test_list.append(Gripper_position[2:4])

    # Gripper speed
    Gripper_speed = Split_2_3_bytes(Gripper_data[1])
    test_list.append(Gripper_speed[2:4])

    # Gripper current
    Gripper_current = Split_2_3_bytes(Gripper_data[2])
    test_list.append(Gripper_current[2:4])  

    # Gripper command
    test_list.append(bytes([Gripper_data[3]]))
    # Gripper mode
    test_list.append(bytes([Gripper_data[4]]))
    
    # ==========================================================
    # === FIX: Make sure calibrate is a one-shot command      ====
    # ==========================================================
    # If the mode was set to calibrate (1) or clear_error (2), reset it
    # back to normal (0) for the next cycle. This prevents an endless loop.
    if Gripper_data_out[4] == 1 or Gripper_data_out[4] == 2:
        Gripper_data_out[4] = 0
    # ==========================================================
    
    # Gripper ID
    test_list.append(bytes([Gripper_data[5]]))
 
    # CRC byte
    test_list.append(bytes([CRC_byte]))

    # END bytes
    test_list.append((end_bytes))
    
    #print(test_list)
    return test_list

def Get_data(Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):
    global input_byte 

    global start_cond1_byte 
    global start_cond2_byte 
    global start_cond3_byte 

    global end_cond1_byte 
    global end_cond2_byte 

    global start_cond1 
    global start_cond2 
    global start_cond3 

    global good_start 
    global data_len 

    global data_buffer 
    global data_counter

    while (ser.inWaiting() > 0):
        input_byte = ser.read()

        #UNCOMMENT THIS TO GET ALL DATA FROM THE ROBOT PRINTED
        #print(input_byte) 

        # When data len is received start is good and after that put all data in receive buffer
        # Data len is ALL data after it; that includes input buffer, end bytes and CRC
        if (good_start != 1):
            # All start bytes are good and next byte is data len
            if (start_cond1 == 1 and start_cond2 == 1 and start_cond3 == 1):
                good_start = 1
                data_len = input_byte
                data_len = struct.unpack('B', data_len)[0]
                logging.debug("data len we got from robot packet= ")
                logging.debug(input_byte)
                logging.debug("good start for DATA that we received at PC")
            # Third start byte is good
            if (input_byte == start_cond3_byte and start_cond2 == 1 and start_cond1 == 1):
                start_cond3 = 1
                #print("good cond 3 PC")
            #Third start byte is bad, reset all flags
            elif (start_cond2 == 1 and start_cond1 == 1):
                #print("bad cond 3 PC")
                start_cond1 = 0
                start_cond2 = 0
            # Second start byte is good
            if (input_byte == start_cond2_byte and start_cond1 == 1):
                start_cond2 = 1
                #print("good cond 2 PC ")
            #Second start byte is bad, reset all flags   
            elif (start_cond1 == 1):
                #print("Bad cond 2 PC")
                start_cond1 = 0
            # First start byte is good
            if (input_byte == start_cond1_byte):
                start_cond1 = 1
                #print("good cond 1 PC")
        else:
            # Here data goes after good  start
            data_buffer[data_counter] = input_byte
            if (data_counter == data_len - 1):

                logging.debug("Data len PC")
                logging.debug(data_len)
                logging.debug("End bytes are:")
                logging.debug(data_buffer[data_len -1])
                logging.debug(data_buffer[data_len -2])

                # Here if last 2 bytes are end condition bytes we process the data 
                if (data_buffer[data_len -1] == end_cond2_byte and data_buffer[data_len - 2] == end_cond1_byte):

                    logging.debug("GOOD END CONDITION PC")
                    logging.debug("I UNPACKED RAW DATA RECEIVED FROM THE ROBOT")
                    Unpack_data(data_buffer, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
                    XTR_data,Gripper_data_in)
                    logging.debug("DATA UNPACK FINISHED")
                    # ako su dobri izračunaj crc
                    # if crc dobar raspakiraj podatke
                    # ako je dobar paket je dobar i spremi ga u nove variable!
                
                # Print every byte
                #print("podaci u data bufferu su:")
                #for i in range(data_len):
                    #print(data_buffer[i])

                good_start = 0
                start_cond1 = 0
                start_cond3 = 0
                start_cond2 = 0
                data_len = 0
                data_counter = 0
            else:
                data_counter = data_counter + 1

# Split data to 3 bytes 
def Split_2_3_bytes(var_in):
    y = int_to_3_bytes(var_in & 0xFFFFFF) # converts my int value to bytes array
    return y

# Splits byte to bitfield list
def Split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]

# Fuses 3 bytes to 1 signed int
def Fuse_3_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<23:
        value -= 1<<24

    return value

# Fuses 2 bytes to 1 signed int
def Fuse_2_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<15:
        value -= 1<<16

    return value

# Fuse bitfield list to byte
def Fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Check if there is element 1 in the list. 
# If yes return its index, if no element is 1 return -1
def check_elements(lst):
    for i, element in enumerate(lst):
        if element == 1:
            return i
    return -1  # Return -1 if no element is 1

def quintic_scaling(s: float) -> float:
    """
    Calculates a smooth 0-to-1 scaling factor for progress 's'
    using a quintic polynomial, ensuring smooth start/end accelerations.
    """
    return 6 * (s**5) - 15 * (s**4) + 10 * (s**3)

#########################################################################
# Robot Commands Start Here
#########################################################################

class HomeCommand:
    """
    A non-blocking command that tells the robot to perform its internal homing sequence.
    This version uses a state machine to allow re-homing even if the robot is already homed.
    """
    def __init__(self):
        self.is_valid = True
        self.is_finished = False
        # State machine: START -> WAIT_FOR_UNHOMED -> WAIT_FOR_HOMED -> FINISHED
        self.state = "START"
        # Counter to send the home command for multiple cycles
        self.start_cmd_counter = 10  # Send command 100 for 10 cycles (0.1s)
        # Safety timeout (20 seconds at 0.01s interval)
        self.timeout_counter = 2000
        print("Initializing Home command...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Manages the homing command and monitors for completion using a state machine.
        """
        if self.is_finished:
            return True

        # --- State: START ---
        # On the first few executions, continuously send the 'home' (100) command.
        if self.state == "START":
            print(f"  -> Sending home signal (100)... Countdown: {self.start_cmd_counter}")
            Command_out.value = 100
            self.start_cmd_counter -= 1
            if self.start_cmd_counter <= 0:
                # Once sent for enough cycles, move to the next state
                self.state = "WAITING_FOR_UNHOMED"
            return False

        # --- State: WAITING_FOR_UNHOMED ---
        # The robot's firmware should reset the homed status. We wait to see that happen.
        # During this time, we send 'idle' (255) to let the robot's controller take over.
        if self.state == "WAITING_FOR_UNHOMED":
            Command_out.value = 255
            # Check if at least one joint has started homing (is no longer homed)
            if any(h == 0 for h in Homed_in[:6]):
                print("  -> Homing sequence initiated by robot.")
                self.state = "WAITING_FOR_HOMED"
            # Check for timeout
            self.timeout_counter -= 1
            if self.timeout_counter <= 0:
                print("  -> ERROR: Timeout waiting for robot to start homing sequence.")
                self.is_finished = True
            return self.is_finished

        # --- State: WAITING_FOR_HOMED ---
        # Now we wait for all joints to report that they are homed (all flags are 1).
        if self.state == "WAITING_FOR_HOMED":
            Command_out.value = 255
            # Check if all joints have finished homing
            if all(h == 1 for h in Homed_in[:6]):
                print("Homing sequence complete. All joints reported home.")
                self.is_finished = True
                Speed_out[:] = [0] * 6 # Ensure robot is stopped

        return self.is_finished

class JogCommand:
    """
    A non-blocking command to jog a joint for a specific duration or distance.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joint, speed_percentage=None, duration=None, distance_deg=None):
        """
        Initializes and validates the jog command. This is the SETUP phase.
        """
        self.is_valid = False
        self.is_finished = False
        self.mode = None
        self.command_step = 0

        # --- 1. Parameter Validation and Mode Selection ---
        if duration and distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Distance {distance_deg} deg, Duration {duration}s.")
        elif duration:
            self.mode = 'time'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Duration {duration}s.")
        elif distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Distance {distance_deg} deg.")
        else:
            print("Error: JogCommand requires either 'duration', 'distance_deg', or both.")
            return

        # --- 2. Store parameters for deferred calculation ---
        self.joint = joint
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.distance_deg = distance_deg

        # --- These will be calculated later ---
        self.direction = 1
        self.joint_index = 0
        self.speed_out = 0
        self.command_len = 0
        self.target_position = 0

        self.is_valid = True # Mark as valid for now; preparation step will confirm.


    def prepare_for_execution(self, current_position_in):
        """Pre-computes speeds and target positions using live data."""
        print(f"  -> Preparing for Jog command...")

        # Determine direction and joint index
        self.direction = 1 if 0 <= self.joint <= 5 else -1
        self.joint_index = self.joint if self.direction == 1 else self.joint - 6
        
        distance_steps = 0
        if self.distance_deg:
            distance_steps = int(PAROL6_ROBOT.DEG2STEPS(abs(self.distance_deg), self.joint_index))
            # --- MOVED LOGIC: Calculate target using the LIVE position ---
            self.target_position = current_position_in[self.joint_index] + (distance_steps * self.direction)
            
            min_limit, max_limit = PAROL6_ROBOT.Joint_limits_steps[self.joint_index]
            if not (min_limit <= self.target_position <= max_limit):
                print(f"  -> VALIDATION FAILED: Target position {self.target_position} is out of joint limits ({min_limit}, {max_limit}).")
                self.is_valid = False
                return

        # Calculate speed and duration
        speed_steps_per_sec = 0
        if self.mode == 'distance' and self.duration:
            speed_steps_per_sec = int(distance_steps / self.duration) if self.duration > 0 else 0
            max_joint_speed = PAROL6_ROBOT.Joint_max_speed[self.joint_index]
            if speed_steps_per_sec > max_joint_speed:
                print(f"  -> VALIDATION FAILED: Required speed ({speed_steps_per_sec} steps/s) exceeds joint's max speed ({max_joint_speed} steps/s).")
                self.is_valid = False
                return
        else:
            if self.speed_percentage is None:
                print("Error: 'speed_percentage' must be provided if not calculating automatically.")
                self.is_valid = False
                return
            speed_steps_per_sec = int(np.interp(abs(self.speed_percentage), [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[self.joint_index] * 2]))

        self.speed_out = speed_steps_per_sec * self.direction
        self.command_len = int(self.duration / INTERVAL_S) if self.duration else float('inf')
        print("  -> Jog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        stop_reason = None
        current_pos = Position_in[self.joint_index]

        if self.mode == 'time':
            if self.command_step >= self.command_len:
                stop_reason = "Timed jog finished."
        elif self.mode == 'distance':
            if (self.direction == 1 and current_pos >= self.target_position) or \
               (self.direction == -1 and current_pos <= self.target_position):
                stop_reason = "Distance jog finished."
        
        if not stop_reason:
            if (self.direction == 1 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][1]) or \
               (self.direction == -1 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][0]):
                stop_reason = f"Limit reached on joint {self.joint_index + 1}."

        if stop_reason:
            print(stop_reason)
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            Speed_out[:] = [0] * 6
            Speed_out[self.joint_index] = self.speed_out
            Command_out.value = 123
            self.command_step += 1
            return False
        
class MultiJogCommand:
    """
    A non-blocking command to jog multiple joints simultaneously for a specific duration.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joints, speed_percentages, duration):
        """
        Initializes and validates the multi-jog command.
        """
        self.is_valid = False
        self.is_finished = False
        self.command_step = 0

        # --- 1. Parameter Validation ---
        if not isinstance(joints, list) or not isinstance(speed_percentages, list):
            print("Error: MultiJogCommand requires 'joints' and 'speed_percentages' to be lists.")
            return

        if len(joints) != len(speed_percentages):
            print("Error: The number of joints must match the number of speed percentages.")
            return

        if not duration or duration <= 0:
            print("Error: MultiJogCommand requires a positive 'duration'.")
            return

        # ==========================================================
        # === NEW: Check for conflicting joint commands          ===
        # ==========================================================
        base_joints = set()
        for joint in joints:
            # Normalize the joint index to its base (0-5)
            base_joint = joint % 6
            # If the base joint is already in our set, it's a conflict.
            if base_joint in base_joints:
                print(f"  -> VALIDATION FAILED: Conflicting commands for Joint {base_joint + 1} (e.g., J1+ and J1-).")
                self.is_valid = False
                return
            base_joints.add(base_joint)
        # ==========================================================

        print(f"Initializing MultiJog for joints {joints} with speeds {speed_percentages}% for {duration}s.")

        # --- 2. Store parameters ---
        self.joints = joints
        self.speed_percentages = speed_percentages
        self.duration = duration
        self.command_len = int(self.duration / INTERVAL_S)

        # --- This will be calculated in the prepare step ---
        self.speeds_out = [0] * 6

        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Pre-computes the speeds for each joint."""
        print(f"  -> Preparing for MultiJog command...")

        for i, joint in enumerate(self.joints):
            # Determine direction and joint index (0-5 for positive, 6-11 for negative)
            direction = 1 if 0 <= joint <= 5 else -1
            joint_index = joint if direction == 1 else joint - 6
            speed_percentage = self.speed_percentages[i]

            # Check for joint index validity
            if not (0 <= joint_index < 6):
                print(f"  -> VALIDATION FAILED: Invalid joint index {joint_index}.")
                self.is_valid = False
                return

            # Calculate speed in steps/sec
            speed_steps_per_sec = int(np.interp(speed_percentage, [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[joint_index]]))
            self.speeds_out[joint_index] = speed_steps_per_sec * direction

        print("  -> MultiJog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        # Stop if the duration has elapsed
        if self.command_step >= self.command_len:
            print("Timed multi-jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            # Continuously check for joint limits during the jog
            for i in range(6):
                if self.speeds_out[i] != 0:
                    current_pos = Position_in[i]
                    # Hitting positive limit while moving positively
                    if self.speeds_out[i] > 0 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[i][1]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True
                    # Hitting negative limit while moving negatively
                    elif self.speeds_out[i] < 0 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[i][0]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True

            # If no limits are hit, apply the speeds
            Speed_out[:] = self.speeds_out
            Command_out.value = 123 # Jog command
            self.command_step += 1
            return False # Command is still running
        
# This dictionary maps descriptive axis names to movement vectors, which is cleaner.
# Format: ([x, y, z], [rx, ry, rz])
AXIS_MAP = {
    'X+': ([1, 0, 0], [0, 0, 0]), 'X-': ([-1, 0, 0], [0, 0, 0]),
    'Y+': ([0, 1, 0], [0, 0, 0]), 'Y-': ([0, -1, 0], [0, 0, 0]),
    'Z+': ([0, 0, 1], [0, 0, 0]), 'Z-': ([0, 0, -1], [0, 0, 0]),
    'RX+': ([0, 0, 0], [1, 0, 0]), 'RX-': ([0, 0, 0], [-1, 0, 0]),
    'RY+': ([0, 0, 0], [0, 1, 0]), 'RY-': ([0, 0, 0], [0, -1, 0]),
    'RZ+': ([0, 0, 0], [0, 0, 1]), 'RZ-': ([0, 0, 0], [0, 0, -1]),
}

class CartesianJogCommand:
    """
    A non-blocking command to jog the robot's end-effector in Cartesian space.
    This is the final, refactored version using clean, standard spatial math
    operations now that the core unit bug has been fixed.
    """
    def __init__(self, frame, axis, speed_percentage=50, duration=1.5, **kwargs):
        """
        Initializes and validates the Cartesian jog command.
        """
        self.is_valid = False
        self.is_finished = False
        print(f"Initializing CartesianJog: Frame {frame}, Axis {axis}...")

        if axis not in AXIS_MAP:
            print(f"  -> VALIDATION FAILED: Invalid axis '{axis}'.")
            return
        
        # Store all necessary parameters for use in execute_step
        self.frame = frame
        self.axis_vectors = AXIS_MAP[axis]
        self.is_rotation = any(self.axis_vectors[1])
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.end_time = time.time() + self.duration
        
        self.is_valid = True
        print("  -> Command is valid and ready.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Check for completion ---
        if time.time() >= self.end_time:
            print("Cartesian jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- B. Calculate Target Pose using clean vector math ---
        Command_out.value = 123 # Set jog command
        
        q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        T_current = PAROL6_ROBOT.robot.fkine(q_current)

        if not isinstance(T_current, SE3):
            return False # Wait for valid pose data

        # Calculate speed and displacement for this cycle
        linear_speed_ms = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min_JOG, PAROL6_ROBOT.Cartesian_linear_velocity_max_JOG]))
        angular_speed_degs = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max]))

        delta_linear = linear_speed_ms * INTERVAL_S
        delta_angular_rad = np.deg2rad(angular_speed_degs * INTERVAL_S)

        # Create the small incremental transformation (delta_pose)
        trans_vec = np.array(self.axis_vectors[0]) * delta_linear
        rot_vec = np.array(self.axis_vectors[1]) * delta_angular_rad
        delta_pose = SE3.Rt(SE3.Eul(rot_vec).R, trans_vec)

        # Apply the transformation in the correct reference frame
        if self.frame == 'WRF':
            # Pre-multiply to apply the change in the World Reference Frame
            target_pose = delta_pose * T_current
        else: # TRF
            # Post-multiply to apply the change in the Tool Reference Frame
            target_pose = T_current * delta_pose
        
        # --- C. Solve IK and Calculate Velocities ---
        var = solve_ik_with_adaptive_tol_subdivision(PAROL6_ROBOT.robot, target_pose, q_current, jogging=True)

        if var.success:
            q_velocities = (var.q - q_current) / INTERVAL_S
            for i in range(6):
                Speed_out[i] = int(PAROL6_ROBOT.SPEED_RAD2STEP(q_velocities[i], i))
        else:
            print("IK Warning: Could not find solution for jog step. Stopping.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- D. Speed Scaling ---
        max_scale_factor = 1.0
        for i in range(6):
            if abs(Speed_out[i]) > PAROL6_ROBOT.Joint_max_speed[i]:
                scale = abs(Speed_out[i]) / PAROL6_ROBOT.Joint_max_speed[i]
                if scale > max_scale_factor:
                    max_scale_factor = scale
        
        if max_scale_factor > 1.0:
            for i in range(6):
                Speed_out[i] = int(Speed_out[i] / max_scale_factor)

        return False # Command is still running

class MovePoseCommand:
    """
    A non-blocking command to move the robot to a specific Cartesian pose.
    The movement itself is a joint-space interpolation.
    """
    def __init__(self, pose, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = True  # Assume valid; preparation step will confirm.
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MovePose to {pose}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.pose = pose
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

    """
        Initializes, validates, and pre-computes the trajectory for a move-to-pose command.

        Args:
            pose (list): A list of 6 values [x, y, z, r, p, y] for the target pose.
                         Positions are in mm, rotations are in degrees.
            duration (float, optional): The total time for the movement in seconds.
            velocity_percent (float, optional): The target velocity as a percentage (0-100).
            accel_percent (float, optional): The target acceleration as a percentage (0-100).
            trajectory_type (str, optional): The type of trajectory ('poly' or 'trap').
        """
    
    def prepare_for_execution(self, current_position_in):
        """Calculates the full trajectory just-in-time before execution."""
        print(f"  -> Preparing trajectory for MovePose to {self.pose}...")

        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pose = SE3(self.pose[0] / 1000.0, self.pose[1] / 1000.0, self.pose[2] / 1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')
        
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_pose, initial_pos_rad, ilimit=100)

        if not ik_solution.success:
            print("  -> VALIDATION FAILED: Inverse kinematics failed at execution time.")
            self.is_valid = False
            return

        target_pos_rad = ik_solution.q

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])

                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue
                    
                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)
            
                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                self.is_valid = False
                return

        else:
            print("  -> Using conservative values for MovePose.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveJointCommand:
    """
    A non-blocking command to move the robot's joints to a specific configuration.
    It pre-calculates the entire trajectory upon initialization.
    """
    def __init__(self, target_angles, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = False  # Will be set to True after basic validation
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MoveJoint to {target_angles}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.target_angles = target_angles
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

        # --- Perform only state-independent validation ---
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])
        for i in range(6):
            min_rad, max_rad = PAROL6_ROBOT.Joint_limits_radian[i]
            if not (min_rad <= target_pos_rad[i] <= max_rad):
                print(f"  -> VALIDATION FAILED: Target for Joint {i+1} ({self.target_angles[i]} deg) is out of range.")
                return
        
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Calculates the trajectory just before execution begins."""
        print(f"  -> Preparing trajectory for MoveJoint to {self.target_angles}...")
        
        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])
                
                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue

                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)

                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                print(f"  -> Please check Joint_min/max_speed and Joint_min/max_acc values in PAROL6_ROBOT.py.")
                self.is_valid = False
                return
        
        else:
            print("  -> Using conservative values for MoveJoint.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveCartCommand:
    """
    A non-blocking command to move the robot's end-effector in a straight line
    in Cartesian space, completing the move in an exact duration.

    It works by:
    1. Pre-validating the final target pose.
    2. Interpolating the pose in Cartesian space in real-time.
    3. Solving Inverse Kinematics for each intermediate step to ensure path validity.
    """
    def __init__(self, pose, duration=None, velocity_percent=None):
        self.is_valid = False
        self.is_finished = False

        # --- MODIFICATION: Validate that at least one timing parameter is given ---
        if duration is None and velocity_percent is None:
            print("  -> VALIDATION FAILED: MoveCartCommand requires either 'duration' or 'velocity_percent'.")
            return
        if duration is not None and velocity_percent is not None:
            print("  -> INFO: Both duration and velocity_percent provided. Using duration.")
            self.velocity_percent = None # Prioritize duration
        else:
            self.velocity_percent = velocity_percent

        # --- Store parameters and set placeholders ---
        self.duration = duration
        self.pose = pose
        self.start_time = None
        self.initial_pose = None
        self.target_pose = None
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Captures the initial state and validates the path just before execution."""
        print(f"  -> Preparing for MoveCart to {self.pose}...")
        
        # --- MOVED LOGIC: Capture initial state from live data ---
        initial_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        self.initial_pose = PAROL6_ROBOT.robot.fkine(initial_q_rad)
        self.target_pose = SE3(self.pose[0]/1000.0, self.pose[1]/1000.0, self.pose[2]/1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')

        print("  -> Pre-validating final target pose...")
        ik_check = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, self.target_pose, initial_q_rad
        )

        if not ik_check.success:
            print("  -> VALIDATION FAILED: The final target pose is unreachable.")
            if ik_check.violations:
                print(f"     Reason: Solution violates joint limits: {ik_check.violations}")
            self.is_valid = False # Mark as invalid if path fails
            return

        # --- NEW BLOCK: Calculate duration from velocity if needed ---
        if self.velocity_percent is not None:
            print(f"  -> Calculating duration for {self.velocity_percent}% speed...")
            # Calculate the total distance for translation and rotation
            linear_distance = np.linalg.norm(self.target_pose.t - self.initial_pose.t)
            angular_distance_rad = self.initial_pose.angdist(self.target_pose)

            # Interpolate the target speeds from percentages, assuming constants exist in PAROL6_ROBOT
            target_linear_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min, PAROL6_ROBOT.Cartesian_linear_velocity_max])
            target_angular_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max])
            target_angular_speed_rad = np.deg2rad(target_angular_speed)

            # Calculate time required for each component of the movement
            time_linear = linear_distance / target_linear_speed if target_linear_speed > 0 else 0
            time_angular = angular_distance_rad / target_angular_speed_rad if target_angular_speed_rad > 0 else 0

            # The total duration is the longer of the two times to ensure synchronization
            calculated_duration = max(time_linear, time_angular)

            if calculated_duration <= 0:
                print("  -> INFO: MoveCart has zero duration. Marking as finished.")
                self.is_finished = True
                self.is_valid = True # It's valid, just already done.
                return

            self.duration = calculated_duration
            print(f"  -> Calculated MoveCart duration: {self.duration:.2f}s")

        print("  -> Command is valid and ready for execution.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        if self.start_time is None:
            self.start_time = time.time()

        elapsed_time = time.time() - self.start_time
        s = min(elapsed_time / self.duration, 1.0)
        s_scaled = quintic_scaling(s)

        current_target_pose = self.initial_pose.interp(self.target_pose, s_scaled)

        current_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, current_target_pose, current_q_rad
        )

        if not ik_solution.success:
            print("  -> ERROR: MoveCart failed. An intermediate point on the path is unreachable.")
            if ik_solution.violations:
                 print(f"     Reason: Path violates joint limits: {ik_solution.violations}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        current_pos_rad = ik_solution.q

        # --- MODIFIED BLOCK ---
        # Send only the target position and let the firmware's P-controller handle speed.
        Position_out[:] = [int(PAROL6_ROBOT.RAD2STEPS(p, i)) for i, p in enumerate(current_pos_rad)]
        Speed_out[:] = [0] * 6 # Set feed-forward velocity to zero for smooth P-control.
        Command_out.value = 156
        # --- END MODIFIED BLOCK ---

        if s >= 1.0:
            print(f"MoveCart finished in ~{elapsed_time:.2f}s.")
            self.is_finished = True
            # The main loop will handle holding the final position.

        return self.is_finished
        
class GripperCommand:
    """
    A single, unified, non-blocking command to control all gripper functions.
    It internally selects the correct logic (position-based waiting, timed delay,
    or instantaneous) based on the specified action.
    """
    def __init__(self, gripper_type, action=None, position=100, speed=100, current=500, output_port=1):
        """
        Initializes the Gripper command and configures its internal state machine
        based on the requested action.
        """
        self.is_valid = True
        self.is_finished = False
        self.gripper_type = gripper_type.lower()
        self.action = action.lower() if action else 'move'
        self.state = "START"
        self.timeout_counter = 1000 # 10-second safety timeout for all waiting states

        # --- Configure based on Gripper Type and Action ---
        if self.gripper_type == 'electric':
            if self.action == 'move':
                self.target_position = position
                self.speed = speed
                self.current = current
                if not (0 <= position <= 255 and 0 <= speed <= 255 and 100 <= current <= 1000):
                    self.is_valid = False
            elif self.action == 'calibrate':
                self.wait_counter = 200 # 2-second fixed delay for calibration
            else:
                self.is_valid = False # Invalid action

        elif self.gripper_type == 'pneumatic':
            if self.action not in ['open', 'close']:
                self.is_valid = False
            self.state_to_set = 1 if self.action == 'open' else 0
            self.port_index = 2 if output_port == 1 else 3
        else:
            self.is_valid = False

        if not self.is_valid:
            print(f"  -> VALIDATION FAILED for GripperCommand with action: '{self.action}'")

    def execute_step(self, Gripper_data_out, InOut_out, Gripper_data_in, InOut_in, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        self.timeout_counter -= 1
        if self.timeout_counter <= 0:
            print(f"  -> ERROR: Gripper command timed out in state {self.state}.")
            self.is_finished = True
            return True

        # --- Pneumatic Logic (Instantaneous) ---
        if self.gripper_type == 'pneumatic':
            InOut_out[self.port_index] = self.state_to_set
            print("  -> Pneumatic gripper command sent.")
            self.is_finished = True
            return True

        # --- Electric Gripper Logic ---
        if self.gripper_type == 'electric':
            # On the first run, transition to the correct state for the action
            if self.state == "START":
                if self.action == 'calibrate':
                    self.state = "SEND_CALIBRATE"
                else: # 'move'
                    self.state = "WAIT_FOR_POSITION"
            
            # --- Calibrate Logic (Timed Delay) ---
            if self.state == "SEND_CALIBRATE":
                print("  -> Sending one-shot calibrate command...")
                Gripper_data_out[4] = 1 # Set mode to calibrate
                self.state = "WAITING_CALIBRATION"
                return False

            if self.state == "WAITING_CALIBRATION":
                self.wait_counter -= 1
                if self.wait_counter <= 0:
                    print("  -> Calibration delay finished.")
                    Gripper_data_out[4] = 0 # Reset to operation mode
                    self.is_finished = True
                    return True
                return False

            # --- Move Logic (Position-Based) ---
            if self.state == "WAIT_FOR_POSITION":
                # Persistently send the move command
                Gripper_data_out[0], Gripper_data_out[1], Gripper_data_out[2] = self.target_position, self.speed, self.current
                Gripper_data_out[4] = 0 # Operation mode
                bitfield = [1, 1, not InOut_in[4], 1, 0, 0, 0, 0]
                fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                Gripper_data_out[3] = int(fused.hex(), 16)

                # Check for completion
                current_position = Gripper_data_in[1]
                if abs(current_position - self.target_position) <= 5:
                    print(f"  -> Gripper move complete.")
                    self.is_finished = True
                    # Set command back to idle
                    bitfield = [1, 0, not InOut_in[4], 1, 0, 0, 0, 0]
                    fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                    Gripper_data_out[3] = int(fused.hex(), 16)
                    return True
                return False
        
        return self.is_finished

class DelayCommand:
    """
    A non-blocking command that pauses execution for a specified duration.
    During the delay, it ensures the robot remains idle by sending the
    appropriate commands.
    """
    def __init__(self, duration):
        """
        Initializes and validates the Delay command.

        Args:
            duration (float): The delay time in seconds.
        """
        self.is_valid = False
        self.is_finished = False

        # --- 1. Parameter Validation ---
        if not isinstance(duration, (int, float)) or duration <= 0:
            print(f"  -> VALIDATION FAILED: Delay duration must be a positive number, but got {duration}.")
            return

        print(f"Initializing Delay for {duration} seconds...")
        
        self.duration = duration
        self.end_time = None  # Will be set in prepare_for_execution
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Set the end time when the command actually starts."""
        self.end_time = time.time() + self.duration
        print(f"  -> Delay starting for {self.duration} seconds...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Checks if the delay duration has passed and keeps the robot idle.
        This method is called on every loop cycle (~0.01s).
        """
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Keep the robot idle during the delay ---
        Command_out.value = 255  # Set command to idle
        Speed_out[:] = [0] * 6   # Set all speeds to zero

        # --- B. Check for completion ---
        if self.end_time and time.time() >= self.end_time:
            print(f"Delay finished after {self.duration} seconds.")
            self.is_finished = True
        
        return self.is_finished
    
#########################################################################
# Smooth Motion Commands Start Here
#########################################################################
    
class BaseSmoothMotionCommand:
    """
    Base class for all smooth motion commands with proper error tracking.
    """
    
    def __init__(self, description="smooth motion"):
        self.description = description
        self.trajectory = None
        self.trajectory_command = None
        self.transition_command = None
        self.is_valid = True
        self.is_finished = False
        self.specified_start_pose = None
        self.transition_complete = False
        self.trajectory_prepared = False
        self.error_state = False
        self.error_message = ""
        self.trajectory_generated = False  # NEW: Track if trajectory is generated
        
    def create_transition_command(self, current_pose, target_pose):
        """Create a MovePose command for smooth transition to start position."""
        pos_error = np.linalg.norm(
            np.array(target_pose[:3]) - np.array(current_pose[:3])
        )
        
        # Lower threshold to 2mm for more aggressive transition generation
        if pos_error < 2.0:  # Changed from 5.0mm to 2.0mm
            print(f"  -> Already near start position (error: {pos_error:.1f}mm)")
            return None
        
        print(f"  -> Creating smooth transition to start ({pos_error:.1f}mm away)")
        
        # Calculate transition speed based on distance
        # Slower for short distances, faster for long distances
        if pos_error < 10:
            transition_speed = 20.0  # mm/s for short distances
        elif pos_error < 30:
            transition_speed = 30.0  # mm/s for medium distances
        else:
            transition_speed = 40.0  # mm/s for long distances
        
        transition_duration = max(pos_error / transition_speed, 0.5)  # Minimum 0.5s
        
        transition_cmd = MovePoseCommand(
            pose=target_pose,
            duration=transition_duration
        )
        
        return transition_cmd
    
    def get_current_pose_from_position(self, position_in):
        """Convert current position to pose [x,y,z,rx,ry,rz]"""
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(position_in)])
        current_pose_se3 = PAROL6_ROBOT.robot.fkine(current_q)
        
        current_xyz = current_pose_se3.t * 1000  # Convert to mm
        current_rpy = current_pose_se3.rpy(unit='deg', order='xyz')
        return np.concatenate([current_xyz, current_rpy]).tolist()
        
    def prepare_for_execution(self, current_position_in):
        """Minimal preparation - just check if we need a transition."""
        print(f"  -> Preparing {self.description}...")
        
        # If there's a specified start pose, prepare transition
        if self.specified_start_pose:
            actual_current_pose = self.get_current_pose_from_position(current_position_in)
            self.transition_command = self.create_transition_command(
                actual_current_pose, self.specified_start_pose
            )
            
            if self.transition_command:
                self.transition_command.prepare_for_execution(current_position_in)
                if not self.transition_command.is_valid:
                    print(f"  -> ERROR: Cannot reach specified start position")
                    self.is_valid = False
                    self.error_state = True
                    self.error_message = "Cannot reach specified start position"
                    return
        else:
            self.transition_command = None
            
        # DON'T generate trajectory yet - wait until execution
        self.trajectory_generated = False
        self.trajectory_prepared = False
        print(f"  -> {self.description} preparation complete (trajectory will be generated at execution)")
            
    def generate_main_trajectory(self, effective_start_pose):
        """Override this in subclasses to generate the specific motion trajectory."""
        raise NotImplementedError("Subclasses must implement generate_main_trajectory")
        
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """Execute transition first if needed, then generate and execute trajectory."""
        if self.is_finished or not self.is_valid:
            return True
        
        # Execute transition first if needed
        if self.transition_command and not self.transition_complete:
            is_done = self.transition_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            if is_done:
                print(f"  -> Transition complete")
                self.transition_complete = True
            return False
        
        # Generate trajectory on first execution step (not during preparation!)
        if not self.trajectory_generated:
            # Get ACTUAL current position NOW
            actual_current_pose = self.get_current_pose_from_position(Position_in)
            print(f"  -> Generating {self.description} from ACTUAL position: {[round(p, 1) for p in actual_current_pose[:3]]}")
            
            # Generate trajectory from where we ACTUALLY are
            self.trajectory = self.generate_main_trajectory(actual_current_pose)
            self.trajectory_command = SmoothTrajectoryCommand(
                self.trajectory, self.description
            )
            
            # Quick validation of first point only
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(Position_in)])
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
            )
            
            if not ik_result.success:
                print(f"  -> ERROR: Cannot reach first trajectory point")
                self.is_finished = True
                self.error_state = True
                self.error_message = "Cannot reach trajectory start"
                Speed_out[:] = [0] * 6
                Command_out.value = 255
                return True
                
            self.trajectory_generated = True
            self.trajectory_prepared = True
            
            # Verify first point is close to current
            distance = np.linalg.norm(first_pose[:3] - np.array(actual_current_pose[:3]))
            if distance > 5.0:
                print(f"  -> WARNING: First trajectory point {distance:.1f}mm from current!")
        
        # Execute main trajectory
        if self.trajectory_command and self.trajectory_prepared:
            is_done = self.trajectory_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            # Check for errors in trajectory execution
            if hasattr(self.trajectory_command, 'error_state') and self.trajectory_command.error_state:
                self.error_state = True
                self.error_message = self.trajectory_command.error_message
            
            if is_done:
                self.is_finished = True
            
            return is_done
        else:
            self.is_finished = True
            return True

class SmoothTrajectoryCommand:
    """Command class for executing pre-generated smooth trajectories."""
    
    def __init__(self, trajectory, description="smooth motion"):
        self.trajectory = np.array(trajectory)
        self.description = description
        self.trajectory_index = 0
        self.is_valid = True
        self.is_finished = False
        self.first_step = True
        self.error_state = False
        self.error_message = ""
        
        print(f"Initializing smooth {description} with {len(trajectory)} points")
    
    def prepare_for_execution(self, current_position_in):
        """Skip validation - trajectory is already generated from correct position"""
        # No validation needed since trajectory was just generated from current position
        self.is_valid = True
        return
    
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, Position_out=None, **kwargs):
        """Execute one step of the smooth trajectory"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Get Position_out from kwargs if not provided
        if Position_out is None:
            Position_out = kwargs.get('Position_out', Position_in)
        
        if self.trajectory_index >= len(self.trajectory):
            print(f"Smooth {self.description} finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get target pose for this step
        target_pose = self.trajectory[self.trajectory_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                            for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
        )
        
        if not ik_result.success:
            print(f"  -> IK failed at trajectory point {self.trajectory_index}")
            self.is_finished = True
            self.error_state = True
            self.error_message = f"IK failed at point {self.trajectory_index}/{len(self.trajectory)}"
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                    for i, q in enumerate(ik_result.q)]
        
        # ADD VELOCITY LIMITING - This prevents violent movements
        if self.trajectory_index > 0:
            for i in range(6):
                step_diff = abs(target_steps[i] - Position_in[i])
                max_step_diff = PAROL6_ROBOT.Joint_max_speed[i] * 0.01  # Max steps in 10ms
                
                # Use 1.2x safety margin (not 2x as before)
                if step_diff > max_step_diff * 1.2:
                    #print(f"  -> WARNING: Joint {i+1} velocity limit exceeded at point {self.trajectory_index}")
                    #print(f"     Step difference: {step_diff}, Max allowed: {max_step_diff * 1.2:.1f}")
                    
                    # Clamp the motion
                    sign = 1 if target_steps[i] > Position_in[i] else -1
                    target_steps[i] = Position_in[i] + sign * int(max_step_diff)
        
        # Send position command
        Position_out[:] = target_steps
        Speed_out[:] = [0] * 6
        Command_out.value = 156
        
        # Advance to next point
        self.trajectory_index += 1
        
        return False

class SmoothCircleCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, plane, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"circle (r={radius}mm, {frame})")
        self.center = center
        self.radius = radius
        self.plane = plane
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame  # Store reference frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None  # Store for TRF transformation
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        # Store current position for potential use in generate_main_trajectory
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'center': self.center,
                'plane': self.plane
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_CIRCLE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Circle: center {self.center[:3]} (WRF), normal {self.normal_vector}")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_CIRCLE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        # Now do normal preparation with transformed parameters
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate circle starting from the actual start position."""
        motion_gen = CircularMotion()
        
        # Use transformed normal for TRF, or standard for WRF
        if self.normal_vector is not None:
            # TRF - use the transformed normal vector
            normal = np.array(self.normal_vector)
            print(f"    Using transformed normal: {normal.round(3)}")
        else:
            # WRF - use standard plane definition
            plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
            normal = np.array(plane_normals.get(self.plane, [0, 0, 1]))  # Convert to numpy array
            print(f"    Using WRF plane {self.plane} with normal: {normal}")
        
        print(f"    Generating circle from position: {[round(p, 1) for p in effective_start_pose[:3]]}")
        print(f"    Circle center: {[round(c, 1) for c in self.center]}")
        
        # Add geometry validation
        center_np = np.array(self.center)
        start_np = np.array(effective_start_pose[:3])
        
        # Project start point onto circle plane to check distance
        to_start = start_np - center_np
        to_start_plane = to_start - np.dot(to_start, normal) * normal
        distance_to_center = np.linalg.norm(to_start_plane)
        
        if abs(distance_to_center - self.radius) > self.radius * 0.3:
            print(f"    WARNING: Robot is {distance_to_center:.1f}mm from center, but radius is {self.radius:.1f}mm")
            print(f"    Circle geometry will be auto-corrected")
        
        # Generate circle that starts at effective_start_pose
        trajectory = motion_gen.generate_circle_3d(
            self.center, 
            self.radius, 
            normal,  # This normal now correctly represents the plane
            start_point=effective_start_pose[:3],
            duration=self.duration
        )
        
        if self.clockwise:
            trajectory = trajectory[::-1]
        
        # Update orientations to match start pose
        for i in range(len(trajectory)):
            trajectory[i][3:] = effective_start_pose[3:]
        
        return trajectory
    
class SmoothArcCenterCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, center, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"arc (center-based, {frame})")
        self.end_pose = end_pose
        self.center = center
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {
                'end_pose': self.end_pose,
                'center': self.center
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
            )
            self.end_pose = transformed['end_pose']
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc from actual start to end."""
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, self.center,
            normal=self.normal_vector,  # Use transformed normal if TRF
            clockwise=self.clockwise, duration=self.duration
        )
    
class SmoothArcParamCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, radius, arc_angle, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"parametric arc (r={radius}mm, θ={arc_angle}°, {frame})")
        self.end_pose = end_pose
        self.radius = radius
        self.arc_angle = arc_angle
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'end_pose': self.end_pose,
                'plane': 'XY'  # Default plane for parametric arc
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.end_pose = transformed['end_pose']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Parametric Arc: end {self.end_pose[:3]} (WRF)")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc based on radius and angle from actual start."""
        # Get start and end positions
        start_xyz = np.array(effective_start_pose[:3])
        end_xyz = np.array(self.end_pose[:3])
        
        # If we have a transformed normal (TRF), use it to define the arc plane
        if self.normal_vector is not None:
            normal = np.array(self.normal_vector)
            
            # Project start and end onto the plane perpendicular to normal
            # This ensures the arc stays in the correct plane for TRF
            
            # Find center of arc using radius and angle
            chord_vec = end_xyz - start_xyz
            chord_length = np.linalg.norm(chord_vec)
            
            if chord_length > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({chord_length:.1f}mm) for radius {self.radius}mm")
                self.radius = chord_length / 2 + 1
            
            # Calculate center position using the normal vector
            chord_mid = (start_xyz + end_xyz) / 2
            
            # Height from chord midpoint to arc center
            if chord_length > 0:
                h = np.sqrt(max(0, self.radius**2 - (chord_length/2)**2))
                
                # Find perpendicular in the plane defined by normal
                chord_dir = chord_vec / chord_length
                perp_in_plane = np.cross(normal, chord_dir)
                if np.linalg.norm(perp_in_plane) > 0.001:
                    perp_in_plane = perp_in_plane / np.linalg.norm(perp_in_plane)
                else:
                    # Chord is parallel to normal (shouldn't happen)
                    perp_in_plane = np.array([1, 0, 0])
                
                # Arc center
                if self.clockwise:
                    center_3d = chord_mid - h * perp_in_plane
                else:
                    center_3d = chord_mid + h * perp_in_plane
            else:
                center_3d = start_xyz
            
        else:
            # WRF - use XY plane (standard behavior)
            normal = np.array([0, 0, 1])
            
            # Calculate arc center in XY plane
            start_xy = start_xyz[:2]
            end_xy = end_xyz[:2]
            
            # Midpoint
            mid = (start_xy + end_xy) / 2
            
            # Distance between points
            d = np.linalg.norm(end_xy - start_xy)
            
            if d > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({d:.1f}mm) for radius {self.radius}mm")
                self.radius = d / 2 + 1
            
            # Height of arc center from midpoint
            h = np.sqrt(max(0, self.radius**2 - (d/2)**2))
            
            # Perpendicular direction
            if d > 0:
                perp = np.array([-(end_xy[1] - start_xy[1]), end_xy[0] - start_xy[0]])
                perp = perp / np.linalg.norm(perp)
            else:
                perp = np.array([1, 0])
            
            # Arc center (choose based on clockwise)
            if self.clockwise:
                center_2d = mid - h * perp
            else:
                center_2d = mid + h * perp
            
            # Use average Z for center
            center_3d = [center_2d[0], center_2d[1], (start_xyz[2] + end_xyz[2]) / 2]
        
        # Generate arc trajectory from actual start
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, center_3d.tolist(),
            normal=normal if self.normal_vector is not None else None,
            clockwise=self.clockwise, duration=self.duration
        )

class SmoothHelixCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, pitch, height, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"helix (h={height}mm, {frame})")
        self.center = center
        self.radius = radius
        self.pitch = pitch
        self.height = height
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.helix_axis = None
        self.up_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {'center': self.center}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_HELIX', params, 'TRF', current_position_in
            )
            self.center = transformed['center']
            self.helix_axis = transformed.get('helix_axis', [0, 0, 1])
            self.up_vector = transformed.get('up_vector', [0, 1, 0])
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_HELIX', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate helix with proper axis orientation."""
        num_revolutions = self.height / self.pitch if self.pitch > 0 else 1
        num_points = int(self.duration * 100)  # 100Hz
        
        # Get helix axis (default Z for WRF, transformed for TRF)
        if self.helix_axis is not None:
            axis = np.array(self.helix_axis)
        else:
            axis = np.array([0, 0, 1])  # Default vertical
        
        # Create orthonormal basis for helix
        if self.up_vector is not None:
            up = np.array(self.up_vector)
        else:
            # Find perpendicular to axis
            if abs(axis[2]) < 0.9:
                up = np.array([0, 0, 1])
            else:
                up = np.array([1, 0, 0])
        
        # Ensure up is perpendicular to axis
        up = up - np.dot(up, axis) * axis
        up = up / np.linalg.norm(up)
        
        # Create right vector
        right = np.cross(axis, up)
        
        # Calculate starting angle based on actual start position
        to_start = np.array(effective_start_pose[:3]) - np.array(self.center)
        # Project onto plane perpendicular to axis
        to_start_plane = to_start - np.dot(to_start, axis) * axis
        
        if np.linalg.norm(to_start_plane) > 0.001:
            to_start_normalized = to_start_plane / np.linalg.norm(to_start_plane)
            start_angle = np.arctan2(np.dot(to_start_normalized, up), 
                                    np.dot(to_start_normalized, right))
        else:
            start_angle = 0
        
        trajectory = []
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            
            angle = start_angle + 2 * np.pi * num_revolutions * t
            if self.clockwise:
                angle = start_angle - 2 * np.pi * num_revolutions * t
            
            # Position on helix
            pos = np.array(self.center) + \
                  self.radius * (np.cos(angle) * right + np.sin(angle) * up) + \
                  self.height * t * axis
            
            # Use orientation from effective start
            trajectory.append(np.concatenate([pos, effective_start_pose[3:]]))
        
        return np.array(trajectory)

class SmoothSplineCommand(BaseSmoothMotionCommand):
    def __init__(self, waypoints, duration, frame='WRF', start_pose=None):
        super().__init__(f"spline ({len(waypoints)} points, {frame})")
        self.waypoints = waypoints
        self.duration = duration
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform waypoints to WRF
            params = {'waypoints': self.waypoints}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_SPLINE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.waypoints = transformed['waypoints']
            
            print(f"  -> TRF Spline: transformed {len(self.waypoints)} waypoints to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_SPLINE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate spline starting from actual position."""
        motion_gen = SplineMotion()
        
        # Always start from the effective start pose
        first_wp_error = np.linalg.norm(
            np.array(self.waypoints[0][:3]) - np.array(effective_start_pose[:3])
        )
        
        if first_wp_error > 5.0:
            # First waypoint is far, prepend the start position
            modified_waypoints = [effective_start_pose] + self.waypoints
            print(f"    Added start position as first waypoint (distance: {first_wp_error:.1f}mm)")
        else:
            # Replace first waypoint with actual start to ensure continuity
            modified_waypoints = [effective_start_pose] + self.waypoints[1:]
            print(f"    Replaced first waypoint with actual start position")
        
        timestamps = np.linspace(0, self.duration, len(modified_waypoints))
        
        # Generate the spline trajectory
        trajectory = motion_gen.generate_cubic_spline(modified_waypoints, timestamps)
        
        print(f"    Generated spline with {len(trajectory)} points")
        
        return trajectory

class SmoothBlendCommand(BaseSmoothMotionCommand):
    def __init__(self, segment_definitions, blend_time, frame='WRF', start_pose=None):
        super().__init__(f"blended ({len(segment_definitions)} segments, {frame})")
        self.segment_definitions = segment_definitions
        self.blend_time = blend_time
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform all segment definitions to WRF
            params = {'segments': self.segment_definitions}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_BLEND', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.segment_definitions = transformed['segments']
            
            print(f"  -> TRF Blend: transformed {len(self.segment_definitions)} segments to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_BLEND', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate blended trajectory starting from actual position."""
        trajectories = []
        motion_gen_circle = CircularMotion()
        motion_gen_spline = SplineMotion()
        
        # Always start from effective start pose
        last_end_pose = effective_start_pose
        
        for i, seg_def in enumerate(self.segment_definitions):
            seg_type = seg_def['type']
            
            # First segment always starts from effective_start_pose
            segment_start = effective_start_pose if i == 0 else last_end_pose
            
            if seg_type == 'LINE':
                end = seg_def['end']
                duration = seg_def['duration']
                
                # Generate line segment from actual position
                num_points = int(duration * 100)
                timestamps = np.linspace(0, duration, num_points)
                
                traj = []
                for t in timestamps:
                    s = t / duration if duration > 0 else 1
                    # Interpolate position
                    pos = [
                        segment_start[j] * (1-s) + end[j] * s
                        for j in range(3)
                    ]
                    # Interpolate orientation
                    orient = [
                        segment_start[j+3] * (1-s) + end[j+3] * s
                        for j in range(3)
                    ]
                    traj.append(pos + orient)
                
                trajectories.append(np.array(traj))
                last_end_pose = end
                
            elif seg_type == 'ARC':
                end = seg_def['end']
                center = seg_def['center']
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Check if we have a transformed normal (from TRF)
                normal = seg_def.get('normal_vector', None)
                
                traj = motion_gen_circle.generate_arc_3d(
                    segment_start, end, center, 
                    normal=normal,  # Use transformed normal if available
                    clockwise=clockwise, duration=duration
                )
                trajectories.append(traj)
                last_end_pose = end
                
            elif seg_type == 'CIRCLE':
                center = seg_def['center']
                radius = seg_def['radius']
                plane = seg_def.get('plane', 'XY')
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Use transformed normal if available (from TRF)
                if 'normal_vector' in seg_def:
                    normal = seg_def['normal_vector']
                else:
                    plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
                    normal = plane_normals.get(plane, [0, 0, 1])
                
                traj = motion_gen_circle.generate_circle_3d(
                    center, radius, normal, 
                    start_point=segment_start[:3],
                    duration=duration
                )
                
                if clockwise:
                    traj = traj[::-1]
                    
                # Update orientations
                for j in range(len(traj)):
                    traj[j][3:] = segment_start[3:]
                    
                trajectories.append(traj)
                # Circle returns to start, so last pose is last point of trajectory
                last_end_pose = traj[-1].tolist()
                
            elif seg_type == 'SPLINE':
                waypoints = seg_def['waypoints']
                duration = seg_def['duration']
                
                # Check if first waypoint is close to segment start
                wp_error = np.linalg.norm(
                    np.array(waypoints[0][:3]) - np.array(segment_start[:3])
                )
                
                if wp_error > 5.0:
                    full_waypoints = [segment_start] + waypoints
                else:
                    full_waypoints = [segment_start] + waypoints[1:]
                
                timestamps = np.linspace(0, duration, len(full_waypoints))
                traj = motion_gen_spline.generate_cubic_spline(full_waypoints, timestamps)
                trajectories.append(traj)
                last_end_pose = waypoints[-1]
        
        # Blend all trajectories
        if len(trajectories) > 1:
            blender = MotionBlender(self.blend_time)
            blended = trajectories[0]
            blend_samples = int(self.blend_time * 100)
            
            for i in range(1, len(trajectories)):
                blended = blender.blend_trajectories(blended, trajectories[i], blend_samples)
            
            print(f"    Blended {len(trajectories)} segments into {len(blended)} points")
            return blended
        elif trajectories:
            return trajectories[0]
        else:
            raise ValueError("No trajectories generated in blend")
        
def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
    """
    Calculate duration based on trajectory length and speed percentage.
    
    Args:
        trajectory_length: Total path length in mm
        speed_percentage: Speed as percentage (1-100)
        
    Returns:
        Duration in seconds
    """
    # Map speed percentage to mm/s (adjustable based on robot capabilities)
    # For example: 100% = 100mm/s, 50% = 50mm/s
    speed_mm_s = np.interp(speed_percentage, [0, 100], 
                          [PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000,
                           PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000])
    
    if speed_mm_s > 0:
        return trajectory_length / speed_mm_s
    else:
        return 5.0  # Default fallback
    
def parse_smooth_motion_commands(parts):
    """
    Parse smooth motion commands received via UDP and create appropriate command objects.
    All commands support:
    - Reference frame selection (WRF or TRF)
    - Optional start position (CURRENT or specified pose)
    - Both DURATION and SPEED timing modes
    
    Args:
        parts: List of command parts split by '|'
        
    Returns:
        Command object or None if parsing fails
    """
    command_type = parts[0]
    
    # Helper function for parsing optional start pose
    def parse_start_pose(start_str):
        """Parse start pose - returns None for CURRENT, or list of floats for specified pose."""
        if start_str == 'CURRENT' or start_str == 'NONE':
            return None
        else:
            try:
                return list(map(float, start_str.split(',')))
            except:
                print(f"Warning: Invalid start pose format: {start_str}")
                return None
    
    # Helper function for calculating duration from speed
    def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
        """Calculate duration based on trajectory length and speed percentage."""
        # Map speed percentage to mm/s
        min_speed = PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000  # Convert to mm/s
        max_speed = PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000  # Convert to mm/s
        speed_mm_s = np.interp(speed_percentage, [0, 100], [min_speed, max_speed])
        
        if speed_mm_s > 0:
            return trajectory_length / speed_mm_s
        else:
            return 5.0  # Default fallback
    
    try:
        if command_type == 'SMOOTH_CIRCLE':
            # Format: SMOOTH_CIRCLE|center_x,center_y,center_z|radius|plane|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            plane = parts[3]
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Circle circumference
                path_length = 2 * np.pi * radius
                duration = calculate_duration_from_speed(path_length, timing_value)
            
            print(f"  -> Parsed circle: r={radius}mm, plane={plane}, frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command object with frame parameter
            return SmoothCircleCommand(center, radius, plane, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_CENTER':
            # Format: SMOOTH_ARC_CENTER|end_pose|center|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            center = list(map(float, parts[2].split(',')))
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[6])
            clockwise = parts[7] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Estimate arc length (will be more accurate when we have actual positions)
                # Use a conservative estimate based on radius
                radius_estimate = np.linalg.norm(np.array(center) - np.array(end_pose[:3]))
                estimated_arc_angle = np.pi / 2  # 90 degrees estimate
                arc_length = radius_estimate * estimated_arc_angle
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (center): frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command with frame
            return SmoothArcCenterCommand(end_pose, center, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_PARAM':
            # Format: SMOOTH_ARC_PARAM|end_pose|radius|angle|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            arc_angle = float(parts[3])
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Arc length = radius * angle (in radians)
                arc_length = radius * np.deg2rad(arc_angle)
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (param): r={radius}mm, θ={arc_angle}°, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothArcParamCommand(end_pose, radius, arc_angle, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_SPLINE':
            # Format: SMOOTH_SPLINE|num_waypoints|frame|start_pose|timing_type|timing_value|waypoint1|waypoint2|...
            num_waypoints = int(parts[1])
            frame = parts[2]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[3])
            timing_type = parts[4]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[5])
            
            # Parse waypoints
            waypoints = []
            idx = 6
            for i in range(num_waypoints):
                wp = []
                for j in range(6):  # Each waypoint has 6 values (x,y,z,rx,ry,rz)
                    wp.append(float(parts[idx]))
                    idx += 1
                waypoints.append(wp)
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate total path length
                total_dist = 0
                for i in range(1, len(waypoints)):
                    dist = np.linalg.norm(np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3]))
                    total_dist += dist
                
                duration = calculate_duration_from_speed(total_dist, timing_value)
            
            print(f"  -> Parsed spline: {num_waypoints} points, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothSplineCommand(waypoints, duration, frame, start_pose)
            
        elif command_type == 'SMOOTH_HELIX':
            # Format: SMOOTH_HELIX|center|radius|pitch|height|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            pitch = float(parts[3])
            height = float(parts[4])
            frame = parts[5]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[6])
            timing_type = parts[7]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[8])
            clockwise = parts[9] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate helix path length
                num_revolutions = height / pitch if pitch > 0 else 1
                horizontal_length = 2 * np.pi * radius * num_revolutions
                helix_length = np.sqrt(horizontal_length**2 + height**2)
                duration = calculate_duration_from_speed(helix_length, timing_value)
            
            print(f"  -> Parsed helix: h={height}mm, pitch={pitch}mm, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothHelixCommand(center, radius, pitch, height, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_BLEND':
            # Format: SMOOTH_BLEND|num_segments|blend_time|frame|start_pose|timing_type|timing_value|segment1||segment2||...
            num_segments = int(parts[1])
            blend_time = float(parts[2])
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DEFAULT', 'DURATION', or 'SPEED'
            
            # Parse overall timing
            if timing_type == 'DEFAULT':
                # Use individual segment durations as-is
                overall_duration = None
                overall_speed = None
                segments_start_idx = 6
            else:
                timing_value = float(parts[6])
                if timing_type == 'DURATION':
                    overall_duration = timing_value
                    overall_speed = None
                else:  # SPEED
                    overall_speed = timing_value
                    overall_duration = None
                segments_start_idx = 7
            
            # Parse segments (separated by ||)
            segments_data = '|'.join(parts[segments_start_idx:])
            segment_strs = segments_data.split('||')
            
            # Parse segment definitions
            segment_definitions = []
            total_original_duration = 0
            total_estimated_length = 0
            
            for seg_str in segment_strs:
                if not seg_str:  # Skip empty segments
                    continue
                    
                seg_parts = seg_str.split('|')
                seg_type = seg_parts[0]
                
                if seg_type == 'LINE':
                    # Format: LINE|end_x,end_y,end_z,end_rx,end_ry,end_rz|duration
                    end = list(map(float, seg_parts[1].split(',')))
                    segment_duration = float(seg_parts[2])
                    total_original_duration += segment_duration
                    
                    # Estimate length (will be refined when we have actual start)
                    estimated_length = 100  # mm, conservative estimate
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'LINE',
                        'end': end,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
                    
                elif seg_type == 'CIRCLE':
                    # Format: CIRCLE|center_x,center_y,center_z|radius|plane|duration|clockwise
                    center = list(map(float, seg_parts[1].split(',')))
                    radius = float(seg_parts[2])
                    plane = seg_parts[3]
                    segment_duration = float(seg_parts[4])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[5] == '1'
                    
                    # Circle circumference
                    estimated_length = 2 * np.pi * radius
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'CIRCLE',
                        'center': center,
                        'radius': radius,
                        'plane': plane,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'ARC':
                    # Format: ARC|end_x,end_y,end_z,end_rx,end_ry,end_rz|center_x,center_y,center_z|duration|clockwise
                    end = list(map(float, seg_parts[1].split(',')))
                    center = list(map(float, seg_parts[2].split(',')))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[4] == '1'
                    
                    # Estimate arc length
                    estimated_radius = 50  # mm
                    estimated_arc_angle = np.pi / 2  # 90 degrees
                    estimated_length = estimated_radius * estimated_arc_angle
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'ARC',
                        'end': end,
                        'center': center,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'SPLINE':
                    # Format: SPLINE|num_points|waypoint1;waypoint2;...|duration
                    num_points = int(seg_parts[1])
                    waypoints = []
                    wp_strs = seg_parts[2].split(';')
                    for wp_str in wp_strs:
                        waypoints.append(list(map(float, wp_str.split(','))))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    
                    # Estimate spline length
                    estimated_length = 0
                    for i in range(1, len(waypoints)):
                        estimated_length += np.linalg.norm(
                            np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3])
                        )
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'SPLINE',
                        'waypoints': waypoints,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
            
            # Adjust segment durations if overall timing is specified
            if overall_duration is not None:
                # Scale all segment durations proportionally
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Scaled blend segments to total duration: {overall_duration:.2f}s")
                        
            elif overall_speed is not None:
                # Calculate duration from speed and estimated path length
                overall_duration = calculate_duration_from_speed(total_estimated_length, overall_speed)
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Calculated blend duration from speed: {overall_duration:.2f}s")
            else:
                print(f"  -> Using original segment durations (total: {total_original_duration:.2f}s)")
            
            print(f"  -> Parsed blend: {num_segments} segments, frame={frame}, blend_time={blend_time}s")
            
            # Return command with frame
            return SmoothBlendCommand(segment_definitions, blend_time, frame, start_pose)
            
    except Exception as e:
        print(f"Error parsing smooth motion command: {e}")
        print(f"Command parts: {parts}")
        import traceback
        traceback.print_exc()
        return None
    
    print(f"Warning: Unknown smooth motion command type: {command_type}")
    return None

def transform_command_params_to_wrf(command_type: str, params: dict, frame: str, current_position_in) -> dict:
    """
    Transform command parameters from TRF to WRF.
    Handles position, orientation, and directional vectors correctly.
    """
    if frame == 'WRF':
        return params
    
    # Get current tool pose
    current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                         for i, p in enumerate(current_position_in)])
    tool_pose = PAROL6_ROBOT.robot.fkine(current_q)
    
    transformed = params.copy()
    
    # SMOOTH_CIRCLE - Transform center and plane normal
    if command_type == 'SMOOTH_CIRCLE':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'plane' in params:
            plane_normals_trf = {
                'XY': [0, 0, 1],   # Tool's Z-axis
                'XZ': [0, 1, 0],   # Tool's Y-axis  
                'YZ': [1, 0, 0]    # Tool's X-axis
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
            print(f"  -> TRF circle plane {params['plane']} transformed to WRF")
    
    # SMOOTH_ARC_CENTER - Transform center, end_pose, and implied plane
    elif command_type == 'SMOOTH_ARC_CENTER':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # Arc plane is determined by start, end, and center points
        # But we should transform any specified plane normal
        if 'plane' in params:
            # Similar to circle plane transformation
            plane_normals_trf = {
                'XY': [0, 0, 1],
                'XZ': [0, 1, 0],
                'YZ': [1, 0, 0]
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_ARC_PARAM - Transform end_pose and arc plane
    elif command_type == 'SMOOTH_ARC_PARAM':
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # For parametric arc, the plane is usually XY of the tool
        # Transform the assumed plane normal
        if 'plane' not in params:
            params['plane'] = 'XY'  # Default to XY plane
        
        plane_normals_trf = {
            'XY': [0, 0, 1],
            'XZ': [0, 1, 0],
            'YZ': [1, 0, 0]
        }
        normal_trf = np.array(plane_normals_trf[params.get('plane', 'XY')])
        normal_wrf = tool_pose.R @ normal_trf
        transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_HELIX - Transform center and helix axis
    elif command_type == 'SMOOTH_HELIX':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        # Helix axis - default is Z-axis (vertical in TRF)
        # In TRF, helix rises along tool's Z-axis
        helix_axis_trf = np.array([0, 0, 1])  # Tool's Z-axis
        helix_axis_wrf = tool_pose.R @ helix_axis_trf
        transformed['helix_axis'] = helix_axis_wrf.tolist()
        
        # Also need to transform the "up" direction for proper orientation
        up_vector_trf = np.array([0, 1, 0])  # Tool's Y-axis
        up_vector_wrf = tool_pose.R @ up_vector_trf
        transformed['up_vector'] = up_vector_wrf.tolist()
    
    # SMOOTH_SPLINE - Transform all waypoints
    elif command_type == 'SMOOTH_SPLINE':
        if 'waypoints' in params:
            transformed_waypoints = []
            for wp in params['waypoints']:
                wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                         SE3.RPY(wp[3:], unit='deg', order='xyz')
                wp_wrf = tool_pose * wp_trf
                wp_transformed = np.concatenate([
                    wp_wrf.t * 1000,
                    wp_wrf.rpy(unit='deg', order='xyz')
                ]).tolist()
                transformed_waypoints.append(wp_transformed)
            transformed['waypoints'] = transformed_waypoints
    
    # SMOOTH_BLEND - Transform all segments recursively
    elif command_type == 'SMOOTH_BLEND':
        if 'segments' in params:
            transformed_segments = []
            for seg in params['segments']:
                seg_copy = seg.copy()
                seg_type = seg['type']
                
                if seg_type == 'LINE':
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'CIRCLE':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'plane' in seg:
                        plane_normals_trf = {
                            'XY': [0, 0, 1],
                            'XZ': [0, 1, 0],
                            'YZ': [1, 0, 0]
                        }
                        normal_trf = np.array(plane_normals_trf[seg['plane']])
                        normal_wrf = tool_pose.R @ normal_trf
                        seg_copy['normal_vector'] = normal_wrf.tolist()
                
                elif seg_type == 'ARC':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'SPLINE':
                    if 'waypoints' in seg:
                        transformed_waypoints = []
                        for wp in seg['waypoints']:
                            wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                                     SE3.RPY(wp[3:], unit='deg', order='xyz')
                            wp_wrf = tool_pose * wp_trf
                            wp_transformed = np.concatenate([
                                wp_wrf.t * 1000,
                                wp_wrf.rpy(unit='deg', order='xyz')
                            ]).tolist()
                            transformed_waypoints.append(wp_transformed)
                        seg_copy['waypoints'] = transformed_waypoints
                
                transformed_segments.append(seg_copy)
            transformed['segments'] = transformed_segments
    
    # Transform start_pose if specified (common to all commands)
    if 'start_pose' in params and params['start_pose'] is not None:
        start_trf = SE3(params['start_pose'][0]/1000, 
                       params['start_pose'][1]/1000, 
                       params['start_pose'][2]/1000) * \
                    SE3.RPY(params['start_pose'][3:], unit='deg', order='xyz')
        start_wrf = tool_pose * start_trf
        transformed['start_pose'] = np.concatenate([
            start_wrf.t * 1000,
            start_wrf.rpy(unit='deg', order='xyz')
        ]).tolist()
    
    return transformed

#########################################################################
# Smooth Motion Commands and Robot Commands End Here
#########################################################################

# Acknowledgment system configuration
CLIENT_ACK_PORT = 5002  # Port where clients listen for acknowledgments
ack_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Command tracking
active_command_id = None
command_id_map = {}  # Maps command objects to their IDs

def send_acknowledgment(cmd_id: str, status: str, details: str = "", addr=None):
    """Send acknowledgment back to client"""
    if not cmd_id:
        return
        
    ack_message = f"ACK|{cmd_id}|{status}|{details}"
    
    # Send to the original sender if we have their address
    if addr:
        try:
            ack_socket.sendto(ack_message.encode('utf-8'), (addr[0], CLIENT_ACK_PORT))
        except Exception as e:
            print(f"Failed to send ack to {addr}: {e}")
    
    # Also broadcast to localhost in case the client is local
    try:
        ack_socket.sendto(ack_message.encode('utf-8'), ('127.0.0.1', CLIENT_ACK_PORT))
    except:
        pass

def parse_command_with_id(message: str) -> Tuple[Optional[str], str]:
    """
    Parse command ID if present.
    Format: [cmd_id|]COMMAND|params...
    Returns: (cmd_id or None, command_string)
    """
    # Clean up any logging artifacts
    if "ID:" in message or "):" in message:
        # Extract the actual command after these artifacts
        if "):" in message:
            message = message[message.rindex("):")+2:].strip()
        elif "ID:" in message:
            message = message[message.index("ID:")+3:].strip()
            # Remove any trailing parentheses or colons
            message = message.lstrip('):').strip()
    
    parts = message.split('|', 1)
    
    # Check if first part looks like a valid command ID (8 chars, alphanumeric)
    # IMPORTANT: Command IDs from uuid.uuid4()[:8] will contain lowercase letters/numbers
    # Actual commands are all uppercase, so exclude all-uppercase strings
    if (len(parts) > 1 and 
        len(parts[0]) == 8 and 
        parts[0].replace('-', '').isalnum() and 
        not parts[0].isupper()):  # This prevents "MOVEPOSE" from being treated as an ID
        return parts[0], parts[1]
    else:
        return None, message


# Create a new, empty command queue
command_queue = deque()

# --------------------------------------------------------------------------
# --- Test 1: Homing and Initial Setup
# --------------------------------------------------------------------------

# 1. Start with the mandatory Home command.
command_queue.append(HomeCommand())

# --- State variable for the currently running command ---
active_command = None
e_stop_active = False

# Use deque for an efficient FIFO queue
incoming_command_buffer = deque()
# Timestamp of the last processed network command
last_command_time = 0
# Cooldown period in seconds to prevent command flooding
COMMAND_COOLDOWN_S = 0.1 # 100ms

# Set interval
timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)

# ============================================================================
# MODIFIED MAIN LOOP WITH ACKNOWLEDGMENTS
# ============================================================================

timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)
prev_time = 0

while timer.elapsed_time < 1100000:
    
    # --- Connection Handling ---
    if ser is None or not ser.is_open:
        print("Serial port not open. Attempting to reconnect...")
        try:
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            if ser.is_open:
                print(f"Successfully reconnected to {com_port_str}")
        except serial.SerialException as e:
            ser = None
            time.sleep(1) 
        continue

    # =======================================================================
    # === NETWORK COMMAND RECEPTION WITH ID PARSING ===
    # =======================================================================
    try:
        while sock in select.select([sock], [], [], 0)[0]:
            data, addr = sock.recvfrom(1024)
            raw_message = data.decode('utf-8').strip()
            if raw_message:
                # Parse command ID if present
                cmd_id, message = parse_command_with_id(raw_message)
                
                parts = message.split('|')
                command_name = parts[0].upper()

                # Handle immediate response commands
                if command_name == 'STOP':
                    print("Received STOP command. Halting all motion and clearing queue.")
                    
                    # Cancel active command
                    if active_command and active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "Stopped by user", addr)
                    active_command = None
                    active_command_id = None
                    
                    # Clear queue and notify about cancelled commands
                    for queued_cmd in command_id_map.keys():
                        if queued_cmd != active_command:
                            if queued_cmd in command_id_map:
                                send_acknowledgment(command_id_map[queued_cmd], 
                                                  "CANCELLED", "Queue cleared by STOP", addr)
                    
                    command_queue.clear()
                    command_id_map.clear()
                    
                    # Stop robot
                    Command_out.value = 255
                    Speed_out[:] = [0] * 6
                    
                    # Send acknowledgment for STOP command itself
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Emergency stop executed", addr)

                elif command_name == 'GET_POSE':
                    q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
                    current_pose_matrix = PAROL6_ROBOT.robot.fkine(q_current).A
                    pose_flat = current_pose_matrix.flatten()
                    pose_str = ",".join(map(str, pose_flat))
                    response_message = f"POSE|{pose_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Pose data sent", addr)

                elif command_name == 'GET_ANGLES':
                    angles_rad = [PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)]
                    angles_deg = np.rad2deg(angles_rad)
                    angles_str = ",".join(map(str, angles_deg))
                    response_message = f"ANGLES|{angles_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Angles data sent", addr)

                elif command_name == 'GET_IO':
                    io_status_str = ",".join(map(str, InOut_in[:5]))
                    response_message = f"IO|{io_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "IO data sent", addr)

                elif command_name == 'GET_GRIPPER':
                    gripper_status_str = ",".join(map(str, Gripper_data_in))
                    response_message = f"GRIPPER|{gripper_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Gripper data sent", addr)

                elif command_name == 'GET_SPEEDS':
                    speeds_str = ",".join(map(str, Speed_in))
                    response_message = f"SPEEDS|{speeds_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Speed data sent", addr)

                else:
                    # Queue command for processing
                    incoming_command_buffer.append((raw_message, addr))

    except Exception as e:
        print(f"Network receive error: {e}")

    # =======================================================================
    # === PROCESS COMMANDS FROM BUFFER WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    current_time = time.time()
    if incoming_command_buffer and (current_time - last_command_time) > COMMAND_COOLDOWN_S and not e_stop_active:
        raw_message, addr = incoming_command_buffer.popleft()
        last_command_time = current_time
        
        # Parse command ID
        cmd_id, message = parse_command_with_id(raw_message)
        print(f"Processing command{' (ID: ' + cmd_id + ')' if cmd_id else ''}: {message[:50]}...")
        
        parts = message.split('|')
        command_name = parts[0].upper()
        
        # Variable to track if command was successfully queued
        command_queued = False
        command_obj = None
        error_details = ""

        # Parse and create command objects
        try:
            if command_name == 'MOVEPOSE' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MovePoseCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
                
            elif command_name == 'MOVEJOINT' and len(parts) == 9:
                joint_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveJointCommand(target_angles=joint_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name in ['SMOOTH_CIRCLE', 'SMOOTH_ARC_CENTER', 'SMOOTH_ARC_PARAM', 
                                 'SMOOTH_SPLINE', 'SMOOTH_HELIX', 'SMOOTH_BLEND']:
                command_obj = parse_smooth_motion_commands(parts)
                if command_obj:
                    command_queued = True
                else:
                    error_details = "Failed to parse smooth motion parameters"
            
            elif command_name == 'MOVECART' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveCartCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name == 'DELAY' and len(parts) == 2:
                duration = float(parts[1])
                command_obj = DelayCommand(duration=duration)
                command_queued = True
            
            elif command_name == 'HOME':
                command_obj = HomeCommand()
                command_queued = True
                
            elif command_name == 'CARTJOG' and len(parts) == 5:
                frame, axis, speed, duration = parts[1].upper(), parts[2], float(parts[3]), float(parts[4])
                command_obj = CartesianJogCommand(frame=frame, axis=axis, speed_percentage=speed, duration=duration)
                command_queued = True
                
            elif command_name == 'JOG' and len(parts) == 5:
                joint_idx, speed = int(parts[1]), float(parts[2])
                duration = None if parts[3].upper() == 'NONE' else float(parts[3])
                distance = None if parts[4].upper() == 'NONE' else float(parts[4])
                command_obj = JogCommand(joint=joint_idx, speed_percentage=speed, duration=duration, distance_deg=distance)
                command_queued = True
            
            elif command_name == 'MULTIJOG' and len(parts) == 4:
                joint_indices = [int(j) for j in parts[1].split(',')]
                speeds = [float(s) for s in parts[2].split(',')]
                duration = float(parts[3])
                command_obj = MultiJogCommand(joints=joint_indices, speed_percentages=speeds, duration=duration)
                command_queued = True
                
            elif command_name == 'PNEUMATICGRIPPER' and len(parts) == 3:
                action, port = parts[1].lower(), int(parts[2])
                command_obj = GripperCommand(gripper_type='pneumatic', action=action, output_port=port)
                command_queued = True
                
            elif command_name == 'ELECTRICGRIPPER' and len(parts) == 5:
                action = None if parts[1].upper() == 'NONE' or parts[1].upper() == 'MOVE' else parts[1].lower()
                pos, spd, curr = int(parts[2]), int(parts[3]), int(parts[4])
                command_obj = GripperCommand(gripper_type='electric', action=action, position=pos, speed=spd, current=curr)
                command_queued = True
            
            else:
                error_details = f"Unknown or malformed command: {command_name}"
                
        except Exception as e:
            error_details = f"Error parsing command: {str(e)}"
            command_queued = False
        
        # Handle command queueing and acknowledgments
        if command_queued and command_obj:
            # Check if command is initially valid
            if hasattr(command_obj, 'is_valid') and not command_obj.is_valid:
                if cmd_id:
                    send_acknowledgment(cmd_id, "INVALID", 
                                       "Command failed validation", addr)
            else:
                # Add to queue
                command_queue.append(command_obj)
                if cmd_id:
                    command_id_map[command_obj] = (cmd_id, addr)
                    send_acknowledgment(cmd_id, "QUEUED", 
                                       f"Position {len(command_queue)} in queue", addr)
        else:
            # Command was not queued
            if cmd_id:
                send_acknowledgment(cmd_id, "INVALID", error_details, addr)
            print(f"Warning: {error_details}")

    # =======================================================================
    # === MAIN EXECUTION LOGIC WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    try:
        # --- E-Stop Handling ---
        if InOut_in[4] == 0:  # E-Stop pressed
            if not e_stop_active:
                cancelled_command_info = "None"
                if active_command is not None:
                    cancelled_command_info = type(active_command).__name__
                    if active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "E-Stop activated")
                
                # Cancel all queued commands
                for cmd_obj in command_queue:
                    if cmd_obj in command_id_map:
                        cmd_id, addr = command_id_map[cmd_obj]
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated", addr)
                
                # Cancel all buffered but unprocessed commands
                for raw_message, addr in incoming_command_buffer:
                    cmd_id, _ = parse_command_with_id(raw_message)
                    if cmd_id:
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated - command not processed", addr)
                
                print(f"E-STOP TRIGGERED! Active command '{cancelled_command_info}' cancelled.")
                print("Release E-Stop and press 'e' to re-enable.")
                e_stop_active = True
            
            Command_out.value = 102
            Speed_out[:] = [0] * 6
            Gripper_data_out[3] = 0
            active_command = None
            active_command_id = None
            command_queue.clear()
            command_id_map.clear()
            incoming_command_buffer.clear()
            
        elif e_stop_active:
            # Waiting for re-enable
            if keyboard.is_pressed('e'):
                print("Re-enabling robot...")
                Command_out.value = 101
                e_stop_active = False
            else:
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]
                
        else:
            # --- Normal Command Processing ---
            
            # Start new command if none active
            if active_command is None and command_queue:
                new_command = command_queue.popleft()
                
                # Get command ID and address if tracked
                cmd_info = command_id_map.get(new_command, (None, None))
                new_cmd_id, new_addr = cmd_info
                
                # Initial validation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Command was invalid from the start
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "INVALID", 
                                        "Initial validation failed", new_addr)
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                    continue  # Skip to next command
                
                # Prepare command
                if hasattr(new_command, 'prepare_for_execution'):
                    try:
                        new_command.prepare_for_execution(current_position_in=Position_in)
                    except Exception as e:
                        print(f"Command preparation failed: {e}")
                        if hasattr(new_command, 'is_valid'):
                            new_command.is_valid = False
                        if hasattr(new_command, 'error_message'):
                            new_command.error_message = str(e)
                
                # Check if still valid after preparation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Failed during preparation
                    error_msg = "Failed during preparation"
                    if hasattr(new_command, 'error_message'):
                        error_msg = new_command.error_message
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "FAILED", error_msg, new_addr)
                    
                    # Clean up
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                else:
                    # Command is valid, make it active
                    active_command = new_command
                    active_command_id = new_cmd_id
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "EXECUTING", 
                                        f"Starting {type(new_command).__name__}", new_addr)
            
            # Execute active command
            if active_command:
                try:
                    is_done = active_command.execute_step(
                        Position_in=Position_in,
                        Homed_in=Homed_in,
                        Speed_out=Speed_out,
                        Command_out=Command_out,
                        Gripper_data_out=Gripper_data_out,
                        InOut_out=InOut_out,
                        InOut_in=InOut_in,
                        Gripper_data_in=Gripper_data_in,
                        Position_out=Position_out  # Add this if needed
                    )
                    
                    if is_done:
                        # Command completed
                        if active_command_id:
                            # Check for error state in smooth motion commands
                            if hasattr(active_command, 'error_state') and active_command.error_state:
                                error_msg = getattr(active_command, 'error_message', 'Command failed during execution')
                                send_acknowledgment(active_command_id, "FAILED", error_msg)
                            else:
                                send_acknowledgment(active_command_id, "COMPLETED", 
                                                f"{type(active_command).__name__} finished successfully")
                        
                        # Clean up
                        if active_command in command_id_map:
                            del command_id_map[active_command]
                        
                        active_command = None
                        active_command_id = None
                        
                except Exception as e:
                    # Command execution error
                    print(f"Command execution error: {e}")
                    if active_command_id:
                        send_acknowledgment(active_command_id, "FAILED", 
                                          f"Execution error: {str(e)}")
                    
                    # Clean up
                    if active_command in command_id_map:
                        del command_id_map[active_command]
                    
                    active_command = None
                    active_command_id = None
                    
            else:
                # No active command - idle
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]

        # --- Communication with Robot ---
        s = Pack_data(Position_out, Speed_out, Command_out.value, 
                     Affected_joint_out, InOut_out, Timeout_out, Gripper_data_out)
        for chunk in s:
            ser.write(chunk)
            
        Get_data(Position_in, Speed_in, Homed_in, InOut_in, Temperature_error_in, 
                Position_error_in, Timeout_error, Timing_data_in, XTR_data, Gripper_data_in)

    except serial.SerialException as e:
        print(f"Serial communication error: {e}")
        
        # Send failure acknowledgments for active command
        if active_command_id:
            send_acknowledgment(active_command_id, "FAILED", "Serial communication lost")
        
        if ser:
            ser.close()
        ser = None
        active_command = None
        active_command_id = None

    timer.checkpt()
````

## File: headless_commander.py.backup_wN_1757428702
````
'''
A full fledged "API" for the PAROL6 robot. To use this, you should pair it with the "robot_api.py" where you can import commands
from said file and use them anywhere within your code. This Python script will handle sending and performing all the commands
to the PAROL6 robot, as well as E-Stop functionality and safety limitations.

To run this program, you must use the "experimental-kinematics" branch of the "PAROL-commander-software" on GitHub
which can be found through this link: https://github.com/PCrnjak/PAROL-commander-software/tree/experimental_kinematics.
You must also save these files into the following folder: "Project Files\PAROL-commander-software\GUI\files".
'''

# * If you press estop robot will stop and you need to enable it by pressing e

from roboticstoolbox import DHRobot, RevoluteDH, ERobot, ELink, ETS, trapezoidal, quintic
import roboticstoolbox as rp
from math import pi, sin, cos
import numpy as np
from oclock import Timer, loop, interactiveloop
import time
import socket
from spatialmath import SE3
import select
import serial
import platform
import os
import re
import logging
import struct
import keyboard
from typing import Optional, Tuple
from spatialmath.base import trinterp
from collections import namedtuple, deque
import GUI.files.PAROL6_ROBOT as PAROL6_ROBOT
from smooth_motion import CircularMotion, SplineMotion, MotionBlender

# Set interval
INTERVAL_S = 0.01
prev_time = 0

logging.basicConfig(level = logging.DEBUG,
    format='%(asctime)s.%(msecs)03d %(levelname)s:\t%(message)s',
    datefmt='%H:%M:%S'
)
logging.disable(logging.DEBUG)


my_os = platform.system()
if my_os == "Windows":
    # Try to read the COM port from a file
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved COM port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        # If the file doesn't exist or the port is invalid, ask the user
        while True:
            try:
                com_port = input("Enter the COM port (e.g., COM9): ")
                ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                print(f"Successfully connected to {com_port}")
                # Save the successful port to the file
                with open("com_port.txt", "w") as f:
                    f.write(com_port)
                break
            except serial.SerialException:
                print(f"Could not open port {com_port}. Please try again.")

# in big endian machines, first byte of binary representation of the multibyte data-type is stored first. 
int_to_3_bytes = struct.Struct('>I').pack # BIG endian order

# data for output string (data that is being sent to the robot)
#######################################################################################
#######################################################################################
start_bytes =  [0xff,0xff,0xff] 
start_bytes = bytes(start_bytes)

end_bytes =  [0x01,0x02] 
end_bytes = bytes(end_bytes)


# data for input string (Data that is being sent by the robot)
#######################################################################################
#######################################################################################
input_byte = 0 # Here save incoming bytes from serial

start_cond1_byte = bytes([0xff])
start_cond2_byte = bytes([0xff])
start_cond3_byte = bytes([0xff])

end_cond1_byte = bytes([0x01])
end_cond2_byte = bytes([0x02])

start_cond1 = 0 #Flag if start_cond1_byte is received
start_cond2 = 0 #Flag if start_cond2_byte is received
start_cond3 = 0 #Flag if start_cond3_byte is received

good_start = 0 #Flag if we got all 3 start condition bytes
data_len = 0 #Length of the data after -3 start condition bytes and length byte, so -4 bytes

data_buffer = [None]*255 #Here save all data after data length byte
data_counter = 0 #Data counter for incoming bytes; compared to data length to see if we have correct length
#######################################################################################
#######################################################################################
prev_positions = [0,0,0,0,0,0]
prev_speed = [0,0,0,0,0,0]
robot_pose = [0,0,0,0,0,0] #np.array([0,0,0,0,0,0])
#######################################################################################
#######################################################################################

# --- Wrapper class to make integers mutable when passed to functions ---
class CommandValue:
    def __init__(self, value):
        self.value = value

#######################################################################################
#######################################################################################
Position_out = [1,11,111,1111,11111,10]
Speed_out = [2,21,22,23,24,25]
Command_out = CommandValue(255)
Affected_joint_out = [1,1,1,1,1,1,1,1]
InOut_out = [0,0,0,0,0,0,0,0]
Timeout_out = 0
#Positon,speed,current,command,mode,ID
Gripper_data_out = [1,1,1,1,0,0]
#######################################################################################
#######################################################################################
# Data sent from robot to PC
Position_in = [31,32,33,34,35,36]
Speed_in = [41,42,43,44,45,46]
Homed_in = [0,0,0,0,0,0,0,0]
InOut_in = [1,1,1,1,1,1,1,1]
Temperature_error_in = [1,1,1,1,1,1,1,1]
Position_error_in = [1,1,1,1,1,1,1,1]
Timeout_error = 0
# how much time passed between 2 sent commands (2byte value, last 2 digits are decimal so max value is 655.35ms?)
Timing_data_in = [0]
XTR_data =   0

# --- State variables for program execution ---
Robot_mode = "Dummy"  # Start in an idle state
Program_step = 0      # Which line of the program to run
Command_step = 0      # The current step within a single command
Command_len = 0       # The total steps for the current command
ik_error = 0          # Flag for inverse kinematics errors
error_state = 0       # General error flag
program_running = False # A flag to start and stop the program

# This will be your "program"
command_list = []

#ID,Position,speed,current,status,obj_detection
Gripper_data_in = [1,1,1,1,1,1] 

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179° and 181° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    
    Parameters
    ----------
    robot : DHRobot
        Robot model
    q : array_like
        Joint configuration
    strict_tol : float
        Strict tolerance away from singularities (default: 1e-10)
    loose_tol : float
        Loose tolerance near singularities (1e-7)
        
    Returns
    -------
    float
        Adaptive tolerance value
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    
    Parameters
    ----------
    q_seed : array_like
        Current joint configuration in radians
        
    Returns
    -------
    float
        Configuration-dependent maximum reach threshold
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 | None = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities:
    - Near singularities: looser tolerance for easier convergence
    - Away from singularities: stricter tolerance for precise solutions
    If necessary, recursively subdivide the motion until ikine_LM converges
    on every segment. Finally check that solution respects joint limits. From experimentation,
    jogging with lower tolerances often produces q_paths that do not differ from current_q,
    essentially freezing the robot.

    Parameters
    ----------
    robot : DHRobot
        Robot model
    target_pose : SE3
        Target pose to reach
    current_q : array_like
        Current joint configuration
    current_pose : SE3, optional
        Current pose (computed if None)
    max_depth : int, optional
        Maximum subdivision depth (default: 8)
    ilimit : int, optional
        Maximum iterations for IK solver (default: 100)

    Returns
    -------
    IKResult
        success  - True/False
        q_path   - (mxn) array of the final joint configuration 
        iterations, residual  - aggregated diagnostics
        tolerance_used - which tolerance was used
        violations - joint limit violations (if any)
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # ── inner recursive solver───────────────────
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            # print(f"current_reach:{current_reach:.3f}, max_reach_threshold:{max_reach_threshold:.3f}")
            if not is_recovery and target_reach > max_reach_threshold:
                print(f"Target reach limit exceeded: {target_reach:.3f} > {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LM(Tb, q0=q_seed, ilimit=ilimit, tol=tol, wN=damping)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # ── kick-off with adaptive tolerance ──────────────────────────────────
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    # Check if solution respects joint limits
    target_q = path[-1] if len(path) != 0 else None
    solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
    if ok and solution_valid:
        return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
    else:
        return IKResult(False, None, its, resid, adaptive_tol, violations)

#Setup IP address and Simulator port
ip = "127.0.0.1" #Loopback address
port = 5001
# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((ip, port))
print(f'Start listening to {ip}:{port}')

def Unpack_data(data_buffer_list, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):

    Joints = []
    Speed = []

    for i in range(0,18, 3):
        variable = data_buffer_list[i:i+3]
        Joints.append(variable)

    for i in range(18,36, 3):
        variable = data_buffer_list[i:i+3]
        Speed.append(variable)


    for i in range(6):
        var =  b'\x00' + b''.join(Joints[i])
        Position_in[i] = Fuse_3_bytes(var)
        var =  b'\x00' + b''.join(Speed[i])
        Speed_in[i] = Fuse_3_bytes(var)

    Homed = data_buffer_list[36]
    IO_var = data_buffer_list[37]
    temp_error = data_buffer_list[38]
    position_error = data_buffer_list[39]
    timing_data = data_buffer_list[40:42]
    Timeout_error_var = data_buffer_list[42]
    xtr2 = data_buffer_list[43]
    device_ID = data_buffer_list[44]
    Gripper_position = data_buffer_list[45:47]
    Gripper_speed = data_buffer_list[47:49]
    Gripper_current = data_buffer_list[49:51]
    Status = data_buffer_list[51]
    # The original object_detection byte at index 52 is ignored as it is not reliable.
    CRC_byte = data_buffer_list[53]
    endy_byte1 = data_buffer_list[54]
    endy_byte2 = data_buffer_list[55]

    # ... (Code for Homed, IO_var, temp_error, etc. remains the same) ...

    temp = Split_2_bitfield(int.from_bytes(Homed,"big"))
    for i in range(8):
        Homed_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(IO_var,"big"))
    for i in range(8):
        InOut_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(temp_error,"big"))
    for i in range(8):
        Temperature_error_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(position_error,"big"))
    for i in range(8):
        Position_error_in[i] = temp[i]

    var = b'\x00' + b'\x00' + b''.join(timing_data)
    Timing_data_in[0] = Fuse_3_bytes(var)
    Timeout_error = int.from_bytes(Timeout_error_var,"big")
    XTR_data = int.from_bytes(xtr2,"big")

    # --- Gripper Data Unpacking ---
    Gripper_data_in[0] = int.from_bytes(device_ID,"big")

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_position)
    Gripper_data_in[1] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_speed)
    Gripper_data_in[2] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_current)
    Gripper_data_in[3] = Fuse_2_bytes(var)

    # --- Start of Corrected Logic ---
    # This section now mirrors the working logic from GUI_PAROL_latest.py
    
    # 1. Store the raw status byte (from index 51)
    status_byte = int.from_bytes(Status,"big")
    Gripper_data_in[4] = status_byte

    # 2. Split the status byte into a list of 8 individual bits
    status_bits = Split_2_bitfield(status_byte)
    
    # 3. Combine the 3rd and 4th bits (at indices 2 and 3) to get the true object detection status
    # This creates a 2-bit number (0-3) which represents the full state.
    object_detection_status = (status_bits[2] << 1) | status_bits[3]
    Gripper_data_in[5] = object_detection_status
    # --- End of Corrected Logic ---

def Pack_data(Position_out,Speed_out,Command_out,Affected_joint_out,InOut_out,Timeout_out,Gripper_data_out):

    # Len is defined by all bytes EXCEPT start bytes and len
    # Start bytes = 3
    len = 52 #1
    Position = [Position_out[0],Position_out[1],Position_out[2],Position_out[3],Position_out[4],Position_out[5]]  #18
    Speed = [Speed_out[0], Speed_out[1], Speed_out[2], Speed_out[3], Speed_out[4], Speed_out[5],] #18
    Command = Command_out#1
    Affected_joint = Affected_joint_out
    InOut = InOut_out #1
    Timeout = Timeout_out #1
    Gripper_data = Gripper_data_out #9
    CRC_byte = 228 #1
    # End bytes = 2


    test_list = []
    #print(test_list)

    #x = bytes(start_bytes)
    test_list.append((start_bytes))
    
    test_list.append(bytes([len]))


    # Position data
    for i in range(6):
        position_split = Split_2_3_bytes(Position[i])
        test_list.append(position_split[1:4])

    # Speed data
    for i in range(6):
        speed_split = Split_2_3_bytes(Speed[i])
        test_list.append(speed_split[1:4])

    # Command data
    test_list.append(bytes([Command]))

    # Affected joint data
    Affected_list = Fuse_bitfield_2_bytearray(Affected_joint[:])
    test_list.append(Affected_list)

    # Inputs outputs data
    InOut_list = Fuse_bitfield_2_bytearray(InOut[:])
    test_list.append(InOut_list)

    # Timeout data
    test_list.append(bytes([Timeout]))

    # Gripper position
    Gripper_position = Split_2_3_bytes(Gripper_data[0])
    test_list.append(Gripper_position[2:4])

    # Gripper speed
    Gripper_speed = Split_2_3_bytes(Gripper_data[1])
    test_list.append(Gripper_speed[2:4])

    # Gripper current
    Gripper_current = Split_2_3_bytes(Gripper_data[2])
    test_list.append(Gripper_current[2:4])  

    # Gripper command
    test_list.append(bytes([Gripper_data[3]]))
    # Gripper mode
    test_list.append(bytes([Gripper_data[4]]))
    
    # ==========================================================
    # === FIX: Make sure calibrate is a one-shot command      ====
    # ==========================================================
    # If the mode was set to calibrate (1) or clear_error (2), reset it
    # back to normal (0) for the next cycle. This prevents an endless loop.
    if Gripper_data_out[4] == 1 or Gripper_data_out[4] == 2:
        Gripper_data_out[4] = 0
    # ==========================================================
    
    # Gripper ID
    test_list.append(bytes([Gripper_data[5]]))
 
    # CRC byte
    test_list.append(bytes([CRC_byte]))

    # END bytes
    test_list.append((end_bytes))
    
    #print(test_list)
    return test_list

def Get_data(Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):
    global input_byte 

    global start_cond1_byte 
    global start_cond2_byte 
    global start_cond3_byte 

    global end_cond1_byte 
    global end_cond2_byte 

    global start_cond1 
    global start_cond2 
    global start_cond3 

    global good_start 
    global data_len 

    global data_buffer 
    global data_counter

    while (ser.inWaiting() > 0):
        input_byte = ser.read()

        #UNCOMMENT THIS TO GET ALL DATA FROM THE ROBOT PRINTED
        #print(input_byte) 

        # When data len is received start is good and after that put all data in receive buffer
        # Data len is ALL data after it; that includes input buffer, end bytes and CRC
        if (good_start != 1):
            # All start bytes are good and next byte is data len
            if (start_cond1 == 1 and start_cond2 == 1 and start_cond3 == 1):
                good_start = 1
                data_len = input_byte
                data_len = struct.unpack('B', data_len)[0]
                logging.debug("data len we got from robot packet= ")
                logging.debug(input_byte)
                logging.debug("good start for DATA that we received at PC")
            # Third start byte is good
            if (input_byte == start_cond3_byte and start_cond2 == 1 and start_cond1 == 1):
                start_cond3 = 1
                #print("good cond 3 PC")
            #Third start byte is bad, reset all flags
            elif (start_cond2 == 1 and start_cond1 == 1):
                #print("bad cond 3 PC")
                start_cond1 = 0
                start_cond2 = 0
            # Second start byte is good
            if (input_byte == start_cond2_byte and start_cond1 == 1):
                start_cond2 = 1
                #print("good cond 2 PC ")
            #Second start byte is bad, reset all flags   
            elif (start_cond1 == 1):
                #print("Bad cond 2 PC")
                start_cond1 = 0
            # First start byte is good
            if (input_byte == start_cond1_byte):
                start_cond1 = 1
                #print("good cond 1 PC")
        else:
            # Here data goes after good  start
            data_buffer[data_counter] = input_byte
            if (data_counter == data_len - 1):

                logging.debug("Data len PC")
                logging.debug(data_len)
                logging.debug("End bytes are:")
                logging.debug(data_buffer[data_len -1])
                logging.debug(data_buffer[data_len -2])

                # Here if last 2 bytes are end condition bytes we process the data 
                if (data_buffer[data_len -1] == end_cond2_byte and data_buffer[data_len - 2] == end_cond1_byte):

                    logging.debug("GOOD END CONDITION PC")
                    logging.debug("I UNPACKED RAW DATA RECEIVED FROM THE ROBOT")
                    Unpack_data(data_buffer, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
                    XTR_data,Gripper_data_in)
                    logging.debug("DATA UNPACK FINISHED")
                    # ako su dobri izračunaj crc
                    # if crc dobar raspakiraj podatke
                    # ako je dobar paket je dobar i spremi ga u nove variable!
                
                # Print every byte
                #print("podaci u data bufferu su:")
                #for i in range(data_len):
                    #print(data_buffer[i])

                good_start = 0
                start_cond1 = 0
                start_cond3 = 0
                start_cond2 = 0
                data_len = 0
                data_counter = 0
            else:
                data_counter = data_counter + 1

# Split data to 3 bytes 
def Split_2_3_bytes(var_in):
    y = int_to_3_bytes(var_in & 0xFFFFFF) # converts my int value to bytes array
    return y

# Splits byte to bitfield list
def Split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]

# Fuses 3 bytes to 1 signed int
def Fuse_3_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<23:
        value -= 1<<24

    return value

# Fuses 2 bytes to 1 signed int
def Fuse_2_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<15:
        value -= 1<<16

    return value

# Fuse bitfield list to byte
def Fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Check if there is element 1 in the list. 
# If yes return its index, if no element is 1 return -1
def check_elements(lst):
    for i, element in enumerate(lst):
        if element == 1:
            return i
    return -1  # Return -1 if no element is 1

def quintic_scaling(s: float) -> float:
    """
    Calculates a smooth 0-to-1 scaling factor for progress 's'
    using a quintic polynomial, ensuring smooth start/end accelerations.
    """
    return 6 * (s**5) - 15 * (s**4) + 10 * (s**3)

#########################################################################
# Robot Commands Start Here
#########################################################################

class HomeCommand:
    """
    A non-blocking command that tells the robot to perform its internal homing sequence.
    This version uses a state machine to allow re-homing even if the robot is already homed.
    """
    def __init__(self):
        self.is_valid = True
        self.is_finished = False
        # State machine: START -> WAIT_FOR_UNHOMED -> WAIT_FOR_HOMED -> FINISHED
        self.state = "START"
        # Counter to send the home command for multiple cycles
        self.start_cmd_counter = 10  # Send command 100 for 10 cycles (0.1s)
        # Safety timeout (20 seconds at 0.01s interval)
        self.timeout_counter = 2000
        print("Initializing Home command...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Manages the homing command and monitors for completion using a state machine.
        """
        if self.is_finished:
            return True

        # --- State: START ---
        # On the first few executions, continuously send the 'home' (100) command.
        if self.state == "START":
            print(f"  -> Sending home signal (100)... Countdown: {self.start_cmd_counter}")
            Command_out.value = 100
            self.start_cmd_counter -= 1
            if self.start_cmd_counter <= 0:
                # Once sent for enough cycles, move to the next state
                self.state = "WAITING_FOR_UNHOMED"
            return False

        # --- State: WAITING_FOR_UNHOMED ---
        # The robot's firmware should reset the homed status. We wait to see that happen.
        # During this time, we send 'idle' (255) to let the robot's controller take over.
        if self.state == "WAITING_FOR_UNHOMED":
            Command_out.value = 255
            # Check if at least one joint has started homing (is no longer homed)
            if any(h == 0 for h in Homed_in[:6]):
                print("  -> Homing sequence initiated by robot.")
                self.state = "WAITING_FOR_HOMED"
            # Check for timeout
            self.timeout_counter -= 1
            if self.timeout_counter <= 0:
                print("  -> ERROR: Timeout waiting for robot to start homing sequence.")
                self.is_finished = True
            return self.is_finished

        # --- State: WAITING_FOR_HOMED ---
        # Now we wait for all joints to report that they are homed (all flags are 1).
        if self.state == "WAITING_FOR_HOMED":
            Command_out.value = 255
            # Check if all joints have finished homing
            if all(h == 1 for h in Homed_in[:6]):
                print("Homing sequence complete. All joints reported home.")
                self.is_finished = True
                Speed_out[:] = [0] * 6 # Ensure robot is stopped

        return self.is_finished

class JogCommand:
    """
    A non-blocking command to jog a joint for a specific duration or distance.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joint, speed_percentage=None, duration=None, distance_deg=None):
        """
        Initializes and validates the jog command. This is the SETUP phase.
        """
        self.is_valid = False
        self.is_finished = False
        self.mode = None
        self.command_step = 0

        # --- 1. Parameter Validation and Mode Selection ---
        if duration and distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Distance {distance_deg} deg, Duration {duration}s.")
        elif duration:
            self.mode = 'time'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Duration {duration}s.")
        elif distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Distance {distance_deg} deg.")
        else:
            print("Error: JogCommand requires either 'duration', 'distance_deg', or both.")
            return

        # --- 2. Store parameters for deferred calculation ---
        self.joint = joint
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.distance_deg = distance_deg

        # --- These will be calculated later ---
        self.direction = 1
        self.joint_index = 0
        self.speed_out = 0
        self.command_len = 0
        self.target_position = 0

        self.is_valid = True # Mark as valid for now; preparation step will confirm.


    def prepare_for_execution(self, current_position_in):
        """Pre-computes speeds and target positions using live data."""
        print(f"  -> Preparing for Jog command...")

        # Determine direction and joint index
        self.direction = 1 if 0 <= self.joint <= 5 else -1
        self.joint_index = self.joint if self.direction == 1 else self.joint - 6
        
        distance_steps = 0
        if self.distance_deg:
            distance_steps = int(PAROL6_ROBOT.DEG2STEPS(abs(self.distance_deg), self.joint_index))
            # --- MOVED LOGIC: Calculate target using the LIVE position ---
            self.target_position = current_position_in[self.joint_index] + (distance_steps * self.direction)
            
            min_limit, max_limit = PAROL6_ROBOT.Joint_limits_steps[self.joint_index]
            if not (min_limit <= self.target_position <= max_limit):
                print(f"  -> VALIDATION FAILED: Target position {self.target_position} is out of joint limits ({min_limit}, {max_limit}).")
                self.is_valid = False
                return

        # Calculate speed and duration
        speed_steps_per_sec = 0
        if self.mode == 'distance' and self.duration:
            speed_steps_per_sec = int(distance_steps / self.duration) if self.duration > 0 else 0
            max_joint_speed = PAROL6_ROBOT.Joint_max_speed[self.joint_index]
            if speed_steps_per_sec > max_joint_speed:
                print(f"  -> VALIDATION FAILED: Required speed ({speed_steps_per_sec} steps/s) exceeds joint's max speed ({max_joint_speed} steps/s).")
                self.is_valid = False
                return
        else:
            if self.speed_percentage is None:
                print("Error: 'speed_percentage' must be provided if not calculating automatically.")
                self.is_valid = False
                return
            speed_steps_per_sec = int(np.interp(abs(self.speed_percentage), [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[self.joint_index] * 2]))

        self.speed_out = speed_steps_per_sec * self.direction
        self.command_len = int(self.duration / INTERVAL_S) if self.duration else float('inf')
        print("  -> Jog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        stop_reason = None
        current_pos = Position_in[self.joint_index]

        if self.mode == 'time':
            if self.command_step >= self.command_len:
                stop_reason = "Timed jog finished."
        elif self.mode == 'distance':
            if (self.direction == 1 and current_pos >= self.target_position) or \
               (self.direction == -1 and current_pos <= self.target_position):
                stop_reason = "Distance jog finished."
        
        if not stop_reason:
            if (self.direction == 1 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][1]) or \
               (self.direction == -1 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][0]):
                stop_reason = f"Limit reached on joint {self.joint_index + 1}."

        if stop_reason:
            print(stop_reason)
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            Speed_out[:] = [0] * 6
            Speed_out[self.joint_index] = self.speed_out
            Command_out.value = 123
            self.command_step += 1
            return False
        
class MultiJogCommand:
    """
    A non-blocking command to jog multiple joints simultaneously for a specific duration.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joints, speed_percentages, duration):
        """
        Initializes and validates the multi-jog command.
        """
        self.is_valid = False
        self.is_finished = False
        self.command_step = 0

        # --- 1. Parameter Validation ---
        if not isinstance(joints, list) or not isinstance(speed_percentages, list):
            print("Error: MultiJogCommand requires 'joints' and 'speed_percentages' to be lists.")
            return

        if len(joints) != len(speed_percentages):
            print("Error: The number of joints must match the number of speed percentages.")
            return

        if not duration or duration <= 0:
            print("Error: MultiJogCommand requires a positive 'duration'.")
            return

        # ==========================================================
        # === NEW: Check for conflicting joint commands          ===
        # ==========================================================
        base_joints = set()
        for joint in joints:
            # Normalize the joint index to its base (0-5)
            base_joint = joint % 6
            # If the base joint is already in our set, it's a conflict.
            if base_joint in base_joints:
                print(f"  -> VALIDATION FAILED: Conflicting commands for Joint {base_joint + 1} (e.g., J1+ and J1-).")
                self.is_valid = False
                return
            base_joints.add(base_joint)
        # ==========================================================

        print(f"Initializing MultiJog for joints {joints} with speeds {speed_percentages}% for {duration}s.")

        # --- 2. Store parameters ---
        self.joints = joints
        self.speed_percentages = speed_percentages
        self.duration = duration
        self.command_len = int(self.duration / INTERVAL_S)

        # --- This will be calculated in the prepare step ---
        self.speeds_out = [0] * 6

        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Pre-computes the speeds for each joint."""
        print(f"  -> Preparing for MultiJog command...")

        for i, joint in enumerate(self.joints):
            # Determine direction and joint index (0-5 for positive, 6-11 for negative)
            direction = 1 if 0 <= joint <= 5 else -1
            joint_index = joint if direction == 1 else joint - 6
            speed_percentage = self.speed_percentages[i]

            # Check for joint index validity
            if not (0 <= joint_index < 6):
                print(f"  -> VALIDATION FAILED: Invalid joint index {joint_index}.")
                self.is_valid = False
                return

            # Calculate speed in steps/sec
            speed_steps_per_sec = int(np.interp(speed_percentage, [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[joint_index]]))
            self.speeds_out[joint_index] = speed_steps_per_sec * direction

        print("  -> MultiJog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        # Stop if the duration has elapsed
        if self.command_step >= self.command_len:
            print("Timed multi-jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            # Continuously check for joint limits during the jog
            for i in range(6):
                if self.speeds_out[i] != 0:
                    current_pos = Position_in[i]
                    # Hitting positive limit while moving positively
                    if self.speeds_out[i] > 0 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[i][1]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True
                    # Hitting negative limit while moving negatively
                    elif self.speeds_out[i] < 0 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[i][0]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True

            # If no limits are hit, apply the speeds
            Speed_out[:] = self.speeds_out
            Command_out.value = 123 # Jog command
            self.command_step += 1
            return False # Command is still running
        
# This dictionary maps descriptive axis names to movement vectors, which is cleaner.
# Format: ([x, y, z], [rx, ry, rz])
AXIS_MAP = {
    'X+': ([1, 0, 0], [0, 0, 0]), 'X-': ([-1, 0, 0], [0, 0, 0]),
    'Y+': ([0, 1, 0], [0, 0, 0]), 'Y-': ([0, -1, 0], [0, 0, 0]),
    'Z+': ([0, 0, 1], [0, 0, 0]), 'Z-': ([0, 0, -1], [0, 0, 0]),
    'RX+': ([0, 0, 0], [1, 0, 0]), 'RX-': ([0, 0, 0], [-1, 0, 0]),
    'RY+': ([0, 0, 0], [0, 1, 0]), 'RY-': ([0, 0, 0], [0, -1, 0]),
    'RZ+': ([0, 0, 0], [0, 0, 1]), 'RZ-': ([0, 0, 0], [0, 0, -1]),
}

class CartesianJogCommand:
    """
    A non-blocking command to jog the robot's end-effector in Cartesian space.
    This is the final, refactored version using clean, standard spatial math
    operations now that the core unit bug has been fixed.
    """
    def __init__(self, frame, axis, speed_percentage=50, duration=1.5, **kwargs):
        """
        Initializes and validates the Cartesian jog command.
        """
        self.is_valid = False
        self.is_finished = False
        print(f"Initializing CartesianJog: Frame {frame}, Axis {axis}...")

        if axis not in AXIS_MAP:
            print(f"  -> VALIDATION FAILED: Invalid axis '{axis}'.")
            return
        
        # Store all necessary parameters for use in execute_step
        self.frame = frame
        self.axis_vectors = AXIS_MAP[axis]
        self.is_rotation = any(self.axis_vectors[1])
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.end_time = time.time() + self.duration
        
        self.is_valid = True
        print("  -> Command is valid and ready.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Check for completion ---
        if time.time() >= self.end_time:
            print("Cartesian jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- B. Calculate Target Pose using clean vector math ---
        Command_out.value = 123 # Set jog command
        
        q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        T_current = PAROL6_ROBOT.robot.fkine(q_current)

        if not isinstance(T_current, SE3):
            return False # Wait for valid pose data

        # Calculate speed and displacement for this cycle
        linear_speed_ms = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min_JOG, PAROL6_ROBOT.Cartesian_linear_velocity_max_JOG]))
        angular_speed_degs = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max]))

        delta_linear = linear_speed_ms * INTERVAL_S
        delta_angular_rad = np.deg2rad(angular_speed_degs * INTERVAL_S)

        # Create the small incremental transformation (delta_pose)
        trans_vec = np.array(self.axis_vectors[0]) * delta_linear
        rot_vec = np.array(self.axis_vectors[1]) * delta_angular_rad
        delta_pose = SE3.Rt(SE3.Eul(rot_vec).R, trans_vec)

        # Apply the transformation in the correct reference frame
        if self.frame == 'WRF':
            # Pre-multiply to apply the change in the World Reference Frame
            target_pose = delta_pose * T_current
        else: # TRF
            # Post-multiply to apply the change in the Tool Reference Frame
            target_pose = T_current * delta_pose
        
        # --- C. Solve IK and Calculate Velocities ---
        var = solve_ik_with_adaptive_tol_subdivision(PAROL6_ROBOT.robot, target_pose, q_current, jogging=True)

        if var.success:
            q_velocities = (var.q - q_current) / INTERVAL_S
            for i in range(6):
                Speed_out[i] = int(PAROL6_ROBOT.SPEED_RAD2STEP(q_velocities[i], i))
        else:
            print("IK Warning: Could not find solution for jog step. Stopping.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- D. Speed Scaling ---
        max_scale_factor = 1.0
        for i in range(6):
            if abs(Speed_out[i]) > PAROL6_ROBOT.Joint_max_speed[i]:
                scale = abs(Speed_out[i]) / PAROL6_ROBOT.Joint_max_speed[i]
                if scale > max_scale_factor:
                    max_scale_factor = scale
        
        if max_scale_factor > 1.0:
            for i in range(6):
                Speed_out[i] = int(Speed_out[i] / max_scale_factor)

        return False # Command is still running

class MovePoseCommand:
    """
    A non-blocking command to move the robot to a specific Cartesian pose.
    The movement itself is a joint-space interpolation.
    """
    def __init__(self, pose, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = True  # Assume valid; preparation step will confirm.
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MovePose to {pose}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.pose = pose
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

    """
        Initializes, validates, and pre-computes the trajectory for a move-to-pose command.

        Args:
            pose (list): A list of 6 values [x, y, z, r, p, y] for the target pose.
                         Positions are in mm, rotations are in degrees.
            duration (float, optional): The total time for the movement in seconds.
            velocity_percent (float, optional): The target velocity as a percentage (0-100).
            accel_percent (float, optional): The target acceleration as a percentage (0-100).
            trajectory_type (str, optional): The type of trajectory ('poly' or 'trap').
        """
    
    def prepare_for_execution(self, current_position_in):
        """Calculates the full trajectory just-in-time before execution."""
        print(f"  -> Preparing trajectory for MovePose to {self.pose}...")

        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pose = SE3(self.pose[0] / 1000.0, self.pose[1] / 1000.0, self.pose[2] / 1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')
        
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_pose, initial_pos_rad, ilimit=100)

        if not ik_solution.success:
            print("  -> VALIDATION FAILED: Inverse kinematics failed at execution time.")
            self.is_valid = False
            return

        target_pos_rad = ik_solution.q

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])

                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue
                    
                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)
            
                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                self.is_valid = False
                return

        else:
            print("  -> Using conservative values for MovePose.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveJointCommand:
    """
    A non-blocking command to move the robot's joints to a specific configuration.
    It pre-calculates the entire trajectory upon initialization.
    """
    def __init__(self, target_angles, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = False  # Will be set to True after basic validation
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MoveJoint to {target_angles}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.target_angles = target_angles
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

        # --- Perform only state-independent validation ---
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])
        for i in range(6):
            min_rad, max_rad = PAROL6_ROBOT.Joint_limits_radian[i]
            if not (min_rad <= target_pos_rad[i] <= max_rad):
                print(f"  -> VALIDATION FAILED: Target for Joint {i+1} ({self.target_angles[i]} deg) is out of range.")
                return
        
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Calculates the trajectory just before execution begins."""
        print(f"  -> Preparing trajectory for MoveJoint to {self.target_angles}...")
        
        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])
                
                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue

                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)

                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                print(f"  -> Please check Joint_min/max_speed and Joint_min/max_acc values in PAROL6_ROBOT.py.")
                self.is_valid = False
                return
        
        else:
            print("  -> Using conservative values for MoveJoint.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveCartCommand:
    """
    A non-blocking command to move the robot's end-effector in a straight line
    in Cartesian space, completing the move in an exact duration.

    It works by:
    1. Pre-validating the final target pose.
    2. Interpolating the pose in Cartesian space in real-time.
    3. Solving Inverse Kinematics for each intermediate step to ensure path validity.
    """
    def __init__(self, pose, duration=None, velocity_percent=None):
        self.is_valid = False
        self.is_finished = False

        # --- MODIFICATION: Validate that at least one timing parameter is given ---
        if duration is None and velocity_percent is None:
            print("  -> VALIDATION FAILED: MoveCartCommand requires either 'duration' or 'velocity_percent'.")
            return
        if duration is not None and velocity_percent is not None:
            print("  -> INFO: Both duration and velocity_percent provided. Using duration.")
            self.velocity_percent = None # Prioritize duration
        else:
            self.velocity_percent = velocity_percent

        # --- Store parameters and set placeholders ---
        self.duration = duration
        self.pose = pose
        self.start_time = None
        self.initial_pose = None
        self.target_pose = None
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Captures the initial state and validates the path just before execution."""
        print(f"  -> Preparing for MoveCart to {self.pose}...")
        
        # --- MOVED LOGIC: Capture initial state from live data ---
        initial_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        self.initial_pose = PAROL6_ROBOT.robot.fkine(initial_q_rad)
        self.target_pose = SE3(self.pose[0]/1000.0, self.pose[1]/1000.0, self.pose[2]/1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')

        print("  -> Pre-validating final target pose...")
        ik_check = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, self.target_pose, initial_q_rad
        )

        if not ik_check.success:
            print("  -> VALIDATION FAILED: The final target pose is unreachable.")
            if ik_check.violations:
                print(f"     Reason: Solution violates joint limits: {ik_check.violations}")
            self.is_valid = False # Mark as invalid if path fails
            return

        # --- NEW BLOCK: Calculate duration from velocity if needed ---
        if self.velocity_percent is not None:
            print(f"  -> Calculating duration for {self.velocity_percent}% speed...")
            # Calculate the total distance for translation and rotation
            linear_distance = np.linalg.norm(self.target_pose.t - self.initial_pose.t)
            angular_distance_rad = self.initial_pose.angdist(self.target_pose)

            # Interpolate the target speeds from percentages, assuming constants exist in PAROL6_ROBOT
            target_linear_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min, PAROL6_ROBOT.Cartesian_linear_velocity_max])
            target_angular_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max])
            target_angular_speed_rad = np.deg2rad(target_angular_speed)

            # Calculate time required for each component of the movement
            time_linear = linear_distance / target_linear_speed if target_linear_speed > 0 else 0
            time_angular = angular_distance_rad / target_angular_speed_rad if target_angular_speed_rad > 0 else 0

            # The total duration is the longer of the two times to ensure synchronization
            calculated_duration = max(time_linear, time_angular)

            if calculated_duration <= 0:
                print("  -> INFO: MoveCart has zero duration. Marking as finished.")
                self.is_finished = True
                self.is_valid = True # It's valid, just already done.
                return

            self.duration = calculated_duration
            print(f"  -> Calculated MoveCart duration: {self.duration:.2f}s")

        print("  -> Command is valid and ready for execution.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        if self.start_time is None:
            self.start_time = time.time()

        elapsed_time = time.time() - self.start_time
        s = min(elapsed_time / self.duration, 1.0)
        s_scaled = quintic_scaling(s)

        current_target_pose = self.initial_pose.interp(self.target_pose, s_scaled)

        current_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, current_target_pose, current_q_rad
        )

        if not ik_solution.success:
            print("  -> ERROR: MoveCart failed. An intermediate point on the path is unreachable.")
            if ik_solution.violations:
                 print(f"     Reason: Path violates joint limits: {ik_solution.violations}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        current_pos_rad = ik_solution.q

        # --- MODIFIED BLOCK ---
        # Send only the target position and let the firmware's P-controller handle speed.
        Position_out[:] = [int(PAROL6_ROBOT.RAD2STEPS(p, i)) for i, p in enumerate(current_pos_rad)]
        Speed_out[:] = [0] * 6 # Set feed-forward velocity to zero for smooth P-control.
        Command_out.value = 156
        # --- END MODIFIED BLOCK ---

        if s >= 1.0:
            print(f"MoveCart finished in ~{elapsed_time:.2f}s.")
            self.is_finished = True
            # The main loop will handle holding the final position.

        return self.is_finished
        
class GripperCommand:
    """
    A single, unified, non-blocking command to control all gripper functions.
    It internally selects the correct logic (position-based waiting, timed delay,
    or instantaneous) based on the specified action.
    """
    def __init__(self, gripper_type, action=None, position=100, speed=100, current=500, output_port=1):
        """
        Initializes the Gripper command and configures its internal state machine
        based on the requested action.
        """
        self.is_valid = True
        self.is_finished = False
        self.gripper_type = gripper_type.lower()
        self.action = action.lower() if action else 'move'
        self.state = "START"
        self.timeout_counter = 1000 # 10-second safety timeout for all waiting states

        # --- Configure based on Gripper Type and Action ---
        if self.gripper_type == 'electric':
            if self.action == 'move':
                self.target_position = position
                self.speed = speed
                self.current = current
                if not (0 <= position <= 255 and 0 <= speed <= 255 and 100 <= current <= 1000):
                    self.is_valid = False
            elif self.action == 'calibrate':
                self.wait_counter = 200 # 2-second fixed delay for calibration
            else:
                self.is_valid = False # Invalid action

        elif self.gripper_type == 'pneumatic':
            if self.action not in ['open', 'close']:
                self.is_valid = False
            self.state_to_set = 1 if self.action == 'open' else 0
            self.port_index = 2 if output_port == 1 else 3
        else:
            self.is_valid = False

        if not self.is_valid:
            print(f"  -> VALIDATION FAILED for GripperCommand with action: '{self.action}'")

    def execute_step(self, Gripper_data_out, InOut_out, Gripper_data_in, InOut_in, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        self.timeout_counter -= 1
        if self.timeout_counter <= 0:
            print(f"  -> ERROR: Gripper command timed out in state {self.state}.")
            self.is_finished = True
            return True

        # --- Pneumatic Logic (Instantaneous) ---
        if self.gripper_type == 'pneumatic':
            InOut_out[self.port_index] = self.state_to_set
            print("  -> Pneumatic gripper command sent.")
            self.is_finished = True
            return True

        # --- Electric Gripper Logic ---
        if self.gripper_type == 'electric':
            # On the first run, transition to the correct state for the action
            if self.state == "START":
                if self.action == 'calibrate':
                    self.state = "SEND_CALIBRATE"
                else: # 'move'
                    self.state = "WAIT_FOR_POSITION"
            
            # --- Calibrate Logic (Timed Delay) ---
            if self.state == "SEND_CALIBRATE":
                print("  -> Sending one-shot calibrate command...")
                Gripper_data_out[4] = 1 # Set mode to calibrate
                self.state = "WAITING_CALIBRATION"
                return False

            if self.state == "WAITING_CALIBRATION":
                self.wait_counter -= 1
                if self.wait_counter <= 0:
                    print("  -> Calibration delay finished.")
                    Gripper_data_out[4] = 0 # Reset to operation mode
                    self.is_finished = True
                    return True
                return False

            # --- Move Logic (Position-Based) ---
            if self.state == "WAIT_FOR_POSITION":
                # Persistently send the move command
                Gripper_data_out[0], Gripper_data_out[1], Gripper_data_out[2] = self.target_position, self.speed, self.current
                Gripper_data_out[4] = 0 # Operation mode
                bitfield = [1, 1, not InOut_in[4], 1, 0, 0, 0, 0]
                fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                Gripper_data_out[3] = int(fused.hex(), 16)

                # Check for completion
                current_position = Gripper_data_in[1]
                if abs(current_position - self.target_position) <= 5:
                    print(f"  -> Gripper move complete.")
                    self.is_finished = True
                    # Set command back to idle
                    bitfield = [1, 0, not InOut_in[4], 1, 0, 0, 0, 0]
                    fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                    Gripper_data_out[3] = int(fused.hex(), 16)
                    return True
                return False
        
        return self.is_finished

class DelayCommand:
    """
    A non-blocking command that pauses execution for a specified duration.
    During the delay, it ensures the robot remains idle by sending the
    appropriate commands.
    """
    def __init__(self, duration):
        """
        Initializes and validates the Delay command.

        Args:
            duration (float): The delay time in seconds.
        """
        self.is_valid = False
        self.is_finished = False

        # --- 1. Parameter Validation ---
        if not isinstance(duration, (int, float)) or duration <= 0:
            print(f"  -> VALIDATION FAILED: Delay duration must be a positive number, but got {duration}.")
            return

        print(f"Initializing Delay for {duration} seconds...")
        
        self.duration = duration
        self.end_time = None  # Will be set in prepare_for_execution
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Set the end time when the command actually starts."""
        self.end_time = time.time() + self.duration
        print(f"  -> Delay starting for {self.duration} seconds...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Checks if the delay duration has passed and keeps the robot idle.
        This method is called on every loop cycle (~0.01s).
        """
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Keep the robot idle during the delay ---
        Command_out.value = 255  # Set command to idle
        Speed_out[:] = [0] * 6   # Set all speeds to zero

        # --- B. Check for completion ---
        if self.end_time and time.time() >= self.end_time:
            print(f"Delay finished after {self.duration} seconds.")
            self.is_finished = True
        
        return self.is_finished
    
#########################################################################
# Smooth Motion Commands Start Here
#########################################################################
    
class BaseSmoothMotionCommand:
    """
    Base class for all smooth motion commands with proper error tracking.
    """
    
    def __init__(self, description="smooth motion"):
        self.description = description
        self.trajectory = None
        self.trajectory_command = None
        self.transition_command = None
        self.is_valid = True
        self.is_finished = False
        self.specified_start_pose = None
        self.transition_complete = False
        self.trajectory_prepared = False
        self.error_state = False
        self.error_message = ""
        self.trajectory_generated = False  # NEW: Track if trajectory is generated
        
    def create_transition_command(self, current_pose, target_pose):
        """Create a MovePose command for smooth transition to start position."""
        pos_error = np.linalg.norm(
            np.array(target_pose[:3]) - np.array(current_pose[:3])
        )
        
        # Lower threshold to 2mm for more aggressive transition generation
        if pos_error < 2.0:  # Changed from 5.0mm to 2.0mm
            print(f"  -> Already near start position (error: {pos_error:.1f}mm)")
            return None
        
        print(f"  -> Creating smooth transition to start ({pos_error:.1f}mm away)")
        
        # Calculate transition speed based on distance
        # Slower for short distances, faster for long distances
        if pos_error < 10:
            transition_speed = 20.0  # mm/s for short distances
        elif pos_error < 30:
            transition_speed = 30.0  # mm/s for medium distances
        else:
            transition_speed = 40.0  # mm/s for long distances
        
        transition_duration = max(pos_error / transition_speed, 0.5)  # Minimum 0.5s
        
        transition_cmd = MovePoseCommand(
            pose=target_pose,
            duration=transition_duration
        )
        
        return transition_cmd
    
    def get_current_pose_from_position(self, position_in):
        """Convert current position to pose [x,y,z,rx,ry,rz]"""
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(position_in)])
        current_pose_se3 = PAROL6_ROBOT.robot.fkine(current_q)
        
        current_xyz = current_pose_se3.t * 1000  # Convert to mm
        current_rpy = current_pose_se3.rpy(unit='deg', order='xyz')
        return np.concatenate([current_xyz, current_rpy]).tolist()
        
    def prepare_for_execution(self, current_position_in):
        """Minimal preparation - just check if we need a transition."""
        print(f"  -> Preparing {self.description}...")
        
        # If there's a specified start pose, prepare transition
        if self.specified_start_pose:
            actual_current_pose = self.get_current_pose_from_position(current_position_in)
            self.transition_command = self.create_transition_command(
                actual_current_pose, self.specified_start_pose
            )
            
            if self.transition_command:
                self.transition_command.prepare_for_execution(current_position_in)
                if not self.transition_command.is_valid:
                    print(f"  -> ERROR: Cannot reach specified start position")
                    self.is_valid = False
                    self.error_state = True
                    self.error_message = "Cannot reach specified start position"
                    return
        else:
            self.transition_command = None
            
        # DON'T generate trajectory yet - wait until execution
        self.trajectory_generated = False
        self.trajectory_prepared = False
        print(f"  -> {self.description} preparation complete (trajectory will be generated at execution)")
            
    def generate_main_trajectory(self, effective_start_pose):
        """Override this in subclasses to generate the specific motion trajectory."""
        raise NotImplementedError("Subclasses must implement generate_main_trajectory")
        
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """Execute transition first if needed, then generate and execute trajectory."""
        if self.is_finished or not self.is_valid:
            return True
        
        # Execute transition first if needed
        if self.transition_command and not self.transition_complete:
            is_done = self.transition_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            if is_done:
                print(f"  -> Transition complete")
                self.transition_complete = True
            return False
        
        # Generate trajectory on first execution step (not during preparation!)
        if not self.trajectory_generated:
            # Get ACTUAL current position NOW
            actual_current_pose = self.get_current_pose_from_position(Position_in)
            print(f"  -> Generating {self.description} from ACTUAL position: {[round(p, 1) for p in actual_current_pose[:3]]}")
            
            # Generate trajectory from where we ACTUALLY are
            self.trajectory = self.generate_main_trajectory(actual_current_pose)
            self.trajectory_command = SmoothTrajectoryCommand(
                self.trajectory, self.description
            )
            
            # Quick validation of first point only
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(Position_in)])
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
            )
            
            if not ik_result.success:
                print(f"  -> ERROR: Cannot reach first trajectory point")
                self.is_finished = True
                self.error_state = True
                self.error_message = "Cannot reach trajectory start"
                Speed_out[:] = [0] * 6
                Command_out.value = 255
                return True
                
            self.trajectory_generated = True
            self.trajectory_prepared = True
            
            # Verify first point is close to current
            distance = np.linalg.norm(first_pose[:3] - np.array(actual_current_pose[:3]))
            if distance > 5.0:
                print(f"  -> WARNING: First trajectory point {distance:.1f}mm from current!")
        
        # Execute main trajectory
        if self.trajectory_command and self.trajectory_prepared:
            is_done = self.trajectory_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            # Check for errors in trajectory execution
            if hasattr(self.trajectory_command, 'error_state') and self.trajectory_command.error_state:
                self.error_state = True
                self.error_message = self.trajectory_command.error_message
            
            if is_done:
                self.is_finished = True
            
            return is_done
        else:
            self.is_finished = True
            return True

class SmoothTrajectoryCommand:
    """Command class for executing pre-generated smooth trajectories."""
    
    def __init__(self, trajectory, description="smooth motion"):
        self.trajectory = np.array(trajectory)
        self.description = description
        self.trajectory_index = 0
        self.is_valid = True
        self.is_finished = False
        self.first_step = True
        self.error_state = False
        self.error_message = ""
        
        print(f"Initializing smooth {description} with {len(trajectory)} points")
    
    def prepare_for_execution(self, current_position_in):
        """Skip validation - trajectory is already generated from correct position"""
        # No validation needed since trajectory was just generated from current position
        self.is_valid = True
        return
    
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, Position_out=None, **kwargs):
        """Execute one step of the smooth trajectory"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Get Position_out from kwargs if not provided
        if Position_out is None:
            Position_out = kwargs.get('Position_out', Position_in)
        
        if self.trajectory_index >= len(self.trajectory):
            print(f"Smooth {self.description} finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get target pose for this step
        target_pose = self.trajectory[self.trajectory_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                            for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
        )
        
        if not ik_result.success:
            print(f"  -> IK failed at trajectory point {self.trajectory_index}")
            self.is_finished = True
            self.error_state = True
            self.error_message = f"IK failed at point {self.trajectory_index}/{len(self.trajectory)}"
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                    for i, q in enumerate(ik_result.q)]
        
        # ADD VELOCITY LIMITING - This prevents violent movements
        if self.trajectory_index > 0:
            for i in range(6):
                step_diff = abs(target_steps[i] - Position_in[i])
                max_step_diff = PAROL6_ROBOT.Joint_max_speed[i] * 0.01  # Max steps in 10ms
                
                # Use 1.2x safety margin (not 2x as before)
                if step_diff > max_step_diff * 1.2:
                    #print(f"  -> WARNING: Joint {i+1} velocity limit exceeded at point {self.trajectory_index}")
                    #print(f"     Step difference: {step_diff}, Max allowed: {max_step_diff * 1.2:.1f}")
                    
                    # Clamp the motion
                    sign = 1 if target_steps[i] > Position_in[i] else -1
                    target_steps[i] = Position_in[i] + sign * int(max_step_diff)
        
        # Send position command
        Position_out[:] = target_steps
        Speed_out[:] = [0] * 6
        Command_out.value = 156
        
        # Advance to next point
        self.trajectory_index += 1
        
        return False

class SmoothCircleCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, plane, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"circle (r={radius}mm, {frame})")
        self.center = center
        self.radius = radius
        self.plane = plane
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame  # Store reference frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None  # Store for TRF transformation
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        # Store current position for potential use in generate_main_trajectory
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'center': self.center,
                'plane': self.plane
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_CIRCLE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Circle: center {self.center[:3]} (WRF), normal {self.normal_vector}")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_CIRCLE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        # Now do normal preparation with transformed parameters
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate circle starting from the actual start position."""
        motion_gen = CircularMotion()
        
        # Use transformed normal for TRF, or standard for WRF
        if self.normal_vector is not None:
            # TRF - use the transformed normal vector
            normal = np.array(self.normal_vector)
            print(f"    Using transformed normal: {normal.round(3)}")
        else:
            # WRF - use standard plane definition
            plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
            normal = np.array(plane_normals.get(self.plane, [0, 0, 1]))  # Convert to numpy array
            print(f"    Using WRF plane {self.plane} with normal: {normal}")
        
        print(f"    Generating circle from position: {[round(p, 1) for p in effective_start_pose[:3]]}")
        print(f"    Circle center: {[round(c, 1) for c in self.center]}")
        
        # Add geometry validation
        center_np = np.array(self.center)
        start_np = np.array(effective_start_pose[:3])
        
        # Project start point onto circle plane to check distance
        to_start = start_np - center_np
        to_start_plane = to_start - np.dot(to_start, normal) * normal
        distance_to_center = np.linalg.norm(to_start_plane)
        
        if abs(distance_to_center - self.radius) > self.radius * 0.3:
            print(f"    WARNING: Robot is {distance_to_center:.1f}mm from center, but radius is {self.radius:.1f}mm")
            print(f"    Circle geometry will be auto-corrected")
        
        # Generate circle that starts at effective_start_pose
        trajectory = motion_gen.generate_circle_3d(
            self.center, 
            self.radius, 
            normal,  # This normal now correctly represents the plane
            start_point=effective_start_pose[:3],
            duration=self.duration
        )
        
        if self.clockwise:
            trajectory = trajectory[::-1]
        
        # Update orientations to match start pose
        for i in range(len(trajectory)):
            trajectory[i][3:] = effective_start_pose[3:]
        
        return trajectory
    
class SmoothArcCenterCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, center, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"arc (center-based, {frame})")
        self.end_pose = end_pose
        self.center = center
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {
                'end_pose': self.end_pose,
                'center': self.center
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
            )
            self.end_pose = transformed['end_pose']
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc from actual start to end."""
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, self.center,
            normal=self.normal_vector,  # Use transformed normal if TRF
            clockwise=self.clockwise, duration=self.duration
        )
    
class SmoothArcParamCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, radius, arc_angle, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"parametric arc (r={radius}mm, θ={arc_angle}°, {frame})")
        self.end_pose = end_pose
        self.radius = radius
        self.arc_angle = arc_angle
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'end_pose': self.end_pose,
                'plane': 'XY'  # Default plane for parametric arc
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.end_pose = transformed['end_pose']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Parametric Arc: end {self.end_pose[:3]} (WRF)")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc based on radius and angle from actual start."""
        # Get start and end positions
        start_xyz = np.array(effective_start_pose[:3])
        end_xyz = np.array(self.end_pose[:3])
        
        # If we have a transformed normal (TRF), use it to define the arc plane
        if self.normal_vector is not None:
            normal = np.array(self.normal_vector)
            
            # Project start and end onto the plane perpendicular to normal
            # This ensures the arc stays in the correct plane for TRF
            
            # Find center of arc using radius and angle
            chord_vec = end_xyz - start_xyz
            chord_length = np.linalg.norm(chord_vec)
            
            if chord_length > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({chord_length:.1f}mm) for radius {self.radius}mm")
                self.radius = chord_length / 2 + 1
            
            # Calculate center position using the normal vector
            chord_mid = (start_xyz + end_xyz) / 2
            
            # Height from chord midpoint to arc center
            if chord_length > 0:
                h = np.sqrt(max(0, self.radius**2 - (chord_length/2)**2))
                
                # Find perpendicular in the plane defined by normal
                chord_dir = chord_vec / chord_length
                perp_in_plane = np.cross(normal, chord_dir)
                if np.linalg.norm(perp_in_plane) > 0.001:
                    perp_in_plane = perp_in_plane / np.linalg.norm(perp_in_plane)
                else:
                    # Chord is parallel to normal (shouldn't happen)
                    perp_in_plane = np.array([1, 0, 0])
                
                # Arc center
                if self.clockwise:
                    center_3d = chord_mid - h * perp_in_plane
                else:
                    center_3d = chord_mid + h * perp_in_plane
            else:
                center_3d = start_xyz
            
        else:
            # WRF - use XY plane (standard behavior)
            normal = np.array([0, 0, 1])
            
            # Calculate arc center in XY plane
            start_xy = start_xyz[:2]
            end_xy = end_xyz[:2]
            
            # Midpoint
            mid = (start_xy + end_xy) / 2
            
            # Distance between points
            d = np.linalg.norm(end_xy - start_xy)
            
            if d > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({d:.1f}mm) for radius {self.radius}mm")
                self.radius = d / 2 + 1
            
            # Height of arc center from midpoint
            h = np.sqrt(max(0, self.radius**2 - (d/2)**2))
            
            # Perpendicular direction
            if d > 0:
                perp = np.array([-(end_xy[1] - start_xy[1]), end_xy[0] - start_xy[0]])
                perp = perp / np.linalg.norm(perp)
            else:
                perp = np.array([1, 0])
            
            # Arc center (choose based on clockwise)
            if self.clockwise:
                center_2d = mid - h * perp
            else:
                center_2d = mid + h * perp
            
            # Use average Z for center
            center_3d = [center_2d[0], center_2d[1], (start_xyz[2] + end_xyz[2]) / 2]
        
        # Generate arc trajectory from actual start
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, center_3d.tolist(),
            normal=normal if self.normal_vector is not None else None,
            clockwise=self.clockwise, duration=self.duration
        )

class SmoothHelixCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, pitch, height, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"helix (h={height}mm, {frame})")
        self.center = center
        self.radius = radius
        self.pitch = pitch
        self.height = height
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.helix_axis = None
        self.up_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {'center': self.center}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_HELIX', params, 'TRF', current_position_in
            )
            self.center = transformed['center']
            self.helix_axis = transformed.get('helix_axis', [0, 0, 1])
            self.up_vector = transformed.get('up_vector', [0, 1, 0])
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_HELIX', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate helix with proper axis orientation."""
        num_revolutions = self.height / self.pitch if self.pitch > 0 else 1
        num_points = int(self.duration * 100)  # 100Hz
        
        # Get helix axis (default Z for WRF, transformed for TRF)
        if self.helix_axis is not None:
            axis = np.array(self.helix_axis)
        else:
            axis = np.array([0, 0, 1])  # Default vertical
        
        # Create orthonormal basis for helix
        if self.up_vector is not None:
            up = np.array(self.up_vector)
        else:
            # Find perpendicular to axis
            if abs(axis[2]) < 0.9:
                up = np.array([0, 0, 1])
            else:
                up = np.array([1, 0, 0])
        
        # Ensure up is perpendicular to axis
        up = up - np.dot(up, axis) * axis
        up = up / np.linalg.norm(up)
        
        # Create right vector
        right = np.cross(axis, up)
        
        # Calculate starting angle based on actual start position
        to_start = np.array(effective_start_pose[:3]) - np.array(self.center)
        # Project onto plane perpendicular to axis
        to_start_plane = to_start - np.dot(to_start, axis) * axis
        
        if np.linalg.norm(to_start_plane) > 0.001:
            to_start_normalized = to_start_plane / np.linalg.norm(to_start_plane)
            start_angle = np.arctan2(np.dot(to_start_normalized, up), 
                                    np.dot(to_start_normalized, right))
        else:
            start_angle = 0
        
        trajectory = []
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            
            angle = start_angle + 2 * np.pi * num_revolutions * t
            if self.clockwise:
                angle = start_angle - 2 * np.pi * num_revolutions * t
            
            # Position on helix
            pos = np.array(self.center) + \
                  self.radius * (np.cos(angle) * right + np.sin(angle) * up) + \
                  self.height * t * axis
            
            # Use orientation from effective start
            trajectory.append(np.concatenate([pos, effective_start_pose[3:]]))
        
        return np.array(trajectory)

class SmoothSplineCommand(BaseSmoothMotionCommand):
    def __init__(self, waypoints, duration, frame='WRF', start_pose=None):
        super().__init__(f"spline ({len(waypoints)} points, {frame})")
        self.waypoints = waypoints
        self.duration = duration
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform waypoints to WRF
            params = {'waypoints': self.waypoints}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_SPLINE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.waypoints = transformed['waypoints']
            
            print(f"  -> TRF Spline: transformed {len(self.waypoints)} waypoints to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_SPLINE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate spline starting from actual position."""
        motion_gen = SplineMotion()
        
        # Always start from the effective start pose
        first_wp_error = np.linalg.norm(
            np.array(self.waypoints[0][:3]) - np.array(effective_start_pose[:3])
        )
        
        if first_wp_error > 5.0:
            # First waypoint is far, prepend the start position
            modified_waypoints = [effective_start_pose] + self.waypoints
            print(f"    Added start position as first waypoint (distance: {first_wp_error:.1f}mm)")
        else:
            # Replace first waypoint with actual start to ensure continuity
            modified_waypoints = [effective_start_pose] + self.waypoints[1:]
            print(f"    Replaced first waypoint with actual start position")
        
        timestamps = np.linspace(0, self.duration, len(modified_waypoints))
        
        # Generate the spline trajectory
        trajectory = motion_gen.generate_cubic_spline(modified_waypoints, timestamps)
        
        print(f"    Generated spline with {len(trajectory)} points")
        
        return trajectory

class SmoothBlendCommand(BaseSmoothMotionCommand):
    def __init__(self, segment_definitions, blend_time, frame='WRF', start_pose=None):
        super().__init__(f"blended ({len(segment_definitions)} segments, {frame})")
        self.segment_definitions = segment_definitions
        self.blend_time = blend_time
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform all segment definitions to WRF
            params = {'segments': self.segment_definitions}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_BLEND', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.segment_definitions = transformed['segments']
            
            print(f"  -> TRF Blend: transformed {len(self.segment_definitions)} segments to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_BLEND', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate blended trajectory starting from actual position."""
        trajectories = []
        motion_gen_circle = CircularMotion()
        motion_gen_spline = SplineMotion()
        
        # Always start from effective start pose
        last_end_pose = effective_start_pose
        
        for i, seg_def in enumerate(self.segment_definitions):
            seg_type = seg_def['type']
            
            # First segment always starts from effective_start_pose
            segment_start = effective_start_pose if i == 0 else last_end_pose
            
            if seg_type == 'LINE':
                end = seg_def['end']
                duration = seg_def['duration']
                
                # Generate line segment from actual position
                num_points = int(duration * 100)
                timestamps = np.linspace(0, duration, num_points)
                
                traj = []
                for t in timestamps:
                    s = t / duration if duration > 0 else 1
                    # Interpolate position
                    pos = [
                        segment_start[j] * (1-s) + end[j] * s
                        for j in range(3)
                    ]
                    # Interpolate orientation
                    orient = [
                        segment_start[j+3] * (1-s) + end[j+3] * s
                        for j in range(3)
                    ]
                    traj.append(pos + orient)
                
                trajectories.append(np.array(traj))
                last_end_pose = end
                
            elif seg_type == 'ARC':
                end = seg_def['end']
                center = seg_def['center']
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Check if we have a transformed normal (from TRF)
                normal = seg_def.get('normal_vector', None)
                
                traj = motion_gen_circle.generate_arc_3d(
                    segment_start, end, center, 
                    normal=normal,  # Use transformed normal if available
                    clockwise=clockwise, duration=duration
                )
                trajectories.append(traj)
                last_end_pose = end
                
            elif seg_type == 'CIRCLE':
                center = seg_def['center']
                radius = seg_def['radius']
                plane = seg_def.get('plane', 'XY')
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Use transformed normal if available (from TRF)
                if 'normal_vector' in seg_def:
                    normal = seg_def['normal_vector']
                else:
                    plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
                    normal = plane_normals.get(plane, [0, 0, 1])
                
                traj = motion_gen_circle.generate_circle_3d(
                    center, radius, normal, 
                    start_point=segment_start[:3],
                    duration=duration
                )
                
                if clockwise:
                    traj = traj[::-1]
                    
                # Update orientations
                for j in range(len(traj)):
                    traj[j][3:] = segment_start[3:]
                    
                trajectories.append(traj)
                # Circle returns to start, so last pose is last point of trajectory
                last_end_pose = traj[-1].tolist()
                
            elif seg_type == 'SPLINE':
                waypoints = seg_def['waypoints']
                duration = seg_def['duration']
                
                # Check if first waypoint is close to segment start
                wp_error = np.linalg.norm(
                    np.array(waypoints[0][:3]) - np.array(segment_start[:3])
                )
                
                if wp_error > 5.0:
                    full_waypoints = [segment_start] + waypoints
                else:
                    full_waypoints = [segment_start] + waypoints[1:]
                
                timestamps = np.linspace(0, duration, len(full_waypoints))
                traj = motion_gen_spline.generate_cubic_spline(full_waypoints, timestamps)
                trajectories.append(traj)
                last_end_pose = waypoints[-1]
        
        # Blend all trajectories
        if len(trajectories) > 1:
            blender = MotionBlender(self.blend_time)
            blended = trajectories[0]
            blend_samples = int(self.blend_time * 100)
            
            for i in range(1, len(trajectories)):
                blended = blender.blend_trajectories(blended, trajectories[i], blend_samples)
            
            print(f"    Blended {len(trajectories)} segments into {len(blended)} points")
            return blended
        elif trajectories:
            return trajectories[0]
        else:
            raise ValueError("No trajectories generated in blend")
        
def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
    """
    Calculate duration based on trajectory length and speed percentage.
    
    Args:
        trajectory_length: Total path length in mm
        speed_percentage: Speed as percentage (1-100)
        
    Returns:
        Duration in seconds
    """
    # Map speed percentage to mm/s (adjustable based on robot capabilities)
    # For example: 100% = 100mm/s, 50% = 50mm/s
    speed_mm_s = np.interp(speed_percentage, [0, 100], 
                          [PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000,
                           PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000])
    
    if speed_mm_s > 0:
        return trajectory_length / speed_mm_s
    else:
        return 5.0  # Default fallback
    
def parse_smooth_motion_commands(parts):
    """
    Parse smooth motion commands received via UDP and create appropriate command objects.
    All commands support:
    - Reference frame selection (WRF or TRF)
    - Optional start position (CURRENT or specified pose)
    - Both DURATION and SPEED timing modes
    
    Args:
        parts: List of command parts split by '|'
        
    Returns:
        Command object or None if parsing fails
    """
    command_type = parts[0]
    
    # Helper function for parsing optional start pose
    def parse_start_pose(start_str):
        """Parse start pose - returns None for CURRENT, or list of floats for specified pose."""
        if start_str == 'CURRENT' or start_str == 'NONE':
            return None
        else:
            try:
                return list(map(float, start_str.split(',')))
            except:
                print(f"Warning: Invalid start pose format: {start_str}")
                return None
    
    # Helper function for calculating duration from speed
    def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
        """Calculate duration based on trajectory length and speed percentage."""
        # Map speed percentage to mm/s
        min_speed = PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000  # Convert to mm/s
        max_speed = PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000  # Convert to mm/s
        speed_mm_s = np.interp(speed_percentage, [0, 100], [min_speed, max_speed])
        
        if speed_mm_s > 0:
            return trajectory_length / speed_mm_s
        else:
            return 5.0  # Default fallback
    
    try:
        if command_type == 'SMOOTH_CIRCLE':
            # Format: SMOOTH_CIRCLE|center_x,center_y,center_z|radius|plane|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            plane = parts[3]
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Circle circumference
                path_length = 2 * np.pi * radius
                duration = calculate_duration_from_speed(path_length, timing_value)
            
            print(f"  -> Parsed circle: r={radius}mm, plane={plane}, frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command object with frame parameter
            return SmoothCircleCommand(center, radius, plane, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_CENTER':
            # Format: SMOOTH_ARC_CENTER|end_pose|center|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            center = list(map(float, parts[2].split(',')))
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[6])
            clockwise = parts[7] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Estimate arc length (will be more accurate when we have actual positions)
                # Use a conservative estimate based on radius
                radius_estimate = np.linalg.norm(np.array(center) - np.array(end_pose[:3]))
                estimated_arc_angle = np.pi / 2  # 90 degrees estimate
                arc_length = radius_estimate * estimated_arc_angle
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (center): frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command with frame
            return SmoothArcCenterCommand(end_pose, center, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_PARAM':
            # Format: SMOOTH_ARC_PARAM|end_pose|radius|angle|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            arc_angle = float(parts[3])
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Arc length = radius * angle (in radians)
                arc_length = radius * np.deg2rad(arc_angle)
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (param): r={radius}mm, θ={arc_angle}°, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothArcParamCommand(end_pose, radius, arc_angle, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_SPLINE':
            # Format: SMOOTH_SPLINE|num_waypoints|frame|start_pose|timing_type|timing_value|waypoint1|waypoint2|...
            num_waypoints = int(parts[1])
            frame = parts[2]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[3])
            timing_type = parts[4]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[5])
            
            # Parse waypoints
            waypoints = []
            idx = 6
            for i in range(num_waypoints):
                wp = []
                for j in range(6):  # Each waypoint has 6 values (x,y,z,rx,ry,rz)
                    wp.append(float(parts[idx]))
                    idx += 1
                waypoints.append(wp)
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate total path length
                total_dist = 0
                for i in range(1, len(waypoints)):
                    dist = np.linalg.norm(np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3]))
                    total_dist += dist
                
                duration = calculate_duration_from_speed(total_dist, timing_value)
            
            print(f"  -> Parsed spline: {num_waypoints} points, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothSplineCommand(waypoints, duration, frame, start_pose)
            
        elif command_type == 'SMOOTH_HELIX':
            # Format: SMOOTH_HELIX|center|radius|pitch|height|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            pitch = float(parts[3])
            height = float(parts[4])
            frame = parts[5]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[6])
            timing_type = parts[7]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[8])
            clockwise = parts[9] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate helix path length
                num_revolutions = height / pitch if pitch > 0 else 1
                horizontal_length = 2 * np.pi * radius * num_revolutions
                helix_length = np.sqrt(horizontal_length**2 + height**2)
                duration = calculate_duration_from_speed(helix_length, timing_value)
            
            print(f"  -> Parsed helix: h={height}mm, pitch={pitch}mm, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothHelixCommand(center, radius, pitch, height, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_BLEND':
            # Format: SMOOTH_BLEND|num_segments|blend_time|frame|start_pose|timing_type|timing_value|segment1||segment2||...
            num_segments = int(parts[1])
            blend_time = float(parts[2])
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DEFAULT', 'DURATION', or 'SPEED'
            
            # Parse overall timing
            if timing_type == 'DEFAULT':
                # Use individual segment durations as-is
                overall_duration = None
                overall_speed = None
                segments_start_idx = 6
            else:
                timing_value = float(parts[6])
                if timing_type == 'DURATION':
                    overall_duration = timing_value
                    overall_speed = None
                else:  # SPEED
                    overall_speed = timing_value
                    overall_duration = None
                segments_start_idx = 7
            
            # Parse segments (separated by ||)
            segments_data = '|'.join(parts[segments_start_idx:])
            segment_strs = segments_data.split('||')
            
            # Parse segment definitions
            segment_definitions = []
            total_original_duration = 0
            total_estimated_length = 0
            
            for seg_str in segment_strs:
                if not seg_str:  # Skip empty segments
                    continue
                    
                seg_parts = seg_str.split('|')
                seg_type = seg_parts[0]
                
                if seg_type == 'LINE':
                    # Format: LINE|end_x,end_y,end_z,end_rx,end_ry,end_rz|duration
                    end = list(map(float, seg_parts[1].split(',')))
                    segment_duration = float(seg_parts[2])
                    total_original_duration += segment_duration
                    
                    # Estimate length (will be refined when we have actual start)
                    estimated_length = 100  # mm, conservative estimate
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'LINE',
                        'end': end,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
                    
                elif seg_type == 'CIRCLE':
                    # Format: CIRCLE|center_x,center_y,center_z|radius|plane|duration|clockwise
                    center = list(map(float, seg_parts[1].split(',')))
                    radius = float(seg_parts[2])
                    plane = seg_parts[3]
                    segment_duration = float(seg_parts[4])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[5] == '1'
                    
                    # Circle circumference
                    estimated_length = 2 * np.pi * radius
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'CIRCLE',
                        'center': center,
                        'radius': radius,
                        'plane': plane,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'ARC':
                    # Format: ARC|end_x,end_y,end_z,end_rx,end_ry,end_rz|center_x,center_y,center_z|duration|clockwise
                    end = list(map(float, seg_parts[1].split(',')))
                    center = list(map(float, seg_parts[2].split(',')))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[4] == '1'
                    
                    # Estimate arc length
                    estimated_radius = 50  # mm
                    estimated_arc_angle = np.pi / 2  # 90 degrees
                    estimated_length = estimated_radius * estimated_arc_angle
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'ARC',
                        'end': end,
                        'center': center,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'SPLINE':
                    # Format: SPLINE|num_points|waypoint1;waypoint2;...|duration
                    num_points = int(seg_parts[1])
                    waypoints = []
                    wp_strs = seg_parts[2].split(';')
                    for wp_str in wp_strs:
                        waypoints.append(list(map(float, wp_str.split(','))))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    
                    # Estimate spline length
                    estimated_length = 0
                    for i in range(1, len(waypoints)):
                        estimated_length += np.linalg.norm(
                            np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3])
                        )
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'SPLINE',
                        'waypoints': waypoints,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
            
            # Adjust segment durations if overall timing is specified
            if overall_duration is not None:
                # Scale all segment durations proportionally
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Scaled blend segments to total duration: {overall_duration:.2f}s")
                        
            elif overall_speed is not None:
                # Calculate duration from speed and estimated path length
                overall_duration = calculate_duration_from_speed(total_estimated_length, overall_speed)
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Calculated blend duration from speed: {overall_duration:.2f}s")
            else:
                print(f"  -> Using original segment durations (total: {total_original_duration:.2f}s)")
            
            print(f"  -> Parsed blend: {num_segments} segments, frame={frame}, blend_time={blend_time}s")
            
            # Return command with frame
            return SmoothBlendCommand(segment_definitions, blend_time, frame, start_pose)
            
    except Exception as e:
        print(f"Error parsing smooth motion command: {e}")
        print(f"Command parts: {parts}")
        import traceback
        traceback.print_exc()
        return None
    
    print(f"Warning: Unknown smooth motion command type: {command_type}")
    return None

def transform_command_params_to_wrf(command_type: str, params: dict, frame: str, current_position_in) -> dict:
    """
    Transform command parameters from TRF to WRF.
    Handles position, orientation, and directional vectors correctly.
    """
    if frame == 'WRF':
        return params
    
    # Get current tool pose
    current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                         for i, p in enumerate(current_position_in)])
    tool_pose = PAROL6_ROBOT.robot.fkine(current_q)
    
    transformed = params.copy()
    
    # SMOOTH_CIRCLE - Transform center and plane normal
    if command_type == 'SMOOTH_CIRCLE':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'plane' in params:
            plane_normals_trf = {
                'XY': [0, 0, 1],   # Tool's Z-axis
                'XZ': [0, 1, 0],   # Tool's Y-axis  
                'YZ': [1, 0, 0]    # Tool's X-axis
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
            print(f"  -> TRF circle plane {params['plane']} transformed to WRF")
    
    # SMOOTH_ARC_CENTER - Transform center, end_pose, and implied plane
    elif command_type == 'SMOOTH_ARC_CENTER':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # Arc plane is determined by start, end, and center points
        # But we should transform any specified plane normal
        if 'plane' in params:
            # Similar to circle plane transformation
            plane_normals_trf = {
                'XY': [0, 0, 1],
                'XZ': [0, 1, 0],
                'YZ': [1, 0, 0]
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_ARC_PARAM - Transform end_pose and arc plane
    elif command_type == 'SMOOTH_ARC_PARAM':
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # For parametric arc, the plane is usually XY of the tool
        # Transform the assumed plane normal
        if 'plane' not in params:
            params['plane'] = 'XY'  # Default to XY plane
        
        plane_normals_trf = {
            'XY': [0, 0, 1],
            'XZ': [0, 1, 0],
            'YZ': [1, 0, 0]
        }
        normal_trf = np.array(plane_normals_trf[params.get('plane', 'XY')])
        normal_wrf = tool_pose.R @ normal_trf
        transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_HELIX - Transform center and helix axis
    elif command_type == 'SMOOTH_HELIX':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        # Helix axis - default is Z-axis (vertical in TRF)
        # In TRF, helix rises along tool's Z-axis
        helix_axis_trf = np.array([0, 0, 1])  # Tool's Z-axis
        helix_axis_wrf = tool_pose.R @ helix_axis_trf
        transformed['helix_axis'] = helix_axis_wrf.tolist()
        
        # Also need to transform the "up" direction for proper orientation
        up_vector_trf = np.array([0, 1, 0])  # Tool's Y-axis
        up_vector_wrf = tool_pose.R @ up_vector_trf
        transformed['up_vector'] = up_vector_wrf.tolist()
    
    # SMOOTH_SPLINE - Transform all waypoints
    elif command_type == 'SMOOTH_SPLINE':
        if 'waypoints' in params:
            transformed_waypoints = []
            for wp in params['waypoints']:
                wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                         SE3.RPY(wp[3:], unit='deg', order='xyz')
                wp_wrf = tool_pose * wp_trf
                wp_transformed = np.concatenate([
                    wp_wrf.t * 1000,
                    wp_wrf.rpy(unit='deg', order='xyz')
                ]).tolist()
                transformed_waypoints.append(wp_transformed)
            transformed['waypoints'] = transformed_waypoints
    
    # SMOOTH_BLEND - Transform all segments recursively
    elif command_type == 'SMOOTH_BLEND':
        if 'segments' in params:
            transformed_segments = []
            for seg in params['segments']:
                seg_copy = seg.copy()
                seg_type = seg['type']
                
                if seg_type == 'LINE':
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'CIRCLE':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'plane' in seg:
                        plane_normals_trf = {
                            'XY': [0, 0, 1],
                            'XZ': [0, 1, 0],
                            'YZ': [1, 0, 0]
                        }
                        normal_trf = np.array(plane_normals_trf[seg['plane']])
                        normal_wrf = tool_pose.R @ normal_trf
                        seg_copy['normal_vector'] = normal_wrf.tolist()
                
                elif seg_type == 'ARC':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'SPLINE':
                    if 'waypoints' in seg:
                        transformed_waypoints = []
                        for wp in seg['waypoints']:
                            wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                                     SE3.RPY(wp[3:], unit='deg', order='xyz')
                            wp_wrf = tool_pose * wp_trf
                            wp_transformed = np.concatenate([
                                wp_wrf.t * 1000,
                                wp_wrf.rpy(unit='deg', order='xyz')
                            ]).tolist()
                            transformed_waypoints.append(wp_transformed)
                        seg_copy['waypoints'] = transformed_waypoints
                
                transformed_segments.append(seg_copy)
            transformed['segments'] = transformed_segments
    
    # Transform start_pose if specified (common to all commands)
    if 'start_pose' in params and params['start_pose'] is not None:
        start_trf = SE3(params['start_pose'][0]/1000, 
                       params['start_pose'][1]/1000, 
                       params['start_pose'][2]/1000) * \
                    SE3.RPY(params['start_pose'][3:], unit='deg', order='xyz')
        start_wrf = tool_pose * start_trf
        transformed['start_pose'] = np.concatenate([
            start_wrf.t * 1000,
            start_wrf.rpy(unit='deg', order='xyz')
        ]).tolist()
    
    return transformed

#########################################################################
# Smooth Motion Commands and Robot Commands End Here
#########################################################################

# Acknowledgment system configuration
CLIENT_ACK_PORT = 5002  # Port where clients listen for acknowledgments
ack_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Command tracking
active_command_id = None
command_id_map = {}  # Maps command objects to their IDs

def send_acknowledgment(cmd_id: str, status: str, details: str = "", addr=None):
    """Send acknowledgment back to client"""
    if not cmd_id:
        return
        
    ack_message = f"ACK|{cmd_id}|{status}|{details}"
    
    # Send to the original sender if we have their address
    if addr:
        try:
            ack_socket.sendto(ack_message.encode('utf-8'), (addr[0], CLIENT_ACK_PORT))
        except Exception as e:
            print(f"Failed to send ack to {addr}: {e}")
    
    # Also broadcast to localhost in case the client is local
    try:
        ack_socket.sendto(ack_message.encode('utf-8'), ('127.0.0.1', CLIENT_ACK_PORT))
    except:
        pass

def parse_command_with_id(message: str) -> Tuple[Optional[str], str]:
    """
    Parse command ID if present.
    Format: [cmd_id|]COMMAND|params...
    Returns: (cmd_id or None, command_string)
    """
    # Clean up any logging artifacts
    if "ID:" in message or "):" in message:
        # Extract the actual command after these artifacts
        if "):" in message:
            message = message[message.rindex("):")+2:].strip()
        elif "ID:" in message:
            message = message[message.index("ID:")+3:].strip()
            # Remove any trailing parentheses or colons
            message = message.lstrip('):').strip()
    
    parts = message.split('|', 1)
    
    # Check if first part looks like a valid command ID (8 chars, alphanumeric)
    # IMPORTANT: Command IDs from uuid.uuid4()[:8] will contain lowercase letters/numbers
    # Actual commands are all uppercase, so exclude all-uppercase strings
    if (len(parts) > 1 and 
        len(parts[0]) == 8 and 
        parts[0].replace('-', '').isalnum() and 
        not parts[0].isupper()):  # This prevents "MOVEPOSE" from being treated as an ID
        return parts[0], parts[1]
    else:
        return None, message


# Create a new, empty command queue
command_queue = deque()

# --------------------------------------------------------------------------
# --- Test 1: Homing and Initial Setup
# --------------------------------------------------------------------------

# 1. Start with the mandatory Home command.
command_queue.append(HomeCommand())

# --- State variable for the currently running command ---
active_command = None
e_stop_active = False

# Use deque for an efficient FIFO queue
incoming_command_buffer = deque()
# Timestamp of the last processed network command
last_command_time = 0
# Cooldown period in seconds to prevent command flooding
COMMAND_COOLDOWN_S = 0.1 # 100ms

# Set interval
timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)

# ============================================================================
# MODIFIED MAIN LOOP WITH ACKNOWLEDGMENTS
# ============================================================================

timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)
prev_time = 0

while timer.elapsed_time < 1100000:
    
    # --- Connection Handling ---
    if ser is None or not ser.is_open:
        print("Serial port not open. Attempting to reconnect...")
        try:
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            if ser.is_open:
                print(f"Successfully reconnected to {com_port_str}")
        except serial.SerialException as e:
            ser = None
            time.sleep(1) 
        continue

    # =======================================================================
    # === NETWORK COMMAND RECEPTION WITH ID PARSING ===
    # =======================================================================
    try:
        while sock in select.select([sock], [], [], 0)[0]:
            data, addr = sock.recvfrom(1024)
            raw_message = data.decode('utf-8').strip()
            if raw_message:
                # Parse command ID if present
                cmd_id, message = parse_command_with_id(raw_message)
                
                parts = message.split('|')
                command_name = parts[0].upper()

                # Handle immediate response commands
                if command_name == 'STOP':
                    print("Received STOP command. Halting all motion and clearing queue.")
                    
                    # Cancel active command
                    if active_command and active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "Stopped by user", addr)
                    active_command = None
                    active_command_id = None
                    
                    # Clear queue and notify about cancelled commands
                    for queued_cmd in command_id_map.keys():
                        if queued_cmd != active_command:
                            if queued_cmd in command_id_map:
                                send_acknowledgment(command_id_map[queued_cmd], 
                                                  "CANCELLED", "Queue cleared by STOP", addr)
                    
                    command_queue.clear()
                    command_id_map.clear()
                    
                    # Stop robot
                    Command_out.value = 255
                    Speed_out[:] = [0] * 6
                    
                    # Send acknowledgment for STOP command itself
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Emergency stop executed", addr)

                elif command_name == 'GET_POSE':
                    q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
                    current_pose_matrix = PAROL6_ROBOT.robot.fkine(q_current).A
                    pose_flat = current_pose_matrix.flatten()
                    pose_str = ",".join(map(str, pose_flat))
                    response_message = f"POSE|{pose_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Pose data sent", addr)

                elif command_name == 'GET_ANGLES':
                    angles_rad = [PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)]
                    angles_deg = np.rad2deg(angles_rad)
                    angles_str = ",".join(map(str, angles_deg))
                    response_message = f"ANGLES|{angles_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Angles data sent", addr)

                elif command_name == 'GET_IO':
                    io_status_str = ",".join(map(str, InOut_in[:5]))
                    response_message = f"IO|{io_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "IO data sent", addr)

                elif command_name == 'GET_GRIPPER':
                    gripper_status_str = ",".join(map(str, Gripper_data_in))
                    response_message = f"GRIPPER|{gripper_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Gripper data sent", addr)

                elif command_name == 'GET_SPEEDS':
                    speeds_str = ",".join(map(str, Speed_in))
                    response_message = f"SPEEDS|{speeds_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Speed data sent", addr)

                else:
                    # Queue command for processing
                    incoming_command_buffer.append((raw_message, addr))

    except Exception as e:
        print(f"Network receive error: {e}")

    # =======================================================================
    # === PROCESS COMMANDS FROM BUFFER WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    current_time = time.time()
    if incoming_command_buffer and (current_time - last_command_time) > COMMAND_COOLDOWN_S and not e_stop_active:
        raw_message, addr = incoming_command_buffer.popleft()
        last_command_time = current_time
        
        # Parse command ID
        cmd_id, message = parse_command_with_id(raw_message)
        print(f"Processing command{' (ID: ' + cmd_id + ')' if cmd_id else ''}: {message[:50]}...")
        
        parts = message.split('|')
        command_name = parts[0].upper()
        
        # Variable to track if command was successfully queued
        command_queued = False
        command_obj = None
        error_details = ""

        # Parse and create command objects
        try:
            if command_name == 'MOVEPOSE' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MovePoseCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
                
            elif command_name == 'MOVEJOINT' and len(parts) == 9:
                joint_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveJointCommand(target_angles=joint_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name in ['SMOOTH_CIRCLE', 'SMOOTH_ARC_CENTER', 'SMOOTH_ARC_PARAM', 
                                 'SMOOTH_SPLINE', 'SMOOTH_HELIX', 'SMOOTH_BLEND']:
                command_obj = parse_smooth_motion_commands(parts)
                if command_obj:
                    command_queued = True
                else:
                    error_details = "Failed to parse smooth motion parameters"
            
            elif command_name == 'MOVECART' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveCartCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name == 'DELAY' and len(parts) == 2:
                duration = float(parts[1])
                command_obj = DelayCommand(duration=duration)
                command_queued = True
            
            elif command_name == 'HOME':
                command_obj = HomeCommand()
                command_queued = True
                
            elif command_name == 'CARTJOG' and len(parts) == 5:
                frame, axis, speed, duration = parts[1].upper(), parts[2], float(parts[3]), float(parts[4])
                command_obj = CartesianJogCommand(frame=frame, axis=axis, speed_percentage=speed, duration=duration)
                command_queued = True
                
            elif command_name == 'JOG' and len(parts) == 5:
                joint_idx, speed = int(parts[1]), float(parts[2])
                duration = None if parts[3].upper() == 'NONE' else float(parts[3])
                distance = None if parts[4].upper() == 'NONE' else float(parts[4])
                command_obj = JogCommand(joint=joint_idx, speed_percentage=speed, duration=duration, distance_deg=distance)
                command_queued = True
            
            elif command_name == 'MULTIJOG' and len(parts) == 4:
                joint_indices = [int(j) for j in parts[1].split(',')]
                speeds = [float(s) for s in parts[2].split(',')]
                duration = float(parts[3])
                command_obj = MultiJogCommand(joints=joint_indices, speed_percentages=speeds, duration=duration)
                command_queued = True
                
            elif command_name == 'PNEUMATICGRIPPER' and len(parts) == 3:
                action, port = parts[1].lower(), int(parts[2])
                command_obj = GripperCommand(gripper_type='pneumatic', action=action, output_port=port)
                command_queued = True
                
            elif command_name == 'ELECTRICGRIPPER' and len(parts) == 5:
                action = None if parts[1].upper() == 'NONE' or parts[1].upper() == 'MOVE' else parts[1].lower()
                pos, spd, curr = int(parts[2]), int(parts[3]), int(parts[4])
                command_obj = GripperCommand(gripper_type='electric', action=action, position=pos, speed=spd, current=curr)
                command_queued = True
            
            else:
                error_details = f"Unknown or malformed command: {command_name}"
                
        except Exception as e:
            error_details = f"Error parsing command: {str(e)}"
            command_queued = False
        
        # Handle command queueing and acknowledgments
        if command_queued and command_obj:
            # Check if command is initially valid
            if hasattr(command_obj, 'is_valid') and not command_obj.is_valid:
                if cmd_id:
                    send_acknowledgment(cmd_id, "INVALID", 
                                       "Command failed validation", addr)
            else:
                # Add to queue
                command_queue.append(command_obj)
                if cmd_id:
                    command_id_map[command_obj] = (cmd_id, addr)
                    send_acknowledgment(cmd_id, "QUEUED", 
                                       f"Position {len(command_queue)} in queue", addr)
        else:
            # Command was not queued
            if cmd_id:
                send_acknowledgment(cmd_id, "INVALID", error_details, addr)
            print(f"Warning: {error_details}")

    # =======================================================================
    # === MAIN EXECUTION LOGIC WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    try:
        # --- E-Stop Handling ---
        if InOut_in[4] == 0:  # E-Stop pressed
            if not e_stop_active:
                cancelled_command_info = "None"
                if active_command is not None:
                    cancelled_command_info = type(active_command).__name__
                    if active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "E-Stop activated")
                
                # Cancel all queued commands
                for cmd_obj in command_queue:
                    if cmd_obj in command_id_map:
                        cmd_id, addr = command_id_map[cmd_obj]
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated", addr)
                
                # Cancel all buffered but unprocessed commands
                for raw_message, addr in incoming_command_buffer:
                    cmd_id, _ = parse_command_with_id(raw_message)
                    if cmd_id:
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated - command not processed", addr)
                
                print(f"E-STOP TRIGGERED! Active command '{cancelled_command_info}' cancelled.")
                print("Release E-Stop and press 'e' to re-enable.")
                e_stop_active = True
            
            Command_out.value = 102
            Speed_out[:] = [0] * 6
            Gripper_data_out[3] = 0
            active_command = None
            active_command_id = None
            command_queue.clear()
            command_id_map.clear()
            incoming_command_buffer.clear()
            
        elif e_stop_active:
            # Waiting for re-enable
            if keyboard.is_pressed('e'):
                print("Re-enabling robot...")
                Command_out.value = 101
                e_stop_active = False
            else:
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]
                
        else:
            # --- Normal Command Processing ---
            
            # Start new command if none active
            if active_command is None and command_queue:
                new_command = command_queue.popleft()
                
                # Get command ID and address if tracked
                cmd_info = command_id_map.get(new_command, (None, None))
                new_cmd_id, new_addr = cmd_info
                
                # Initial validation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Command was invalid from the start
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "INVALID", 
                                        "Initial validation failed", new_addr)
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                    continue  # Skip to next command
                
                # Prepare command
                if hasattr(new_command, 'prepare_for_execution'):
                    try:
                        new_command.prepare_for_execution(current_position_in=Position_in)
                    except Exception as e:
                        print(f"Command preparation failed: {e}")
                        if hasattr(new_command, 'is_valid'):
                            new_command.is_valid = False
                        if hasattr(new_command, 'error_message'):
                            new_command.error_message = str(e)
                
                # Check if still valid after preparation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Failed during preparation
                    error_msg = "Failed during preparation"
                    if hasattr(new_command, 'error_message'):
                        error_msg = new_command.error_message
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "FAILED", error_msg, new_addr)
                    
                    # Clean up
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                else:
                    # Command is valid, make it active
                    active_command = new_command
                    active_command_id = new_cmd_id
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "EXECUTING", 
                                        f"Starting {type(new_command).__name__}", new_addr)
            
            # Execute active command
            if active_command:
                try:
                    is_done = active_command.execute_step(
                        Position_in=Position_in,
                        Homed_in=Homed_in,
                        Speed_out=Speed_out,
                        Command_out=Command_out,
                        Gripper_data_out=Gripper_data_out,
                        InOut_out=InOut_out,
                        InOut_in=InOut_in,
                        Gripper_data_in=Gripper_data_in,
                        Position_out=Position_out  # Add this if needed
                    )
                    
                    if is_done:
                        # Command completed
                        if active_command_id:
                            # Check for error state in smooth motion commands
                            if hasattr(active_command, 'error_state') and active_command.error_state:
                                error_msg = getattr(active_command, 'error_message', 'Command failed during execution')
                                send_acknowledgment(active_command_id, "FAILED", error_msg)
                            else:
                                send_acknowledgment(active_command_id, "COMPLETED", 
                                                f"{type(active_command).__name__} finished successfully")
                        
                        # Clean up
                        if active_command in command_id_map:
                            del command_id_map[active_command]
                        
                        active_command = None
                        active_command_id = None
                        
                except Exception as e:
                    # Command execution error
                    print(f"Command execution error: {e}")
                    if active_command_id:
                        send_acknowledgment(active_command_id, "FAILED", 
                                          f"Execution error: {str(e)}")
                    
                    # Clean up
                    if active_command in command_id_map:
                        del command_id_map[active_command]
                    
                    active_command = None
                    active_command_id = None
                    
            else:
                # No active command - idle
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]

        # --- Communication with Robot ---
        s = Pack_data(Position_out, Speed_out, Command_out.value, 
                     Affected_joint_out, InOut_out, Timeout_out, Gripper_data_out)
        for chunk in s:
            ser.write(chunk)
            
        Get_data(Position_in, Speed_in, Homed_in, InOut_in, Temperature_error_in, 
                Position_error_in, Timeout_error, Timing_data_in, XTR_data, Gripper_data_in)

    except serial.SerialException as e:
        print(f"Serial communication error: {e}")
        
        # Send failure acknowledgments for active command
        if active_command_id:
            send_acknowledgment(active_command_id, "FAILED", "Serial communication lost")
        
        if ser:
            ser.close()
        ser = None
        active_command = None
        active_command_id = None

    timer.checkpt()
````

## File: LICENSE
````
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
````

## File: linux_serial_patch.py
````python
else:
    # Linux/Mac system
    # Try to read the serial port from a file
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved serial port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        # If the file doesn't exist or the port is invalid, try default ports
        default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
        ser = None
        for port in default_ports:
            try:
                ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                print(f"Successfully connected to {port}")
                # Save the successful port to the file
                with open("com_port.txt", "w") as f:
                    f.write(port)
                break
            except serial.SerialException:
                continue
        
        if ser is None:
            print("Could not find any available serial ports.")
            import serial.tools.list_ports
            ports = serial.tools.list_ports.comports()
            if ports:
                print("Available ports:")
                for port in ports:
                    print(f"  {port.device}")
            
            while True:
                try:
                    com_port = input("Enter the serial port (e.g., /dev/ttyACM0): ")
                    ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                    print(f"Successfully connected to {com_port}")
                    # Save the successful port to the file
                    with open("com_port.txt", "w") as f:
                        f.write(com_port)
                    break
                except serial.SerialException:
                    print(f"Could not open port {com_port}. Please try again.")
````

## File: parol6_controller.py
````python
#!/usr/bin/env python3
"""
PAROL6 机械臂控制器 - 完整版本
包含串口通信修复和ROS2接口准备
"""
import os
import sys
import platform
import serial
import serial.tools.list_ports
import time
import threading
import numpy as np
from typing import Optional, List, Tuple
import logging

# 设置日志
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class PAROL6Controller:
    """PAROL6机械臂控制器类"""
    
    def __init__(self, port: Optional[str] = None, baudrate: int = 3000000):
        """
        初始化PAROL6控制器
        
        Args:
            port: 串口端口号，如果为None则自动检测
            baudrate: 波特率，默认3000000
        """
        self.ser = None
        self.com_port_str = port
        self.baudrate = baudrate
        self.is_connected = False
        self.lock = threading.Lock()
        
        # 机械臂参数
        self.num_joints = 6
        self.joint_limits = [
            (-170, 170),  # Joint 1
            (-120, 120),  # Joint 2
            (-145, 145),  # Joint 3
            (-180, 180),  # Joint 4
            (-120, 120),  # Joint 5
            (-360, 360),  # Joint 6
        ]
        
        # 初始化连接
        self.connect()

    
    def connect(self) -> bool:
        """连接到PAROL6机械臂"""
        logger.info("🔧 正在连接PAROL6机械臂...")
        
        # 如果已指定端口，直接尝试连接
        if self.com_port_str:
            if self._try_connect(self.com_port_str):
                return True
        
        # 尝试从配置文件读取
        try:
            with open("com_port.txt", "r") as f:
                saved_port = f.read().strip()
                if self._try_connect(saved_port):
                    self.com_port_str = saved_port
                    return True
        except FileNotFoundError:
            pass
        
        # 自动检测端口
        return self._auto_detect_port()
    
    def _try_connect(self, port: str) -> bool:
        """尝试连接指定端口"""
        if not os.path.exists(port):
            logger.warning(f"端口 {port} 不存在")
            return False
            
        try:
            self.ser = serial.Serial(
                port=port,
                baudrate=self.baudrate,
                timeout=0.1,
                write_timeout=0.1
            )
            self.is_connected = True
            logger.info(f"✅ 成功连接到 {port}")
            
            # 保存成功的端口
            with open("com_port.txt", "w") as f:
                f.write(port)
            
            # 发送初始化命令测试连接
            time.sleep(2)  # 等待设备准备
            if self._test_connection():
                return True
            else:
                logger.warning(f"设备在 {port} 无响应")
                self.disconnect()
                return False
                
        except serial.SerialException as e:
            logger.error(f"连接 {port} 失败: {e}")
            return False

    
    def _auto_detect_port(self) -> bool:
        """自动检测串口"""
        logger.info("🔍 自动检测串口...")
        
        # 默认端口列表
        default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
        
        # 尝试默认端口
        for port in default_ports:
            if self._try_connect(port):
                self.com_port_str = port
                return True
        
        # 列出所有可用串口
        ports = serial.tools.list_ports.comports()
        for port in ports:
            logger.info(f"📡 发现端口: {port.device} - {port.description}")
            if "ACM" in port.device or "USB" in port.device:
                if self._try_connect(port.device):
                    self.com_port_str = port.device
                    return True
        
        logger.error("❌ 未找到可用的串口")
        return False
    
    def _test_connection(self) -> bool:
        """测试与机械臂的连接"""
        try:
            # 发送测试命令（根据PAROL6协议调整）
            self.ser.write(b"READY\n")
            time.sleep(0.1)
            if self.ser.in_waiting > 0:
                response = self.ser.read(self.ser.in_waiting)
                logger.debug(f"收到响应: {response}")
                return True
            return False
        except Exception as e:
            logger.error(f"测试连接失败: {e}")
            return False
    
    def disconnect(self):
        """断开与机械臂的连接"""
        if self.ser and self.ser.is_open:
            self.ser.close()
            self.is_connected = False
            logger.info("🔌 已断开连接")
````

## File: parol6_ik_fix.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 专用 ikine_LM 测试和修复程序
基于确认可用的 ikine_LM 方法
"""
import sys
import os

# 获取当前文件的绝对路径
current_dir = os.path.dirname(os.path.abspath(__file__))

# 获取父目录路径
parent_dir = os.path.dirname(current_dir)

# 将父目录添加到模块搜索路径中
sys.path.append(parent_dir)

# 现在可以导入父目录中的模块
from robot_api import *
import numpy as np
import time
import os
import shutil
from robot_api import *

# 尝试导入PAROL6模型
try:
    from PAROL6_ROBOT import PAROL6_ROBOT
    import spatialmath as sm
    PAROL_AVAILABLE = True
    print("✅ PAROL6 模型和spatialmath可用")
except ImportError as e:
    PAROL_AVAILABLE = False
    print(f"❌ 导入失败: {e}")

class PAROL6_IK_Fixer:
    def __init__(self):
        """初始化PAROL6 IK修复器"""
        self.robot = None
        self.current_pose = None
        self.current_joints = None
        
        print("🔧 PAROL6 逆运动学修复工具")
        print("基于确认可用的 ikine_LM 方法")

    def test_parol6_ik(self):
        """测试PAROL6机器人的逆运动学"""
        print("\n" + "="*50)
        print("🧪 测试PAROL6机器人逆运动学")
        print("="*50)
        
        if not PAROL_AVAILABLE:
            print("❌ 无法导入PAROL6模型，跳过IK测试")
            return False
        
        try:
            # 初始化PAROL6机器人
            self.robot = PAROL6_ROBOT()
            print("✅ PAROL6机器人模型初始化成功")
            
            # 获取当前机器人状态
            self.current_pose = get_robot_pose()
            self.current_joints = get_robot_joint_angles()
            
            if not self.current_pose or not self.current_joints:
                print("❌ 无法获取机器人当前状态")
                return False
            
            print(f"📍 当前位姿: {[round(p, 2) for p in self.current_pose]}")
            print(f"🔧 当前关节: {[round(a, 2) for a in self.current_joints]}")
            
            # 转换当前关节角度到弧度
            q_current = np.radians(self.current_joints)
            
            # 计算当前位姿的变换矩阵
            T_current = self.robot.fkine(q_current)
            print("✅ 正运动学计算成功")
            
            # 创建测试目标（小偏移）
            T_target = T_current * sm.SE3.Tx(0.02) * sm.SE3.Ty(0.02) * sm.SE3.Tz(0.01)
            print("🎯 测试目标：当前位置 + (20mm, 20mm, 10mm)")
            
            # 测试 ikine_LM
            print("\n🔍 测试 ikine_LM 求解器...")
            start_time = time.time()
            
            sol = self.robot.ikine_LM(T_target, q0=q_current)
            
            solve_time = time.time() - start_time
            
            if sol.success:
                print(f"✅ ikine_LM 求解成功！(耗时: {solve_time:.3f}s)")
                solution_deg = np.degrees(sol.q)
                print(f"🎯 解（度）: {solution_deg.round(2)}")
                
                # 验证解的精度
                T_verify = self.robot.fkine(sol.q)
                pos_error = np.linalg.norm(T_target.t - T_verify.t)
                print(f"📏 位置误差: {pos_error*1000:.3f}mm")
                
                if pos_error < 0.001:  # 1mm精度
                    print("✅ 解验证通过，精度良好")
                    return True
                else:
                    print("⚠️ 解精度较低，但可用")
                    return True
            else:
                print(f"❌ ikine_LM 求解失败: {sol.reason}")
                return False
                
        except Exception as e:
            print(f"❌ 测试过程出错: {e}")
            return False

    def find_files_to_fix(self):
        """查找需要修复的文件"""
        print("\n" + "="*50)
        print("🔍 查找需要修复的文件")
        print("="*50)
        
        files_to_check = [
            "headless_commander.py",
            "PAROL6_ROBOT.py",
            "smooth_motion.py"
        ]
        
        files_needing_fix = []
        
        for filename in files_to_check:
            if os.path.exists(filename):
                try:
                    with open(filename, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    ikine_lms_count = content.count('ikine_LMS')
                    if ikine_lms_count > 0:
                        print(f"📄 {filename}: 发现 {ikine_lms_count} 个 'ikine_LMS'")
                        files_needing_fix.append((filename, ikine_lms_count))
                        
                        # 显示具体位置
                        lines = content.split('\n')
                        for i, line in enumerate(lines, 1):
                            if 'ikine_LMS' in line:
                                print(f"   行 {i}: {line.strip()}")
                    else:
                        print(f"📄 {filename}: 无需修复")
                        
                except Exception as e:
                    print(f"📄 {filename}: 读取失败 - {e}")
            else:
                print(f"📄 {filename}: 文件不存在")
        
        return files_needing_fix

    def backup_and_fix_file(self, filename):
        """备份并修复单个文件"""
        try:
            # 读取原文件
            with open(filename, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            # 检查是否需要修复
            if 'ikine_LMS' not in original_content:
                print(f"📄 {filename}: 无需修复")
                return True
            
            # 创建备份
            backup_filename = f"{filename}.backup_{int(time.time())}"
            shutil.copy2(filename, backup_filename)
            print(f"💾 {filename}: 已备份到 {backup_filename}")
            
            # 执行替换
            fixed_content = original_content.replace('ikine_LMS', 'ikine_LM')
            replacement_count = original_content.count('ikine_LMS')
            
            # 写入修复后的内容
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(fixed_content)
            
            print(f"✅ {filename}: 替换了 {replacement_count} 处 'ikine_LMS' -> 'ikine_LM'")
            return True
            
        except Exception as e:
            print(f"❌ {filename}: 修复失败 - {e}")
            return False

    def fix_all_files(self, files_needing_fix):
        """修复所有需要的文件"""
        print("\n" + "="*50)
        print("🔧 开始修复文件")
        print("="*50)
        
        if not files_needing_fix:
            print("🎉 没有文件需要修复！")
            return True
        
        success_count = 0
        total_replacements = 0
        
        for filename, count in files_needing_fix:
            print(f"\n🔧 修复 {filename}...")
            if self.backup_and_fix_file(filename):
                success_count += 1
                total_replacements += count
            
        print(f"\n📊 修复统计:")
        print(f"   成功修复: {success_count}/{len(files_needing_fix)} 个文件")
        print(f"   总替换数: {total_replacements} 处")
        
        return success_count == len(files_needing_fix)

    def test_api_after_fix(self):
        """修复后测试API"""
        print("\n" + "="*50)
        print("🧪 修复后API测试")
        print("="*50)
        
        print("⚠️ 请先重启 headless_commander.py，然后按Enter继续...")
        input("按Enter继续测试...")
        
        # 测试一个简单的位姿移动
        current_pose = get_robot_pose()
        if current_pose:
            print(f"📍 当前位姿: {[round(p, 2) for p in current_pose]}")
            
            # 创建一个小的移动目标
            target_pose = current_pose.copy()
            target_pose[0] += 10  # X轴移动10mm
            
            print(f"🎯 测试目标: {[round(p, 2) for p in target_pose]}")
            print("🚀 执行测试移动...")
            
            try:
                result = move_robot_pose(
                    target_pose,
                    speed_percentage=10,  # 很慢的速度
                    wait_for_ack=True,
                    timeout=15
                )
                
                if result and result.get('status') == 'COMPLETED':
                    print("✅ 位姿移动测试成功！ikine_LM 修复有效！")
                    return True
                else:
                    print(f"❌ 位姿移动测试失败: {result}")
                    return False
                    
            except Exception as e:
                print(f"❌ 测试过程出错: {e}")
                return False
        else:
            print("❌ 无法获取当前位姿")
            return False

    def run_complete_fix(self):
        """运行完整的修复流程"""
        print("🚀 PAROL6 ikine_LM 完整修复流程")
        print("="*50)
        
        # 步骤1: 测试 ikine_LM 可用性
        print("步骤1: 验证 ikine_LM 可用性")
        if not self.test_parol6_ik():
            print("❌ ikine_LM 不可用，无法继续修复")
            return
        
        print("✅ ikine_LM 验证通过，可以用于修复")
        
        # 步骤2: 查找需要修复的文件
        print("\n步骤2: 查找需要修复的文件")
        files_needing_fix = self.find_files_to_fix()
        
        if not files_needing_fix:
            print("🎉 所有文件都已经是正确的！")
            return
        
        # 步骤3: 用户确认
        print(f"\n步骤3: 确认修复")
        print(f"将要修复 {len(files_needing_fix)} 个文件:")
        for filename, count in files_needing_fix:
            print(f"   • {filename}: {count} 处替换")
        
        if input("\n确认开始修复? (y/N): ").lower() != 'y':
            print("❌ 用户取消修复")
            return
        
        # 步骤4: 执行修复
        print("\n步骤4: 执行文件修复")
        if not self.fix_all_files(files_needing_fix):
            print("❌ 修复过程出现问题")
            return
        
        print("✅ 文件修复完成！")
        
        # 步骤5: 指导测试
        print("\n步骤5: 验证修复效果")
        print("📋 接下来请:")
        print("1. 停止当前的 headless_commander.py (Ctrl+C)")
        print("2. 重新启动 headless_commander.py")
        print("3. 按Enter继续API测试")
        
        if input("\n已重启服务器？按y继续测试 (y/N): ").lower() == 'y':
            if self.test_api_after_fix():
                print("\n🎉 修复成功！所有API应该都能正常工作了！")
            else:
                print("\n⚠️ API测试未通过，可能需要进一步检查")
        
        print("\n" + "="*60)
        print("📋 修复完成总结")
        print("="*60)
        print("✅ ikine_LMS -> ikine_LM 替换完成")
        print("✅ 原文件已备份")
        print("🎯 现在可以使用以下API:")
        print("   • move_robot_pose")
        print("   • move_robot_cartesian") 
        print("   • jog_cartesian")
        print("   • smooth_circle")
        print("   • smooth_arc_*")
        print("   • smooth_spline")
        print("   • smooth_helix")
        print("="*60)

def main():
    """主程序"""
    print("🔧 PAROL6 ikine_LM 自动修复工具")
    print("基于您测试通过的 ikine_LM 方法")
    
    fixer = PAROL6_IK_Fixer()
    
    print("\n选择操作:")
    print("1. 完整修复流程（推荐）")
    print("2. 仅测试 ikine_LM")
    print("3. 仅查找需要修复的文件")
    print("4. 退出")
    
    choice = input("\n请选择 (1-4): ").strip()
    
    if choice == '1':
        fixer.run_complete_fix()
    elif choice == '2':
        fixer.test_parol6_ik()
    elif choice == '3':
        fixer.find_files_to_fix()
    elif choice == '4':
        print("👋 退出程序")
    else:
        print("❌ 无效选择")

if __name__ == "__main__":
    main()
````

## File: PAROL6_ROBOT.py.backup_1757427986
````
# This file acts as configuration file for robot you are using
# It works in conjustion with configuration file from robotics toolbox

from swift import Swift
import spatialmath.base.symbolic as sym
from roboticstoolbox import ETS as ET
from roboticstoolbox import *
import roboticstoolbox as rtb
from spatialmath import *
from spatialgeometry import *
from math import pi
import numpy as np
import time
import random

Joint_num = 6 # Number of joints
Microstep = 32
steps_per_revolution=200
degree_per_step_constant = 360/(32*200) 
radian_per_step_constant = (2*pi) / (32*200)
radian_per_sec_2_deg_per_sec_const = 360/ (2*np.pi)
deg_per_sec_2_radian_per_sec_const = (2*np.pi) / 360

# robot length values (metres)
a1 = 110.50 / 1000
a2 = 23.42 / 1000
a3 = 180 / 1000
a4 = 43.5 / 1000
a5 = 176.35 / 1000
a6 = 62.8 / 1000
a7 = 45.25 / 1000

alpha_DH = [-pi / 2,pi,pi/2,-pi/2,pi/2,pi]

robot = DHRobot(
    [
        RevoluteDH(d=a1, a=a2, alpha=alpha_DH[0]),
        RevoluteDH(a=a3,d = 0,alpha=alpha_DH[1]),
        RevoluteDH(alpha= alpha_DH[2], a= -a4),
        RevoluteDH(d=-a5, a=0, alpha=alpha_DH[3]),
        RevoluteDH(a=0,d=0,alpha=alpha_DH[4]),
        RevoluteDH(alpha=alpha_DH[5], a = -a7,d = -a6),
    ],
    name="PAROL6",
)
#print(robot.isspherical())
#pyplot = rtb.backends.PyPlot()

# in degrees
Joints_standby_position_degree = np.array([0,-90,180,0,0,180]) 
# in radians
Joints_standby_position_radian = [np.deg2rad(angle) for angle in Joints_standby_position_degree]

# values you get after homing robot and moving it to its most left and right sides
# In degrees
Joint_limits_degree =[[-123.046875,123.046875], [-145.0088,-3.375], [107.866,287.8675], [-105.46975,105.46975], [-90,90], [0,360]] 

# in radians
Joint_limits_radian = []
for limits in Joint_limits_degree:
    radian_limits = [np.deg2rad(angle) for angle in limits]
    Joint_limits_radian.append(radian_limits)

# Reduction ratio we have on our joints
Joint_reduction_ratio = [6.4, 20, 20*(38/42) , 4, 4, 10] 

# min and max jog speeds. Usually slower from real maximal speeds
Joint_max_jog_speed = [1500, 3000, 3600, 7000, 7000, 18000]
Joint_min_jog_speed = [100,100,100,100,100,100]

# LINEAR CARTESIAN JOG MAX MIN SPEED IN METERS PER SECOND
Cartesian_linear_velocity_min_JOG = 0.002
Cartesian_linear_velocity_max_JOG = 0.06

# LINEAR CARTESIAN MAX MIN SPEED IN METERS PER SECOND
Cartesian_linear_velocity_min = 0.002
Cartesian_linear_velocity_max = 0.06

# LINEAR CARTESIAN MAX MIN ACC IN METERS PER SECOND²
Cartesian_linear_acc_min = 0.002
Cartesian_linear_acc_max = 0.06

# ANGULAR CARTESIAN JOG MAX MIN SPEED IN DEGREES PER SECOND
Cartesian_angular_velocity_min = 0.7
Cartesian_angular_velocity_max = 25

Joint_max_speed = [6500,18000,20000,20000,22000,22000] # max speed in STEP/S used
Joint_min_speed = [100,100,100,100,100,100] # min speed in STEP/S used 

Joint_max_acc = 32000 # max acceleration in RAD/S²
Joint_min_acc = 100 # min acceleration in RAD/S²

Cart_lin_velocity_limits = [[-100,100],[-100,100],[-100,100]]
Cart_ang_velocity_limits = [[-100,100],[-100,100],[-100,100]]


Commands_list = [ "Input","Output","Dummy","Begin","Home","Delay","End","Loop","MoveJoint","MovePose","SpeedJoint","MoveCart",
                 "MoveCart","MoveCartRelTRF","Gripper","Gripper_cal"]

Commands_list_true = [item + "()" for item in Commands_list]

# 360 / (200 * 32) = 0.05625
def DEG2STEPS(Degrees, index):
    Steps = Degrees / degree_per_step_constant * Joint_reduction_ratio[index]
    return Steps

Joint_limits_steps =[[DEG2STEPS(Joint_limits_degree[0][0],0),DEG2STEPS(Joint_limits_degree[0][1],0)],
                      [DEG2STEPS(Joint_limits_degree[1][0],1),DEG2STEPS(Joint_limits_degree[1][1],1)],
                      [DEG2STEPS(Joint_limits_degree[2][0],2),DEG2STEPS(Joint_limits_degree[2][1],2)],
                      [DEG2STEPS(Joint_limits_degree[3][0],3),DEG2STEPS(Joint_limits_degree[3][1],3)],
                      [DEG2STEPS(Joint_limits_degree[4][0],4),DEG2STEPS(Joint_limits_degree[4][1],4)],
                      [DEG2STEPS(Joint_limits_degree[5][0],5),DEG2STEPS(Joint_limits_degree[5][1],5)]]
Joint_limits_steps = [[int(i[0]),int(i[1])] for i in Joint_limits_steps]


def STEPS2DEG(Steps,index):
    Degrees = Steps * degree_per_step_constant / Joint_reduction_ratio[index]
    return Degrees

def RAD2STEPS(Rads,index):
    deg = np.rad2deg(Rads)
    steps = DEG2STEPS(deg,index)
    return steps

def STEPS2RADS(Steps,index):
    deg = STEPS2DEG(Steps,index)
    rads = np.deg2rad(deg)
    return rads

def RAD2DEG(radian):
    return np.rad2deg(radian)

def DEG2RAD(degree):
    return np.deg2rad(degree)

def SPEED_STEPS2DEG(Steps_per_second,index):

    '''     Transform true RADS/S to true RPM.
    Both these values are true values at witch MOTORS SPIN  '''

    degrees_per_step = degree_per_step_constant / Joint_reduction_ratio[index]
    degrees_per_second = Steps_per_second * degrees_per_step
    return degrees_per_second

def SPEED_DEG2STEPS(Deg_per_second,index):
    steps_per_second = Deg_per_second / degree_per_step_constant * Joint_reduction_ratio[index]
    return steps_per_second

def SPEED_STEP2RAD(Steps_per_second,index):
    degrees_per_step = radian_per_step_constant / Joint_reduction_ratio[index]
    rad_per_second = Steps_per_second * degrees_per_step
    return rad_per_second

def SPEED_RAD2STEP(Rad_per_second,index):
    steps_per_second = Rad_per_second / radian_per_step_constant * Joint_reduction_ratio[index]
    return steps_per_second

def RAD_SEC_2_DEG_SEC(rad_per_sec):
    return rad_per_sec * radian_per_sec_2_deg_per_sec_const

def DEG_SEC_2_RAD_SEC(deg_per_sec):
    return deg_per_sec * deg_per_sec_2_radian_per_sec_const


def check_joint_limits(q, target_q=None, allow_recovery=True):
    """
    Check if joint angles are within their limits, with support for recovery movements.
    
    Parameters
    ----------
    q : array_like
        Current joint angles in radians
    target_q : array_like, optional
        Target joint angles in radians. If provided, recovery logic is applied.
    allow_recovery : bool, optional
        Whether to allow recovery movements when current position violates limits
        
    Returns
    -------
    bool
        True if movement is allowed (within limits or valid recovery), False otherwise
    dict
        Dictionary with joint limit violation details and recovery information
    """
    q_array = np.array(q)
    target_array = np.array(target_q) if target_q is not None else None
    violations = {}
    all_valid = True
    
    for i in range(min(len(q_array), len(Joint_limits_radian))):
        min_limit = Joint_limits_radian[i][0]
        max_limit = Joint_limits_radian[i][1]
        current_pos = q_array[i]
        
        # Check if current position violates limits
        current_violates = current_pos < min_limit or current_pos > max_limit
        
        if current_violates:
            violation_type = 'below_min' if current_pos < min_limit else 'above_max'
            
            # If we have a target and recovery is enabled, check if it's a recovery movement
            if target_array is not None and allow_recovery:
                target_pos = target_array[i]
                is_recovery = False
                
                if current_pos > max_limit:  # Past upper limit
                    # Recovery means moving towards or below the upper limit
                    is_recovery = target_pos <= current_pos
                    recovery_direction = "move joint towards negative direction"
                elif current_pos < min_limit:  # Past lower limit
                    # Recovery means moving towards or above the lower limit  
                    is_recovery = target_pos >= current_pos
                    recovery_direction = "move joint towards positive direction"
                
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': target_pos if target_array is not None else None,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': violation_type,
                    'is_recovery': is_recovery,
                    'recovery_direction': recovery_direction if not is_recovery else None,
                    'movement_allowed': is_recovery
                }
                
                # Only flag as invalid if it's not a recovery movement
                if not is_recovery:
                    all_valid = False
            else:
                # No target provided or recovery disabled - flag as violation
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': None,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': violation_type,
                    'is_recovery': False,
                    'recovery_direction': None,
                    'movement_allowed': False
                }
                all_valid = False
        elif target_array is not None:
            # Current is within limits, check if target would violate
            target_pos = target_array[i]
            target_violates = target_pos < min_limit or target_pos > max_limit
            
            if target_violates:
                target_violation_type = 'below_min' if target_pos < min_limit else 'above_max'
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': target_pos,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': f'target_{target_violation_type}',
                    'is_recovery': False,
                    'recovery_direction': None,
                    'movement_allowed': False
                }
                all_valid = False
    
    return all_valid, violations

def extract_from_can_id(can_id):
    # Extracting ID2 (first 4 MSB)
    id2 = (can_id >> 7) & 0xF

    # Extracting CAN Command (next 6 bits)
    can_command = (can_id >> 1) & 0x3F

    # Extracting Error Bit (last bit)
    error_bit = can_id & 0x1
    
    return id2, can_command, error_bit


def combine_2_can_id(id2, can_command, error_bit):
    # Combine components into an 11-bit CAN ID
    can_id = 0

    # Add ID2 (first 4 MSB)
    can_id |= (id2 & 0xF) << 7

    # Add CAN Command (next 6 bits)
    can_id |= (can_command & 0x3F) << 1

    # Add Error Bit (last bit)
    can_id |= (error_bit & 0x1)

    return can_id

# Fuse bitfield list to byte
def fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Splits byte to bitfield list
def split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]


if __name__ == "__main__":
    """
    print(DEG2STEPS(180,2))
    print(STEPS2DEG(57905,2))
    print(RAD2STEPS(pi,5))
    print(STEPS2RADS(32000,5))
    print(SPEED_STEPS2DEG(1000,5))
    print(SPEED_STEP2RAD(1000,5))
    print(Joint_limits_radian)
    print(Joints_standby_position_radian)
    print(Joint_limits_steps)
    print(Joint_limits_radian)
    print(DEG2STEPS(-62.5,1))
    """

    J0_var = STEPS2RADS(1,0)
    J1_var = STEPS2RADS(1,1)
    J2_var = STEPS2RADS(1,2)
    J3_var = STEPS2RADS(1,3)
    J4_var = STEPS2RADS(1,4)
    J5_var = STEPS2RADS(1,5)


    print("Joint 1 smallest step:",RAD2DEG(J0_var))
    print("Joint 2 smallest step:",RAD2DEG(J1_var))
    print("Joint 3 smallest step:",RAD2DEG(J2_var))
    print("Joint 4 smallest step:",RAD2DEG(J3_var))
    print("Joint 5 smallest step:",RAD2DEG(J4_var))
    print("Joint 6 smallest step:",RAD2DEG(J5_var))
    print("rad 2 step:",SPEED_RAD2STEP(-2.948504399390715 / 2,5))
    print("standby radian is",Joints_standby_position_radian)

    test = RAD2STEPS(0.0001,5)
    print(test)

    #robot.ikine_LMS()
````

## File: python quick_fix.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
快速修复脚本：ikine_LMS -> ikine_LM
基于测试通过的方法
"""

import os
import shutil
import time

def quick_fix():
    """快速修复所有文件"""
    print("🚀 PAROL6 快速修复：ikine_LMS -> ikine_LM")
    print("="*50)
    
    files = ["headless_commander.py", "PAROL6_ROBOT.py", "smooth_motion.py"]
    
    total_fixes = 0
    
    for filename in files:
        if not os.path.exists(filename):
            print(f"⚠️ {filename}: 文件不存在")
            continue
            
        try:
            # 读取文件
            with open(filename, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # 检查是否需要修复
            count = content.count('ikine_LMS')
            if count == 0:
                print(f"📄 {filename}: 无需修复")
                continue
            
            # 备份
            backup = f"{filename}.backup_{int(time.time())}"
            shutil.copy2(filename, backup)
            
            # 修复
            fixed_content = content.replace('ikine_LMS', 'ikine_LM')
            
            # 写入
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(fixed_content)
            
            print(f"✅ {filename}: 修复 {count} 处，备份到 {backup}")
            total_fixes += count
            
        except Exception as e:
            print(f"❌ {filename}: 修复失败 - {e}")
    
    print("="*50)
    print(f"🎉 修复完成！总共修复 {total_fixes} 处")
    print("\n📋 下一步:")
    print("1. 重启 headless_commander.py")
    print("2. 运行API测试验证修复效果")

if __name__ == "__main__":
    if input("确认执行快速修复? (y/N): ").lower() == 'y':
        quick_fix()
    else:
        print("❌ 取消修复")
````

## File: README_FIXED.md
````markdown
# PAROL6 Python API - Linux修复版

## 📋 项目说明
这是PAROL6机械臂的Python API，已修复Linux环境下的串口连接问题。

## ✅ 已修复的问题

### 1. **串口连接问题**
- 修复了Linux环境下串口初始化失败的问题
- 添加了自动串口检测功能
- 实现了串口权限检查

### 2. **模块导入问题**
- 修复了GUI模块导入路径问题
- 正确设置了PYTHONPATH

### 3. **依赖管理**
- 使用conda虚拟环境管理依赖
- 确保所有必要的包都已安装

## 🚀 快速开始

### 1. 激活环境
```bash
source ~/anaconda3/bin/activate
conda activate parol
```

### 2. 测试串口连接
```bash
cd ~/PAROL-commander-software/PAROL6-python-API
python test_serial.py
```

### 3. 运行主程序
```bash
python run_parol6_fixed.py
```

## 📁 文件说明

- `run_parol6_fixed.py` - 主启动脚本（修复版）
- `test_serial.py` - 串口连接测试工具
- `parol6_controller.py` - PAROL6控制器类（准备ROS2集成）
- `headless_commander.py` - 原始控制程序
- `robot_api.py` - 机器人API
- `PAROL6_ROBOT.py` - 机器人模型定义
- `smooth_motion.py` - 平滑运动控制

## 🔧 故障排除

### 串口权限问题
如果遇到权限错误，运行：
```bash
sudo usermod -a -G dialout $USER
# 然后重新登录
```

### 临时解决方案
```bash
sudo -E python run_parol6_fixed.py
```

### 端口冲突
如果遇到 "Address already in use" 错误：
```bash
# 查找占用端口的进程
lsof -i :5001
# 结束进程
kill -9 <PID>
```

## 📡 串口配置

- 默认波特率: 3000000
- 默认端口: /dev/ttyACM0 或 /dev/ttyUSB0
- 端口配置文件: com_port.txt

## 🤖 ROS2集成（下一步）

准备工作已完成，下一步将集成到ROS2和MoveIt：
1. 创建ROS2包
2. 实现MoveIt控制器接口
3. 配置URDF模型
4. 设置MoveIt配置

## 📝 更新日志

### 2024-09-01
- 修复Linux串口连接问题
- 添加串口自动检测
- 创建测试工具
- 准备ROS2集成接口

## 👥 维护者
- wzy

## 📄 许可证
MIT License
````

## File: README.md
````markdown
# PAROL6 Headless Commander Documentation

## 1. Important Notes & Disclaimers
* **Software Origin**: This control system is based on the `experimental_kinematics` branch of the `PAROL_commander_software` repository. The core communication functions were derived from the `Serial_sender_good_latest.py` file; however, the approach to motion planning has been altered from the original implementation. This system was created by editing the `Commander_minimal_version.py` file, which was used as a base.
* **Automatic Homing on Startup**: By default, the `headless_commander.py` script will immediately command the robot to home itself upon startup. This is done for convenience but can be disabled. To prevent automatic homing, comment out or delete the corresponding line in `headless_commander.py`.
* **AI-Assisted Development**: This code was developed with significant AI assistance. While the core logic has been corrected and improved, it has not been exhaustively tested in all scenarios. Users should proceed with caution and verify functionality for their specific needs.

## 2. Safety Precautions & Disclaimer
This control software includes several built-in safety features designed to prevent damage to the robot and ensure predictable operation:
* **E-Stop Monitoring**: The system constantly checks the physical E-Stop button. If triggered, all motion is immediately halted, the command queue is cleared, and the robot is disabled. The system must be manually re-enabled by pressing the `'e'` key after the E-Stop is released.
* **Synchronized Speed Calculation**: For moves defined by a speed percentage (`MoveJoint`, `MovePose`), the system now calculates the maximum possible synchronized speed for all joints involved. This prevents individual joints from exceeding their limits and ensures predictable, smooth motion.
* **Inverse Kinematics (IK) Validation**: The system verifies that a valid kinematic solution exists for any pose-based command. If the target pose is unreachable, the command will fail safely before any motion occurs.

> **WARNING**: These are software-based safety measures and are not a substitute for responsible operation and a safe work environment. The user assumes all responsibility for safe operation. Always be attentive when the robot is active, ensure you have immediate access to the physical E-Stop, and operate the robot in a clear area.

## 3. Installation

### Base Software Installation
Follow the official PAROL commander software installation guide:
- Repository: [PAROL Commander Software](https://github.com/PCrnjak/PAROL-commander-software)
- Branch: Use the `experimental_kinematics` branch
- Installation Guide: [Official Instructions](https://github.com/PCrnjak/PAROL-commander-software)

### Additional Dependencies for Headless Commander
After installing the base software, install these additional packages:

```bash
# Install Python 3 and pip (if not already installed)
# https://www.python.org/downloads/

# Install Git (if not already installed)
# https://git-scm.com/book/en/v2/Getting-Started-Installing-Git

# Core dependencies (from official installation)
pip3 install roboticstoolbox-python==1.0.3
pip3 install numpy==1.23.4
pip3 install scipy==1.11.4
pip3 install spatialmath
pip3 install pyserial
pip3 install oclock
pip3 install keyboard
```
## 4. System Architecture

### Client-Server Design
The system uses a UDP-based client-server architecture that separates robot control from command generation:

* **The Robot Controller (`headless_commander.py`)**: 
  - Runs on the computer physically connected to the robot via USB/Serial
  - Maintains a high-frequency control loop (100Hz) for real-time robot control
  - Handles all complex calculations (inverse kinematics, trajectory planning)
  - Requires heavy dependencies (roboticstoolbox, numpy, scipy)
  - Listens for UDP commands on port 5001

* **The Remote Client (`robot_api.py`)**: 
  - Can run on any computer (same or different from controller)
  - Sends simple text commands via UDP
  - Requires minimal dependencies (mostly Python standard library)
  - Extremely lightweight - can run on resource-constrained devices
  - Optionally receives acknowledgments on port 5002

* **Support Modules**:
  - `smooth_motion.py`: Advanced trajectory generation algorithms
  - `PAROL6_ROBOT.py`: Robot-specific parameters and kinematic model

### Why UDP?
The UDP protocol was chosen for several reasons:
- **Simplicity**: No connection management overhead
- **Low Latency**: Direct message passing without handshaking
- **Lightweight Client**: Client only needs to send text strings
- **Cross-Platform**: Works on any OS with network support
- **Flexible Deployment**: Client can run anywhere on the network

### Command Flow
1. Client calls API function (e.g., `move_robot_joints()`)
2. API formats command as text string (e.g., `"MOVEJOINT|90|-45|90|0|45|180|5.5|None"`)
3. Command sent via UDP to controller
4. Controller queues and executes command
5. Optional: Acknowledgment sent back to client
6. Optional: Client checks status using command ID

### Command Acknowledgment System
The system includes an optional acknowledgment tracking feature that provides feedback on command execution:
* **Tracking States**: Commands can report status as `QUEUED`, `EXECUTING`, `COMPLETED`, `FAILED`, `CANCELLED`, or `INVALID`
* **Zero Overhead**: When not used, the tracking system has zero resource overhead - no threads or sockets are created
* **Non-Blocking Mode**: Commands can be sent with `non_blocking=True` to return immediately with a command ID, allowing asynchronous operation
* **Status Checking**: Use `check_command_status(command_id)` to poll command status later

Example of non-blocking usage:
```python
# Send command and get ID immediately
cmd_id = move_robot_joints([90, -45, 90, 0, 45, 180], 
                          duration=5, 
                          wait_for_ack=True, 
                          non_blocking=True)

# Do other work...
time.sleep(1)

# Check status later
status = check_command_status(cmd_id)
if status and status['completed']:
    print(f"Command finished with status: {status['status']}")
```

## 5. Command Reference & API Usage

### Motion Commands

#### `home_robot()`
* **Purpose**: Initiates the robot's built-in homing sequence.
* **Parameters**: 
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 30.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import home_robot
    home_robot()  # Simple usage
    home_robot(wait_for_ack=True, timeout=30)  # With tracking
    ```

#### `move_robot_joints()`
* **Purpose**: Moves joints to a target configuration (in degrees).
* **Parameters**:
    * `joint_angles` (List[float]): List of 6 target angles in degrees for joints 1-6
    * `duration` (float, optional): Total time for the movement in seconds
    * `speed_percentage` (int, optional): Speed as percentage (0-100)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import move_robot_joints

    # Simple move by speed
    move_robot_joints([90, -45, 90, 0, 45, 180], speed_percentage=75)

    # Move with acknowledgment tracking
    result = move_robot_joints([0, -90, 180, 0, 0, 180], 
                               duration=5.5, 
                               wait_for_ack=True)
    if result['status'] == 'COMPLETED':
        print("Move completed successfully")
    ```

#### `move_robot_pose()`
* **Purpose**: Moves the end-effector to a Cartesian pose via a joint-based path.
* **Parameters**:
    * `pose` (List[float]): Target pose [x, y, z, Rx, Ry, Rz] in mm and degrees
    * `duration` (float, optional): Total time for the movement in seconds
    * `speed_percentage` (int, optional): Speed as percentage (0-100)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import move_robot_pose
    move_robot_pose([250, 0, 200, 180, 0, 90], speed_percentage=50)
    ```

#### `move_robot_cartesian()`
* **Purpose**: Moves the end-effector to a target pose in a guaranteed straight-line path.
* **Parameters**:
    * `pose` (List[float]): Target pose [x, y, z, Rx, Ry, Rz] in mm and degrees
    * `duration` (float, optional): Time for the movement in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import move_robot_cartesian
    move_robot_cartesian([200, -50, 180, 180, 0, 135], duration=4.0)
    ```

### Jogging Commands

#### `jog_robot_joint()`
* **Purpose**: Jogs a single joint by time or angular distance.
* **Parameters**:
    * `joint_index` (int): Joint to move (0-5 for positive direction, 6-11 for negative)
    * `speed_percentage` (int): Jog speed as percentage (0-100)
    * `duration` (float, optional): Time to jog in seconds
    * `distance_deg` (float, optional): Distance to jog in degrees
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `distance_deg`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import jog_robot_joint
    # Jog joint 1 for 2 seconds
    jog_robot_joint(joint_index=0, speed_percentage=40, duration=2.0)
    # Jog joint 3 backwards by 15 degrees
    jog_robot_joint(joint_index=8, speed_percentage=60, distance_deg=15)
    ```

#### `jog_multiple_joints()`
* **Purpose**: Jogs multiple joints simultaneously.
* **Parameters**:
    * `joints` (List[int]): List of joint indices (0-5 positive, 6-11 negative)
    * `speeds` (List[float]): List of corresponding speeds (1-100%)
    * `duration` (float): Duration in seconds
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import jog_multiple_joints
    # Jog joints 1, 4, and 6 simultaneously
    jog_multiple_joints([0, 3, 5], [70, 40, 60], 1.2)
    ```

#### `jog_cartesian()`
* **Purpose**: Jogs the end-effector continuously along an axis.
* **Parameters**:
    * `frame` (str): Reference frame ('TRF' for Tool, 'WRF' for World)
    * `axis` (str): Axis and direction ('X+', 'X-', 'Y+', 'Y-', 'Z+', 'Z-', 'RX+', 'RX-', 'RY+', 'RY-', 'RZ+', 'RZ-')
    * `speed_percentage` (int): Jog speed as percentage (0-100)
    * `duration` (float): Time to jog in seconds
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import jog_cartesian
    jog_cartesian(frame='TRF', axis='Z+', speed_percentage=50, duration=1.5)
    ```

### Smooth Motion Commands

These commands create smooth, curved trajectories with continuous velocity profiles. All commands support reference frame selection via the `frame` parameter:

- **WRF (World Reference Frame)**: Default. All coordinates are interpreted relative to the robot's base coordinate system.
- **TRF (Tool Reference Frame)**: All coordinates are interpreted relative to the tool's current position and orientation. This means:
  - Positions are relative to the tool's origin
  - Planes (XY, XZ, YZ) are the tool's local planes, not world planes
  - If the tool is rotated, the entire motion rotates with it

#### `smooth_circle()`
* **Purpose**: Execute a smooth circular motion.
* **Parameters**:
    * `center` (List[float]): Center point [x, y, z] in mm
    * `radius` (float): Circle radius in mm
    * `plane` (str, optional): Plane of circle ('XY', 'XZ', or 'YZ'). Default: 'XY'
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF'). Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose [x, y, z, rx, ry, rz], or None for current position. Default: None
    * `duration` (float, optional): Time to complete circle in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `clockwise` (bool, optional): Direction of motion. Default: False
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 10.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import smooth_circle
    
    # Draw a 50mm radius circle in world XY plane
    smooth_circle(center=[200, 0, 200], radius=50, plane='XY', duration=5.0)
    
    # Draw a circle in tool's XY plane (follows tool orientation)
    smooth_circle(center=[0, 30, 0], radius=25, plane='XY', frame='TRF', duration=4.0)
    ```

#### `smooth_arc_center()`
* **Purpose**: Execute a smooth arc motion defined by center point.
* **Parameters**:
    * `end_pose` (List[float]): End pose [x, y, z, rx, ry, rz] in mm and degrees
    * `center` (List[float]): Arc center point [x, y, z] in mm
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF'). Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose, or None for current position. Default: None
    * `duration` (float, optional): Time to complete arc in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `clockwise` (bool, optional): Direction of motion. Default: False
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 10.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import smooth_arc_center
    
    # Arc in world coordinates
    smooth_arc_center(end_pose=[250, 50, 200, 0, 0, 90], 
                     center=[200, 0, 200], 
                     duration=3.0)
    
    # Arc in tool coordinates (relative to tool position/orientation)
    smooth_arc_center(end_pose=[30, 30, 0, 0, 0, 45],
                     center=[15, 15, 0],
                     frame='TRF',
                     duration=3.0)
    ```

#### `smooth_arc_parametric()`
* **Purpose**: Execute a smooth arc motion defined by radius and angle.
* **Parameters**:
    * `end_pose` (List[float]): End pose [x, y, z, rx, ry, rz] in mm and degrees
    * `radius` (float): Arc radius in mm
    * `arc_angle` (float): Arc angle in degrees
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF'). Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose, or None for current position. Default: None
    * `duration` (float, optional): Time to complete arc in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `clockwise` (bool, optional): Direction of motion. Default: False
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 10.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import smooth_arc_parametric
    
    # Parametric arc in world frame
    smooth_arc_parametric(end_pose=[250, 50, 200, 0, 0, 90],
                         radius=50, arc_angle=90, duration=3.0)
    
    # Parametric arc in tool frame
    smooth_arc_parametric(end_pose=[40, 0, 0, 0, 0, 60],
                         radius=25, arc_angle=60,
                         frame='TRF',
                         speed_percentage=40)
    ```

#### `smooth_spline()`
* **Purpose**: Create smooth spline through waypoints.
* **Parameters**:
    * `waypoints` (List[List[float]]): List of poses [x, y, z, rx, ry, rz] to pass through
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF'). Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose, or None for current position. Default: None
    * `duration` (float, optional): Total time for motion in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 10.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* **Python API Usage**:
    ```python
    from robot_api import smooth_spline
    
    # Spline through world coordinates
    waypoints = [
        [200, 0, 100, 0, 0, 0],
        [250, 50, 150, 0, 15, 45],
        [200, 100, 200, 0, 30, 90]
    ]
    smooth_spline(waypoints, duration=8.0)
    
    # Spline through tool-relative coordinates
    tool_waypoints = [
        [20, 0, 0, 0, 0, 0],
        [20, 20, 10, 0, 0, 30],
        [0, 20, 20, 0, 0, 60]
    ]
    smooth_spline(tool_waypoints, frame='TRF', duration=6.0)
    ```

#### `smooth_helix()`
* **Purpose**: Execute helical motion.
* **Parameters**:
    * `center` (List[float]): Helix center point [x, y, z] in mm
    * `radius` (float): Helix radius in mm
    * `pitch` (float): Vertical distance per revolution in mm
    * `height` (float): Total height of helix in mm
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF'). Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose, or None for current position. Default: None
    * `duration` (float, optional): Time to complete helix in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `clockwise` (bool, optional): Direction of motion. Default: False
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 10.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* > *Note: You must provide either `duration` or `speed_percentage`, but not both.*
* > *Note: In TRF mode, the helix rises along the tool's Z-axis, not the world Z-axis.*
* **Python API Usage**:
    ```python
    from robot_api import smooth_helix
    
    # Vertical helix in world frame
    smooth_helix(center=[200, 0, 150], radius=30, pitch=20, 
                height=100, duration=10.0)
    
    # Helix along tool's Z-axis (follows tool orientation)
    smooth_helix(center=[0, 30, 0], radius=20, pitch=15,
                height=60, frame='TRF', duration=8.0)
    ```

#### `smooth_blend()`
* **Purpose**: Blend multiple motion segments smoothly.
* **Parameters**:
    * `segments` (List[Dict]): List of segment dictionaries defining the motion path
    * `blend_time` (float, optional): Time for blending between segments in seconds. Default: 0.5
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF') for all segments. Default: 'WRF'
    * `start_pose` (List[float], optional): Starting pose, or None for current position. Default: None
    * `duration` (float, optional): Total time for entire motion in seconds
    * `speed_percentage` (float, optional): Speed as percentage (1-100)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 15.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import smooth_blend
    
    # Blend in world coordinates
    segments = [
        {'type': 'LINE', 'end': [250, 0, 200, 0, 0, 0], 'duration': 2.0},
        {'type': 'CIRCLE', 'center': [250, 0, 200], 'radius': 50, 
         'plane': 'XY', 'duration': 4.0, 'clockwise': False},
        {'type': 'LINE', 'end': [200, 0, 200, 0, 0, 0], 'duration': 2.0}
    ]
    smooth_blend(segments, blend_time=0.5, duration=10.0)
    
    # Blend in tool coordinates (all segments relative to tool)
    tool_segments = [
        {'type': 'LINE', 'end': [30, 0, 0, 0, 0, 0], 'duration': 2.0},
        {'type': 'CIRCLE', 'center': [30, 20, 0], 'radius': 20, 
         'plane': 'XY', 'duration': 4.0, 'clockwise': False},
        {'type': 'LINE', 'end': [0, 20, 0, 0, 0, 0], 'duration': 2.0}
    ]
    smooth_blend(tool_segments, frame='TRF', blend_time=0.5, duration=10.0)
    ```
### Gripper Commands

#### `control_pneumatic_gripper()`
* **Purpose**: Controls the pneumatic gripper.
* **Parameters**:
    * `action` (str): Action to perform ('open' or 'close')
    * `port` (int): Digital output port (1 or 2)
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import control_pneumatic_gripper
    control_pneumatic_gripper(action='open', port=1)
    ```

#### `control_electric_gripper()`
* **Purpose**: Controls the electric gripper.
* **Parameters**:
    * `action` (str): Action to perform ('move' or 'calibrate')
    * `position` (int, optional): Target position (0-255). Default: 255
    * `speed` (int, optional): Movement speed (0-255). Default: 150
    * `current` (int, optional): Max motor current in mA (100-1000). Default: 500
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import control_electric_gripper
    control_electric_gripper(action='calibrate')
    control_electric_gripper(action='move', position=200, speed=150)
    ```

### Utility Commands

#### `delay_robot()`
* **Purpose**: Pauses command queue execution.
* **Parameters**:
    * `duration` (float): Pause time in seconds
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import delay_robot
    delay_robot(2.5)
    ```

#### `stop_robot_movement()`
* **Purpose**: Immediately stops all motion and clears command queue.
* **Parameters**:
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: False
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 2.0
    * `non_blocking` (bool, optional): Return immediately with command ID. Default: False
* **Python API Usage**:
    ```python
    from robot_api import stop_robot_movement
    stop_robot_movement()
    ```

### Query Commands

These commands request current robot state without moving the robot:

#### `get_robot_pose()`
* **Purpose**: Get current end-effector pose.
* **Parameters**: None
* **Returns**: List [x, y, z, Rx, Ry, Rz] in mm and degrees, or None if failed
* **Python API Usage**:
    ```python
    from robot_api import get_robot_pose
    pose = get_robot_pose()
    if pose:
        print(f"Current pose: {pose}")
    ```

#### `get_robot_joint_angles()`
* **Purpose**: Get current joint angles.
* **Parameters**: None
* **Returns**: List of 6 angles in degrees, or None if failed
* **Python API Usage**:
    ```python
    from robot_api import get_robot_joint_angles
    angles = get_robot_joint_angles()
    ```

#### `get_robot_joint_speeds()`
* **Purpose**: Get current joint speeds.
* **Parameters**: None
* **Returns**: List of 6 speeds in steps/sec, or None if failed

#### `get_robot_io()`
* **Purpose**: Get digital I/O status.
* **Parameters**:
    * `verbose` (bool, optional): Print formatted status to console. Default: False
* **Returns**: List [IN1, IN2, OUT1, OUT2, ESTOP] (0 or 1 values), or None if failed

#### `get_electric_gripper_status()`
* **Purpose**: Get electric gripper status.
* **Parameters**:
    * `verbose` (bool, optional): Print formatted status to console. Default: False
* **Returns**: List [ID, Position, Speed, Current, StatusByte, ObjectDetected], or None if failed

#### `get_robot_pose_matrix()`
* **Purpose**: Get robot pose as transformation matrix.
* **Parameters**: None
* **Returns**: 4x4 numpy array, or None if failed

#### `is_robot_stopped()`
* **Purpose**: Check if robot has stopped moving.
* **Parameters**:
    * `threshold_speed` (float, optional): Speed threshold in steps/sec. Default: 2.0
* **Returns**: Boolean (True if stopped, False otherwise)

#### `is_estop_pressed()`
* **Purpose**: Check if E-stop is currently pressed.
* **Parameters**: None
* **Returns**: Boolean (True if pressed, False otherwise)

#### `get_robot_status()`
* **Purpose**: Get comprehensive robot status.
* **Parameters**: None
* **Returns**: Dictionary containing pose, angles, speeds, IO, gripper status, stopped state, and E-stop state

### Helper Functions

#### `execute_trajectory()`
* **Purpose**: High-level trajectory execution with best method selection.
* **Parameters**:
    * `trajectory` (List[List[float]]): List of poses [x, y, z, rx, ry, rz]
    * `timing_mode` (str, optional): Either 'duration' or 'speed'. Default: 'duration'
    * `timing_value` (float, optional): Duration in seconds or speed percentage. Default: 5.0
    * `motion_type` (str, optional): Either 'spline' or 'linear'. Default: 'spline'
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF') for spline motion. Default: 'WRF'
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: True
    * `timeout` (float, optional): Timeout for acknowledgment in seconds. Default: 30.0
* > *Note: The `frame` parameter only applies when `motion_type='spline'`. Linear motions are always in WRF.*
* **Python API Usage**:
    ```python
    from robot_api import execute_trajectory
    
    # Execute trajectory in world frame
    trajectory = [[200, 0, 200, 0, 0, 0], 
                  [250, 50, 200, 0, 0, 45],
                  [200, 100, 200, 0, 0, 90]]
    execute_trajectory(trajectory, timing_mode='duration', 
                      timing_value=10.0, motion_type='spline')
    
    # Execute trajectory in tool frame (spline only)
    tool_trajectory = [[20, 0, 0, 0, 0, 0],
                      [20, 20, 0, 0, 0, 30],
                      [0, 20, 10, 0, 0, 60]]
    execute_trajectory(tool_trajectory, frame='TRF',
                      timing_mode='speed', 
                      timing_value=40, motion_type='spline')
    ```


#### `wait_for_robot_stopped()`
* **Purpose**: Wait for robot to stop moving.
* **Parameters**:
    * `timeout` (float, optional): Maximum time to wait in seconds. Default: 10.0
    * `poll_rate` (float, optional): How often to check in seconds. Default: 0.1
* **Returns**: Boolean (True if robot stopped, False if timeout)

#### `safe_move_with_retry()`
* **Purpose**: Execute move with automatic retry on failure.
* **Parameters**:
    * `move_func` (callable): The movement function to call
    * `*args`: Arguments for the movement function
    * `max_retries` (int, optional): Maximum number of retry attempts. Default: 3
    * `retry_delay` (float, optional): Delay between retries in seconds. Default: 1.0
    * `**kwargs`: Keyword arguments for the movement function
* **Returns**: Result from the movement function or error dictionary

#### `chain_smooth_motions()`
* **Purpose**: Chain multiple smooth motions with automatic continuity.
* **Parameters**:
    * `motions` (List[Dict]): List of motion dictionaries
    * `ensure_continuity` (bool, optional): Automatically set start_pose for continuity. Default: True
    * `frame` (str, optional): Reference frame ('WRF' or 'TRF') for all motions. Default: 'WRF'
    * `wait_for_ack` (bool, optional): Enable command tracking. Default: True
    * `timeout` (float, optional): Timeout per motion in seconds. Default: 30.0
* **Returns**: List of results for each motion
* **Python API Usage**:
    ```python
    from robot_api import chain_smooth_motions
    
    # Chain motions in world frame (default)
    motions = [
        {'type': 'circle', 'center': [200, 0, 200], 'radius': 50, 'duration': 5},
        {'type': 'arc', 'end_pose': [250, 50, 200, 0, 0, 90], 
         'center': [225, 25, 200], 'duration': 3}
    ]
    chain_smooth_motions(motions, ensure_continuity=True)
    
    # Chain motions in tool frame
    tool_motions = [
        {'type': 'circle', 'center': [0, 30, 0], 'radius': 25, 'duration': 4},
        {'type': 'arc', 'end_pose': [30, 30, 0, 0, 0, 45], 
         'center': [15, 15, 0], 'duration': 3}
    ]
    chain_smooth_motions(tool_motions, frame='TRF', ensure_continuity=True)
    ```

#### `check_command_status()`
* **Purpose**: Check status of a previously sent command.
* **Parameters**:
    * `command_id` (str): The command ID returned from a non-blocking command
* **Returns**: Dictionary with status information, or None if tracker not initialized
* **Dictionary Contents**:
    * `status` (str): Current status ('QUEUED', 'EXECUTING', 'COMPLETED', 'FAILED', 'CANCELLED', 'INVALID')
    * `details` (str): Additional status details
    * `completed` (bool): Whether command has finished
    * `sent_time` (datetime): When command was sent
    * `ack_time` (datetime, optional): When acknowledgment was received

#### `is_tracking_active()`
* **Purpose**: Check if command tracking system is active.
* **Parameters**: None
* **Returns**: Boolean (True if tracking is active, False otherwise)

#### `get_tracking_stats()`
* **Purpose**: Get resource usage statistics for tracking system.
* **Parameters**: None
* **Returns**: Dictionary with tracking statistics
* **Dictionary Contents**:
    * `active` (bool): Whether tracking is active
    * `commands_tracked` (int): Number of commands being tracked
    * `memory_bytes` (int): Approximate memory usage
    * `thread_active` (bool): Whether tracking thread is running

## 6. Setup & Operation

### Dependencies

The system is designed with a client-server architecture where most dependencies are only needed on the server (robot controller) side. The client API (`robot_api.py`) uses only standard Python libraries for UDP communication, making it lightweight and portable.

#### Server Dependencies (for `headless_commander.py`)
Install Python 3 and the following packages on the computer connected to the robot:

```bash
# Core robotics libraries
pip3 install roboticstoolbox-python==1.0.3
pip3 install numpy==1.23.4
pip3 install scipy==1.11.4
pip3 install spatialmath

# Serial communication and timing
pip3 install pyserial
pip3 install oclock

# User input
pip3 install keyboard
```

#### Client Dependencies (for `robot_api.py`)
The client API is designed to be lightweight with minimal dependencies:

```bash
# Only needed for get_robot_pose() matrix conversion
pip3 install numpy==1.23.4
pip3 install spatialmath

# All other functionality uses only Python standard library:
# socket, threading, time, uuid, datetime, collections, typing
```

**Note**: If you only need to send commands and don't use `get_robot_pose()`, the client requires NO external dependencies - only Python's built-in libraries.

### File Structure

#### Server Side (Robot Controller Computer)
Required files in the same folder:
* `headless_commander.py` - Main server/controller
* `PAROL6_ROBOT.py` - Robot configuration and kinematic model  
* `smooth_motion.py` - Advanced trajectory generation
* `GUI/files/` folder structure - For imports to work correctly

Optional:
* `com_port.txt` - Contains the USB COM port (e.g., COM5)

#### Client Side (Any Computer)
Only required file:
* `robot_api.py` - Client API for sending commands

The client can run on any computer on the same network as the server, or on the same computer in a different process.

### How to Operate

#### Starting the Server (Robot Controller)

1. **Connect Robot**: Ensure the robot is connected via USB to the controller computer.

2. **Start Controller**: On the robot controller computer, navigate to the folder containing the server files and run:
    ```bash
    python headless_commander.py
    ```
    The controller will:
    - Connect to the robot via serial port (prompts if `com_port.txt` not found)
    - Start listening for UDP commands on port 5001
    - Optionally home the robot on startup (unless disabled)

#### Sending Commands (Client)

Commands can be sent from:
- **Same Computer**: Run Python scripts or interactive sessions in another terminal
- **Different Computer**: Ensure network connectivity and update `SERVER_IP` in `robot_api.py`

3. **Send Commands**: Use the API functions from `robot_api.py`:
    ```python
    from robot_api import *
    
    # Example sequence
    home_robot()
    move_robot_joints([90, -90, 160, 12, 12, 180], duration=5.5)
    delay_robot(0.5)
    
    # Smooth motion example
    smooth_circle([200, 0, 200], radius=50, duration=5.0)
    
    # Non-blocking example with status checking
    cmd_id = move_robot_pose([250, 0, 200, 180, 0, 90], 
                             speed_percentage=50,
                             wait_for_ack=True, 
                             non_blocking=True)
    
    # Check status after some time
    import time
    time.sleep(2)
    status = check_command_status(cmd_id)
    if status:
        print(f"Command status: {status['status']}")
    ```

#### Network Configuration

If running client and server on different computers:

1. **Update Server IP**: In `robot_api.py`, modify the `SERVER_IP` variable:
    ```python
    SERVER_IP = "192.168.1.100"  # Replace with robot controller's IP
    SERVER_PORT = 5001  # Default port (usually no change needed)
    ```

2. **Firewall Settings**: Ensure UDP port 5001 is open on the robot controller computer.

3. **Network Requirements**: 
    - Both computers must be on the same network
    - Low latency recommended for real-time control
    - Command acknowledgments use port 5002 (optional feature)

### Advanced Usage with Acknowledgments

The acknowledgment system allows for sophisticated command management:

```python
from robot_api import *
import time

# Send multiple commands non-blocking
cmd1 = move_robot_joints([90, -45, 90, 0, 45, 180], 
                         duration=3, 
                         wait_for_ack=True, 
                         non_blocking=True)

cmd2 = smooth_circle([200, 0, 200], radius=30, 
                    duration=5, 
                    wait_for_ack=True, 
                    non_blocking=True)

# Monitor both commands
while True:
    status1 = check_command_status(cmd1)
    status2 = check_command_status(cmd2)
    
    if status1 and status1['completed'] and status2 and status2['completed']:
        print("Both commands completed!")
        break
    
    time.sleep(0.1)
```

## 7. Troubleshooting

* **Serial Connection Issues**: Check COM port in Device Manager (Windows) and update `com_port.txt`
* **Command Not Executing**: Verify robot is homed and E-stop is not pressed
* **Tracking Not Working**: Ensure `wait_for_ack=True` is set for commands
* **IK Failures**: Target pose may be unreachable; check robot workspace limits
* **Smooth Motion Errors**: Verify waypoints are reachable and properly formatted

For additional support, refer to the [PAROL commander software repository](https://github.com/PCrnjak/PAROL-commander-software).

Or you can head over to the [PAROL6 Discord channel](https://discord.com/invite/prjUvjmGpZ) for extra support
````

## File: replace_ikine_LMS.py
````python
#!/usr/bin/env python3
# PAROL6 ikine_LMS 替换脚本

import os
import re

def replace_in_file(filename, old_pattern, new_pattern):
    """在文件中替换内容"""
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # 备份原文件
        backup_filename = filename + '.backup'
        with open(backup_filename, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"✅ 已备份: {backup_filename}")
        
        # 执行替换
        new_content = re.sub(old_pattern, new_pattern, content)
        changes = content.count(old_pattern.replace(r'\b', ''))
        
        if changes > 0:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(new_content)
            print(f"✅ {filename}: 替换了 {changes} 处")
        else:
            print(f"📄 {filename}: 无需替换")
            
    except Exception as e:
        print(f"❌ {filename}: 替换失败 - {e}")

# 要修改的文件列表
files_to_modify = [
    "headless_commander.py",
    "PAROL6_ROBOT.py", 
    "smooth_motion.py"
]

print("🔧 开始替换 ikine_LMS -> ikine_LM")
for filename in files_to_modify:
    if os.path.exists(filename):
        replace_in_file(filename, r'\bikine_LMS\b', 'ikine_LM')
    else:
        print(f"⚠️ 文件不存在: {filename}")

print("\n🎉 替换完成！")
print("💡 如果 ikine_LM 不工作，请尝试替换为 ik_LM")
````

## File: robot_api.py
````python
"""
Zero-Overhead Robot API with Optional Acknowledgments
======================================================
This version guarantees ZERO resource overhead when tracking is not used.
The tracking system is only initialized when explicitly requested.
"""

import socket
from typing import List, Optional, Literal, Dict, Tuple, Union
import time
import threading
import queue
import uuid
from collections import deque
from datetime import datetime, timedelta

# Global configuration
SERVER_IP = "127.0.0.1"
SERVER_PORT = 5001

# Global tracker - starts as None (no resources)
_command_tracker = None
_tracker_lock = threading.Lock()

# ============================================================================
# ORIGINAL SEND FUNCTION - ZERO OVERHEAD
# ============================================================================

def send_robot_command(command_string: str):
    """
    Original send function - NO TRACKING, NO OVERHEAD.
    This is what gets called for all backward-compatible operations.
    
    Resource usage:
    - No threads
    - No extra sockets
    - No memory allocation
    - Exactly the same as your original implementation
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
            sock.sendto(command_string.encode('utf-8'), (SERVER_IP, SERVER_PORT))
        return f"Successfully sent command: '{command_string[:50]}...'"
    except Exception as e:
        return f"Error sending command: {e}"

# ============================================================================
# TRACKING SYSTEM - ONLY LOADED WHEN NEEDED
# ============================================================================

class LazyCommandTracker:
    """
    Command tracker with lazy initialization.
    Resources are ONLY allocated when tracking is actually used.
    """
    
    def __init__(self, listen_port=5002, history_size=100):
        self.listen_port = listen_port
        self.history_size = history_size
        self.command_history = {}
        self.lock = threading.Lock()
        
        # Lazy initialization flags
        self._initialized = False
        self._thread = None
        self._socket = None
        self._running = False
    
    def _lazy_init(self):
        """
        Initialize resources only when first tracking is requested.
        This is called ONLY when someone uses tracking features.
        """
        if self._initialized:
            return True
            
        try:
            print("[Tracker] First tracking request - initializing resources...")
            
            # Create socket
            self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self._socket.bind(('', self.listen_port))
            self._socket.settimeout(0.1)
            
            # Start thread
            self._running = True
            self._thread = threading.Thread(target=self._listen_loop, daemon=True)
            self._thread.start()
            
            self._initialized = True
            print(f"[Tracker] Initialized on port {self.listen_port}")
            return True
            
        except Exception as e:
            print(f"[Tracker] Failed to initialize: {e}")
            self._cleanup()
            return False
    
    def _cleanup(self):
        """Clean up resources"""
        self._running = False
        if self._thread:
            self._thread.join(timeout=0.5)
            self._thread = None
        if self._socket:
            self._socket.close()
            self._socket = None
        self._initialized = False
    
    def _listen_loop(self):
        """Listener thread - only runs if tracking is used"""
        while self._running:
            try:
                data, addr = self._socket.recvfrom(2048)
                message = data.decode('utf-8')
                
                parts = message.split('|', 3)
                if parts[0] == 'ACK' and len(parts) >= 3:
                    cmd_id = parts[1]
                    status = parts[2]
                    details = parts[3] if len(parts) > 3 else ""
                    
                    with self.lock:
                        if cmd_id in self.command_history:
                            self.command_history[cmd_id].update({
                                'status': status,
                                'details': details,
                                'ack_time': datetime.now(),
                                'completed': status in ['COMPLETED', 'FAILED', 'INVALID', 'CANCELLED']
                            })
                    
                    # Clean old entries (only if we have many)
                    if len(self.command_history) > self.history_size:
                        self._cleanup_old_entries()
                        
            except socket.timeout:
                continue
            except Exception:
                if self._running:
                    pass  # Silently continue
    
    def _cleanup_old_entries(self):
        """Remove old entries to prevent memory growth"""
        with self.lock:
            now = datetime.now()
            expired = [cmd_id for cmd_id, info in self.command_history.items()
                      if now - info['sent_time'] > timedelta(seconds=30)]
            for cmd_id in expired:
                del self.command_history[cmd_id]
    
    def track_command(self, command: str) -> Tuple[str, str]:
        """
        Track a command - initializes tracker if needed.
        Returns (modified_command, cmd_id)
        """
        # Initialize on first use
        if not self._initialized:
            if not self._lazy_init():
                # Initialization failed - fall back to non-tracking
                return command, None
        
        # Generate ID and modify command
        cmd_id = str(uuid.uuid4())[:8]
        tracked_command = f"{cmd_id}|{command}"
        
        # Register in history
        with self.lock:
            self.command_history[cmd_id] = {
                'command': command,
                'sent_time': datetime.now(),
                'status': 'SENT',
                'details': '',
                'completed': False
            }
        
        return tracked_command, cmd_id
    
    def get_status(self, cmd_id: str) -> Optional[Dict]:
        """Get status if tracker is initialized"""
        if not self._initialized:
            return None
        with self.lock:
            return self.command_history.get(cmd_id, None)
    
    def wait_for_completion(self, cmd_id: str, timeout: float = 5.0) -> Dict:
        """Wait for completion if tracker is initialized"""
        if not self._initialized:
            return {'status': 'NO_TRACKING', 'details': 'Tracker not initialized', 'completed': True}
            
        start_time = time.time()
        while time.time() - start_time < timeout:
            status = self.get_status(cmd_id)
            if status and status['completed']:
                return status
            time.sleep(0.01)
        
        return self.get_status(cmd_id) or {
            'status': 'TIMEOUT',
            'details': 'No acknowledgment received',
            'completed': True
        }
    
    def is_active(self) -> bool:
        """Check if tracker is initialized and running"""
        return self._initialized and self._running

# ============================================================================
# LAZY TRACKER ACCESS
# ============================================================================

def _get_tracker_if_needed() -> Optional[LazyCommandTracker]:
    """
    Get tracker ONLY if tracking is requested.
    This ensures zero overhead for non-tracking operations.
    """
    global _command_tracker, _tracker_lock
    
    # Fast path - tracker already exists
    if _command_tracker is not None:
        return _command_tracker
    
    # Slow path - create tracker (only happens once)
    with _tracker_lock:
        if _command_tracker is None:
            _command_tracker = LazyCommandTracker()
        return _command_tracker

# ============================================================================
# ENHANCED SEND WITH OPTIONAL TRACKING
# ============================================================================

def send_robot_command_tracked(command_string: str) -> Tuple[str, Optional[str]]:
    """
    Send with tracking - initializes tracker on first use.
    
    Resource impact:
    - First call: Starts tracker thread
    - Subsequent calls: Minimal overhead (UUID generation)
    """
    tracker = _get_tracker_if_needed()
    if tracker:
        tracked_cmd, cmd_id = tracker.track_command(command_string)
        if cmd_id:
            # Send tracked command
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                    sock.sendto(tracked_cmd.encode('utf-8'), (SERVER_IP, SERVER_PORT))
                return f"Command sent with tracking (ID: {cmd_id})", cmd_id
            except Exception as e:
                return f"Error: {e}", None
    
    # Fall back to non-tracked
    return send_robot_command(command_string), None

def send_and_wait(
    command_string: str, 
    timeout: float = 2.0, 
    non_blocking: bool = False
    ) -> Union[Dict, str, None]:
    """
    Send and wait for acknowledgment OR return a command_id immediately.
    First use initializes tracker.
    """
    result, cmd_id = send_robot_command_tracked(command_string)
    
    if cmd_id:
        # If non_blocking is True, return the ID right away
        if non_blocking:
            return cmd_id
            
        # Otherwise, proceed with the original blocking logic
        tracker = _get_tracker_if_needed()
        if tracker:
            status_dict = tracker.wait_for_completion(cmd_id, timeout)
            # Add the command_id to the returned dictionary
            status_dict['command_id'] = cmd_id
            return status_dict
    
    # Handle cases where a command_id could not be generated
    if non_blocking:
        return None
    else:
        return {'status': 'NO_TRACKING', 'details': result, 'completed': True, 'command_id': None}

# ============================================================================
# BACKWARD COMPATIBLE MOVEMENT FUNCTIONS - ZERO OVERHEAD BY DEFAULT
# ============================================================================

def move_robot_joints(
    joint_angles: List[float],
    duration: Optional[float] = None,
    speed_percentage: Optional[int] = None,
    wait_for_ack: bool = False,  # Default: No tracking, no overhead
    timeout: float = 2.0,
    non_blocking: bool = False
):
    """
    Move robot joints.
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    # Validation
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either a duration or a speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    # Build command
    angles_str = "|".join(map(str, joint_angles))
    duration_str = str(duration) if duration is not None else "None"
    speed_str = str(speed_percentage) if speed_percentage is not None else "None"
    command = f"MOVEJOINT|{angles_str}|{duration_str}|{speed_str}"
    
    # Send with or without tracking
    if wait_for_ack:
        # User explicitly requested tracking - initialize if needed
        return send_and_wait(command, timeout, non_blocking)
    else:
        # Default path - NO TRACKING, NO OVERHEAD
        return send_robot_command(command)

def move_robot_pose(
    pose: List[float],
    duration: Optional[float] = None,
    speed_percentage: Optional[int] = None,
    wait_for_ack: bool = False,  # Default: No tracking
    timeout: float = 2.,
    non_blocking: bool = False
):
    """
    Move to pose - zero overhead by default.
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either a duration or a speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    pose_str = "|".join(map(str, pose))
    duration_str = str(duration) if duration is not None else "None"
    speed_str = str(speed_percentage) if speed_percentage is not None else "None"
    command = f"MOVEPOSE|{pose_str}|{duration_str}|{speed_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)
    
def jog_robot_joint(
    joint_index: int,
    speed_percentage: int,
    duration: Optional[float] = None,
    distance_deg: Optional[float] = None,
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
):
    """
    Jogs a single robot joint for a specified time or distance.
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    if duration is None and distance_deg is None:
        error = "Error: You must provide either a duration or a distance_deg."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    if duration is not None:
        try:
            duration = float(duration)
        except (ValueError, TypeError):
            error = "Error: Duration must be a valid number."
            return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    duration_str = str(duration) if duration is not None else "None"
    distance_str = str(distance_deg) if distance_deg is not None else "None"
    command = f"JOG|{joint_index}|{speed_percentage}|{duration_str}|{distance_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def jog_multiple_joints(
    joints: List[int], 
    speeds: List[float], 
    duration: float,
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
) -> str:
    """
    Jogs multiple robot joints simultaneously for a specified duration.

    Args:
        joints: List of joint indices (0-5 for positive, 6-11 for negative)
        speeds: List of corresponding speeds (1-100%)
        duration: Duration of the jog in seconds
        wait_for_ack: Enable command tracking (default False)
        timeout: Timeout for acknowledgment
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    if len(joints) != len(speeds):
        error = "Error: The number of joints must match the number of speeds."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    joints_str = ",".join(map(str, joints))
    speeds_str = ",".join(map(str, speeds))
    command = f"MULTIJOG|{joints_str}|{speeds_str}|{duration}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def jog_cartesian(
    frame: Literal['TRF', 'WRF'],
    axis: Literal['X+', 'X-', 'Y+', 'Y-', 'Z+', 'Z-', 'RX+', 'RX-', 'RY+', 'RY-', 'RZ+', 'RZ-'],
    speed_percentage: int,
    duration: float,
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
):
    """
    Jogs the robot's end-effector continuously in Cartesian space.
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    if duration is not None:
        try:
            duration = float(duration)
        except (ValueError, TypeError):
            error = "Error: Duration must be a valid number."
            return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    command = f"CARTJOG|{frame}|{axis}|{speed_percentage}|{duration}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def move_robot_cartesian(
    pose: List[float],
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
) -> str:
    """
    Moves the robot's end-effector to a specific Cartesian pose in a straight line.
    
    Args:
        pose: Target pose as [x, y, z, r, p, y] (mm and degrees)
        duration: Total time for the movement in seconds
        speed_percentage: Movement speed as a percentage (1-100)
        wait_for_ack: Enable command tracking (default False)
        timeout: Timeout for acknowledgment
        
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    # Validate timing arguments
    if (duration is None and speed_percentage is None):
        error = "Error: You must provide either 'duration' or 'speed_percentage'."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    if (duration is not None and speed_percentage is not None):
        error = "Error: Please provide either 'duration' or 'speed_percentage', not both."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    # Prepare command arguments
    duration_arg = 'NONE'
    speed_arg = 'NONE'
    
    if duration is not None:
        try:
            if float(duration) <= 0:
                error = "Error: Duration must be a positive number."
                return {'status': 'INVALID', 'details': error} if wait_for_ack else error
            duration_arg = str(duration)
        except (ValueError, TypeError):
            error = "Error: Duration must be a valid number."
            return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    if speed_percentage is not None:
        try:
            speed_val = float(speed_percentage)
            if not (0 < speed_val <= 100):
                error = "Error: Speed percentage must be between 1 and 100."
                return {'status': 'INVALID', 'details': error} if wait_for_ack else error
            speed_arg = str(speed_val)
        except (ValueError, TypeError):
            error = "Error: Speed percentage must be a valid number."
            return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    # Construct command
    pose_str = "|".join(map(str, pose))
    command = f"MOVECART|{pose_str}|{duration_arg}|{speed_arg}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def control_pneumatic_gripper(
    action: Literal['open', 'close'], 
    port: Literal[1, 2],
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
):
    """
    Controls the pneumatic gripper.
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    command = f"PNEUMATICGRIPPER|{action}|{port}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def control_electric_gripper(
    action: Literal['move', 'calibrate'],
    position: Optional[int] = 255,
    speed: Optional[int] = 150,
    current: Optional[int] = 500,
    wait_for_ack: bool = False,
    timeout: float = 2.0,
    non_blocking: bool = False
):
    """
    Controls the electric gripper.
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead, no tracking
    - wait_for_ack=True: Initializes tracker on first use
    """
    action_str = "move" if action == 'move' else 'calibrate'
    command = f"ELECTRICGRIPPER|{action_str}|{position}|{speed}|{current}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)
    
# ============================================================================
# SMOOTH MOTION COMMANDS - WITH START POSITION AND DUAL TIMING SUPPORT
# ============================================================================

def smooth_circle(
    center: List[float],
    radius: float,
    plane: Literal['XY', 'XZ', 'YZ'] = 'XY',
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    clockwise: bool = False,
    wait_for_ack: bool = False,
    timeout: float = 10.0,
    non_blocking: bool = False
):
    """
    Execute a smooth circular motion.
    
    Args:
        center: [x, y, z] center point in mm
        radius: Circle radius in mm
        plane: Plane of the circle ('XY', 'XZ', or 'YZ')
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose (mm and degrees).
                   If None, starts from current position.
        duration: Time to complete the circle in seconds
        speed_percentage: Speed as percentage (1-100)
        clockwise: Direction of motion
        wait_for_ack: Enable command tracking (default False)
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
    
    Resource usage:
    - wait_for_ack=False (default): ZERO overhead
    - wait_for_ack=True: Initializes tracker on first use
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either duration or speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    center_str = ",".join(map(str, center))
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    clockwise_str = "1" if clockwise else "0"
    
    # Format timing
    if duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    command = f"SMOOTH_CIRCLE|{center_str}|{radius}|{plane}|{frame}|{start_str}|{timing_str}|{clockwise_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def smooth_arc_center(
    end_pose: List[float],
    center: List[float],
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    clockwise: bool = False,
    wait_for_ack: bool = False,
    timeout: float = 10.0,
    non_blocking: bool = False
):
    """
    Execute a smooth arc motion defined by center point.
    
    Args:
        end_pose: [x, y, z, rx, ry, rz] end pose (mm and degrees)
        center: [x, y, z] arc center point in mm
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose.
                   If None, starts from current position.
                   If specified, adds smooth transition from current position.
        duration: Time to complete the arc in seconds
        speed_percentage: Speed as percentage (1-100)
        clockwise: Direction of motion
        wait_for_ack: Enable command tracking
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either duration or speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    end_str = ",".join(map(str, end_pose))
    center_str = ",".join(map(str, center))
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    clockwise_str = "1" if clockwise else "0"
    
    # Format timing
    if duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    command = f"SMOOTH_ARC_CENTER|{end_str}|{center_str}|{frame}|{start_str}|{timing_str}|{clockwise_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def smooth_arc_parametric(
    end_pose: List[float],
    radius: float,
    arc_angle: float,
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    clockwise: bool = False,
    wait_for_ack: bool = False,
    timeout: float = 10.0,
    non_blocking: bool = False
):
    """
    Execute a smooth arc motion defined by radius and angle.
    
    Args:
        end_pose: [x, y, z, rx, ry, rz] end pose (mm and degrees)
        radius: Arc radius in mm
        arc_angle: Arc angle in degrees
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose.
                   If None, starts from current position.
        duration: Time to complete the arc in seconds
        speed_percentage: Speed as percentage (1-100)
        clockwise: Direction of motion
        wait_for_ack: Enable command tracking
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either duration or speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    end_str = ",".join(map(str, end_pose))
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    clockwise_str = "1" if clockwise else "0"
    
    # Format timing
    if duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    command = f"SMOOTH_ARC_PARAM|{end_str}|{radius}|{arc_angle}|{frame}|{start_str}|{timing_str}|{clockwise_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def smooth_spline(
    waypoints: List[List[float]],
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    wait_for_ack: bool = False,
    timeout: float = 10.0,
    non_blocking: bool = False
):
    """
    Execute a smooth spline motion through waypoints.
    
    Args:
        waypoints: List of [x, y, z, rx, ry, rz] poses (mm and degrees)
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose.
                   If None, starts from current position.
                   If specified and different from first waypoint, adds transition.
        duration: Total time for the motion in seconds
        speed_percentage: Speed as percentage (1-100)
        wait_for_ack: Enable command tracking
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either duration or speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    num_waypoints = len(waypoints)
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    
    # Format timing
    if duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    # Format waypoints - flatten each waypoint's 6 values
    waypoint_strs = []
    for wp in waypoints:
        waypoint_strs.extend(map(str, wp))
    
    # Build command
    command_parts = [f"SMOOTH_SPLINE", str(num_waypoints), frame, start_str, timing_str]
    command_parts.extend(waypoint_strs)
    command = "|".join(command_parts)
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def smooth_helix(
    center: List[float],
    radius: float,
    pitch: float,
    height: float,
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    clockwise: bool = False,
    wait_for_ack: bool = False,
    timeout: float = 10.0,
    non_blocking: bool = False
):
    """
    Execute a smooth helical motion.
    
    Args:
        center: [x, y, z] helix center point in mm
        radius: Helix radius in mm
        pitch: Vertical distance per revolution in mm
        height: Total height of helix in mm
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose.
                   If None, starts from current position on helix perimeter.
        duration: Time to complete the helix in seconds
        speed_percentage: Speed as percentage (1-100)
        clockwise: Direction of motion
        wait_for_ack: Enable command tracking
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
    """
    if duration is None and speed_percentage is None:
        error = "Error: You must provide either duration or speed_percentage."
        return {'status': 'INVALID', 'details': error} if wait_for_ack else error
    
    center_str = ",".join(map(str, center))
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    clockwise_str = "1" if clockwise else "0"
    
    # Format timing
    if duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    command = f"SMOOTH_HELIX|{center_str}|{radius}|{pitch}|{height}|{frame}|{start_str}|{timing_str}|{clockwise_str}"
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def smooth_blend(
    segments: List[Dict],
    blend_time: float = 0.5,
    frame: Literal['WRF', 'TRF'] = 'WRF',
    start_pose: Optional[List[float]] = None,
    duration: Optional[float] = None,
    speed_percentage: Optional[float] = None,
    wait_for_ack: bool = False,
    timeout: float = 15.0,
    non_blocking: bool = False
):
    """
    Execute a blended motion through multiple segments.
    
    Args:
        segments: List of segment dictionaries, each containing:
            - 'type': 'LINE', 'CIRCLE', 'ARC', or 'SPLINE'
            - Additional parameters based on type
        blend_time: Time to blend between segments in seconds
        frame: Reference frame ('WRF' for World, 'TRF' for Tool)
        start_pose: Optional [x, y, z, rx, ry, rz] start pose for first segment.
                   If None, starts from current position.
        duration: Total time for entire motion (scales all segments proportionally)
        speed_percentage: Speed as percentage (1-100) for entire motion
        wait_for_ack: Enable command tracking
        timeout: Timeout for acknowledgment
        non_blocking: Return immediately with command ID
        
    Example:
        segments = [
            {'type': 'LINE', 'end': [x,y,z,rx,ry,rz], 'duration': 2.0},
            {'type': 'CIRCLE', 'center': [x,y,z], 'radius': 50, 'plane': 'XY', 
             'duration': 3.0, 'clockwise': False},
            {'type': 'ARC', 'end': [x,y,z,rx,ry,rz], 'center': [x,y,z], 
             'duration': 2.0, 'clockwise': True}
        ]
    """
    num_segments = len(segments)
    start_str = ",".join(map(str, start_pose)) if start_pose else "CURRENT"
    
    # Format timing
    if duration is None and speed_percentage is None:
        # Use individual segment durations
        timing_str = "DEFAULT"
    elif duration is not None:
        timing_str = f"DURATION|{duration}"
    else:
        timing_str = f"SPEED|{speed_percentage}"
    
    # Format segments
    segment_strs = []
    for seg in segments:
        seg_type = seg['type']
        
        if seg_type == 'LINE':
            end_str = ",".join(map(str, seg['end']))
            seg_str = f"LINE|{end_str}|{seg.get('duration', 2.0)}"
            
        elif seg_type == 'CIRCLE':
            center_str = ",".join(map(str, seg['center']))
            clockwise_str = "1" if seg.get('clockwise', False) else "0"
            seg_str = f"CIRCLE|{center_str}|{seg['radius']}|{seg['plane']}|{seg.get('duration', 3.0)}|{clockwise_str}"
            
        elif seg_type == 'ARC':
            end_str = ",".join(map(str, seg['end']))
            center_str = ",".join(map(str, seg['center']))
            clockwise_str = "1" if seg.get('clockwise', False) else "0"
            seg_str = f"ARC|{end_str}|{center_str}|{seg.get('duration', 2.0)}|{clockwise_str}"
            
        elif seg_type == 'SPLINE':
            waypoints_str = ";".join([",".join(map(str, wp)) for wp in seg['waypoints']])
            seg_str = f"SPLINE|{len(seg['waypoints'])}|{waypoints_str}|{seg.get('duration', 3.0)}"
            
        else:
            continue
            
        segment_strs.append(seg_str)
    
    # Build command with || separators between segments
    command = f"SMOOTH_BLEND|{num_segments}|{blend_time}|{frame}|{start_str}|{timing_str}|" + "||".join(segment_strs)
    
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

# ============================================================================
# CONVENIENCE FUNCTIONS FOR SMOOTH MOTION CHAINS
# ============================================================================

def chain_smooth_motions(
    motions: List[Dict],
    ensure_continuity: bool = True,
    frame: Literal['WRF', 'TRF'] = 'WRF',  # ADD THIS
    wait_for_ack: bool = True,
    timeout: float = 30.0
):
    """
    Chain multiple smooth motions together with automatic continuity.
    
    Args:
        motions: List of motion dictionaries, each with 'type' and parameters
        ensure_continuity: If True, automatically sets start_pose of each motion
                          to end of previous motion for perfect continuity
        frame: Reference frame for all motions ('WRF' or 'TRF')  # ADD THIS
        wait_for_ack: Enable command tracking
        timeout: Timeout per motion
        
    Example:
        chain_smooth_motions([
            {'type': 'circle', 'center': [200, 0, 200], 'radius': 50, 'duration': 5},
            {'type': 'arc', 'end_pose': [250, 50, 200, 0, 0, 90], 'center': [225, 25, 200], 'duration': 3},
            {'type': 'helix', 'center': [250, 50, 150], 'radius': 30, 'pitch': 20, 'height': 100, 'duration': 8}
        ], frame='TRF')  # Can now specify frame
    """
    results = []
    last_end_pose = None
    
    for i, motion in enumerate(motions):
        motion_type = motion.get('type', '').lower()
        
        # Add frame to motion parameters
        motion['frame'] = frame
        
        # Add start_pose from previous motion if ensuring continuity
        if ensure_continuity and last_end_pose and i > 0:
            motion['start_pose'] = last_end_pose
        
        # Execute the appropriate motion (add frame parameter to each call)
        if motion_type == 'circle':
            result = smooth_circle(**{k: v for k, v in motion.items() if k != 'type'}, 
                                  wait_for_ack=wait_for_ack, timeout=timeout)
            last_end_pose = None  # Circles return to start
            
        elif motion_type == 'arc' or motion_type == 'arc_center':
            result = smooth_arc_center(**{k: v for k, v in motion.items() if k != 'type'},
                                      wait_for_ack=wait_for_ack, timeout=timeout)
            last_end_pose = motion.get('end_pose')
            
        elif motion_type == 'arc_param' or motion_type == 'arc_parametric':
            result = smooth_arc_parametric(**{k: v for k, v in motion.items() if k != 'type'},
                                          wait_for_ack=wait_for_ack, timeout=timeout)
            last_end_pose = motion.get('end_pose')
            
        elif motion_type == 'spline':
            result = smooth_spline(**{k: v for k, v in motion.items() if k != 'type'},
                                  wait_for_ack=wait_for_ack, timeout=timeout)
            waypoints = motion.get('waypoints', [])
            last_end_pose = waypoints[-1] if waypoints else None
            
        elif motion_type == 'helix':
            result = smooth_helix(**{k: v for k, v in motion.items() if k != 'type'},
                                 wait_for_ack=wait_for_ack, timeout=timeout)
            last_end_pose = None
            
        else:
            result = {'status': 'INVALID', 'details': f'Unknown motion type: {motion_type}'}
        
        results.append(result)
        
        # Check for failures if tracking
        if wait_for_ack and isinstance(result, dict) and result.get('status') == 'FAILED':
            print(f"Motion {i+1} failed: {result.get('details')}")
            break
    
    return results

def execute_trajectory(
    trajectory: List[List[float]],
    timing_mode: Literal['duration', 'speed'] = 'duration',
    timing_value: float = 5.0,
    motion_type: Literal['spline', 'linear'] = 'spline',
    frame: Literal['WRF', 'TRF'] = 'WRF',  # ADD THIS
    wait_for_ack: bool = True,
    timeout: float = 30.0,
):
    """
    High-level function to execute a trajectory using the best method.
    
    Args:
        trajectory: List of poses [x, y, z, rx, ry, rz]
        timing_mode: 'duration' for total time, 'speed' for percentage
        timing_value: Duration in seconds or speed percentage
        motion_type: 'spline' for smooth curves, 'linear' for point-to-point
        frame: Reference frame ('WRF' or 'TRF')  # ADD THIS
        wait_for_ack: Enable command tracking (recommended for trajectories)
        timeout: Timeout for acknowledgment
    """
    if motion_type == 'spline':
        if timing_mode == 'duration':
            return smooth_spline(trajectory, frame=frame, duration=timing_value,  # ADD frame
                               wait_for_ack=wait_for_ack, timeout=timeout)
        else:
            return smooth_spline(trajectory, frame=frame, speed_percentage=timing_value,  # ADD frame
                               wait_for_ack=wait_for_ack, timeout=timeout)
    else:
        # Linear motion - send as individual move commands
        results = []
        for pose in trajectory:
            if timing_mode == 'duration':
                segment_duration = timing_value / len(trajectory)
                # Note: move_robot_cartesian doesn't support TRF, only smooth motions do
                result = move_robot_cartesian(pose, duration=segment_duration,
                                             wait_for_ack=wait_for_ack, timeout=timeout)
            else:
                result = move_robot_cartesian(pose, speed_percentage=timing_value,
                                             wait_for_ack=wait_for_ack, timeout=timeout)
            results.append(result)
            
            # Check for failures if tracking
            if wait_for_ack and result.get('status') == 'FAILED':
                break
        
        return results

# ============================================================================
# BASIC FUNCTIONS
# ============================================================================

def delay_robot(duration: float, wait_for_ack: bool = False, timeout: float = 2.0, non_blocking: bool = False):
    """Delay - optional tracking"""
    command = f"DELAY|{duration}"
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def home_robot(wait_for_ack: bool = False, timeout: float = 30.0, non_blocking: bool = False):
    """Home robot - optional tracking (longer timeout for homing)"""
    command = "HOME"
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

def stop_robot_movement(wait_for_ack: bool = False, timeout: float = 2.0, non_blocking: bool = False):
    """Stop robot - optional tracking"""
    command = "STOP"
    if wait_for_ack:
        return send_and_wait(command, timeout, non_blocking)
    else:
        return send_robot_command(command)

# ============================================================================
# GET FUNCTIONS - ZERO OVERHEAD, IMMEDIATE RESPONSE
# ============================================================================

def get_robot_pose():
    """
    Get the robot's current end-effector pose.
    Returns [x, y, z, roll, pitch, yaw] or None if it fails.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_POSE"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(2048)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'POSE' and len(parts) == 2:
                pose_values = [float(v) for v in parts[1].split(',')]
                if len(pose_values) == 16:
                    # Convert 4x4 matrix to [x,y,z,r,p,y]
                    import numpy as np
                    from spatialmath import SE3
                    
                    pose_matrix = np.array(pose_values).reshape((4, 4))
                    T = SE3(pose_matrix, check=False)
                    xyz_mm = T.t * 1000  # Convert to mm
                    rpy_deg = T.rpy(unit='deg', order='xyz')
                    
                    # Convert numpy float64 to regular Python floats
                    return [float(x) for x in xyz_mm] + [float(r) for r in rpy_deg]
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for pose response")
        return None
    except Exception as e:
        print(f"Error getting robot pose: {e}")
        return None

def get_robot_joint_angles():
    """
    Get the robot's current joint angles in degrees.
    Returns list of 6 angles or None if it fails.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_ANGLES"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(1024)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'ANGLES' and len(parts) == 2:
                angles = [float(v) for v in parts[1].split(',')]
                return angles
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for angles response")
        return None
    except Exception as e:
        print(f"Error getting robot angles: {e}")
        return None

def get_robot_io(verbose = False):
    """
    Get the robot's current digital I/O status.
    Returns [IN1, IN2, OUT1, OUT2, ESTOP] or None if it fails.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_IO"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(1024)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'IO' and len(parts) == 2:
                io_values = [int(v) for v in parts[1].split(',')]

                if verbose:
                    print("--- I/O Status ---")
                    print(f"  IN1:   {io_values[0]} | {'ON' if io_values[0] else 'OFF'}")
                    print(f"  IN2:   {io_values[1]} | {'ON' if io_values[1] else 'OFF'}")
                    print(f"  OUT1:  {io_values[2]} | {'ON' if io_values[2] else 'OFF'}")
                    print(f"  OUT2:  {io_values[3]} | {'ON' if io_values[3] else 'OFF'}")
                    # More intuitive E-stop display
                    if io_values[4] == 0:
                        print(f"  ESTOP: {io_values[4]} | PRESSED (Emergency Stop Active!)")
                    else:
                        print(f"  ESTOP: {io_values[4]} | OK (Normal Operation)")
                    print("--------------------------")

                return io_values
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for I/O response")
        return None
    except Exception as e:
        print(f"Error getting robot I/O: {e}")
        return None

def get_electric_gripper_status(verbose = False):
    """
    Get the electric gripper's current status.
    Returns [ID, Position, Speed, Current, StatusByte, ObjectDetected] or None.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_GRIPPER"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(1024)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'GRIPPER' and len(parts) == 2:
                gripper_values = [int(v) for v in parts[1].split(',')]
                
                # Decode the status byte
                status_byte = gripper_values[4] if len(gripper_values) > 4 else 0
                is_active = (status_byte & 0b00000001) != 0
                is_moving = (status_byte & 0b00000010) != 0
                is_calibrated = (status_byte & 0b10000000) != 0
                
                # Interpret object detection
                object_detection = gripper_values[5] if len(gripper_values) > 5 else 0
                if object_detection == 1:
                    detection_text = "Yes (closing)"
                elif object_detection == 2:
                    detection_text = "Yes (opening)"
                else:
                    detection_text = "No"


                if verbose:
                    # Print formatted status
                    print("--- Electric Gripper Status ---")
                    print(f"  Device ID:         {gripper_values[0]}")
                    print(f"  Current Position:  {gripper_values[1]}")
                    print(f"  Current Speed:     {gripper_values[2]}")
                    print(f"  Current Current:   {gripper_values[3]}")
                    print(f"  Object Detected:   {detection_text}")
                    print(f"  Status Byte:       {bin(status_byte)}")
                    print(f"    - Calibrated:    {is_calibrated}")
                    print(f"    - Active:        {is_active}")
                    print(f"    - Moving:        {is_moving}")
                    print("-------------------------------")
                
                return gripper_values
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for gripper response")
        return None
    except Exception as e:
        print(f"Error getting gripper status: {e}")
        return None

def get_robot_joint_speeds():
    """
    Get the robot's current joint speeds in steps/sec.
    Returns list of 6 speed values or None if it fails.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_SPEEDS"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(1024)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'SPEEDS' and len(parts) == 2:
                speeds = [float(v) for v in parts[1].split(',')]
                return speeds
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for speeds response")
        return None
    except Exception as e:
        print(f"Error getting robot speeds: {e}")
        return None

def get_robot_pose_matrix():
    """
    Get the robot's current pose as a 4x4 transformation matrix.
    Returns 4x4 numpy array or None if it fails.
    
    Resource usage: ZERO overhead - simple request/response
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_socket:
            client_socket.settimeout(2.0)
            
            request_message = "GET_POSE"
            client_socket.sendto(request_message.encode('utf-8'), (SERVER_IP, SERVER_PORT))
            
            data, _ = client_socket.recvfrom(2048)
            response_str = data.decode('utf-8')
            
            parts = response_str.split('|')
            if parts[0] == 'POSE' and len(parts) == 2:
                pose_values = [float(v) for v in parts[1].split(',')]
                if len(pose_values) == 16:
                    import numpy as np
                    return np.array(pose_values).reshape((4, 4))
            
            return None
            
    except socket.timeout:
        print("Timeout waiting for pose response")
        return None
    except Exception as e:
        print(f"Error getting robot pose matrix: {e}")
        return None

def is_robot_stopped(threshold_speed: float = 2.0) -> bool:
    """
    Check if the robot has stopped moving.
    
    Args:
        threshold_speed: Speed threshold in steps/sec
        
    Returns:
        True if all joints below threshold, False otherwise
        
    Resource usage: ZERO overhead - simple request/response
    """
    speeds = get_robot_joint_speeds()
    if not speeds:
        return False
    
    max_speed = max(abs(s) for s in speeds)
    return max_speed < threshold_speed

def is_estop_pressed() -> bool:
    """
    Check if the E-stop is currently pressed.
    
    Returns:
        True if E-stop is pressed, False otherwise
        
    Resource usage: ZERO overhead - simple request/response
    """
    io_status = get_robot_io()
    if io_status and len(io_status) >= 5:
        return io_status[4] == 0  # E-stop is at index 4, 0 means pressed
    return False

def get_robot_status() -> Dict:
    """
    Get comprehensive robot status in one call.
    
    Returns:
        Dictionary with pose, angles, speeds, IO, gripper status
        
    Resource usage: Multiple requests but still zero overhead
    """
    return {
        'pose': get_robot_pose(),
        'angles': get_robot_joint_angles(),
        'speeds': get_robot_joint_speeds(),
        'io': get_robot_io(),
        'gripper': get_electric_gripper_status(),
        'stopped': is_robot_stopped(),
        'estop': is_estop_pressed()
    }

# ============================================================================
# TRACKING FUNCTIONS - ONLY FOR EXPLICIT USE
# ============================================================================

def check_command_status(command_id: str) -> Optional[Dict]:
    """
    Check status - returns None if tracker not initialized.
    Does NOT initialize tracker (read-only).
    """
    if _command_tracker and _command_tracker.is_active():
        return _command_tracker.get_status(command_id)
    return None

def is_tracking_active() -> bool:
    """
    Check if tracking is active.
    Returns False if never used (zero overhead check).
    """
    return _command_tracker is not None and _command_tracker.is_active()

def get_tracking_stats() -> Dict:
    """
    Get resource usage statistics.
    """
    if _command_tracker and _command_tracker.is_active():
        with _command_tracker.lock:
            return {
                'active': True,
                'commands_tracked': len(_command_tracker.command_history),
                'memory_bytes': len(str(_command_tracker.command_history)),
                'thread_active': _command_tracker._thread.is_alive() if _command_tracker._thread else False
            }
    else:
        return {
            'active': False,
            'commands_tracked': 0,
            'memory_bytes': 0,
            'thread_active': False
        }

# ============================================================================
# CONVENIENCE FUNCTIONS FOR COMMON OPERATIONS
# ============================================================================

def wait_for_robot_stopped(timeout: float = 10.0, poll_rate: float = 0.1) -> bool:
    """
    Wait for the robot to stop moving.
    
    Args:
        timeout: Maximum time to wait in seconds
        poll_rate: How often to check in seconds
        
    Returns:
        True if robot stopped, False if timeout
    """
    import time
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        if is_robot_stopped():
            return True
        time.sleep(poll_rate)
    
    return False

def safe_move_with_retry(
    move_func,
    *args,
    max_retries: int = 3,
    retry_delay: float = 1.0,
    **kwargs
):
    """
    Execute a move command with automatic retry on failure.
    
    Args:
        move_func: The movement function to call
        *args: Arguments for the movement function
        max_retries: Maximum number of retry attempts
        retry_delay: Delay between retries in seconds
        **kwargs: Keyword arguments for the movement function
        
    Returns:
        Result from the movement function or error dict
    """
    import time
    
    # Ensure tracking is enabled for retry logic
    kwargs['wait_for_ack'] = True
    
    for attempt in range(max_retries):
        result = move_func(*args, **kwargs)
        
        if isinstance(result, dict):
            if result.get('status') in ['COMPLETED', 'QUEUED', 'EXECUTING']:
                return result
            elif result.get('status') in ['FAILED', 'TIMEOUT', 'CANCELLED']:
                if attempt < max_retries - 1:
                    print(f"Attempt {attempt + 1} failed: {result.get('details', 'Unknown error')}")
                    print(f"Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                else:
                    print(f"All {max_retries} attempts failed")
                    return result
        else:
            # Non-tracked response, assume success
            return result
    
    return {'status': 'FAILED', 'details': f'Failed after {max_retries} attempts'}
````

## File: run_headless_complete_fix.py
````python
#!/usr/bin/env python3
"""
PAROL6 Headless Commander 完整修复版
修复所有Linux串口相关问题，包括com_port_str变量定义
"""
import os
import sys
import platform
import serial
import serial.tools.list_ports
import time

def init_serial_connection():
    """初始化串口连接并返回串口对象和端口字符串"""
    print("🔧 Initializing serial connection for Linux...")
    
    ser = None
    com_port_str = None
    
    # 尝试从文件读取串口配置
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"✅ Connected to saved serial port: {com_port_str}")
            return ser, com_port_str
    except (FileNotFoundError, serial.SerialException) as e:
        print(f"⚠️ Could not connect to saved port: {e}")
    
    # 尝试默认端口
    default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
    print("🔍 Trying default ports...")
    
    for port in default_ports:
        if os.path.exists(port):
            try:
                ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                com_port_str = port
                print(f"✅ Successfully connected to {port}")
                # 保存成功的端口到文件
                with open("com_port.txt", "w") as f:
                    f.write(port)
                return ser, com_port_str
            except serial.SerialException as e:
                print(f"❌ Failed to connect to {port}: {e}")
                continue
        else:
            print(f"⚠️ Port {port} does not exist")
    
    # 如果都失败了，显示错误信息
    print("\n❌ Could not connect to any serial port.")
    print("\nAvailable serial ports:")
    ports = serial.tools.list_ports.comports()
    if ports:
        for port in ports:
            print(f"  📡 {port.device} - {port.description}")
    else:
        print("  No serial ports detected!")
    
    print("\n🔧 Troubleshooting:")
    print("1. Make sure the robot is connected and powered on")
    print("2. Check if user has permission to access serial ports:")
    print("   sudo usermod -a -G dialout $USER")
    print("   (then logout and login again)")
    print("3. Try running with sudo (temporary fix):")
    print("   sudo -E python run_headless_complete_fix.py")
    
    return None, None

def patch_and_run_original():
    """读取、修复并运行原始脚本"""
    # 初始化串口连接
    ser, com_port_str = init_serial_connection()
    
    if ser is None or com_port_str is None:
        print("❌ Failed to initialize serial connection. Exiting.")
        sys.exit(1)
    
    print(f"✅ Serial connection established: {ser.port}")
    
    # 读取原始脚本
    with open('headless_commander.py', 'r') as f:
        script_content = f.read()
    
    # 创建修复后的全局命名空间
    script_globals = globals().copy()
    script_globals.update({
        'ser': ser,
        'com_port_str': com_port_str,
        'my_os': platform.system()
    })
    
    print("🚀 Starting PAROL6 headless commander...")
    print(f"📡 Using serial port: {com_port_str}")
    print("🔄 Press Ctrl+C to stop\n")
    
    try:
        # 执行原始脚本
        exec(script_content, script_globals)
    except KeyboardInterrupt:
        print("\n⏹️ Program interrupted by user")
    except Exception as e:
        print(f"\n❌ Error running program: {e}")
        import traceback
        traceback.print_exc()
    finally:
        # 清理串口连接
        if ser and ser.is_open:
            print("🔌 Closing serial connection...")
            ser.close()

if __name__ == "__main__":
    print("🤖 PAROL6 Headless Commander - Linux Complete Fix")
    print("=" * 50)
    
    # 检查是否在Linux系统上
    if platform.system() == "Windows":
        print("ℹ️ This is a Linux-specific fix. On Windows, run headless_commander.py directly.")
        sys.exit(1)
    
    # 检查文件是否存在
    if not os.path.exists('headless_commander.py'):
        print("❌ headless_commander.py not found in current directory!")
        sys.exit(1)
    
    patch_and_run_original()
````

## File: run_headless_fixed.py
````python
#!/usr/bin/env python3
"""
PAROL6 Headless Commander 启动器 - Linux修复版
修复原始脚本中缺少Linux串口初始化的问题
"""
import os
import sys
import platform
import serial
import serial.tools.list_ports

def init_serial():
    """初始化串口连接"""
    print("Initializing serial connection...")
    
    my_os = platform.system()
    ser = None
    
    if my_os != "Windows":
        # Linux/Mac系统
        try:
            # 尝试从文件读取串口配置
            with open("com_port.txt", "r") as f:
                com_port_str = f.read().strip()
                ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
                print(f"Connected to saved serial port: {com_port_str}")
        except (FileNotFoundError, serial.SerialException) as e:
            print(f"Could not connect to saved port: {e}")
            # 尝试默认端口
            default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
            for port in default_ports:
                try:
                    ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                    print(f"Successfully connected to {port}")
                    # 保存成功的端口到文件
                    with open("com_port.txt", "w") as f:
                        f.write(port)
                    break
                except serial.SerialException as e:
                    print(f"Failed to connect to {port}: {e}")
                    continue
            
            if ser is None:
                print("\nError: Could not connect to any serial port.")
                print("\nAvailable serial ports:")
                ports = serial.tools.list_ports.comports()
                if ports:
                    for port in ports:
                        print(f"  {port.device} - {port.description}")
                else:
                    print("  No serial ports found!")
                
                print("\nTroubleshooting:")
                print("1. Make sure the robot is connected and powered on")
                print("2. Check if user has permission to access serial ports:")
                print("   sudo usermod -a -G dialout $USER")
                print("   (then logout and login again)")
                print("3. Check device permissions:")
                print("   ls -l /dev/ttyACM* /dev/ttyUSB*")
                print("4. Try running with sudo (temporary fix):")
                print("   sudo -E python run_headless_fixed.py")
                return None
    
    return ser

def run_original_with_ser(ser):
    """运行原始脚本，预先定义ser变量"""
    # 将ser变量注入全局命名空间
    globals()['ser'] = ser
    
    # 读取原始脚本内容
    with open('headless_commander.py', 'r') as f:
        script_content = f.read()
    
    # 在全局命名空间中执行脚本
    print("Starting PAROL6 headless commander...")
    exec(script_content, globals())

if __name__ == "__main__":
    # 初始化串口
    ser = init_serial()
    
    if ser is not None:
        print(f"Serial port initialized successfully: {ser.port}")
        try:
            run_original_with_ser(ser)
        except KeyboardInterrupt:
            print("\nProgram interrupted by user")
            if ser and ser.is_open:
                ser.close()
        except Exception as e:
            print(f"Error running program: {e}")
            if ser and ser.is_open:
                ser.close()
    else:
        print("Failed to initialize serial connection. Exiting.")
        sys.exit(1)
````

## File: run_headless_linux.py
````python
#!/usr/bin/env python3
"""
启动器脚本来修复headless_commander.py中的Linux串口问题
"""
import platform
import serial
import serial.tools.list_ports

def initialize_serial_for_linux():
    """为Linux系统初始化串口连接"""
    ser = None
    
    # 尝试从文件读取串口配置
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved serial port: {com_port_str}")
            return ser
    except (FileNotFoundError, serial.SerialException) as e:
        print(f"Failed to connect to saved port: {e}")
    
    # 尝试默认端口
    default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
    for port in default_ports:
        try:
            ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
            print(f"Successfully connected to {port}")
            # 保存成功的端口到文件
            with open("com_port.txt", "w") as f:
                f.write(port)
            return ser
        except serial.SerialException:
            print(f"Failed to connect to {port}")
            continue
    
    # 如果都失败了，显示可用端口并要求用户输入
    print("Could not find any available serial ports.")
    ports = serial.tools.list_ports.comports()
    if ports:
        print("Available ports:")
        for port in ports:
            print(f"  {port.device}")
    else:
        print("No serial ports detected!")
    
    while True:
        try:
            com_port = input("Enter the serial port (e.g., /dev/ttyACM0): ").strip()
            if not com_port:
                continue
            ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
            print(f"Successfully connected to {com_port}")
            # 保存成功的端口到文件
            with open("com_port.txt", "w") as f:
                f.write(com_port)
            return ser
        except serial.SerialException as e:
            print(f"Could not open port {com_port}: {e}. Please try again.")

if __name__ == "__main__":
    print("Initializing serial connection for Linux...")
    
    my_os = platform.system()
    if my_os != "Windows":
        ser = initialize_serial_for_linux()
        if ser:
            # 将ser变量注入到全局命名空间，然后导入原始脚本
            import sys
            import os
            
            # 临时将ser添加到builtins中，这样原始脚本就能看到它
            import builtins
            builtins.ser = ser
            
            print("Serial connection established. Starting main program...")
            
            # 现在执行原始脚本
            exec(compile(open("headless_commander.py").read(), "headless_commander.py", 'exec'))
        else:
            print("Failed to establish serial connection!")
            sys.exit(1)
    else:
        print("This is a Linux-specific fix. On Windows, run headless_commander.py directly.")
        sys.exit(1)
````

## File: run_minimal.py
````python
#!/usr/bin/env python3
"""
PAROL6 Headless Commander 最小化启动器
直接初始化串口并运行原始程序
"""
import os
import sys
import serial
import platform

# 设置环境
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ['PYTHONPATH'] = os.pathsep.join([
    os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
    os.environ.get('PYTHONPATH', '')
])

# 初始化串口
print("🔧 初始化串口...")
try:
    ser = serial.Serial(
        port='/dev/ttyACM0',
        baudrate=3000000,
        timeout=0
    )
    com_port_str = '/dev/ttyACM0'
    print(f"✅ 串口连接成功: {com_port_str}")
except Exception as e:
    print(f"❌ 串口初始化失败: {e}")
    sys.exit(1)

# 设置全局变量
import builtins
builtins.ser = ser
builtins.com_port_str = com_port_str
builtins.my_os = platform.system()

# 运行原始程序
print("🚀 启动PAROL6 Headless Commander...")
print("-" * 50)

try:
    exec(open('headless_commander.py').read(), {
        '__name__': '__main__',
        'ser': ser,
        'com_port_str': com_port_str,
        'my_os': platform.system()
    })
except KeyboardInterrupt:
    print("\n⏹️ 程序被用户中断")
except Exception as e:
    print(f"\n❌ 运行错误: {e}")
    import traceback
    traceback.print_exc()
finally:
    if ser and ser.is_open:
        ser.close()
        print("🔌 串口已关闭")
````

## File: run_parol6_fixed.py
````python
#!/usr/bin/env python3
"""
PAROL6 Headless Commander - 完整Linux修复版
修复所有串口连接问题并提供稳定的运行环境
"""
import os
import sys
import platform
import serial
import serial.tools.list_ports
import time
import threading

# 添加上级目录到Python路径（用于导入GUI模块）
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def check_permissions():
    """检查串口权限"""
    import grp
    import pwd
    
    username = pwd.getpwuid(os.getuid()).pw_name
    groups = [g.gr_name for g in grp.getgrall() if username in g.gr_mem]
    
    if 'dialout' not in groups:
        print("⚠️  警告: 用户不在dialout组中")
        print("   请运行: sudo usermod -a -G dialout $USER")
        print("   然后重新登录")
        return False
    return True

def init_serial_connection():
    """初始化串口连接"""
    print("🔧 初始化Linux串口连接...")
    
    ser = None
    com_port_str = None
    
    # 1. 检查权限
    if not check_permissions():
        print("⚠️  继续尝试连接（可能需要sudo）...")
    
    # 2. 尝试从文件读取上次使用的端口
    try:
        with open("com_port.txt", "r") as f:
            saved_port = f.read().strip()
            if os.path.exists(saved_port):
                try:
                    ser = serial.Serial(
                        port=saved_port,
                        baudrate=3000000,
                        timeout=0.1,
                        write_timeout=0.1
                    )
                    com_port_str = saved_port
                    print(f"✅ 连接到保存的端口: {saved_port}")
                    return ser, com_port_str
                except serial.SerialException as e:
                    print(f"⚠️  无法连接到保存的端口 {saved_port}: {e}")
    except FileNotFoundError:
        pass
    
    # 3. 自动检测可用端口
    print("🔍 扫描可用串口...")
    
    # 默认端口列表
    default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
    
    for port in default_ports:
        if os.path.exists(port):
            print(f"  尝试 {port}...")
            try:
                ser = serial.Serial(
                    port=port,
                    baudrate=3000000,
                    timeout=0.1,
                    write_timeout=0.1
                )
                com_port_str = port
                print(f"✅ 成功连接到 {port}")
                
                # 保存成功的端口
                with open("com_port.txt", "w") as f:
                    f.write(port)
                
                return ser, com_port_str
            except serial.SerialException as e:
                print(f"  ❌ 无法连接到 {port}: {e}")
                continue
    
    # 4. 列出所有可用串口供选择
    print("\n📡 可用的串口设备:")
    ports = serial.tools.list_ports.comports()
    
    if not ports:
        print("  未检测到任何串口设备!")
        print("\n排查步骤:")
        print("1. 确认机械臂已连接并上电")
        print("2. 检查USB线缆连接")
        print("3. 运行 'lsusb' 查看USB设备")
        return None, None
    
    for i, port in enumerate(ports):
        print(f"  [{i}] {port.device} - {port.description}")
    
    # 5. 让用户选择（或自动尝试所有）
    for port in ports:
        if "ACM" in port.device or "USB" in port.device:
            try:
                ser = serial.Serial(
                    port=port.device,
                    baudrate=3000000,
                    timeout=0.1,
                    write_timeout=0.1
                )
                com_port_str = port.device
                print(f"✅ 成功连接到 {port.device}")
                
                with open("com_port.txt", "w") as f:
                    f.write(port.device)
                
                return ser, com_port_str
            except Exception as e:
                continue
    
    print("\n❌ 无法连接到任何串口")
    return None, None


def run_headless_commander():
    """运行headless commander主程序"""
    print("\n🚀 启动PAROL6 Headless Commander...")
    
    # 初始化串口
    ser, com_port_str = init_serial_connection()
    
    if ser is None or com_port_str is None:
        print("❌ 无法初始化串口连接")
        print("\n可能的解决方案:")
        print("1. 使用sudo运行: sudo -E python run_parol6_fixed.py")
        print("2. 添加用户到dialout组: sudo usermod -a -G dialout $USER")
        print("3. 检查设备连接和电源")
        return False
    
    print(f"📡 使用串口: {com_port_str}")
    print(f"⚡ 波特率: 3000000")
    
    # 准备运行原始脚本
    script_path = os.path.join(os.path.dirname(__file__), 'headless_commander.py')
    
    if not os.path.exists(script_path):
        print(f"❌ 找不到 {script_path}")
        return False
    
    # 读取原始脚本
    with open(script_path, 'r') as f:
        script_content = f.read()
    
    # 设置全局变量
    script_globals = {
        '__name__': '__main__',
        '__file__': script_path,
        'ser': ser,
        'com_port_str': com_port_str,
        'my_os': platform.system()
    }
    
    # 添加所需的导入
    import_code = """
import serial
import serial.tools.list_ports
import platform
import sys
import os
import time
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
"""
    
    print("\n✅ 串口连接就绪")
    print("🤖 按Ctrl+C停止程序\n")
    print("-" * 50)
    
    try:
        # 先执行导入
        exec(import_code, script_globals)
        # 然后执行主脚本
        exec(script_content, script_globals)
        return True
    except KeyboardInterrupt:
        print("\n\n⏹️  用户中断程序")
        return True
    except Exception as e:
        print(f"\n❌ 运行错误: {e}")
        import traceback
        traceback.print_exc()
        return False
    finally:
        # 清理
        if ser and ser.is_open:
            print("🔌 关闭串口连接...")
            ser.close()


def main():
    """主函数"""
    print("=" * 60)
    print("🤖 PAROL6 Headless Commander - Linux完整修复版")
    print("=" * 60)
    
    # 检查操作系统
    if platform.system() == "Windows":
        print("ℹ️  这是Linux修复版。Windows请直接运行headless_commander.py")
        return 1
    
    # 检查Python版本
    if sys.version_info < (3, 6):
        print(f"❌ 需要Python 3.6或更高版本，当前版本: {sys.version}")
        return 1
    
    # 检查必要的依赖
    try:
        import serial
        import numpy
        import roboticstoolbox
    except ImportError as e:
        print(f"❌ 缺少依赖: {e}")
        print("请运行: pip install pyserial numpy roboticstoolbox-python")
        return 1
    
    # 运行主程序
    if run_headless_commander():
        print("\n✅ 程序正常退出")
        return 0
    else:
        print("\n❌ 程序异常退出")
        return 1

if __name__ == "__main__":
    sys.exit(main())
````

## File: run_patched.py
````python
#!/usr/bin/env python3
"""
PAROL6 Headless Commander - 完整Linux修补版
修复原始文件缺少Linux串口初始化的问题
"""
import os
import sys
import serial
import platform
import serial.tools.list_ports

# 添加上级目录到Python路径
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def patch_headless_commander():
    """修补headless_commander.py以支持Linux"""
    
    # 读取原始文件
    with open('headless_commander.py', 'r') as f:
        content = f.read()
    
    # 找到Windows串口初始化的位置
    windows_init_start = content.find('my_os = platform.system()')
    if windows_init_start == -1:
        print("❌ 找不到操作系统检测代码")
        return None
    
    # 找到结束位置（第一个int_to_3_bytes定义）
    init_end = content.find('# in big endian machines')
    if init_end == -1:
        print("❌ 找不到初始化代码结束位置")
        return None
    
    # 创建新的初始化代码（支持Windows和Linux）
    new_init_code = '''
my_os = platform.system()

# Initialize serial port based on OS
ser = None
com_port_str = None

if my_os == "Windows":
    # Windows serial port initialization
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved COM port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        while True:
            try:
                com_port = input("Enter the COM port (e.g., COM9): ")
                ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                com_port_str = com_port
                print(f"Successfully connected to {com_port}")
                with open("com_port.txt", "w") as f:
                    f.write(com_port)
                break
            except serial.SerialException:
                print(f"Could not open port {com_port}. Please try again.")

else:  # Linux/Mac
    # Linux serial port initialization
    print("🔧 Initializing serial port for Linux/Mac...")
    
    # Try to read saved port
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            if os.path.exists(com_port_str):
                ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
                print(f"✅ Connected to saved port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException) as e:
        print(f"⚠️ Could not connect to saved port: {e}")
        ser = None
    
    # If not connected, try default ports
    if ser is None:
        default_ports = ["/dev/ttyACM0", "/dev/ttyUSB0", "/dev/ttyACM1", "/dev/ttyUSB1"]
        for port in default_ports:
            if os.path.exists(port):
                try:
                    ser = serial.Serial(port=port, baudrate=3000000, timeout=0)
                    com_port_str = port
                    print(f"✅ Connected to {port}")
                    with open("com_port.txt", "w") as f:
                        f.write(port)
                    break
                except serial.SerialException as e:
                    print(f"❌ Failed to connect to {port}: {e}")
    
    # If still not connected, list available ports
    if ser is None:
        print("\\n📡 Available serial ports:")
        ports = serial.tools.list_ports.comports()
        for port in ports:
            print(f"  • {port.device} - {port.description}")
        
        # Try to connect to the first available ACM/USB port
        for port in ports:
            if "ACM" in port.device or "USB" in port.device:
                try:
                    ser = serial.Serial(port=port.device, baudrate=3000000, timeout=0)
                    com_port_str = port.device
                    print(f"✅ Connected to {port.device}")
                    with open("com_port.txt", "w") as f:
                        f.write(port.device)
                    break
                except Exception:
                    pass
        
        if ser is None:
            print("\\n❌ Could not connect to any serial port!")
            print("Please check:")
            print("1. Robot is connected and powered on")
            print("2. User has permission (sudo usermod -a -G dialout $USER)")
            print("3. No other program is using the serial port")
            sys.exit(1)

print(f"📡 Using serial port: {com_port_str}")
print(f"⚡ Baudrate: 3000000")
print("🤖 PAROL6 Headless Commander Ready\\n")

'''
    
    # 替换初始化代码
    new_content = (
        content[:windows_init_start] + 
        new_init_code + 
        content[init_end:]
    )
    
    return new_content

def main():
    print("=" * 60)
    print("🔧 PAROL6 Headless Commander - Linux修补器")
    print("=" * 60)
    
    # 修补文件
    patched_content = patch_headless_commander()
    if patched_content is None:
        print("❌ 修补失败")
        return 1
    
    # 保存修补后的文件
    with open('headless_commander_patched.py', 'w') as f:
        f.write(patched_content)
    
    print("✅ 已创建修补文件: headless_commander_patched.py")
    print("\n🚀 正在运行修补后的程序...")
    print("-" * 60)
    
    # 运行修补后的程序
    try:
        exec(patched_content, {'__name__': '__main__'})
    except KeyboardInterrupt:
        print("\n⏹️ 程序被用户中断")
    except Exception as e:
        print(f"\n❌ 运行错误: {e}")
        import traceback
        traceback.print_exc()
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
````

## File: smooth_motion.py.backup_1757427986
````
"""
Smooth Motion Module for PAROL6 Robotic Arm
============================================
This module provides advanced trajectory generation capabilities including:
- Circular and arc movements
- Cubic spline trajectories
- Motion blending
- Pre-computed and real-time trajectory generation

Compatible with:
- numpy==1.23.4
- scipy==1.11.4
- roboticstoolbox-python==1.0.3
"""

import sys
import warnings
from collections import namedtuple
from roboticstoolbox import DHRobot
from spatialmath.base import trinterp

# Version compatibility check
try:
    import numpy as np
    # Check numpy version
    np_version = tuple(map(int, np.__version__.split('.')[:2]))
    if np_version < (1, 23):
        warnings.warn(f"NumPy version {np.__version__} detected. Recommended: 1.23.4")
    
    from scipy.interpolate import CubicSpline
    from scipy.spatial.transform import Rotation, Slerp
    import scipy
    # Check scipy version
    scipy_version = tuple(map(int, scipy.__version__.split('.')[:2]))
    if scipy_version < (1, 11):
        warnings.warn(f"SciPy version {scipy.__version__} detected. Recommended: 1.11.4")
        
except ImportError as e:
    print(f"Error importing required packages: {e}")
    print("Please install: pip3 install numpy==1.23.4 scipy==1.11.4")
    sys.exit(1)

from spatialmath import SE3
import time
from typing import List, Tuple, Optional, Dict, Union
from collections import deque

# Import PAROL6 specific modules (these should be in your path)
try:
    import GUI.files.PAROL6_ROBOT
except ImportError:
    print("Warning: PAROL6 modules not found. Some functions may not work.")
    PAROL6_ROBOT = None

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

# IK Result structure
IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179° and 181° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities.
    If necessary, recursively subdivide the motion until ikine_LMS converges
    on every segment. Finally check that solution respects joint limits.
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # ── inner recursive solver───────────────────
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            if current_reach >= max_reach_threshold:
                print(f"Reach limit exceeded: {current_reach:.3f} >= {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LMS(Tb, q0=q_seed, ilimit=ilimit, tol=tol, wN=damping)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # ── kick-off with adaptive tolerance ──────────────────────────────────
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    
    # Check if solution respects joint limits
    if PAROL6_ROBOT is not None:
        target_q = path[-1] if len(path) != 0 else None
        solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
        if ok and solution_valid:
            return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, violations)
    else:
        # If PAROL6_ROBOT not available, skip joint limit checking
        if ok and len(path) > 0:
            return IKResult(True, path[-1], its, resid, adaptive_tol, None)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, None)

# ============================================================================
# END OF IK SOLVER FUNCTIONS
# ============================================================================

class TrajectoryGenerator:
    """Base class for trajectory generation with caching support"""
    
    def __init__(self, control_rate: float = 100.0):
        """
        Initialize trajectory generator
        
        Args:
            control_rate: Control loop frequency in Hz (default 100Hz for PAROL6)
        """
        self.control_rate = control_rate
        self.dt = 1.0 / control_rate
        self.trajectory_cache = {}
        
    def generate_timestamps(self, duration: float) -> np.ndarray:
        """Generate evenly spaced timestamps for trajectory"""
        num_points = int(duration * self.control_rate)
        return np.linspace(0, duration, num_points)

class CircularMotion(TrajectoryGenerator):
    """Generate circular and arc trajectories in 3D space"""
    
    def generate_arc_3d(self, 
                       start_pose: List[float], 
                       end_pose: List[float], 
                       center: List[float], 
                       normal: Optional[List[float]] = None,
                       clockwise: bool = True,
                       duration: float = 2.0) -> np.ndarray:
        """
        Generate a 3D circular arc trajectory
        
        Args:
            start_pose: Starting pose [x, y, z, rx, ry, rz] (mm and degrees)
            end_pose: Ending pose [x, y, z, rx, ry, rz] (mm and degrees)
            center: Center point of arc [x, y, z] (mm)
            normal: Normal vector to arc plane (default: z-axis)
            clockwise: Direction of rotation
            duration: Time to complete arc (seconds)
            
        Returns:
            Array of poses along the arc trajectory
        """
        # Convert to numpy arrays
        start_pos = np.array(start_pose[:3])
        end_pos = np.array(end_pose[:3])
        center_pt = np.array(center)
        
        # Calculate radius vectors
        r1 = start_pos - center_pt
        r2 = end_pos - center_pt
        radius = np.linalg.norm(r1)
        
        # Determine arc plane normal if not provided
        if normal is None:
            normal = np.cross(r1, r2)
            if np.linalg.norm(normal) < 1e-6:  # Points are collinear
                normal = np.array([0, 0, 1])  # Default to XY plane
        normal = normal / np.linalg.norm(normal)
        
        # Calculate arc angle
        r1_norm = r1 / np.linalg.norm(r1)
        r2_norm = r2 / np.linalg.norm(r2)
        cos_angle = np.clip(np.dot(r1_norm, r2_norm), -1, 1)
        arc_angle = np.arccos(cos_angle)
        
        # Check direction using cross product
        cross = np.cross(r1_norm, r2_norm)
        if np.dot(cross, normal) < 0:
            arc_angle = 2 * np.pi - arc_angle
            
        if clockwise:
            arc_angle = -arc_angle
            
        # Generate trajectory points
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        for i, t in enumerate(timestamps):
            # Interpolation factor
            s = t / duration
            
            # For first point, use exact start position
            if i == 0:
                current_pos = start_pos
            else:
                # Rotate radius vector
                angle = s * arc_angle
                rot_matrix = self._rotation_matrix_from_axis_angle(normal, angle)
                current_pos = center_pt + rot_matrix @ r1
            
            # Interpolate orientation (SLERP)
            current_orient = self._slerp_orientation(start_pose[3:], end_pose[3:], s)
            
            # Combine position and orientation
            pose = np.concatenate([current_pos, current_orient])
            trajectory.append(pose)
            
        return np.array(trajectory)
    
    def generate_circle_3d(self,
                      center: List[float],
                      radius: float,
                      normal: List[float] = [0, 0, 1],
                      start_angle: float = None,
                      duration: float = 4.0,
                      start_point: List[float] = None) -> np.ndarray:
        """
        Generate a complete circle trajectory that starts at start_point
        """
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        # Create orthonormal basis for circle plane
        normal = np.array(normal) / np.linalg.norm(normal)
        u = self._get_perpendicular_vector(normal)
        v = np.cross(normal, u)
        
        center_np = np.array(center)
        
        # CRITICAL FIX: Validate and handle geometry
        if start_point is not None:
            start_pos = np.array(start_point[:3])
            
            # Project start point onto the circle plane
            to_start = start_pos - center_np
            to_start_plane = to_start - np.dot(to_start, normal) * normal
            
            # Get distance from center in the plane
            dist_in_plane = np.linalg.norm(to_start_plane)
            
            if dist_in_plane < 0.001:
                # Start point is at center - can't determine angle
                print(f"    WARNING: Start point is at circle center, using default position")
                start_angle = 0
                actual_start = center_np + radius * u
            else:
                # Calculate the angle of the start point
                to_start_normalized = to_start_plane / dist_in_plane
                u_comp = np.dot(to_start_normalized, u)
                v_comp = np.dot(to_start_normalized, v)
                start_angle = np.arctan2(v_comp, u_comp)
                
                # CHECK FOR INVALID GEOMETRY
                radius_error = abs(dist_in_plane - radius)
                if radius_error > radius * 0.3:  # More than 30% off
                    print(f"    WARNING: Start point is {dist_in_plane:.1f}mm from center,")
                    print(f"             but circle radius is {radius:.1f}mm!")
                    
                    # AUTO-CORRECT: Adjust center to make geometry valid
                    print(f"    AUTO-CORRECTING: Moving center to maintain {radius}mm radius from start")
                    direction = to_start_plane / dist_in_plane
                    center_np = start_pos - direction * radius
                    print(f"    New center: {center_np.round(1)}")
                    
                    # Recalculate with new center
                    to_start = start_pos - center_np
                    to_start_plane = to_start - np.dot(to_start, normal) * normal
                    dist_in_plane = np.linalg.norm(to_start_plane)
                
                actual_start = start_pos
        else:
            start_angle = 0 if start_angle is None else start_angle
            actual_start = None
        
        # Generate the circle 
        for i, t in enumerate(timestamps):
            if i == 0 and actual_start is not None:
                # First point MUST be exactly the start point
                pos = actual_start
            else:
                # Generate circle points
                angle = start_angle + (2 * np.pi * t / duration)
                pos = center_np + radius * (np.cos(angle) * u + np.sin(angle) * v)
            
            # Placeholder orientation (will be overridden)
            orient = [0, 0, 0]
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def _rotation_matrix_from_axis_angle(self, axis: np.ndarray, angle: float) -> np.ndarray:
        """Generate rotation matrix using Rodrigues' formula"""
        axis = axis / np.linalg.norm(axis)
        cos_a = np.cos(angle)
        sin_a = np.sin(angle)
        
        # Cross-product matrix
        K = np.array([[0, -axis[2], axis[1]],
                     [axis[2], 0, -axis[0]],
                     [-axis[1], axis[0], 0]])
        
        # Rodrigues' formula
        R = np.eye(3) + sin_a * K + (1 - cos_a) * K @ K
        return R
    
    def _get_perpendicular_vector(self, v: np.ndarray) -> np.ndarray:
        """Find a vector perpendicular to the given vector"""
        v = np.array(v)  # Ensure it's a numpy array
        if abs(v[0]) < 0.9:
            return np.cross(v, [1, 0, 0]) / np.linalg.norm(np.cross(v, [1, 0, 0]))
        else:
            return np.cross(v, [0, 1, 0]) / np.linalg.norm(np.cross(v, [0, 1, 0]))
    
    def _slerp_orientation(self, start_orient: List[float], 
                          end_orient: List[float], 
                          t: float) -> np.ndarray:
        """Spherical linear interpolation for orientation"""
        # Convert to quaternions
        r1 = Rotation.from_euler('xyz', start_orient, degrees=True)
        r2 = Rotation.from_euler('xyz', end_orient, degrees=True)
        
        # Create slerp object - compatible with scipy 1.11.4
        # Stack rotations into a single Rotation object
        key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
        slerp = Slerp([0, 1], key_rots)
        
        # Interpolate
        interp_rot = slerp(t)
        return interp_rot.as_euler('xyz', degrees=True)

class SplineMotion(TrajectoryGenerator):
    """Generate smooth spline trajectories through waypoints"""
    
    def generate_cubic_spline(self,
                             waypoints: List[List[float]],
                             timestamps: Optional[List[float]] = None,
                             velocity_start: Optional[List[float]] = None,
                             velocity_end: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate cubic spline trajectory through waypoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint (auto-generated if None)
            velocity_start: Initial velocity (zero if None)
            velocity_end: Final velocity (zero if None)
            
        Returns:
            Array of interpolated poses
        """
        waypoints = np.array(waypoints)
        num_waypoints = len(waypoints)
        
        # Auto-generate timestamps if not provided
        if timestamps is None:
            # Estimate based on distance
            total_dist = 0
            for i in range(1, num_waypoints):
                dist = np.linalg.norm(waypoints[i, :3] - waypoints[i-1, :3])
                total_dist += dist
            
            # Assume average speed of 50 mm/s
            total_time = total_dist / 50.0
            timestamps = np.linspace(0, total_time, num_waypoints)
        
        # Create splines for position
        pos_splines = []
        for i in range(3):
            bc_type = 'not-a-knot'  # Default boundary condition
            
            # Apply velocity boundary conditions if specified
            if velocity_start is not None and velocity_end is not None:
                bc_type = ((1, velocity_start[i]), (1, velocity_end[i]))
            
            spline = CubicSpline(timestamps, waypoints[:, i], bc_type=bc_type)
            pos_splines.append(spline)
        
        # Create splines for orientation (convert to quaternions for smooth interpolation)
        rotations = [Rotation.from_euler('xyz', wp[3:], degrees=True) for wp in waypoints]
        # Stack quaternions for scipy 1.11.4 compatibility
        quats = np.array([r.as_quat() for r in rotations])
        key_rots = Rotation.from_quat(quats)
        slerp = Slerp(timestamps, key_rots)
        
        # Generate dense trajectory
        t_eval = self.generate_timestamps(timestamps[-1])
        trajectory = []
        
        for t in t_eval:
            # Evaluate position splines
            pos = [spline(t) for spline in pos_splines]
            
            # Evaluate orientation
            rot = slerp(t)
            orient = rot.as_euler('xyz', degrees=True)
            
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def generate_quintic_spline(self,
                               waypoints: List[List[float]],
                               timestamps: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate quintic (5th order) spline with zero velocity and acceleration at endpoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint
            
        Returns:
            Array of interpolated poses
        """
        # For quintic spline, we need to ensure zero velocity and acceleration
        # at the endpoints for smooth motion
        return self.generate_cubic_spline(
            waypoints, 
            timestamps,
            velocity_start=[0, 0, 0],
            velocity_end=[0, 0, 0]
        )

class MotionBlender:
    """Blend between different motion segments for smooth transitions"""
    
    def __init__(self, blend_time: float = 0.5):
        self.blend_time = blend_time
        
    def blend_trajectories(self, traj1, traj2, blend_samples=50):
        """Blend two trajectory segments with improved velocity continuity"""
        
        if blend_samples < 4:
            return np.vstack([traj1, traj2])
        
        # Use more samples for smoother blending
        blend_samples = max(blend_samples, 20)  # Minimum 20 samples for smooth blend
        
        # Calculate overlap region more carefully
        overlap_start = max(0, len(traj1) - blend_samples // 3)
        overlap_end = min(len(traj2), blend_samples // 3)
        
        # Extract blend region
        blend_start_pose = traj1[overlap_start] if overlap_start < len(traj1) else traj1[-1]
        blend_end_pose = traj2[overlap_end] if overlap_end < len(traj2) else traj2[0]
        
        # Generate smooth transition using S-curve
        blended = []
        for i in range(blend_samples):
            t = i / (blend_samples - 1)
            # Use smoothstep function for smoother acceleration
            s = t * t * (3 - 2 * t)  # Smoothstep
            
            # Blend position
            pos_blend = blend_start_pose * (1 - s) + blend_end_pose * s
            
            # For orientation, use SLERP
            r1 = Rotation.from_euler('xyz', blend_start_pose[3:], degrees=True)
            r2 = Rotation.from_euler('xyz', blend_end_pose[3:], degrees=True)
            key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
            slerp = Slerp([0, 1], key_rots)
            orient_blend = slerp(s).as_euler('xyz', degrees=True)
            
            pos_blend[3:] = orient_blend
            blended.append(pos_blend)
        
        # Combine with better overlap handling
        result = np.vstack([
            traj1[:overlap_start],
            np.array(blended),
            traj2[overlap_end:]
        ])
        
        return result

class SmoothMotionCommand:
    """Command class for executing smooth motions on PAROL6"""
    
    def __init__(self, trajectory: np.ndarray, speed_factor: float = 1.0):
        """
        Initialize smooth motion command
        
        Args:
            trajectory: Pre-computed trajectory array
            speed_factor: Speed scaling factor (1.0 = normal speed)
        """
        self.trajectory = trajectory
        self.speed_factor = speed_factor
        self.current_index = 0
        self.is_finished = False
        self.is_valid = True
        
    def prepare_for_execution(self, current_position_in):
        """Validate trajectory is reachable from current position"""
        # Check if IK solver is available
        if solve_ik_with_adaptive_tol_subdivision is None:
            print("Warning: IK solver not available, skipping validation")
            self.is_valid = True
            return True
            
        try:
            # Convert current position to radians
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(current_position_in)])
            
            # Check first waypoint is reachable
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
            )
            
            if not ik_result.success:
                print(f"Smooth motion validation failed: Cannot reach first waypoint")
                self.is_valid = False
                return False
                
            print(f"Smooth motion prepared with {len(self.trajectory)} waypoints")
            return True
            
        except Exception as e:
            print(f"Smooth motion preparation error: {e}")
            self.is_valid = False
            return False
    
    def execute_step(self, Position_in, Speed_out, Command_out, **kwargs):
        """Execute one step of the smooth motion"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Check if required modules are available
        if PAROL6_ROBOT is None or solve_ik_with_adaptive_tol_subdivision is None:
            print("Error: Required PAROL6 modules not available")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Apply speed scaling
        step_increment = max(1, int(self.speed_factor))
        self.current_index += step_increment
        
        if self.current_index >= len(self.trajectory):
            print("Smooth motion completed")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get current target pose
        target_pose = self.trajectory[self.current_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
        )
        
        if not ik_result.success:
            print(f"IK failed at trajectory point {self.current_index}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps and send
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                       for i, q in enumerate(ik_result.q)]
        
        # Calculate velocities for smooth following
        for i in range(6):
            Speed_out[i] = int((target_steps[i] - Position_in[i]) * 10)  # P-control factor
        
        Command_out.value = 156  # Smooth motion command
        return False

# Helper functions for integration with robot_api.py

def execute_circle(center: List[float], 
                  radius: float, 
                  duration: float = 4.0,
                  normal: List[float] = [0, 0, 1]) -> str:
    """
    Execute a circular motion on PAROL6
    
    Args:
        center: Center point [x, y, z] in mm
        radius: Circle radius in mm
        duration: Time to complete circle
        normal: Normal vector to circle plane
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_circle_3d(center, radius, normal, 0, duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|CIRCLE|{traj_str}"
    
    return command

def execute_arc(start_pose: List[float],
               end_pose: List[float],
               center: List[float],
               clockwise: bool = True,
               duration: float = 2.0) -> str:
    """
    Execute an arc motion on PAROL6
    
    Args:
        start_pose: Starting pose [x, y, z, rx, ry, rz]
        end_pose: Ending pose [x, y, z, rx, ry, rz]
        center: Arc center point [x, y, z]
        clockwise: Direction of rotation
        duration: Time to complete arc
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_arc_3d(start_pose, end_pose, center, 
                                           clockwise=clockwise, duration=duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|ARC|{traj_str}"
    
    return command

def execute_spline(waypoints: List[List[float]], 
                  total_time: Optional[float] = None) -> str:
    """
    Execute a spline motion through waypoints
    
    Args:
        waypoints: List of poses [x, y, z, rx, ry, rz]
        total_time: Total time for motion (auto-calculated if None)
        
    Returns:
        Command string for robot_api
    """
    motion_gen = SplineMotion()
    
    # Generate timestamps if total_time is provided
    timestamps = None
    if total_time:
        timestamps = np.linspace(0, total_time, len(waypoints))
    
    trajectory = motion_gen.generate_cubic_spline(waypoints, timestamps)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|SPLINE|{traj_str}"
    
    return command

# Example usage
if __name__ == "__main__":
    # Example: Generate a circle trajectory
    circle_gen = CircularMotion()
    circle_traj = circle_gen.generate_circle_3d(
        center=[200, 0, 200],  # mm
        radius=50,  # mm
        duration=4.0  # seconds
    )
    print(f"Generated circle with {len(circle_traj)} points")
    
    # Example: Generate arc trajectory
    arc_traj = circle_gen.generate_arc_3d(
        start_pose=[250, 0, 200, 0, 0, 0],
        end_pose=[200, 50, 200, 0, 0, 90],
        center=[200, 0, 200],
        duration=2.0
    )
    print(f"Generated arc with {len(arc_traj)} points")
    
    # Example: Generate spline through waypoints
    spline_gen = SplineMotion()
    waypoints = [
        [200, 0, 100, 0, 0, 0],
        [250, 50, 150, 0, 15, 45],
        [200, 100, 200, 0, 30, 90],
        [150, 50, 150, 0, 15, 45],
        [200, 0, 100, 0, 0, 0]
    ]
    spline_traj = spline_gen.generate_cubic_spline(waypoints)
    print(f"Generated spline with {len(spline_traj)} points")
````

## File: smooth_motion.py.backup_wN_1757428702
````
"""
Smooth Motion Module for PAROL6 Robotic Arm
============================================
This module provides advanced trajectory generation capabilities including:
- Circular and arc movements
- Cubic spline trajectories
- Motion blending
- Pre-computed and real-time trajectory generation

Compatible with:
- numpy==1.23.4
- scipy==1.11.4
- roboticstoolbox-python==1.0.3
"""

import sys
import warnings
from collections import namedtuple
from roboticstoolbox import DHRobot
from spatialmath.base import trinterp

# Version compatibility check
try:
    import numpy as np
    # Check numpy version
    np_version = tuple(map(int, np.__version__.split('.')[:2]))
    if np_version < (1, 23):
        warnings.warn(f"NumPy version {np.__version__} detected. Recommended: 1.23.4")
    
    from scipy.interpolate import CubicSpline
    from scipy.spatial.transform import Rotation, Slerp
    import scipy
    # Check scipy version
    scipy_version = tuple(map(int, scipy.__version__.split('.')[:2]))
    if scipy_version < (1, 11):
        warnings.warn(f"SciPy version {scipy.__version__} detected. Recommended: 1.11.4")
        
except ImportError as e:
    print(f"Error importing required packages: {e}")
    print("Please install: pip3 install numpy==1.23.4 scipy==1.11.4")
    sys.exit(1)

from spatialmath import SE3
import time
from typing import List, Tuple, Optional, Dict, Union
from collections import deque

# Import PAROL6 specific modules (these should be in your path)
try:
    import GUI.files.PAROL6_ROBOT
except ImportError:
    print("Warning: PAROL6 modules not found. Some functions may not work.")
    PAROL6_ROBOT = None

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

# IK Result structure
IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179° and 181° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities.
    If necessary, recursively subdivide the motion until ikine_LM converges
    on every segment. Finally check that solution respects joint limits.
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # ── inner recursive solver───────────────────
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            if current_reach >= max_reach_threshold:
                print(f"Reach limit exceeded: {current_reach:.3f} >= {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LM(Tb, q0=q_seed, ilimit=ilimit, tol=tol, wN=damping)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # ── kick-off with adaptive tolerance ──────────────────────────────────
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    
    # Check if solution respects joint limits
    if PAROL6_ROBOT is not None:
        target_q = path[-1] if len(path) != 0 else None
        solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
        if ok and solution_valid:
            return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, violations)
    else:
        # If PAROL6_ROBOT not available, skip joint limit checking
        if ok and len(path) > 0:
            return IKResult(True, path[-1], its, resid, adaptive_tol, None)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, None)

# ============================================================================
# END OF IK SOLVER FUNCTIONS
# ============================================================================

class TrajectoryGenerator:
    """Base class for trajectory generation with caching support"""
    
    def __init__(self, control_rate: float = 100.0):
        """
        Initialize trajectory generator
        
        Args:
            control_rate: Control loop frequency in Hz (default 100Hz for PAROL6)
        """
        self.control_rate = control_rate
        self.dt = 1.0 / control_rate
        self.trajectory_cache = {}
        
    def generate_timestamps(self, duration: float) -> np.ndarray:
        """Generate evenly spaced timestamps for trajectory"""
        num_points = int(duration * self.control_rate)
        return np.linspace(0, duration, num_points)

class CircularMotion(TrajectoryGenerator):
    """Generate circular and arc trajectories in 3D space"""
    
    def generate_arc_3d(self, 
                       start_pose: List[float], 
                       end_pose: List[float], 
                       center: List[float], 
                       normal: Optional[List[float]] = None,
                       clockwise: bool = True,
                       duration: float = 2.0) -> np.ndarray:
        """
        Generate a 3D circular arc trajectory
        
        Args:
            start_pose: Starting pose [x, y, z, rx, ry, rz] (mm and degrees)
            end_pose: Ending pose [x, y, z, rx, ry, rz] (mm and degrees)
            center: Center point of arc [x, y, z] (mm)
            normal: Normal vector to arc plane (default: z-axis)
            clockwise: Direction of rotation
            duration: Time to complete arc (seconds)
            
        Returns:
            Array of poses along the arc trajectory
        """
        # Convert to numpy arrays
        start_pos = np.array(start_pose[:3])
        end_pos = np.array(end_pose[:3])
        center_pt = np.array(center)
        
        # Calculate radius vectors
        r1 = start_pos - center_pt
        r2 = end_pos - center_pt
        radius = np.linalg.norm(r1)
        
        # Determine arc plane normal if not provided
        if normal is None:
            normal = np.cross(r1, r2)
            if np.linalg.norm(normal) < 1e-6:  # Points are collinear
                normal = np.array([0, 0, 1])  # Default to XY plane
        normal = normal / np.linalg.norm(normal)
        
        # Calculate arc angle
        r1_norm = r1 / np.linalg.norm(r1)
        r2_norm = r2 / np.linalg.norm(r2)
        cos_angle = np.clip(np.dot(r1_norm, r2_norm), -1, 1)
        arc_angle = np.arccos(cos_angle)
        
        # Check direction using cross product
        cross = np.cross(r1_norm, r2_norm)
        if np.dot(cross, normal) < 0:
            arc_angle = 2 * np.pi - arc_angle
            
        if clockwise:
            arc_angle = -arc_angle
            
        # Generate trajectory points
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        for i, t in enumerate(timestamps):
            # Interpolation factor
            s = t / duration
            
            # For first point, use exact start position
            if i == 0:
                current_pos = start_pos
            else:
                # Rotate radius vector
                angle = s * arc_angle
                rot_matrix = self._rotation_matrix_from_axis_angle(normal, angle)
                current_pos = center_pt + rot_matrix @ r1
            
            # Interpolate orientation (SLERP)
            current_orient = self._slerp_orientation(start_pose[3:], end_pose[3:], s)
            
            # Combine position and orientation
            pose = np.concatenate([current_pos, current_orient])
            trajectory.append(pose)
            
        return np.array(trajectory)
    
    def generate_circle_3d(self,
                      center: List[float],
                      radius: float,
                      normal: List[float] = [0, 0, 1],
                      start_angle: float = None,
                      duration: float = 4.0,
                      start_point: List[float] = None) -> np.ndarray:
        """
        Generate a complete circle trajectory that starts at start_point
        """
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        # Create orthonormal basis for circle plane
        normal = np.array(normal) / np.linalg.norm(normal)
        u = self._get_perpendicular_vector(normal)
        v = np.cross(normal, u)
        
        center_np = np.array(center)
        
        # CRITICAL FIX: Validate and handle geometry
        if start_point is not None:
            start_pos = np.array(start_point[:3])
            
            # Project start point onto the circle plane
            to_start = start_pos - center_np
            to_start_plane = to_start - np.dot(to_start, normal) * normal
            
            # Get distance from center in the plane
            dist_in_plane = np.linalg.norm(to_start_plane)
            
            if dist_in_plane < 0.001:
                # Start point is at center - can't determine angle
                print(f"    WARNING: Start point is at circle center, using default position")
                start_angle = 0
                actual_start = center_np + radius * u
            else:
                # Calculate the angle of the start point
                to_start_normalized = to_start_plane / dist_in_plane
                u_comp = np.dot(to_start_normalized, u)
                v_comp = np.dot(to_start_normalized, v)
                start_angle = np.arctan2(v_comp, u_comp)
                
                # CHECK FOR INVALID GEOMETRY
                radius_error = abs(dist_in_plane - radius)
                if radius_error > radius * 0.3:  # More than 30% off
                    print(f"    WARNING: Start point is {dist_in_plane:.1f}mm from center,")
                    print(f"             but circle radius is {radius:.1f}mm!")
                    
                    # AUTO-CORRECT: Adjust center to make geometry valid
                    print(f"    AUTO-CORRECTING: Moving center to maintain {radius}mm radius from start")
                    direction = to_start_plane / dist_in_plane
                    center_np = start_pos - direction * radius
                    print(f"    New center: {center_np.round(1)}")
                    
                    # Recalculate with new center
                    to_start = start_pos - center_np
                    to_start_plane = to_start - np.dot(to_start, normal) * normal
                    dist_in_plane = np.linalg.norm(to_start_plane)
                
                actual_start = start_pos
        else:
            start_angle = 0 if start_angle is None else start_angle
            actual_start = None
        
        # Generate the circle 
        for i, t in enumerate(timestamps):
            if i == 0 and actual_start is not None:
                # First point MUST be exactly the start point
                pos = actual_start
            else:
                # Generate circle points
                angle = start_angle + (2 * np.pi * t / duration)
                pos = center_np + radius * (np.cos(angle) * u + np.sin(angle) * v)
            
            # Placeholder orientation (will be overridden)
            orient = [0, 0, 0]
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def _rotation_matrix_from_axis_angle(self, axis: np.ndarray, angle: float) -> np.ndarray:
        """Generate rotation matrix using Rodrigues' formula"""
        axis = axis / np.linalg.norm(axis)
        cos_a = np.cos(angle)
        sin_a = np.sin(angle)
        
        # Cross-product matrix
        K = np.array([[0, -axis[2], axis[1]],
                     [axis[2], 0, -axis[0]],
                     [-axis[1], axis[0], 0]])
        
        # Rodrigues' formula
        R = np.eye(3) + sin_a * K + (1 - cos_a) * K @ K
        return R
    
    def _get_perpendicular_vector(self, v: np.ndarray) -> np.ndarray:
        """Find a vector perpendicular to the given vector"""
        v = np.array(v)  # Ensure it's a numpy array
        if abs(v[0]) < 0.9:
            return np.cross(v, [1, 0, 0]) / np.linalg.norm(np.cross(v, [1, 0, 0]))
        else:
            return np.cross(v, [0, 1, 0]) / np.linalg.norm(np.cross(v, [0, 1, 0]))
    
    def _slerp_orientation(self, start_orient: List[float], 
                          end_orient: List[float], 
                          t: float) -> np.ndarray:
        """Spherical linear interpolation for orientation"""
        # Convert to quaternions
        r1 = Rotation.from_euler('xyz', start_orient, degrees=True)
        r2 = Rotation.from_euler('xyz', end_orient, degrees=True)
        
        # Create slerp object - compatible with scipy 1.11.4
        # Stack rotations into a single Rotation object
        key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
        slerp = Slerp([0, 1], key_rots)
        
        # Interpolate
        interp_rot = slerp(t)
        return interp_rot.as_euler('xyz', degrees=True)

class SplineMotion(TrajectoryGenerator):
    """Generate smooth spline trajectories through waypoints"""
    
    def generate_cubic_spline(self,
                             waypoints: List[List[float]],
                             timestamps: Optional[List[float]] = None,
                             velocity_start: Optional[List[float]] = None,
                             velocity_end: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate cubic spline trajectory through waypoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint (auto-generated if None)
            velocity_start: Initial velocity (zero if None)
            velocity_end: Final velocity (zero if None)
            
        Returns:
            Array of interpolated poses
        """
        waypoints = np.array(waypoints)
        num_waypoints = len(waypoints)
        
        # Auto-generate timestamps if not provided
        if timestamps is None:
            # Estimate based on distance
            total_dist = 0
            for i in range(1, num_waypoints):
                dist = np.linalg.norm(waypoints[i, :3] - waypoints[i-1, :3])
                total_dist += dist
            
            # Assume average speed of 50 mm/s
            total_time = total_dist / 50.0
            timestamps = np.linspace(0, total_time, num_waypoints)
        
        # Create splines for position
        pos_splines = []
        for i in range(3):
            bc_type = 'not-a-knot'  # Default boundary condition
            
            # Apply velocity boundary conditions if specified
            if velocity_start is not None and velocity_end is not None:
                bc_type = ((1, velocity_start[i]), (1, velocity_end[i]))
            
            spline = CubicSpline(timestamps, waypoints[:, i], bc_type=bc_type)
            pos_splines.append(spline)
        
        # Create splines for orientation (convert to quaternions for smooth interpolation)
        rotations = [Rotation.from_euler('xyz', wp[3:], degrees=True) for wp in waypoints]
        # Stack quaternions for scipy 1.11.4 compatibility
        quats = np.array([r.as_quat() for r in rotations])
        key_rots = Rotation.from_quat(quats)
        slerp = Slerp(timestamps, key_rots)
        
        # Generate dense trajectory
        t_eval = self.generate_timestamps(timestamps[-1])
        trajectory = []
        
        for t in t_eval:
            # Evaluate position splines
            pos = [spline(t) for spline in pos_splines]
            
            # Evaluate orientation
            rot = slerp(t)
            orient = rot.as_euler('xyz', degrees=True)
            
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def generate_quintic_spline(self,
                               waypoints: List[List[float]],
                               timestamps: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate quintic (5th order) spline with zero velocity and acceleration at endpoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint
            
        Returns:
            Array of interpolated poses
        """
        # For quintic spline, we need to ensure zero velocity and acceleration
        # at the endpoints for smooth motion
        return self.generate_cubic_spline(
            waypoints, 
            timestamps,
            velocity_start=[0, 0, 0],
            velocity_end=[0, 0, 0]
        )

class MotionBlender:
    """Blend between different motion segments for smooth transitions"""
    
    def __init__(self, blend_time: float = 0.5):
        self.blend_time = blend_time
        
    def blend_trajectories(self, traj1, traj2, blend_samples=50):
        """Blend two trajectory segments with improved velocity continuity"""
        
        if blend_samples < 4:
            return np.vstack([traj1, traj2])
        
        # Use more samples for smoother blending
        blend_samples = max(blend_samples, 20)  # Minimum 20 samples for smooth blend
        
        # Calculate overlap region more carefully
        overlap_start = max(0, len(traj1) - blend_samples // 3)
        overlap_end = min(len(traj2), blend_samples // 3)
        
        # Extract blend region
        blend_start_pose = traj1[overlap_start] if overlap_start < len(traj1) else traj1[-1]
        blend_end_pose = traj2[overlap_end] if overlap_end < len(traj2) else traj2[0]
        
        # Generate smooth transition using S-curve
        blended = []
        for i in range(blend_samples):
            t = i / (blend_samples - 1)
            # Use smoothstep function for smoother acceleration
            s = t * t * (3 - 2 * t)  # Smoothstep
            
            # Blend position
            pos_blend = blend_start_pose * (1 - s) + blend_end_pose * s
            
            # For orientation, use SLERP
            r1 = Rotation.from_euler('xyz', blend_start_pose[3:], degrees=True)
            r2 = Rotation.from_euler('xyz', blend_end_pose[3:], degrees=True)
            key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
            slerp = Slerp([0, 1], key_rots)
            orient_blend = slerp(s).as_euler('xyz', degrees=True)
            
            pos_blend[3:] = orient_blend
            blended.append(pos_blend)
        
        # Combine with better overlap handling
        result = np.vstack([
            traj1[:overlap_start],
            np.array(blended),
            traj2[overlap_end:]
        ])
        
        return result

class SmoothMotionCommand:
    """Command class for executing smooth motions on PAROL6"""
    
    def __init__(self, trajectory: np.ndarray, speed_factor: float = 1.0):
        """
        Initialize smooth motion command
        
        Args:
            trajectory: Pre-computed trajectory array
            speed_factor: Speed scaling factor (1.0 = normal speed)
        """
        self.trajectory = trajectory
        self.speed_factor = speed_factor
        self.current_index = 0
        self.is_finished = False
        self.is_valid = True
        
    def prepare_for_execution(self, current_position_in):
        """Validate trajectory is reachable from current position"""
        # Check if IK solver is available
        if solve_ik_with_adaptive_tol_subdivision is None:
            print("Warning: IK solver not available, skipping validation")
            self.is_valid = True
            return True
            
        try:
            # Convert current position to radians
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(current_position_in)])
            
            # Check first waypoint is reachable
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
            )
            
            if not ik_result.success:
                print(f"Smooth motion validation failed: Cannot reach first waypoint")
                self.is_valid = False
                return False
                
            print(f"Smooth motion prepared with {len(self.trajectory)} waypoints")
            return True
            
        except Exception as e:
            print(f"Smooth motion preparation error: {e}")
            self.is_valid = False
            return False
    
    def execute_step(self, Position_in, Speed_out, Command_out, **kwargs):
        """Execute one step of the smooth motion"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Check if required modules are available
        if PAROL6_ROBOT is None or solve_ik_with_adaptive_tol_subdivision is None:
            print("Error: Required PAROL6 modules not available")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Apply speed scaling
        step_increment = max(1, int(self.speed_factor))
        self.current_index += step_increment
        
        if self.current_index >= len(self.trajectory):
            print("Smooth motion completed")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get current target pose
        target_pose = self.trajectory[self.current_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
        )
        
        if not ik_result.success:
            print(f"IK failed at trajectory point {self.current_index}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps and send
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                       for i, q in enumerate(ik_result.q)]
        
        # Calculate velocities for smooth following
        for i in range(6):
            Speed_out[i] = int((target_steps[i] - Position_in[i]) * 10)  # P-control factor
        
        Command_out.value = 156  # Smooth motion command
        return False

# Helper functions for integration with robot_api.py

def execute_circle(center: List[float], 
                  radius: float, 
                  duration: float = 4.0,
                  normal: List[float] = [0, 0, 1]) -> str:
    """
    Execute a circular motion on PAROL6
    
    Args:
        center: Center point [x, y, z] in mm
        radius: Circle radius in mm
        duration: Time to complete circle
        normal: Normal vector to circle plane
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_circle_3d(center, radius, normal, 0, duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|CIRCLE|{traj_str}"
    
    return command

def execute_arc(start_pose: List[float],
               end_pose: List[float],
               center: List[float],
               clockwise: bool = True,
               duration: float = 2.0) -> str:
    """
    Execute an arc motion on PAROL6
    
    Args:
        start_pose: Starting pose [x, y, z, rx, ry, rz]
        end_pose: Ending pose [x, y, z, rx, ry, rz]
        center: Arc center point [x, y, z]
        clockwise: Direction of rotation
        duration: Time to complete arc
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_arc_3d(start_pose, end_pose, center, 
                                           clockwise=clockwise, duration=duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|ARC|{traj_str}"
    
    return command

def execute_spline(waypoints: List[List[float]], 
                  total_time: Optional[float] = None) -> str:
    """
    Execute a spline motion through waypoints
    
    Args:
        waypoints: List of poses [x, y, z, rx, ry, rz]
        total_time: Total time for motion (auto-calculated if None)
        
    Returns:
        Command string for robot_api
    """
    motion_gen = SplineMotion()
    
    # Generate timestamps if total_time is provided
    timestamps = None
    if total_time:
        timestamps = np.linspace(0, total_time, len(waypoints))
    
    trajectory = motion_gen.generate_cubic_spline(waypoints, timestamps)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|SPLINE|{traj_str}"
    
    return command

# Example usage
if __name__ == "__main__":
    # Example: Generate a circle trajectory
    circle_gen = CircularMotion()
    circle_traj = circle_gen.generate_circle_3d(
        center=[200, 0, 200],  # mm
        radius=50,  # mm
        duration=4.0  # seconds
    )
    print(f"Generated circle with {len(circle_traj)} points")
    
    # Example: Generate arc trajectory
    arc_traj = circle_gen.generate_arc_3d(
        start_pose=[250, 0, 200, 0, 0, 0],
        end_pose=[200, 50, 200, 0, 0, 90],
        center=[200, 0, 200],
        duration=2.0
    )
    print(f"Generated arc with {len(arc_traj)} points")
    
    # Example: Generate spline through waypoints
    spline_gen = SplineMotion()
    waypoints = [
        [200, 0, 100, 0, 0, 0],
        [250, 50, 150, 0, 15, 45],
        [200, 100, 200, 0, 30, 90],
        [150, 50, 150, 0, 15, 45],
        [200, 0, 100, 0, 0, 0]
    ]
    spline_traj = spline_gen.generate_cubic_spline(waypoints)
    print(f"Generated spline with {len(spline_traj)} points")
````

## File: start_parol6.sh
````bash
#!/bin/bash
# PAROL6 启动脚本

echo "=================================================="
echo "🤖 PAROL6 机械臂控制系统启动脚本"
echo "=================================================="

# 激活conda环境
echo "🔧 激活Python环境..."
source ~/anaconda3/bin/activate
conda activate parol

# 切换到工作目录
cd ~/PAROL-commander-software/PAROL6-python-API

# 检查依赖
echo "📦 检查依赖..."
python -c "import serial; import roboticstoolbox; import numpy" 2>/dev/null
if [ $? -ne 0 ]; then
    echo "❌ 缺少依赖，正在安装..."
    pip install pyserial roboticstoolbox-python numpy
fi

# 测试串口连接
echo "🔍 测试串口连接..."
python test_serial.py

if [ $? -eq 0 ]; then
    echo ""
    echo "✅ 串口测试通过"
    echo ""
    echo "🚀 启动PAROL6控制程序..."
    echo "=================================================="
    python run_parol6_fixed.py
else
    echo ""
    echo "❌ 串口连接失败"
    echo ""
    echo "故障排除："
    echo "1. 检查机械臂是否连接并上电"
    echo "2. 检查USB线缆"
    echo "3. 运行: sudo usermod -a -G dialout \$USER"
    echo "4. 或使用: sudo bash start_parol6.sh"
    exit 1
fi
````

## File: STATUS_REPORT.md
````markdown
# PAROL6 Linux修复完成报告

## ✅ 已完成的工作

### 1. **问题修复**
- ✅ 修复了Linux环境下串口初始化问题
- ✅ 解决了GUI模块导入错误
- ✅ 添加了串口自动检测功能
- ✅ 实现了串口权限检查
- ✅ 创建了错误恢复机制

### 2. **新增文件**
| 文件名 | 功能描述 |
|--------|----------|
| `run_parol6_fixed.py` | 主程序启动器（修复版）|
| `test_serial.py` | 串口连接测试工具 |
| `parol6_controller.py` | PAROL6控制器类（ROS2准备）|
| `start_parol6.sh` | 一键启动脚本 |
| `README_FIXED.md` | 使用文档 |
| `.gitignore` | Git忽略文件配置 |

### 3. **Git提交历史**
```
2e47273 添加一键启动脚本
ec0dfe6 修复Linux串口连接问题，添加测试工具和ROS2准备
```

## 🚀 如何使用

### 方法1：一键启动（推荐）
```bash
cd ~/PAROL-commander-software/PAROL6-python-API
./start_parol6.sh
```

### 方法2：手动启动
```bash
# 1. 激活环境
source ~/anaconda3/bin/activate
conda activate parol

# 2. 进入目录
cd ~/PAROL-commander-software/PAROL6-python-API

# 3. 测试连接
python test_serial.py

# 4. 运行程序
python run_parol6_fixed.py
```

## 📡 当前状态

### ✅ 正常工作
- 串口连接和检测
- 权限检查
- 基本通信测试

### ⚠️ 已知问题
1. **UDP端口冲突**（5001端口）
   - 原因：headless_commander.py尝试绑定UDP端口
   - 解决：需要检查端口是否被占用

2. **机械臂响应**
   - 设备连接成功但未收到响应
   - 可能需要调整通信协议

## 🔄 下一步：ROS2集成

### 1. 创建ROS2包
```bash
# 创建工作空间
mkdir -p ~/parol6_ws/src
cd ~/parol6_ws/src

# 创建包
ros2 pkg create parol6_controller \
  --build-type ament_python \
  --dependencies rclpy sensor_msgs trajectory_msgs
```

### 2. 实现控制器节点
- 将`parol6_controller.py`转换为ROS2节点
- 实现JointTrajectory接口
- 添加状态发布器

### 3. MoveIt配置
- 创建URDF模型
- 生成MoveIt配置包
- 配置控制器

### 4. 测试集成
- 启动MoveIt
- 测试轨迹执行
- 验证运动控制

## 📋 待办事项

- [ ] 解决UDP端口冲突问题
- [ ] 完善通信协议
- [ ] 创建ROS2包
- [ ] 实现MoveIt接口
- [ ] 添加URDF模型
- [ ] 编写单元测试
- [ ] 创建Docker镜像

## 🛠️ 技术细节

### 串口配置
- 波特率：3000000
- 默认端口：/dev/ttyACM0
- 超时：0.1秒

### 依赖包
- pyserial
- numpy
- roboticstoolbox-python
- scipy

### Python版本
- Python 3.10（conda环境：parol）

## 📞 支持

如有问题，请检查：
1. 机械臂电源和连接
2. 用户权限（dialout组）
3. 串口设备存在性
4. Python环境激活

---
**更新时间**: 2024-09-01
**维护者**: wzy
````

## File: test_basic.py
````python
#!/usr/bin/env python3
"""
PAROL6 简单功能测试
测试基本的串口通信和机械臂控制
"""
import sys
import os
import time
import serial
import socket
import threading

# 添加上级目录到Python路径
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def test_basic_functions():
    """测试基本功能"""
    print("=" * 60)
    print("PAROL6 基本功能测试")
    print("=" * 60)
    
    # 1. 测试串口连接
    print("\n1️⃣ 测试串口连接...")
    try:
        ser = serial.Serial(
            port='/dev/ttyACM0',
            baudrate=3000000,
            timeout=0.5
        )
        print(f"   ✅ 串口打开成功: {ser.port}")
        
        # 尝试发送一些基本命令
        test_commands = [
            b"READY\n",
            b"HOME\n",
            b"STATUS\n"
        ]
        
        for cmd in test_commands:
            print(f"   📤 发送: {cmd.decode().strip()}")
            ser.write(cmd)
            time.sleep(0.1)
            
            if ser.in_waiting > 0:
                response = ser.read(ser.in_waiting)
                print(f"   📥 响应: {response}")
            else:
                print(f"   ⚠️  无响应")
        
        ser.close()
        print("   ✅ 串口测试完成")
        
    except Exception as e:
        print(f"   ❌ 串口错误: {e}")
        return False
    
    # 2. 测试UDP端口
    print("\n2️⃣ 测试UDP端口...")
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(1.0)
        sock.bind(('0.0.0.0', 5001))
        print(f"   ✅ UDP端口5001绑定成功")
        
        # 尝试接收数据（1秒超时）
        print("   ⏳ 等待UDP数据（1秒）...")
        try:
            data, addr = sock.recvfrom(1024)
            print(f"   📥 收到数据: {data} from {addr}")
        except socket.timeout:
            print("   ⚠️  无UDP数据（正常）")
        
        sock.close()
        print("   ✅ UDP测试完成")
        
    except Exception as e:
        print(f"   ❌ UDP错误: {e}")
    
    # 3. 测试导入模块
    print("\n3️⃣ 测试导入模块...")
    try:
        from GUI.files import PAROL6_ROBOT
        print("   ✅ PAROL6_ROBOT模块导入成功")
        
        import robot_api
        print("   ✅ robot_api模块导入成功")
        
        import smooth_motion
        print("   ✅ smooth_motion模块导入成功")
        
    except Exception as e:
        print(f"   ❌ 模块导入错误: {e}")
    
    print("\n" + "=" * 60)
    print("测试完成")
    print("=" * 60)
    return True

if __name__ == "__main__":
    test_basic_functions()
````

## File: test_script.py
````python
from robot_api import move_robot_joints, home_robot, delay_robot, get_robot_joint_angles, control_pneumatic_gripper,get_robot_pose, control_electric_gripper, move_robot_pose,move_robot_cartesian,get_electric_gripper_status,get_robot_io
import time
print("Homing robot...") 
time.sleep(2)
control_electric_gripper(action = "calibrate")
time.sleep(2)
control_electric_gripper(action='move', position=100, speed=150, current = 200) 
time.sleep(2)
control_electric_gripper(action='move', position=200, speed=150, current = 200) 
time.sleep(2)
print(get_robot_joint_angles())
print(get_robot_pose())
print("Moving to new position...") 
control_pneumatic_gripper("open",1)
time.sleep(0.3)
control_pneumatic_gripper("close",1)
time.sleep(0.3)
control_pneumatic_gripper("open",1)
time.sleep(0.3)
control_pneumatic_gripper("close",1)
time.sleep(0.3)
move_robot_joints([90, -90, 160, 12, 12, 180], duration=5.5)
time.sleep(6)
move_robot_joints([50, -60, 180, -12, 32, 0], duration=5.5)
time.sleep(6)
move_robot_joints([90, -90, 160, 12, 12, 180], duration=5.5)
time.sleep(6)
move_robot_pose([7, 250, 200, -100, 0, -90], duration=5.5) 
time.sleep(6)
move_robot_cartesian([7, 250, 150, -100, 0, -90], speed_percentage=50) 
delay_robot(0.2)
print(get_electric_gripper_status())
print(get_robot_io())
````

## File: test_serial.py
````python
#!/usr/bin/env python3
"""
PAROL6 串口连接测试脚本
用于验证串口通信是否正常
"""
import serial
import serial.tools.list_ports
import time
import sys
import os

def test_serial_connection():
    """测试串口连接"""
    print("🔍 PAROL6 串口连接测试")
    print("-" * 40)
    
    # 列出所有可用串口
    print("\n📡 可用的串口:")
    ports = serial.tools.list_ports.comports()
    
    if not ports:
        print("  ❌ 未检测到任何串口设备")
        return False
    
    for port in ports:
        print(f"  • {port.device} - {port.description}")
    
    # 测试串口权限
    print("\n🔑 检查串口权限:")
    test_ports = ["/dev/ttyACM0", "/dev/ttyUSB0"]
    
    for port_name in test_ports:
        if os.path.exists(port_name):
            # 检查文件权限
            import stat
            st = os.stat(port_name)
            mode = st.st_mode
            
            # 检查是否可读写
            if os.access(port_name, os.R_OK | os.W_OK):
                print(f"  ✅ {port_name} - 可读写")
            else:
                print(f"  ❌ {port_name} - 权限不足")
                print(f"     运行: sudo chmod 666 {port_name}")
                print(f"     或: sudo usermod -a -G dialout $USER")
    
    # 尝试连接
    print("\n🔌 尝试连接串口:")
    
    for port in ports:
        if "ACM" in port.device or "USB" in port.device:
            print(f"\n尝试连接 {port.device}...")
            try:
                ser = serial.Serial(
                    port=port.device,
                    baudrate=3000000,
                    timeout=1,
                    write_timeout=1
                )
                
                print(f"  ✅ 成功打开 {port.device}")
                
                # 发送测试命令
                print("  📤 发送测试命令...")
                ser.write(b"READY\n")
                time.sleep(0.5)
                
                # 读取响应
                if ser.in_waiting > 0:
                    response = ser.read(ser.in_waiting)
                    print(f"  📥 收到响应: {response}")
                else:
                    print("  ⚠️  未收到响应（设备可能未准备好）")
                
                ser.close()
                print(f"  ✅ 串口测试成功!")
                return True
                
            except serial.SerialException as e:
                print(f"  ❌ 连接失败: {e}")
            except PermissionError as e:
                print(f"  ❌ 权限错误: {e}")
                print(f"     请运行: sudo chmod 666 {port.device}")
                print(f"     或使用: sudo python {sys.argv[0]}")
    
    print("\n❌ 无法连接到任何串口")
    return False

if __name__ == "__main__":
    print("=" * 50)
    print("PAROL6 串口诊断工具")
    print("=" * 50)
    
    success = test_serial_connection()
    
    print("\n" + "=" * 50)
    if success:
        print("✅ 测试通过！可以运行主程序:")
        print("   python run_parol6_fixed.py")
    else:
        print("❌ 测试失败，请检查:")
        print("   1. 机械臂是否连接并上电")
        print("   2. USB线缆是否正常")
        print("   3. 用户权限是否正确")
        print("   4. 尝试使用sudo运行")
    print("=" * 50)
````

## File: test_smooth_motion.py
````python
import time
import robot_api
import numpy as np

# Define the safe starting joint configuration for all smooth motion tests.
# This ensures consistency and repeatability for each test.
# Angles: [J1, J2, J3, J4, J5, J6] in degrees.
SAFE_SMOOTH_START_JOINTS = [42.697,-89.381,144.831,-0.436,31.528,180.0]

def initialize_test_position():
    """
    Moves the robot to the predefined safe starting joint angles and waits.
    This function is called before every smooth motion test.

    Returns:
        list: The robot's Cartesian pose [x, y, z, rx, ry, rz] after moving,
              or None if the move fails or the pose cannot be retrieved.
    """
    print("\n" + "="*60)
    print(f"MOVING TO SAFE STARTING POSITION: {SAFE_SMOOTH_START_JOINTS}")
    print("="*60)
    
    # Move to the joint position with a 4-second duration and wait for acknowledgment.
    result = robot_api.move_robot_joints(
        SAFE_SMOOTH_START_JOINTS, 
        duration=4, 
        wait_for_ack=True,
        timeout=5
    )
    print(f"--> Move command result: {result}")

    # Wait until the robot has physically stopped moving.
    if robot_api.wait_for_robot_stopped(timeout=10):
        print("--> Robot has reached the starting position.")
        time.sleep(1)
        start_pose = robot_api.get_robot_pose()
        if start_pose:
            print(f"--> Starting Pose confirmed at: {[round(p, 2) for p in start_pose]}")
            return start_pose
        else:
            print("--> ERROR: Could not retrieve robot pose after moving.")
            return None
    else:
        print("--> ERROR: Robot did not stop in time. Aborting test.")
        return None

def test_smooth_circle_basic(start_pose):
    """Tests the smooth_circle command with different planes, directions, and timing modes."""
    print("\n--- TESTING SMOOTH CIRCLE (BASIC) ---")
    
    # Define a center point relative to the starting Z-height
    radius = 30.0  # 30mm radius

    center_point = [start_pose[0], start_pose[1] + radius, start_pose[2]]  # Changed from +50 to +radius

    # Test 1: XY plane, counter-clockwise with DURATION
    print("\n[1/4] Testing Circle: XY Plane, Counter-Clockwise (Duration mode)")
    result = robot_api.smooth_circle(
        center=center_point,
        radius=radius,
        plane='XY',
        duration=5.0,  # Using duration
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)

    # Test 1: XY plane, counter-clockwise with DURATION in TRF
    print("\n[2/4] Testing Circle: XY Plane, Counter-Clockwise (Duration mode)")
    result = robot_api.smooth_circle(
        center=center_point,
        radius=radius,
        frame='TRF',  # NEW: Test in TRF
        plane='XY',
        duration=5.0,  # Using duration
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)

    # Test 2: XZ plane, clockwise with SPEED PERCENTAGE
    print("\n[3/4] Testing Circle: XZ Plane, Clockwise (Speed percentage mode)")
    result = robot_api.smooth_circle(
        center=center_point,
        radius=radius,
        plane='XZ',
        speed_percentage=30,  # Using speed percentage (30% speed)
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)
    
    # Test 3: YZ plane with specified start position (NEW)
    print("\n[4/4] Testing Circle: YZ Plane with SPECIFIED START POSITION")
    # Define a start position slightly offset from current
    specified_start = [start_pose[0] + 10, start_pose[1] + 10, start_pose[2], 
                      start_pose[3], start_pose[4], start_pose[5]]
    result = robot_api.smooth_circle(
        center=center_point,
        radius=radius,
        plane='YZ',
        start_pose=specified_start,  # NEW: Will transition here first
        duration=5.0,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)

def test_smooth_arc_with_start_positions(start_pose):
    """Tests smooth arc commands with specified start positions and transitions."""
    print("\n--- TESTING SMOOTH ARC WITH START POSITIONS ---")

    # Test 1: Arc with FAR start position (should see smooth transition)
    print("\n[1/4] Testing Arc with FAR START POSITION (big transition)")
    far_start = [start_pose[0] + 40, start_pose[1] - 20, start_pose[2] + 10,
                 start_pose[3], start_pose[4], start_pose[5]]
    arc_center = [far_start[0] - 20, far_start[1], far_start[2]]
    end_pose_arc = [arc_center[0], arc_center[1] + 20, far_start[2],
                   far_start[3], far_start[4], far_start[5] + 45]
    
    print(f"  Current position: {[round(p, 1) for p in start_pose[:3]]}")
    print(f"  Transition to: {[round(p, 1) for p in far_start[:3]]}")
    print(f"  Then arc to: {[round(p, 1) for p in end_pose_arc[:3]]}")
    
    result = robot_api.smooth_arc_center(
        end_pose=end_pose_arc,
        center=arc_center,
        start_pose=far_start,  # Will transition here first
        duration=6.0,
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=12)
    time.sleep(2)

    # Re-initialize for next test
    current_pose = initialize_test_position()
    if not current_pose: return

    # Test 2: Arc with CLOSE start position (minimal transition)
    print("\n[2/4] Testing Arc with CLOSE START POSITION (minimal transition)")
    close_start = [current_pose[0] + 2, current_pose[1] + 2, current_pose[2],
                   current_pose[3], current_pose[4], current_pose[5]]
    arc_center = [close_start[0] - 15, close_start[1], close_start[2]]
    end_pose_arc = [arc_center[0], arc_center[1] + 15, close_start[2],
                   close_start[3], close_start[4], close_start[5] + 30]
    
    print(f"  Current position: {[round(p, 1) for p in current_pose[:3]]}")
    print(f"  Transition to: {[round(p, 1) for p in close_start[:3]]}")
    print(f"  Then arc to: {[round(p, 1) for p in end_pose_arc[:3]]}")
    
    result = robot_api.smooth_arc_center(
        end_pose=end_pose_arc,
        center=arc_center,
        start_pose=close_start,  # Very close, minimal transition
        speed_percentage=40,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)

    # Test 3: Parametric arc with specified start
    print("\n[3/4] Testing PARAMETRIC Arc with specified start")
    param_start = [current_pose[0] - 10, current_pose[1] + 5, current_pose[2],
                   current_pose[3], current_pose[4], current_pose[5]]
    end_pose_param = [param_start[0] + 20, param_start[1] - 10, param_start[2],
                     param_start[3], param_start[4], param_start[5]]
    
    result = robot_api.smooth_arc_parametric(
        end_pose=end_pose_param,
        radius=20.0,
        arc_angle=60.0,
        start_pose=param_start,
        duration=4.0,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)

    # Test 4: Arc in TRF - arc plane follows tool orientation
    print("\n[4/4] Testing Arc in TOOL REFERENCE FRAME (TRF)")
    # In TRF, the arc is defined relative to the tool's coordinate system
    trf_start = [10, 10, 10, 0, 0, 0]  # Position relative to tool
    trf_center = [0, 0, 0]  # Center at tool origin
    trf_end = [10, -10, 10, 0, 0, 45]  # End position in tool frame
    
    print(f"  TRF Arc - all coordinates relative to tool position/orientation")
    print(f"  If tool is tilted, the arc plane will be tilted too!")
    
    result = robot_api.smooth_arc_center(
        end_pose=trf_end,
        center=trf_center,
        frame='TRF',  # NEW: Using Tool Reference Frame
        start_pose=trf_start,
        duration=5.0,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)

def test_motion_chaining(start_pose):
    """Tests precise motion chaining using end pose of one motion as start of next."""
    print("\n--- TESTING MOTION CHAINING (NEW) ---")
    print("This tests using the exact end pose of one motion as the start of the next")
    
    # Motion 1: Arc to a specific end pose
    print("\n[1/4] First Motion: Arc")
    arc_center = [start_pose[0] - 20, start_pose[1], start_pose[2]]
    arc_end = [arc_center[0], arc_center[1] + 30, start_pose[2],
               start_pose[3], start_pose[4] + 15, start_pose[5] + 45]
    
    result = robot_api.smooth_arc_center(
        end_pose=arc_end,
        center=arc_center,
        duration=4.0,
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Arc ended at: {[round(p, 1) for p in arc_end[:3]]}")
    robot_api.wait_for_robot_stopped(timeout=8)
    time.sleep(1)
    
    # Motion 2: Circle in TRF starting exactly where arc ended
    print("\n[2/4] Second Motion: Circle in TRF starting at arc's end position")
    # In TRF, center is relative to current tool position
    trf_circle_center = [0, 25, 0]  # 25mm forward in tool Y-axis
    
    result = robot_api.smooth_circle(
        center=trf_circle_center,
        radius=25.0,
        plane='XY',  # This is the tool's XY plane, not world XY!
        frame='TRF',  # NEW: Circle plane follows tool orientation
        start_pose=arc_end,  # Start exactly where arc ended
        speed_percentage=35,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Circle in TRF completed (plane followed tool orientation)")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(1)
    
    # Since circle returns to start, we know where we are
    circle_end = arc_end  # Circle returns to its start point
    
    # Motion 3: Helix starting where circle ended
    print("\n[3/4] Third Motion: Helix starting at circle's position")
    # Calculate actual radius from circle end position
    helix_center = [circle_end[0], circle_end[1], circle_end[2] - 30]
    # Use the actual distance as radius
    actual_radius = np.sqrt((circle_end[0] - helix_center[0])**2 + 
                        (circle_end[1] - helix_center[1])**2)
    radius = max(actual_radius, 1.0)  # Use actual distance, minimum 1mm
    
    result = robot_api.smooth_helix(
        center=helix_center,
        radius=15.0,
        pitch=10.0,
        height=30.0,
        start_pose=circle_end,  # Start where circle ended
        duration=6.0,
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Helix completed")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(1)
    
    # Calculate helix end position (approximately)
    helix_end = [helix_center[0] + 15, helix_center[1], helix_center[2] + 30,
                 circle_end[3], circle_end[4], circle_end[5]]
    
    # Motion 4: Spline back to near start
    print("\n[4/4] Fourth Motion: Spline path back near start")
    waypoints = [
        helix_end,  # Start from helix end
        [helix_end[0] - 10, helix_end[1] - 10, helix_end[2] - 10,
         helix_end[3], helix_end[4], helix_end[5] - 20],
        [start_pose[0] + 5, start_pose[1] + 5, start_pose[2],
         start_pose[3], start_pose[4], start_pose[5]]
    ]
    
    result = robot_api.smooth_spline(
        waypoints=waypoints[1:],  # Skip first since we specify start_pose
        start_pose=waypoints[0],  # Explicitly start from helix end
        speed_percentage=30,
        wait_for_ack=True
    )
    print(f"--> Spline completed - returned near start")
    robot_api.wait_for_robot_stopped(timeout=10)

def test_smooth_spline_with_starts(start_pose):
    """Tests smooth_spline with various start position scenarios."""
    print("\n--- TESTING SMOOTH SPLINE WITH START POSITIONS ---")
    
    # Test 1: Spline with default start (current position)
    print("\n[1/4] Spline with DEFAULT start (from current position)")
    waypoints = []
    for i in range(4):
        x = start_pose[0] + i * 15
        y = start_pose[1] + (15 if i % 2 else -15)
        z = start_pose[2]
        waypoints.append([x, y, z, start_pose[3], start_pose[4], start_pose[5]])
    
    result = robot_api.smooth_spline(
        waypoints=waypoints,
        # No start_pose specified - uses current
        duration=5.0,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)
    
    # Re-initialize
    current_pose = initialize_test_position()
    if not current_pose: return
    
    # Test 2: Spline with specified start far from first waypoint
    print("\n[2/4] Spline with SPECIFIED start (different from first waypoint)")
    specified_start = [current_pose[0] - 20, current_pose[1] + 15, current_pose[2],
                      current_pose[3], current_pose[4], current_pose[5]]
    
    waypoints = [
        [specified_start[0] + 30, specified_start[1], specified_start[2],
         specified_start[3], specified_start[4], specified_start[5]],
        [specified_start[0] + 40, specified_start[1] + 20, specified_start[2],
         specified_start[3], specified_start[4], specified_start[5]],
        [specified_start[0] + 20, specified_start[1] + 30, specified_start[2],
         specified_start[3], specified_start[4], specified_start[5]]
    ]
    
    print(f"  Current: {[round(p, 1) for p in current_pose[:3]]}")
    print(f"  Will transition to: {[round(p, 1) for p in specified_start[:3]]}")
    print(f"  Then follow spline through waypoints")
    
    result = robot_api.smooth_spline(
        waypoints=waypoints,
        start_pose=specified_start,  # Will transition here first
        speed_percentage=40,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=12)
    time.sleep(2)
    
    # Re-initialize
    current_pose = initialize_test_position()
    if not current_pose: return
    
    # Test 3: Spline with start matching first waypoint (no transition needed)
    print("\n[3/4] Spline with start MATCHING first waypoint (no transition)")
    first_waypoint = [current_pose[0] + 5, current_pose[1] + 5, current_pose[2],
                     current_pose[3], current_pose[4], current_pose[5]]
    
    waypoints = [
        first_waypoint,  # Same as start_pose
        [first_waypoint[0] + 20, first_waypoint[1] + 10, first_waypoint[2],
         first_waypoint[3], first_waypoint[4], first_waypoint[5]],
        [first_waypoint[0] + 10, first_waypoint[1] + 25, first_waypoint[2],
         first_waypoint[3], first_waypoint[4], first_waypoint[5]]
    ]
    
    result = robot_api.smooth_spline(
        waypoints=waypoints[1:],  # Skip first since we use it as start_pose
        start_pose=first_waypoint,  # Same as would-be first waypoint
        duration=4.0,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=8)

    # Test 4: Spline in TRF - waypoints relative to tool
    print("\n[4/4] Spline in TOOL REFERENCE FRAME (TRF)")
    # In TRF, all waypoints are relative to the tool's coordinate system
    trf_waypoints = [
        [20, 0, 0, 0, 0, 0],     # 20mm forward in tool X
        [20, 20, 0, 0, 0, 15],   # Add 20mm in tool Y
        [0, 20, 10, 0, 0, 30],   # Move to tool Y=20, Z=10
        [0, 0, 0, 0, 0, 0]       # Return to tool origin
    ]
    
    print(f"  TRF Spline - all waypoints relative to tool coordinate system")
    print(f"  If tool is rotated, entire spline path rotates with it!")
    
    result = robot_api.smooth_spline(
        waypoints=trf_waypoints,
        frame='TRF',  # NEW: Waypoints interpreted in tool frame
        duration=6.0,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)

def test_smooth_helix_with_starts(start_pose):
    """Tests smooth_helix with specified start positions."""
    print("\n--- TESTING SMOOTH HELIX WITH START POSITIONS ---")
    
    # Test 1: Helix with default start
    print("\n[1/3] Helix with DEFAULT start (from current position)")
    center = [start_pose[0], start_pose[1] + 30, start_pose[2] - 40]
    
    result = robot_api.smooth_helix(
        center=center,
        radius=30.0,
        pitch=12.0,
        height=36.0,  # 3 revolutions
        # No start_pose - uses current
        duration=10.0,
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=10)
    time.sleep(2)
    
    # Re-initialize
    current_pose = initialize_test_position()
    if not current_pose: return
    
    # Test 2: Helix with specified start on the helix perimeter
    print("\n[2/3] Helix with SPECIFIED start on perimeter")
    center = [current_pose[0], current_pose[1] + 30, current_pose[2] - 40]
    # Start position on the helix perimeter (different angle)
    start_on_perimeter = [
        center[0] + 20,  # radius * cos(0)
        center[1],       # radius * sin(0)
        center[2],       # Starting height
        current_pose[3], current_pose[4], current_pose[5]
    ]
    
    print(f"  Current: {[round(p, 1) for p in current_pose[:3]]}")
    print(f"  Will transition to helix start: {[round(p, 1) for p in start_on_perimeter[:3]]}")
    
    result = robot_api.smooth_helix(
        center=center,
        radius=20.0,
        pitch=12.0,
        height=36.0,
        start_pose=start_on_perimeter,
        speed_percentage=30,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=12)

    # Test 3: Helix in TRF - helix axis follows tool Z-axis
    print("\n[3/3] Helix in TOOL REFERENCE FRAME (TRF)")
    # In TRF, the helix rises along the tool's Z-axis, not world Z
    trf_center = [0, 30, -40]  # Center relative to tool
    trf_start = [20, 30, -40, 0, 0, 0]  # Start on perimeter
    
    print(f"  TRF Helix - rises along TOOL'S Z-axis")
    print(f"  If tool is horizontal, helix will be horizontal too!")
    
    result = robot_api.smooth_helix(
        center=trf_center,
        radius=20.0,
        pitch=12.0,
        height=36.0,
        frame='TRF',  # NEW: Helix axis follows tool orientation
        start_pose=trf_start,
        duration=8.0,
        clockwise=True,
        wait_for_ack=True
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=12)

def test_smooth_blend_with_starts(start_pose):
    """Tests smooth_blend with specified start position for first segment."""
    print("\n--- TESTING SMOOTH BLEND WITH START POSITIONS ---")
    
    # Test 1: Blend with default start
    print("\n[1/4] Blend with DEFAULT start")
    p1 = start_pose
    p2 = [p1[0] + 25, p1[1] + 10, p1[2], p1[3], p1[4], p1[5] + 20]
    arc_center = [p2[0] - 10, p2[1] + 10, p2[2]]
    p3 = [arc_center[0], arc_center[1] + 15, arc_center[2], p1[3], p1[4], p1[5] + 40]
    
    segments = [
        {'type': 'LINE', 'end': p2, 'duration': 2.0},
        {'type': 'ARC', 'end': p3, 'center': arc_center, 'duration': 3.0, 'clockwise': False},
    ]
    
    result = robot_api.smooth_blend(
        segments=segments,
        blend_time=0.5,
        # No start_pose - uses current
        duration=6.0,
        wait_for_ack=True,
        timeout=15
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=15)
    time.sleep(2)
    
    # Re-initialize
    current_pose = initialize_test_position()
    if not current_pose: return
    
    # Test 2: Blend with specified start for first segment
    print("\n[2/4] Blend with SPECIFIED start (adds transition)")
    specified_start = [current_pose[0] + 15, current_pose[1] - 10, current_pose[2],
                      current_pose[3], current_pose[4], current_pose[5]]
    p2 = [specified_start[0] + 20, specified_start[1] + 15, specified_start[2],
          specified_start[3], specified_start[4], specified_start[5] + 30]
    circle_center = [p2[0], p2[1] + 20, p2[2]]
    
    segments = [
        {'type': 'LINE', 'end': p2, 'duration': 2.5},
        {'type': 'CIRCLE', 'center': circle_center, 'radius': 20, 'plane': 'XY', 
         'duration': 4.0, 'clockwise': True},
    ]
    
    print(f"  Current: {[round(p, 1) for p in current_pose[:3]]}")
    print(f"  Will transition to: {[round(p, 1) for p in specified_start[:3]]}")
    print(f"  Then execute blend segments")
    
    result = robot_api.smooth_blend(
        segments=segments,
        blend_time=0.75,
        start_pose=specified_start,  # First segment starts here
        speed_percentage=35,
        wait_for_ack=True,
        timeout=20
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=20)
    time.sleep(2)
    
    # Re-initialize
    current_pose = initialize_test_position()
    if not current_pose: return
    
    # Test 3: Complex blend with spline segment and specified start
    print("\n[3/4] Complex blend with SPLINE segment and specified start")
    blend_start = [current_pose[0] - 10, current_pose[1] + 10, current_pose[2],
                   current_pose[3], current_pose[4], current_pose[5]]
    
    # Define waypoints for spline segment
    spline_waypoints = [
        [blend_start[0] + 30, blend_start[1], blend_start[2],
         blend_start[3], blend_start[4], blend_start[5]],
        [blend_start[0] + 35, blend_start[1] + 15, blend_start[2],
         blend_start[3], blend_start[4], blend_start[5] + 15],
        [blend_start[0] + 25, blend_start[1] + 25, blend_start[2],
         blend_start[3], blend_start[4], blend_start[5] + 30]
    ]
    
    segments = [
        {'type': 'LINE', 'end': spline_waypoints[0], 'duration': 2.0},
        {'type': 'SPLINE', 'waypoints': spline_waypoints, 'duration': 4.0},
        {'type': 'LINE', 'end': [blend_start[0], blend_start[1] + 20, blend_start[2],
                                 blend_start[3], blend_start[4], blend_start[5]], 
         'duration': 2.0}
    ]
    
    result = robot_api.smooth_blend(
        segments=segments,
        blend_time=0.5,
        start_pose=blend_start,
        duration=10.0,  # Overall duration
        wait_for_ack=True,
        timeout=20
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=20)

    # Test 4: Blend in TRF - all segments relative to tool
    print("\n[4/4] Blend in TOOL REFERENCE FRAME (TRF)")
    # All segment coordinates are relative to tool position/orientation
    trf_segments = [
        {'type': 'LINE', 'end': [30, 0, 0, 0, 0, 0], 'duration': 2.0},
        {'type': 'CIRCLE', 'center': [30, 20, 0], 'radius': 20, 'plane': 'XY', 
         'duration': 4.0, 'clockwise': False},  # Tool's XY plane
        {'type': 'LINE', 'end': [0, 20, 0, 0, 0, 0], 'duration': 2.0}
    ]
    
    print(f"  TRF Blend - all segments in tool coordinate system")
    print(f"  Circle plane is tool's XY, not world XY!")
    
    result = robot_api.smooth_blend(
        segments=trf_segments,
        blend_time=0.5,
        frame='TRF',  # NEW: All segments in tool frame
        duration=10.0,
        wait_for_ack=True,
        timeout=20
    )
    print(f"--> Command result: {result}")
    robot_api.wait_for_robot_stopped(timeout=20)

def test_transition_distances():
    """Test transitions with various distances to verify smooth transition behavior."""
    print("\n--- TESTING TRANSITION DISTANCES ---")
    
    # Get current position
    start_pose = initialize_test_position()
    if not start_pose: return
    
    # Define test distances: very close, medium, far
    test_cases = [
        ("Very Close (3mm)", 3),
        ("Close (10mm)", 10),
        ("Medium (30mm)", 30),
        ("Far (50mm)", 50)
    ]
    
    for description, distance in test_cases:
        print(f"\n[{test_cases.index((description, distance)) + 1}/{len(test_cases)}] Testing transition: {description}")
        
        # Create a start position at the specified distance
        transition_start = [
            start_pose[0] + distance,
            start_pose[1],
            start_pose[2],
            start_pose[3], start_pose[4], start_pose[5]
        ]
        
        # Use a simple circle to observe the transition
        circle_center = [transition_start[0], transition_start[1] + 30, transition_start[2]]
        
        print(f"  Current position: {[round(p, 1) for p in start_pose[:3]]}")
        print(f"  Transition to: {[round(p, 1) for p in transition_start[:3]]}")
        print(f"  Distance: {distance}mm")
        
        start_time = time.time()
        result = robot_api.smooth_circle(
            center=circle_center,
            radius=30.0,
            plane='XY',
            start_pose=transition_start,
            duration=5.0,
            clockwise=False,
            wait_for_ack=True
        )
        
        # Note the transition time
        robot_api.wait_for_robot_stopped(timeout=10)
        total_time = time.time() - start_time
        
        print(f"  Total execution time: {total_time:.2f}s")
        if distance <= 5:
            print(f"  -> Minimal transition expected and observed")
        else:
            transition_time = distance / 30.0  # Assuming 30mm/s transition speed
            print(f"  -> Estimated transition time: {transition_time:.2f}s")
        
        time.sleep(2)
        
        # Return to start for next test
        if test_cases.index((description, distance)) < len(test_cases) - 1:
            initialize_test_position()

    # Additional test: Transition in TRF
    print("\n[BONUS] Testing transition in TRF")
    print("In TRF, transition is relative to tool, not world")
    
    # TRF start position (30mm forward in tool X)
    trf_transition_start = [30, 0, 0, 0, 0, 0]
    trf_circle_center = [30, 30, 0]  # Center in tool frame
    
    result = robot_api.smooth_circle(
        center=trf_circle_center,
        radius=30.0,
        plane='XY',  # Tool's XY plane
        frame='TRF',  # NEW: Transition happens in tool space
        start_pose=trf_transition_start,
        duration=5.0,
        clockwise=False,
        wait_for_ack=True
    )
    print(f"  -> TRF transition completed")
    robot_api.wait_for_robot_stopped(timeout=10)

def test_timing_comparison_with_starts():
    """Compare timing modes with specified start positions."""
    print("\n--- TESTING TIMING MODES WITH START POSITIONS ---")
    
    # Initialize
    start_pose = initialize_test_position()
    if not start_pose: return
    
    # Define a specific start position for both tests
    test_start = [start_pose[0] + 20, start_pose[1] - 10, start_pose[2],
                  start_pose[3], start_pose[4], start_pose[5]]
    center = [test_start[0], test_start[1] + 30, test_start[2]]
    radius = 30.0
    
    print("\n[1/3] Circle with specified start + 5-second DURATION")
    print(f"  Transition from: {[round(p, 1) for p in start_pose[:3]]}")
    print(f"  To start position: {[round(p, 1) for p in test_start[:3]]}")
    
    start_time = time.time()
    result = robot_api.smooth_circle(
        center=center,
        radius=radius,
        plane='XY',
        start_pose=test_start,
        duration=5.0,
        clockwise=False,
        wait_for_ack=True
    )
    robot_api.wait_for_robot_stopped(timeout=12)
    elapsed = time.time() - start_time
    print(f"--> Total execution time (including transition): {elapsed:.2f}s")
    time.sleep(2)
    
    # Return to start
    initialize_test_position()
    
    print("\n[2/3] Same circle with specified start + 40% SPEED")
    print(f"  Same transition and circle path")
    
    start_time = time.time()
    result = robot_api.smooth_circle(
        center=center,
        radius=radius,
        plane='XY',
        start_pose=test_start,
        speed_percentage=40,
        clockwise=False,
        wait_for_ack=True
    )
    robot_api.wait_for_robot_stopped(timeout=12)
    elapsed = time.time() - start_time
    print(f"--> Total execution time (including transition): {elapsed:.2f}s")

    print("\n[3/3] Same circle in TRF with 40% SPEED")
    print(f"  Testing how TRF affects timing with transitions")
    
    # TRF coordinates (relative to tool)
    trf_start = [20, -10, 0, 0, 0, 0]
    trf_center = [20, 20, 0]  # 30mm forward in tool Y from start
    
    start_time = time.time()
    result = robot_api.smooth_circle(
        center=trf_center,
        radius=30.0,
        plane='XY',  # Tool's XY plane
        frame='TRF',  # NEW: Using tool reference frame
        start_pose=trf_start,
        speed_percentage=40,
        clockwise=False,
        wait_for_ack=True
    )
    robot_api.wait_for_robot_stopped(timeout=12)
    elapsed = time.time() - start_time
    print(f"--> TRF execution time: {elapsed:.2f}s")
    print(f"  Note: TRF doesn't change timing, just coordinate interpretation")
    
    # Calculate expected times
    circumference = 2 * np.pi * radius
    transition_dist = np.sqrt((test_start[0] - start_pose[0])**2 + 
                              (test_start[1] - start_pose[1])**2 + 
                              (test_start[2] - start_pose[2])**2)
    print(f"\nAnalysis:")
    print(f"  Transition distance: {transition_dist:.1f}mm")
    print(f"  Circle circumference: {circumference:.1f}mm")
    print(f"  At 40% speed (~40mm/s), circle should take ~{circumference/40:.1f}s")
    print(f"  Transition at ~30mm/s should take ~{transition_dist/30:.1f}s")

if __name__ == "__main__":
    print("="*70)
    print("COMPREHENSIVE SMOOTH MOTION TEST SUITE")
    print("Testing NEW features: Start Positions & Automatic Transitions")
    print("="*70)
    
    
    # Test 1: Basic tests with new start position feature
    print("\n[TEST GROUP 1: BASIC COMMANDS WITH START POSITIONS]")
    start_pose = initialize_test_position()
    if start_pose:
        test_smooth_circle_basic(start_pose)
    
    # Test 2: Arc commands with various start positions
    print("\n[TEST GROUP 2: ARC COMMANDS WITH TRANSITIONS]")
    start_pose = initialize_test_position()
    if start_pose:
        test_smooth_arc_with_start_positions(start_pose)
    
    # Test 3: Motion chaining - using end of one as start of next
    print("\n[TEST GROUP 3: PRECISE MOTION CHAINING]")
    start_pose = initialize_test_position()
    if start_pose:
        test_motion_chaining(start_pose)
    
    # Test 4: Spline with various start scenarios
    print("\n[TEST GROUP 4: SPLINE WITH START POSITIONS]")
    start_pose = initialize_test_position()
    if start_pose:
        test_smooth_spline_with_starts(start_pose)
    
    # Test 5: Helix with start positions
    print("\n[TEST GROUP 5: HELIX WITH START POSITIONS]")
    start_pose = initialize_test_position()
    if start_pose:
        test_smooth_helix_with_starts(start_pose)
    
    # Test 6: Blend with start positions
    print("\n[TEST GROUP 6: BLEND WITH START POSITIONS]")
    start_pose = initialize_test_position()
    if start_pose:
        test_smooth_blend_with_starts(start_pose)
    
    # Test 7: Transition distance testing
    print("\n[TEST GROUP 7: TRANSITION DISTANCE BEHAVIOR]")
    test_transition_distances()
    
    # Test 8: Timing comparison with transitions
    print("\n[TEST GROUP 8: TIMING MODES WITH TRANSITIONS]")
    test_timing_comparison_with_starts()
    
    print("\n" + "="*70)
    print("COMPREHENSIVE TEST SUITE COMPLETE")
    print("Tested features:")
    print("  ✓ All commands with duration mode")
    print("  ✓ All commands with speed percentage mode")
    print("  ✓ Default start positions (current position)")
    print("  ✓ Specified start positions with automatic transitions")
    print("  ✓ Motion chaining with precise continuity")
    print("  ✓ Transition behavior for various distances")
    print("  ✓ Blend segments with overall timing control")
    print("="*70)
    
    # Final return to safe position
    print("\nReturning to safe position...")
    initialize_test_position()
    print("\n===== All Tests Finished =====")
````

## File: test/all-test.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 API 全功能安全测试程序
系统性测试所有可用的API功能
"""
import sys
import os

# 获取当前文件的绝对路径
current_dir = os.path.dirname(os.path.abspath(__file__))

# 获取父目录路径
parent_dir = os.path.dirname(current_dir)

# 将父目录添加到模块搜索路径中
sys.path.append(parent_dir)

# 现在可以导入父目录中的模块
from robot_api import *
import time
import traceback
from robot_api import *

class PAROL6APITester:
    def __init__(self):
        """初始化API测试器"""
        self.test_results = {}
        self.safe_pose = [200, 0, 200, 180, 0, 90]  # 安全的测试位姿
        self.safe_joints = [0, -45, 90, 0, 45, 90]  # 安全的关节角度
        self.test_count = 0
        self.passed_count = 0
        self.failed_count = 0
        self.skipped_count = 0
        
        print("🔬 PAROL6 API 全功能测试器已初始化")
        print("⚠️  注意：本程序将测试所有API功能，请确保:")
        print("   1. 机器人周围安全无障碍物")
        print("   2. 急停按钮随时可用")
        print("   3. 有足够的工作空间")
        print("   4. 已连接夹具（如需测试夹具功能）")

    def log_test(self, test_name, result, details=""):
        """记录测试结果"""
        self.test_count += 1
        status = "✅ 通过" if result == "PASS" else "❌ 失败" if result == "FAIL" else "⏭️ 跳过"
        
        if result == "PASS":
            self.passed_count += 1
        elif result == "FAIL":
            self.failed_count += 1
        else:
            self.skipped_count += 1
            
        self.test_results[test_name] = {"status": result, "details": details}
        print(f"{status} {test_name}: {details}")

    def safe_execute(self, func, *args, **kwargs):
        """安全执行函数"""
        try:
            result = func(*args, **kwargs)
            return result, None
        except Exception as e:
            return None, str(e)

    def user_confirm(self, message, default="y"):
        """用户确认"""
        choice = input(f"{message} ({default}/n/s=跳过): ").lower() or default
        if choice == 's':
            return "skip"
        return choice == 'y'

    # ================================
    # 1. 状态查询API测试
    # ================================
    
    def test_status_apis(self):
        """测试所有状态查询API"""
        print("\n" + "="*50)
        print("🔍 测试状态查询API")
        print("="*50)
        
        # 1. 获取关节角度
        result, error = self.safe_execute(get_robot_joint_angles)
        if result is not None:
            self.log_test("get_robot_joint_angles", "PASS", f"关节角度: {[round(a,2) for a in result]}")
        else:
            self.log_test("get_robot_joint_angles", "FAIL", f"错误: {error}")
        
        # 2. 获取机器人位姿
        result, error = self.safe_execute(get_robot_pose)
        if result is not None:
            self.log_test("get_robot_pose", "PASS", f"位姿: {[round(p,2) for p in result]}")
        else:
            self.log_test("get_robot_pose", "FAIL", f"错误: {error}")
        
        # 3. 获取关节速度
        result, error = self.safe_execute(get_robot_joint_speeds)
        if result is not None:
            self.log_test("get_robot_joint_speeds", "PASS", f"速度: {result}")
        else:
            self.log_test("get_robot_joint_speeds", "FAIL", f"错误: {error}")
        
        # 4. 获取IO状态
        # result, error = self.safe_execute(get_io_status)
        # if result is not None:
        #     self.log_test("get_io_status", "PASS", f"IO状态: {result}")
        # else:
        #     self.log_test("get_io_status", "FAIL", f"错误: {error}")
        
        # 5. 获取电动夹具状态
        result, error = self.safe_execute(get_electric_gripper_status)
        if result is not None:
            self.log_test("get_electric_gripper_status", "PASS", f"夹具状态: {result}")
        else:
            self.log_test("get_electric_gripper_status", "FAIL", f"错误: {error}")
        
        # 6. 获取变换矩阵
        result, error = self.safe_execute(get_robot_pose_matrix)
        if result is not None:
            self.log_test("get_robot_pose_matrix", "PASS", "矩阵获取成功")
        else:
            self.log_test("get_robot_pose_matrix", "FAIL", f"错误: {error}")
        
        # 7. 检查是否停止
        result, error = self.safe_execute(is_robot_stopped)
        if result is not None:
            self.log_test("is_robot_stopped", "PASS", f"停止状态: {result}")
        else:
            self.log_test("is_robot_stopped", "FAIL", f"错误: {error}")
        
        # 8. 获取综合状态
        result, error = self.safe_execute(get_robot_status)
        if result is not None:
            self.log_test("get_robot_status", "PASS", "综合状态获取成功")
        else:
            self.log_test("get_robot_status", "FAIL", f"错误: {error}")

    # ================================
    # 2. 基础移动API测试
    # ================================
    
    def test_basic_movement_apis(self):
        """测试基础移动API"""
        print("\n" + "="*50)
        print("🤖 测试基础移动API")
        print("="*50)
        
        # 1. 归零测试
        if self.user_confirm("测试机器人归零?") == "skip":
            self.log_test("home_robot", "SKIP", "用户跳过")
        else:
            result, error = self.safe_execute(home_robot, wait_for_ack=True, timeout=30)
            if result and result.get('status') == 'COMPLETED':
                self.log_test("home_robot", "PASS", "归零成功")
                time.sleep(2)
            else:
                self.log_test("home_robot", "FAIL", f"归零失败: {error or result}")
        
        # 2. 关节移动测试
        if self.user_confirm("测试关节移动到安全位置?") == "skip":
            self.log_test("move_robot_joints", "SKIP", "用户跳过")
        else:
            result, error = self.safe_execute(
                move_robot_joints, 
                self.safe_joints, 
                speed_percentage=20, 
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("move_robot_joints", "PASS", f"移动到: {self.safe_joints}")
                time.sleep(1)
            else:
                self.log_test("move_robot_joints", "FAIL", f"失败: {error or result}")
        
        # 3. 位姿移动测试
        if self.user_confirm("测试位姿移动?") == "skip":
            self.log_test("move_robot_pose", "SKIP", "用户跳过")
        else:
            result, error = self.safe_execute(
                move_robot_pose, 
                self.safe_pose, 
                speed_percentage=20, 
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("move_robot_pose", "PASS", f"移动到: {self.safe_pose}")
                time.sleep(1)
            else:
                self.log_test("move_robot_pose", "FAIL", f"失败: {error or result}")
        
        # 4. 直线移动测试
        if self.user_confirm("测试笛卡尔直线移动?") == "skip":
            self.log_test("move_robot_cartesian", "SKIP", "用户跳过")
        else:
            target_pose = self.safe_pose.copy()
            target_pose[2] += 20  # Z轴上移20mm
            result, error = self.safe_execute(
                move_robot_cartesian, 
                target_pose, 
                speed_percentage=15, 
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("move_robot_cartesian", "PASS", "直线移动成功")
                time.sleep(1)
            else:
                self.log_test("move_robot_cartesian", "FAIL", f"失败: {error or result}")

    # ================================
    # 3. 点动API测试
    # ================================
    
    def test_jog_apis(self):
        """测试点动API"""
        print("\n" + "="*50)
        print("🕹️ 测试点动API")
        print("="*50)
        
        # 1. 单关节点动
        if self.user_confirm("测试单关节点动(底座+2度)?") == "skip":
            self.log_test("jog_robot_joint", "SKIP", "用户跳过")
        else:
            result, error = self.safe_execute(
                jog_robot_joint,
                joint_index=0,
                speed_percentage=15,
                distance_deg=2.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("jog_robot_joint", "PASS", "底座点动+2度成功")
                time.sleep(1)
            else:
                self.log_test("jog_robot_joint", "FAIL", f"失败: {error or result}")
        
        # 2. 多关节点动
        if self.user_confirm("测试多关节同时点动?") == "skip":
            self.log_test("jog_multiple_joints", "SKIP", "用户跳过")
        else:
            result, error = self.safe_execute(
                jog_multiple_joints,
                joints=[0, 1],  # 底座和肩部
                speeds=[10, 10],
                duration=1.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("jog_multiple_joints", "PASS", "多关节点动成功")
                time.sleep(1)
            else:
                self.log_test("jog_multiple_joints", "FAIL", f"失败: {error or result}")
        
        # 3. 笛卡尔点动
        if self.user_confirm("测试笛卡尔点动(Z轴向上)?") == "skip":
            self.log_test("jog_cartesian", "SKIP", "用户跳过")
        else:
            result, error = self.safe_execute(
                jog_cartesian,
                frame='WRF',
                axis='Z+',
                speed_percentage=15,
                duration=1.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("jog_cartesian", "PASS", "笛卡尔点动成功")
                time.sleep(1)
            else:
                self.log_test("jog_cartesian", "FAIL", f"失败: {error or result}")

    # ================================
    # 4. 平滑运动API测试
    # ================================
    
    def test_smooth_motion_apis(self):
        """测试平滑运动API"""
        print("\n" + "="*50)
        print("🌊 测试平滑运动API")
        print("="*50)
        
        # 1. 圆形运动
        if self.user_confirm("测试圆形运动(小半径)?") == "skip":
            self.log_test("smooth_circle", "SKIP", "用户跳过")
        else:
            result, error = self.safe_execute(
                smooth_circle,
                center=[200, 0, 200],
                radius=20,
                plane='XY',
                duration=5.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("smooth_circle", "PASS", "圆形运动成功")
                time.sleep(1)
            else:
                self.log_test("smooth_circle", "FAIL", f"失败: {error or result}")
        
        # 2. 圆弧运动(中心点)
        if self.user_confirm("测试圆弧运动?") == "skip":
            self.log_test("smooth_arc_center", "SKIP", "用户跳过")
        else:
            result, error = self.safe_execute(
                smooth_arc_center,
                end_pose=[220, 20, 200, 180, 0, 90],
                center=[210, 10, 200],
                duration=3.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("smooth_arc_center", "PASS", "圆弧运动成功")
                time.sleep(1)
            else:
                self.log_test("smooth_arc_center", "FAIL", f"失败: {error or result}")
        
        # 3. 参数化圆弧
        if self.user_confirm("测试参数化圆弧?") == "skip":
            self.log_test("smooth_arc_parametric", "SKIP", "用户跳过")
        else:
            result, error = self.safe_execute(
                smooth_arc_parametric,
                end_pose=[200, 20, 200, 180, 0, 90],
                radius=15,
                arc_angle=90,
                duration=3.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("smooth_arc_parametric", "PASS", "参数化圆弧成功")
                time.sleep(1)
            else:
                self.log_test("smooth_arc_parametric", "FAIL", f"失败: {error or result}")
        
        # 4. 样条曲线
        if self.user_confirm("测试样条曲线运动?") == "skip":
            self.log_test("smooth_spline", "SKIP", "用户跳过")
        else:
            waypoints = [
                [200, 0, 200, 180, 0, 90],
                [210, 10, 210, 180, 0, 90],
                [220, 0, 200, 180, 0, 90]
            ]
            result, error = self.safe_execute(
                smooth_spline,
                waypoints=waypoints,
                duration=5.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("smooth_spline", "PASS", "样条曲线运动成功")
                time.sleep(1)
            else:
                self.log_test("smooth_spline", "FAIL", f"失败: {error or result}")
        
        # 5. 螺旋运动
        if self.user_confirm("测试螺旋运动?") == "skip":
            self.log_test("smooth_helix", "SKIP", "用户跳过")
        else:
            result, error = self.safe_execute(
                smooth_helix,
                center=[200, 0, 180],
                radius=15,
                pitch=10,
                height=30,
                duration=6.0,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("smooth_helix", "PASS", "螺旋运动成功")
                time.sleep(1)
            else:
                self.log_test("smooth_helix", "FAIL", f"失败: {error or result}")

    # ================================
    # 5. 夹具控制API测试
    # ================================
    
    def test_gripper_apis(self):
        """测试夹具控制API"""
        print("\n" + "="*50)
        print("🤏 测试夹具控制API")
        print("="*50)
        
        # 1. 气动夹具控制
        if self.user_confirm("测试气动夹具控制?") == "skip":
            self.log_test("control_pneumatic_gripper", "SKIP", "用户跳过")
        else:
            # 打开夹具
            result, error = self.safe_execute(
                control_pneumatic_gripper,
                action='open',
                port=1,
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("control_pneumatic_gripper(open)", "PASS", "气动夹具打开成功")
                time.sleep(1)
                
                # 关闭夹具
                result, error = self.safe_execute(
                    control_pneumatic_gripper,
                    action='close',
                    port=1,
                    wait_for_ack=True
                )
                if result and result.get('status') == 'COMPLETED':
                    self.log_test("control_pneumatic_gripper(close)", "PASS", "气动夹具关闭成功")
                else:
                    self.log_test("control_pneumatic_gripper(close)", "FAIL", f"失败: {error or result}")
            else:
                self.log_test("control_pneumatic_gripper(open)", "FAIL", f"失败: {error or result}")
        
        # 2. 电动夹具控制
        if self.user_confirm("测试电动夹具控制?") == "skip":
            self.log_test("control_electric_gripper", "SKIP", "用户跳过")
        else:
            # 校准夹具
            result, error = self.safe_execute(
                control_electric_gripper,
                action='calibrate',
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("control_electric_gripper(calibrate)", "PASS", "电动夹具校准成功")
                time.sleep(2)
                
                # 移动夹具
                result, error = self.safe_execute(
                    control_electric_gripper,
                    action='move',
                    position=200,
                    speed=100,
                    wait_for_ack=True
                )
                if result and result.get('status') == 'COMPLETED':
                    self.log_test("control_electric_gripper(move)", "PASS", "电动夹具移动成功")
                else:
                    self.log_test("control_electric_gripper(move)", "FAIL", f"失败: {error or result}")
            else:
                self.log_test("control_electric_gripper(calibrate)", "FAIL", f"失败: {error or result}")

    # ================================
    # 6. 系统控制API测试
    # ================================
    
    def test_system_apis(self):
        """测试系统控制API"""
        print("\n" + "="*50)
        print("⚙️ 测试系统控制API")
        print("="*50)
        
        # 1. 延迟命令
        print("测试延迟命令(2秒)...")
        start_time = time.time()
        result, error = self.safe_execute(delay_robot, duration=2.0, wait_for_ack=True)
        elapsed = time.time() - start_time
        
        if result and result.get('status') == 'COMPLETED' and 1.8 <= elapsed <= 2.5:
            self.log_test("delay_robot", "PASS", f"延迟{elapsed:.1f}秒成功")
        else:
            self.log_test("delay_robot", "FAIL", f"失败: {error or result}, 用时{elapsed:.1f}秒")
        
        # 2. 停止运动(需要有运动时测试)
        print("测试停止命令...")
        result, error = self.safe_execute(stop_robot_movement, wait_for_ack=True)
        if result and result.get('status') == 'COMPLETED':
            self.log_test("stop_robot_movement", "PASS", "停止命令成功")
        else:
            self.log_test("stop_robot_movement", "FAIL", f"失败: {error or result}")

    # ================================
    # 7. 高级功能API测试
    # ================================
    
    def test_advanced_apis(self):
        """测试高级功能API"""
        print("\n" + "="*50)
        print("🚀 测试高级功能API")
        print("="*50)
        
        # 1. 轨迹执行
        if self.user_confirm("测试轨迹执行?") == "skip":
            self.log_test("execute_trajectory", "SKIP", "用户跳过")
        else:
            trajectory = [
                [200, 0, 200, 180, 0, 90],
                [210, 10, 200, 180, 0, 90],
                [200, 20, 200, 180, 0, 90]
            ]
            result, error = self.safe_execute(
                execute_trajectory,
                trajectory=trajectory,
                timing_mode='duration',
                timing_value=5.0,
                motion_type='spline',
                wait_for_ack=True
            )
            if result and result.get('status') == 'COMPLETED':
                self.log_test("execute_trajectory", "PASS", "轨迹执行成功")
            else:
                self.log_test("execute_trajectory", "FAIL", f"失败: {error or result}")
        
        # 2. 等待停止
        # result, error = self.safe_execute(wait_for_robot_stop, timeout=5.0)
        # if result is True:
        #     self.log_test("wait_for_robot_stop", "PASS", "等待停止成功")
        # else:
        #     self.log_test("wait_for_robot_stop", "FAIL", f"失败: {error}")
        
        # 3. 检查跟踪状态
        result, error = self.safe_execute(is_tracking_active)
        if result is not None:
            self.log_test("is_tracking_active", "PASS", f"跟踪状态: {result}")
        else:
            self.log_test("is_tracking_active", "FAIL", f"失败: {error}")
        
        # 4. 获取跟踪统计
        result, error = self.safe_execute(get_tracking_stats)
        if result is not None:
            self.log_test("get_tracking_stats", "PASS", f"跟踪统计获取成功")
        else:
            self.log_test("get_tracking_stats", "FAIL", f"失败: {error}")

    # ================================
    # 主测试流程
    # ================================
    
    def run_all_tests(self):
        """运行所有测试"""
        print("\n🚀 开始PAROL6 API全功能测试")
        print("测试将分为7个类别进行...")
        
        start_time = time.time()
        
        try:
            # 1. 状态查询测试(安全，总是执行)
            self.test_status_apis()
            
            # 2. 基础移动测试
            if self.user_confirm("\n是否测试基础移动API?") != False:
                self.test_basic_movement_apis()
            else:
                print("⏭️ 跳过基础移动测试")
            
            # 3. 点动测试
            if self.user_confirm("\n是否测试点动API?") != False:
                self.test_jog_apis()
            else:
                print("⏭️ 跳过点动测试")
            
            # 4. 平滑运动测试
            if self.user_confirm("\n是否测试平滑运动API?") != False:
                self.test_smooth_motion_apis()
            else:
                print("⏭️ 跳过平滑运动测试")
            
            # 5. 夹具控制测试
            if self.user_confirm("\n是否测试夹具控制API?") != False:
                self.test_gripper_apis()
            else:
                print("⏭️ 跳过夹具控制测试")
            
            # 6. 系统控制测试
            if self.user_confirm("\n是否测试系统控制API?") != False:
                self.test_system_apis()
            else:
                print("⏭️ 跳过系统控制测试")
            
            # 7. 高级功能测试
            if self.user_confirm("\n是否测试高级功能API?") != False:
                self.test_advanced_apis()
            else:
                print("⏭️ 跳过高级功能测试")
                
        except KeyboardInterrupt:
            print("\n🛑 测试被用户中断")
        except Exception as e:
            print(f"\n❌ 测试过程发生错误: {e}")
            traceback.print_exc()
        
        finally:
            # 生成测试报告
            self.generate_report(time.time() - start_time)

    def generate_report(self, total_time):
        """生成测试报告"""
        print("\n" + "="*60)
        print("📊 PAROL6 API 测试报告")
        print("="*60)
        
        print(f"🕐 总测试时间: {total_time:.1f}秒")
        print(f"📈 测试统计:")
        print(f"   总测试数: {self.test_count}")
        print(f"   ✅ 通过: {self.passed_count}")
        print(f"   ❌ 失败: {self.failed_count}")
        print(f"   ⏭️ 跳过: {self.skipped_count}")
        
        if self.test_count > 0:
            success_rate = (self.passed_count / (self.test_count - self.skipped_count)) * 100 if (self.test_count - self.skipped_count) > 0 else 0
            print(f"   📊 成功率: {success_rate:.1f}%")
        
        # 详细结果
        print(f"\n📋 详细测试结果:")
        for test_name, result in self.test_results.items():
            status_icon = {"PASS": "✅", "FAIL": "❌", "SKIP": "⏭️"}[result["status"]]
            print(f"   {status_icon} {test_name}: {result['details']}")
        
        # 失败分析
        if self.failed_count > 0:
            print(f"\n⚠️ 失败的测试:")
            for test_name, result in self.test_results.items():
                if result["status"] == "FAIL":
                    print(f"   ❌ {test_name}: {result['details']}")
        
        print(f"\n🎯 测试建议:")
        if self.failed_count == 0:
            print("   🎉 所有测试通过！API功能正常")
        else:
            print("   🔧 请检查失败的API功能")
            print("   📖 参考文档确认使用方法")
            print("   🔗 检查机器人连接和状态")
        
        print("="*60)

def main():
    """主程序"""
    print("🔬 PAROL6 API 全功能安全测试程序")
    print("="*50)
    
    # 创建测试器
    tester = PAROL6APITester()
    
    # 安全确认
    print("\n⚠️ 安全检查清单:")
    print("□ 机器人周围安全无障碍")
    print("□ 急停按钮可随时按下")
    print("□ 工作空间足够大")
    print("□ 已做好应急准备")
    
    if not tester.user_confirm("\n确认以上安全条件已满足，开始测试?"):
        print("❌ 用户取消测试")
        return
    
    try:
        # 运行所有测试
        tester.run_all_tests()
        
    except KeyboardInterrupt:
        print("\n🛑 程序被用户中断")
    except Exception as e:
        print(f"\n❌ 程序错误: {e}")
        traceback.print_exc()
    finally:
        print("\n👋 测试程序结束")

if __name__ == "__main__":
    main()
````

## File: test/base01.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 简单底座旋转控制程序（简化版）
只控制底座关节，小角度慢速旋转
"""

import time
from robot_api import *

class SimpleBaseController:
    def __init__(self):
        """初始化底座控制器"""
        self.base_joint_index = 0  # 底座是第1个关节（索引0）
        self.max_angle_step = 5.0  # 每次最大旋转角度（度）
        self.slow_speed = 15       # 慢速度（百分比）
        
        print("🤖 底座控制器已初始化")
        print(f"📊 设置：最大步长{self.max_angle_step}°，速度{self.slow_speed}%")

    def rotate_base(self, angle_degrees):
        """
        旋转底座指定角度
        
        参数:
        angle_degrees: 旋转角度（正数顺时针，负数逆时针）
        """
        try:
            # 限制角度范围
            if abs(angle_degrees) > self.max_angle_step:
                print(f"⚠️ 角度限制为±{self.max_angle_step}°")
                angle_degrees = self.max_angle_step if angle_degrees > 0 else -self.max_angle_step
            
            print(f"🔄 底座旋转 {angle_degrees}°...")
            
            # 确定方向
            if angle_degrees > 0:
                joint_index = self.base_joint_index  # 正方向 (0)
            else:
                joint_index = self.base_joint_index + 6  # 负方向 (6)
                angle_degrees = abs(angle_degrees)
            
            # 执行旋转
            result = jog_robot_joint(
                joint_index=joint_index,
                speed_percentage=self.slow_speed,
                distance_deg=angle_degrees,
                wait_for_ack=True,
                timeout=10.0
            )
            
            if result and result.get('status') == 'COMPLETED':
                print("✅ 底座旋转完成")
                return True
            else:
                print("❌ 底座旋转失败")
                print(f"   结果: {result}")
                return False
                
        except Exception as e:
            print(f"❌ 旋转错误: {e}")
            return False

    def get_base_angle(self):
        """获取当前底座角度"""
        try:
            angles = get_robot_joint_angles()
            if angles:
                base_angle = angles[0]
                print(f"📍 当前底座角度: {base_angle:.2f}°")
                return base_angle
            else:
                print("❌ 无法获取角度信息")
                return None
        except Exception as e:
            print(f"❌ 获取角度错误: {e}")
            return None

def main():
    """主程序"""
    print("=" * 40)
    print("🤖 PAROL6 简单底座控制")
    print("=" * 40)
    
    controller = SimpleBaseController()
    
    try:
        # 询问是否需要归零
        home_choice = input("是否需要机器人归零? (y/N): ").lower()
        if home_choice == 'y':
            print("🏠 机器人归零...")
            result = home_robot(wait_for_ack=True, timeout=30)
            if result:
                print("✅ 归零完成")
            else:
                print("⚠️ 归零可能未完成，请检查")
            
            # 等待稳定
            time.sleep(2)
        
        # 显示当前角度
        controller.get_base_angle()
        
        while True:
            print("\n" + "-" * 30)
            print("选择操作:")
            print("1. 顺时针旋转")
            print("2. 逆时针旋转")
            print("3. 查看当前角度")
            print("4. 查看所有关节角度")
            print("5. 退出")
            print("-" * 30)
            
            choice = input("请选择 (1-5): ").strip()
            
            if choice == '1':
                # 顺时针旋转
                try:
                    angle = float(input(f"输入角度 (1-{controller.max_angle_step}): ") or "2")
                    controller.rotate_base(abs(angle))
                except ValueError:
                    print("❌ 输入无效")
                    
            elif choice == '2':
                # 逆时针旋转
                try:
                    angle = float(input(f"输入角度 (1-{controller.max_angle_step}): ") or "2")
                    controller.rotate_base(-abs(angle))
                except ValueError:
                    print("❌ 输入无效")
                    
            elif choice == '3':
                # 查看底座角度
                controller.get_base_angle()
                
            elif choice == '4':
                # 查看所有关节角度
                try:
                    angles = get_robot_joint_angles()
                    if angles:
                        print("🔧 所有关节角度:")
                        joint_names = ["底座", "肩部", "肘部", "腕1", "腕2", "腕3"]
                        for i, angle in enumerate(angles):
                            print(f"   {joint_names[i]}: {angle:.2f}°")
                    else:
                        print("❌ 无法获取关节角度")
                except Exception as e:
                    print(f"❌ 获取角度错误: {e}")
                    
            elif choice == '5':
                # 退出
                print("👋 程序退出")
                break
                
            else:
                print("❌ 无效选择，请输入1-5")
                
    except KeyboardInterrupt:
        print("\n🛑 程序中断")
    except Exception as e:
        print(f"❌ 程序错误: {e}")

if __name__ == "__main__":
    main()
````

## File: test/base02.py
````python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PAROL6 安全底座旋转控制程序
通过命令结果检测异常状态
"""
import sys
import os

# 获取当前文件的绝对路径
current_dir = os.path.dirname(os.path.abspath(__file__))

# 获取父目录路径
parent_dir = os.path.dirname(current_dir)

# 将父目录添加到模块搜索路径中
sys.path.append(parent_dir)

# 现在可以导入父目录中的模块
from robot_api import *
import time


class SafeBaseController:
    def __init__(self):
        """初始化底座控制器"""
        self.base_joint_index = 0  # 底座是第1个关节（索引0）
        self.max_angle_step = 3.0  # 减小最大角度为3度，更安全
        self.slow_speed = 10       # 进一步降低速度到10%
        self.last_successful_angles = None
        
        print("🛡️ 安全底座控制器已初始化")
        print(f"📊 安全设置：最大步长{self.max_angle_step}°，速度{self.slow_speed}%")
        print("⚠️ 注意：急停时请手动停止程序！")

    def safety_check_by_status(self):
        """通过状态查询进行安全检查"""
        try:
            # 尝试获取当前角度作为通信测试
            angles = get_robot_joint_angles()
            if angles is None:
                print("⚠️ 警告：无法获取机器人状态，可能存在问题")
                return False
            
            # 检查角度是否合理（不是异常值）
            base_angle = angles[0]
            if abs(base_angle) > 180:
                print(f"⚠️ 警告：底座角度异常 {base_angle}°")
                return False
            
            self.last_successful_angles = angles
            return True
            
        except Exception as e:
            print(f"⚠️ 状态检查失败: {e}")
            return False

    def safe_rotate_base(self, angle_degrees):
        """
        安全旋转底座，包含多重检查
        """
        # 预检查
        if not self.safety_check_by_status():
            print("❌ 安全检查失败，取消移动")
            return False
        
        try:
            # 限制角度
            if abs(angle_degrees) > self.max_angle_step:
                print(f"⚠️ 角度限制为±{self.max_angle_step}°")
                angle_degrees = self.max_angle_step if angle_degrees > 0 else -self.max_angle_step
            
            # 获取移动前状态
            before_angles = get_robot_joint_angles()
            if not before_angles:
                print("❌ 无法获取移动前状态")
                return False
            
            print(f"🔄 准备底座旋转 {angle_degrees}°...")
            print(f"   当前角度: {before_angles[0]:.2f}°")
            
            # 用户确认（对于大角度）
            if abs(angle_degrees) > 2.0:
                confirm = input(f"确认旋转 {angle_degrees}°? (y/N): ").lower()
                if confirm != 'y':
                    print("❌ 用户取消操作")
                    return False
            
            # 确定方向
            if angle_degrees > 0:
                joint_index = self.base_joint_index  # 正方向
            else:
                joint_index = self.base_joint_index + 6  # 负方向
                angle_degrees = abs(angle_degrees)
            
            # 执行旋转
            print(f"🔄 执行旋转...")
            result = jog_robot_joint(
                joint_index=joint_index,
                speed_percentage=self.slow_speed,
                distance_deg=angle_degrees,
                wait_for_ack=True,
                timeout=15.0  # 增加超时时间
            )
            
            # 检查结果
            if not result:
                print("❌ 旋转命令无响应，可能机器人被急停")
                return False
                
            if result.get('status') != 'COMPLETED':
                print(f"❌ 旋转失败: {result.get('status', '未知错误')}")
                print(f"   详情: {result}")
                return False
            
            # 移动后验证
            time.sleep(1)  # 等待稳定
            after_angles = get_robot_joint_angles()
            if not after_angles:
                print("⚠️ 移动后无法获取状态，请检查机器人")
                return False
            
            # 验证移动是否成功
            angle_change = after_angles[0] - before_angles[0]
            expected_change = angle_degrees if joint_index == 0 else -angle_degrees
            
            if abs(angle_change - expected_change) > 1.0:  # 允许1度误差
                print(f"⚠️ 移动结果异常:")
                print(f"   期望变化: {expected_change:.2f}°")
                print(f"   实际变化: {angle_change:.2f}°")
            else:
                print("✅ 底座旋转完成并验证成功")
                print(f"   新角度: {after_angles[0]:.2f}°")
            
            return True
                
        except Exception as e:
            print(f"❌ 旋转错误: {e}")
            return False

    def get_base_status(self):
        """获取详细的底座状态"""
        try:
            angles = get_robot_joint_angles()
            if angles:
                print(f"📍 底座状态:")
                print(f"   当前角度: {angles[0]:.2f}°")
                print(f"   所有关节: {[round(a, 2) for a in angles]}")
                
                # 显示变化（如果有之前的数据）
                if self.last_successful_angles:
                    change = angles[0] - self.last_successful_angles[0]
                    if abs(change) > 0.1:
                        print(f"   角度变化: {change:.2f}°")
                
                return angles[0]
            else:
                print("❌ 无法获取状态")
                return None
                
        except Exception as e:
            print(f"❌ 状态获取错误: {e}")
            return None

def main():
    """主程序"""
    print("=" * 50)
    print("🛡️ PAROL6 安全底座控制程序")
    print("=" * 50)
    print("⚠️ 安全提醒:")
    print("   1. 急停按钮随时可用")
    print("   2. 如按急停，请手动停止程序(Ctrl+C)")
    print("   3. 每次移动都会进行安全检查")
    print("   4. 大角度移动需要确认")
    print("=" * 50)
    
    controller = SafeBaseController()
    
    try:
        # 初始状态检查
        if not controller.safety_check_by_status():
            print("❌ 初始安全检查失败，程序退出")
            return
        
        # 询问是否需要归零
        home_choice = input("\n是否需要机器人归零? (y/N): ").lower()
        if home_choice == 'y':
            print("🏠 机器人归零...")
            result = home_robot(wait_for_ack=True, timeout=30)
            time.sleep(2)
            
        # 显示当前状态
        controller.get_base_status()
        
        while True:
            print("\n" + "=" * 30)
            print("🎮 控制选项:")
            print("1. 小角度顺时针 (+1°)")
            print("2. 小角度逆时针 (-1°)")
            print("3. 中角度顺时针 (+3°)")
            print("4. 中角度逆时针 (-3°)")
            print("5. 自定义角度")
            print("6. 查看状态")
            print("7. 安全检查")
            print("8. 退出")
            print("=" * 30)
            
            choice = input("请选择 (1-8): ").strip()
            
            if choice == '1':
                controller.safe_rotate_base(1.0)
            elif choice == '2':
                controller.safe_rotate_base(-1.0)
            elif choice == '3':
                controller.safe_rotate_base(3.0)
            elif choice == '4':
                controller.safe_rotate_base(-3.0)
            elif choice == '5':
                try:
                    angle = float(input(f"输入角度 (±{controller.max_angle_step}): "))
                    controller.safe_rotate_base(angle)
                except ValueError:
                    print("❌ 输入无效")
            elif choice == '6':
                controller.get_base_status()
            elif choice == '7':
                if controller.safety_check_by_status():
                    print("✅ 安全检查通过")
                else:
                    print("❌ 安全检查失败")
            elif choice == '8':
                print("👋 程序安全退出")
                break
            else:
                print("❌ 无效选择")
                
            # 每次操作后短暂暂停
            time.sleep(0.5)
                
    except KeyboardInterrupt:
        print("\n🛑 程序被用户中断")
        print("✅ 安全退出")
    except Exception as e:
        print(f"\n❌ 程序错误: {e}")
        print("🛑 建议检查机器人状态")

if __name__ == "__main__":
    main()
````

## File: test/testik.py
````python
# d:/Onedrive/p/09-PAROL6-python-API/test/testik.py
import numpy as np
import spatialmath as sm
from roboticstoolbox.models.DH import Puma560

r = Puma560()  # DHRobot

# 目标位姿：0.5m, 0.1m, 0.2m，姿态用RPY(度)
T = sm.SE3(0.5, 0.1, 0.2) * sm.SE3.RPY([0, 90, 0], unit='deg')

# 初始猜测（给个合理的初值更容易收敛）
q0 = r.qz  # 零姿；也可以用当前关节角

# 用 ikine_LM（1.0.3 版本正确方法名）
sol = r.ikine_LM(T, q0=q0)  # 可加 ilimit=100, slimit=100 调参

if sol.success:
    print("IK 成功！关节角(度)：", np.rad2deg(sol.q))
else:
    print("IK 失败：", sol.reason)
````

## File: PAROL6_ROBOT.py
````python
# This file acts as configuration file for robot you are using
# It works in conjustion with configuration file from robotics toolbox

from swift import Swift
import spatialmath.base.symbolic as sym
from roboticstoolbox import ETS as ET
from roboticstoolbox import *
import roboticstoolbox as rtb
from spatialmath import *
from spatialgeometry import *
from math import pi
import numpy as np
import time
import random

Joint_num = 6 # Number of joints
Microstep = 32
steps_per_revolution=200
degree_per_step_constant = 360/(32*200) 
radian_per_step_constant = (2*pi) / (32*200)
radian_per_sec_2_deg_per_sec_const = 360/ (2*np.pi)
deg_per_sec_2_radian_per_sec_const = (2*np.pi) / 360

# robot length values (metres)
a1 = 110.50 / 1000
a2 = 23.42 / 1000
a3 = 180 / 1000
a4 = 43.5 / 1000
a5 = 176.35 / 1000
a6 = 62.8 / 1000
a7 = 45.25 / 1000

alpha_DH = [-pi / 2,pi,pi/2,-pi/2,pi/2,pi]

robot = DHRobot(
    [
        RevoluteDH(d=a1, a=a2, alpha=alpha_DH[0]),
        RevoluteDH(a=a3,d = 0,alpha=alpha_DH[1]),
        RevoluteDH(alpha= alpha_DH[2], a= -a4),
        RevoluteDH(d=-a5, a=0, alpha=alpha_DH[3]),
        RevoluteDH(a=0,d=0,alpha=alpha_DH[4]),
        RevoluteDH(alpha=alpha_DH[5], a = -a7,d = -a6),
    ],
    name="PAROL6",
)
#print(robot.isspherical())
#pyplot = rtb.backends.PyPlot()

# in degrees
Joints_standby_position_degree = np.array([0,-90,180,0,0,180]) 
# in radians
Joints_standby_position_radian = [np.deg2rad(angle) for angle in Joints_standby_position_degree]

# values you get after homing robot and moving it to its most left and right sides
# In degrees
Joint_limits_degree =[[-123.046875,123.046875], [-145.0088,-3.375], [107.866,287.8675], [-105.46975,105.46975], [-90,90], [0,360]] 

# in radians
Joint_limits_radian = []
for limits in Joint_limits_degree:
    radian_limits = [np.deg2rad(angle) for angle in limits]
    Joint_limits_radian.append(radian_limits)

# Reduction ratio we have on our joints
Joint_reduction_ratio = [6.4, 20, 20*(38/42) , 4, 4, 10] 

# min and max jog speeds. Usually slower from real maximal speeds
Joint_max_jog_speed = [1500, 3000, 3600, 7000, 7000, 18000]
Joint_min_jog_speed = [100,100,100,100,100,100]

# LINEAR CARTESIAN JOG MAX MIN SPEED IN METERS PER SECOND
Cartesian_linear_velocity_min_JOG = 0.002
Cartesian_linear_velocity_max_JOG = 0.06

# LINEAR CARTESIAN MAX MIN SPEED IN METERS PER SECOND
Cartesian_linear_velocity_min = 0.002
Cartesian_linear_velocity_max = 0.06

# LINEAR CARTESIAN MAX MIN ACC IN METERS PER SECOND²
Cartesian_linear_acc_min = 0.002
Cartesian_linear_acc_max = 0.06

# ANGULAR CARTESIAN JOG MAX MIN SPEED IN DEGREES PER SECOND
Cartesian_angular_velocity_min = 0.7
Cartesian_angular_velocity_max = 25

Joint_max_speed = [6500,18000,20000,20000,22000,22000] # max speed in STEP/S used
Joint_min_speed = [100,100,100,100,100,100] # min speed in STEP/S used 

Joint_max_acc = 32000 # max acceleration in RAD/S²
Joint_min_acc = 100 # min acceleration in RAD/S²

Cart_lin_velocity_limits = [[-100,100],[-100,100],[-100,100]]
Cart_ang_velocity_limits = [[-100,100],[-100,100],[-100,100]]


Commands_list = [ "Input","Output","Dummy","Begin","Home","Delay","End","Loop","MoveJoint","MovePose","SpeedJoint","MoveCart",
                 "MoveCart","MoveCartRelTRF","Gripper","Gripper_cal"]

Commands_list_true = [item + "()" for item in Commands_list]

# 360 / (200 * 32) = 0.05625
def DEG2STEPS(Degrees, index):
    Steps = Degrees / degree_per_step_constant * Joint_reduction_ratio[index]
    return Steps

Joint_limits_steps =[[DEG2STEPS(Joint_limits_degree[0][0],0),DEG2STEPS(Joint_limits_degree[0][1],0)],
                      [DEG2STEPS(Joint_limits_degree[1][0],1),DEG2STEPS(Joint_limits_degree[1][1],1)],
                      [DEG2STEPS(Joint_limits_degree[2][0],2),DEG2STEPS(Joint_limits_degree[2][1],2)],
                      [DEG2STEPS(Joint_limits_degree[3][0],3),DEG2STEPS(Joint_limits_degree[3][1],3)],
                      [DEG2STEPS(Joint_limits_degree[4][0],4),DEG2STEPS(Joint_limits_degree[4][1],4)],
                      [DEG2STEPS(Joint_limits_degree[5][0],5),DEG2STEPS(Joint_limits_degree[5][1],5)]]
Joint_limits_steps = [[int(i[0]),int(i[1])] for i in Joint_limits_steps]


def STEPS2DEG(Steps,index):
    Degrees = Steps * degree_per_step_constant / Joint_reduction_ratio[index]
    return Degrees

def RAD2STEPS(Rads,index):
    deg = np.rad2deg(Rads)
    steps = DEG2STEPS(deg,index)
    return steps

def STEPS2RADS(Steps,index):
    deg = STEPS2DEG(Steps,index)
    rads = np.deg2rad(deg)
    return rads

def RAD2DEG(radian):
    return np.rad2deg(radian)

def DEG2RAD(degree):
    return np.deg2rad(degree)

def SPEED_STEPS2DEG(Steps_per_second,index):

    '''     Transform true RADS/S to true RPM.
    Both these values are true values at witch MOTORS SPIN  '''

    degrees_per_step = degree_per_step_constant / Joint_reduction_ratio[index]
    degrees_per_second = Steps_per_second * degrees_per_step
    return degrees_per_second

def SPEED_DEG2STEPS(Deg_per_second,index):
    steps_per_second = Deg_per_second / degree_per_step_constant * Joint_reduction_ratio[index]
    return steps_per_second

def SPEED_STEP2RAD(Steps_per_second,index):
    degrees_per_step = radian_per_step_constant / Joint_reduction_ratio[index]
    rad_per_second = Steps_per_second * degrees_per_step
    return rad_per_second

def SPEED_RAD2STEP(Rad_per_second,index):
    steps_per_second = Rad_per_second / radian_per_step_constant * Joint_reduction_ratio[index]
    return steps_per_second

def RAD_SEC_2_DEG_SEC(rad_per_sec):
    return rad_per_sec * radian_per_sec_2_deg_per_sec_const

def DEG_SEC_2_RAD_SEC(deg_per_sec):
    return deg_per_sec * deg_per_sec_2_radian_per_sec_const


def check_joint_limits(q, target_q=None, allow_recovery=True):
    """
    Check if joint angles are within their limits, with support for recovery movements.
    
    Parameters
    ----------
    q : array_like
        Current joint angles in radians
    target_q : array_like, optional
        Target joint angles in radians. If provided, recovery logic is applied.
    allow_recovery : bool, optional
        Whether to allow recovery movements when current position violates limits
        
    Returns
    -------
    bool
        True if movement is allowed (within limits or valid recovery), False otherwise
    dict
        Dictionary with joint limit violation details and recovery information
    """
    q_array = np.array(q)
    target_array = np.array(target_q) if target_q is not None else None
    violations = {}
    all_valid = True
    
    for i in range(min(len(q_array), len(Joint_limits_radian))):
        min_limit = Joint_limits_radian[i][0]
        max_limit = Joint_limits_radian[i][1]
        current_pos = q_array[i]
        
        # Check if current position violates limits
        current_violates = current_pos < min_limit or current_pos > max_limit
        
        if current_violates:
            violation_type = 'below_min' if current_pos < min_limit else 'above_max'
            
            # If we have a target and recovery is enabled, check if it's a recovery movement
            if target_array is not None and allow_recovery:
                target_pos = target_array[i]
                is_recovery = False
                
                if current_pos > max_limit:  # Past upper limit
                    # Recovery means moving towards or below the upper limit
                    is_recovery = target_pos <= current_pos
                    recovery_direction = "move joint towards negative direction"
                elif current_pos < min_limit:  # Past lower limit
                    # Recovery means moving towards or above the lower limit  
                    is_recovery = target_pos >= current_pos
                    recovery_direction = "move joint towards positive direction"
                
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': target_pos if target_array is not None else None,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': violation_type,
                    'is_recovery': is_recovery,
                    'recovery_direction': recovery_direction if not is_recovery else None,
                    'movement_allowed': is_recovery
                }
                
                # Only flag as invalid if it's not a recovery movement
                if not is_recovery:
                    all_valid = False
            else:
                # No target provided or recovery disabled - flag as violation
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': None,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': violation_type,
                    'is_recovery': False,
                    'recovery_direction': None,
                    'movement_allowed': False
                }
                all_valid = False
        elif target_array is not None:
            # Current is within limits, check if target would violate
            target_pos = target_array[i]
            target_violates = target_pos < min_limit or target_pos > max_limit
            
            if target_violates:
                target_violation_type = 'below_min' if target_pos < min_limit else 'above_max'
                violations[f'joint_{i+1}'] = {
                    'current_value': current_pos,
                    'target_value': target_pos,
                    'min_limit': min_limit,
                    'max_limit': max_limit,
                    'violation': f'target_{target_violation_type}',
                    'is_recovery': False,
                    'recovery_direction': None,
                    'movement_allowed': False
                }
                all_valid = False
    
    return all_valid, violations

def extract_from_can_id(can_id):
    # Extracting ID2 (first 4 MSB)
    id2 = (can_id >> 7) & 0xF

    # Extracting CAN Command (next 6 bits)
    can_command = (can_id >> 1) & 0x3F

    # Extracting Error Bit (last bit)
    error_bit = can_id & 0x1
    
    return id2, can_command, error_bit


def combine_2_can_id(id2, can_command, error_bit):
    # Combine components into an 11-bit CAN ID
    can_id = 0

    # Add ID2 (first 4 MSB)
    can_id |= (id2 & 0xF) << 7

    # Add CAN Command (next 6 bits)
    can_id |= (can_command & 0x3F) << 1

    # Add Error Bit (last bit)
    can_id |= (error_bit & 0x1)

    return can_id

# Fuse bitfield list to byte
def fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Splits byte to bitfield list
def split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]


if __name__ == "__main__":
    """
    print(DEG2STEPS(180,2))
    print(STEPS2DEG(57905,2))
    print(RAD2STEPS(pi,5))
    print(STEPS2RADS(32000,5))
    print(SPEED_STEPS2DEG(1000,5))
    print(SPEED_STEP2RAD(1000,5))
    print(Joint_limits_radian)
    print(Joints_standby_position_radian)
    print(Joint_limits_steps)
    print(Joint_limits_radian)
    print(DEG2STEPS(-62.5,1))
    """

    J0_var = STEPS2RADS(1,0)
    J1_var = STEPS2RADS(1,1)
    J2_var = STEPS2RADS(1,2)
    J3_var = STEPS2RADS(1,3)
    J4_var = STEPS2RADS(1,4)
    J5_var = STEPS2RADS(1,5)


    print("Joint 1 smallest step:",RAD2DEG(J0_var))
    print("Joint 2 smallest step:",RAD2DEG(J1_var))
    print("Joint 3 smallest step:",RAD2DEG(J2_var))
    print("Joint 4 smallest step:",RAD2DEG(J3_var))
    print("Joint 5 smallest step:",RAD2DEG(J4_var))
    print("Joint 6 smallest step:",RAD2DEG(J5_var))
    print("rad 2 step:",SPEED_RAD2STEP(-2.948504399390715 / 2,5))
    print("standby radian is",Joints_standby_position_radian)

    test = RAD2STEPS(0.0001,5)
    print(test)

    #robot.ikine_LM()
````

## File: headless_commander.py
````python
'''
A full fledged "API" for the PAROL6 robot. To use this, you should pair it with the "robot_api.py" where you can import commands
from said file and use them anywhere within your code. This Python script will handle sending and performing all the commands
to the PAROL6 robot, as well as E-Stop functionality and safety limitations.

To run this program, you must use the "experimental-kinematics" branch of the "PAROL-commander-software" on GitHub
which can be found through this link: https://github.com/PCrnjak/PAROL-commander-software/tree/experimental_kinematics.
You must also save these files into the following folder: "Project Files\PAROL-commander-software\GUI\files".
'''

# * If you press estop robot will stop and you need to enable it by pressing e

from roboticstoolbox import DHRobot, RevoluteDH, ERobot, ELink, ETS, trapezoidal, quintic
import roboticstoolbox as rp
from math import pi, sin, cos
import numpy as np
from oclock import Timer, loop, interactiveloop
import time
import socket
from spatialmath import SE3
import select
import serial
import platform
import os
import re
import logging
import struct
import keyboard
from typing import Optional, Tuple
from spatialmath.base import trinterp
from collections import namedtuple, deque
import GUI.files.PAROL6_ROBOT as PAROL6_ROBOT
from smooth_motion import CircularMotion, SplineMotion, MotionBlender

# Set interval
INTERVAL_S = 0.01
prev_time = 0

logging.basicConfig(level = logging.DEBUG,
    format='%(asctime)s.%(msecs)03d %(levelname)s:\t%(message)s',
    datefmt='%H:%M:%S'
)
logging.disable(logging.DEBUG)


my_os = platform.system()
if my_os == "Windows":
    # Try to read the COM port from a file
    try:
        with open("com_port.txt", "r") as f:
            com_port_str = f.read().strip()
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            print(f"Connected to saved COM port: {com_port_str}")
    except (FileNotFoundError, serial.SerialException):
        # If the file doesn't exist or the port is invalid, ask the user
        while True:
            try:
                com_port = input("Enter the COM port (e.g., COM9): ")
                ser = serial.Serial(port=com_port, baudrate=3000000, timeout=0)
                print(f"Successfully connected to {com_port}")
                # Save the successful port to the file
                with open("com_port.txt", "w") as f:
                    f.write(com_port)
                break
            except serial.SerialException:
                print(f"Could not open port {com_port}. Please try again.")

# in big endian machines, first byte of binary representation of the multibyte data-type is stored first. 
int_to_3_bytes = struct.Struct('>I').pack # BIG endian order

# data for output string (data that is being sent to the robot)
#######################################################################################
#######################################################################################
start_bytes =  [0xff,0xff,0xff] 
start_bytes = bytes(start_bytes)

end_bytes =  [0x01,0x02] 
end_bytes = bytes(end_bytes)


# data for input string (Data that is being sent by the robot)
#######################################################################################
#######################################################################################
input_byte = 0 # Here save incoming bytes from serial

start_cond1_byte = bytes([0xff])
start_cond2_byte = bytes([0xff])
start_cond3_byte = bytes([0xff])

end_cond1_byte = bytes([0x01])
end_cond2_byte = bytes([0x02])

start_cond1 = 0 #Flag if start_cond1_byte is received
start_cond2 = 0 #Flag if start_cond2_byte is received
start_cond3 = 0 #Flag if start_cond3_byte is received

good_start = 0 #Flag if we got all 3 start condition bytes
data_len = 0 #Length of the data after -3 start condition bytes and length byte, so -4 bytes

data_buffer = [None]*255 #Here save all data after data length byte
data_counter = 0 #Data counter for incoming bytes; compared to data length to see if we have correct length
#######################################################################################
#######################################################################################
prev_positions = [0,0,0,0,0,0]
prev_speed = [0,0,0,0,0,0]
robot_pose = [0,0,0,0,0,0] #np.array([0,0,0,0,0,0])
#######################################################################################
#######################################################################################

# --- Wrapper class to make integers mutable when passed to functions ---
class CommandValue:
    def __init__(self, value):
        self.value = value

#######################################################################################
#######################################################################################
Position_out = [1,11,111,1111,11111,10]
Speed_out = [2,21,22,23,24,25]
Command_out = CommandValue(255)
Affected_joint_out = [1,1,1,1,1,1,1,1]
InOut_out = [0,0,0,0,0,0,0,0]
Timeout_out = 0
#Positon,speed,current,command,mode,ID
Gripper_data_out = [1,1,1,1,0,0]
#######################################################################################
#######################################################################################
# Data sent from robot to PC
Position_in = [31,32,33,34,35,36]
Speed_in = [41,42,43,44,45,46]
Homed_in = [0,0,0,0,0,0,0,0]
InOut_in = [1,1,1,1,1,1,1,1]
Temperature_error_in = [1,1,1,1,1,1,1,1]
Position_error_in = [1,1,1,1,1,1,1,1]
Timeout_error = 0
# how much time passed between 2 sent commands (2byte value, last 2 digits are decimal so max value is 655.35ms?)
Timing_data_in = [0]
XTR_data =   0

# --- State variables for program execution ---
Robot_mode = "Dummy"  # Start in an idle state
Program_step = 0      # Which line of the program to run
Command_step = 0      # The current step within a single command
Command_len = 0       # The total steps for the current command
ik_error = 0          # Flag for inverse kinematics errors
error_state = 0       # General error flag
program_running = False # A flag to start and stop the program

# This will be your "program"
command_list = []

#ID,Position,speed,current,status,obj_detection
Gripper_data_in = [1,1,1,1,1,1] 

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179° and 181° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    
    Parameters
    ----------
    robot : DHRobot
        Robot model
    q : array_like
        Joint configuration
    strict_tol : float
        Strict tolerance away from singularities (default: 1e-10)
    loose_tol : float
        Loose tolerance near singularities (1e-7)
        
    Returns
    -------
    float
        Adaptive tolerance value
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    
    Parameters
    ----------
    q_seed : array_like
        Current joint configuration in radians
        
    Returns
    -------
    float
        Configuration-dependent maximum reach threshold
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 | None = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities:
    - Near singularities: looser tolerance for easier convergence
    - Away from singularities: stricter tolerance for precise solutions
    If necessary, recursively subdivide the motion until ikine_LM converges
    on every segment. Finally check that solution respects joint limits. From experimentation,
    jogging with lower tolerances often produces q_paths that do not differ from current_q,
    essentially freezing the robot.

    Parameters
    ----------
    robot : DHRobot
        Robot model
    target_pose : SE3
        Target pose to reach
    current_q : array_like
        Current joint configuration
    current_pose : SE3, optional
        Current pose (computed if None)
    max_depth : int, optional
        Maximum subdivision depth (default: 8)
    ilimit : int, optional
        Maximum iterations for IK solver (default: 100)

    Returns
    -------
    IKResult
        success  - True/False
        q_path   - (mxn) array of the final joint configuration 
        iterations, residual  - aggregated diagnostics
        tolerance_used - which tolerance was used
        violations - joint limit violations (if any)
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # ── inner recursive solver───────────────────
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            # print(f"current_reach:{current_reach:.3f}, max_reach_threshold:{max_reach_threshold:.3f}")
            if not is_recovery and target_reach > max_reach_threshold:
                print(f"Target reach limit exceeded: {target_reach:.3f} > {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LM(Tb, q0=q_seed, ilimit=ilimit, tol=tol)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # ── kick-off with adaptive tolerance ──────────────────────────────────
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    # Check if solution respects joint limits
    target_q = path[-1] if len(path) != 0 else None
    solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
    if ok and solution_valid:
        return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
    else:
        return IKResult(False, None, its, resid, adaptive_tol, violations)

#Setup IP address and Simulator port
ip = "127.0.0.1" #Loopback address
port = 5001
# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((ip, port))
print(f'Start listening to {ip}:{port}')

def Unpack_data(data_buffer_list, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):

    Joints = []
    Speed = []

    for i in range(0,18, 3):
        variable = data_buffer_list[i:i+3]
        Joints.append(variable)

    for i in range(18,36, 3):
        variable = data_buffer_list[i:i+3]
        Speed.append(variable)


    for i in range(6):
        var =  b'\x00' + b''.join(Joints[i])
        Position_in[i] = Fuse_3_bytes(var)
        var =  b'\x00' + b''.join(Speed[i])
        Speed_in[i] = Fuse_3_bytes(var)

    Homed = data_buffer_list[36]
    IO_var = data_buffer_list[37]
    temp_error = data_buffer_list[38]
    position_error = data_buffer_list[39]
    timing_data = data_buffer_list[40:42]
    Timeout_error_var = data_buffer_list[42]
    xtr2 = data_buffer_list[43]
    device_ID = data_buffer_list[44]
    Gripper_position = data_buffer_list[45:47]
    Gripper_speed = data_buffer_list[47:49]
    Gripper_current = data_buffer_list[49:51]
    Status = data_buffer_list[51]
    # The original object_detection byte at index 52 is ignored as it is not reliable.
    CRC_byte = data_buffer_list[53]
    endy_byte1 = data_buffer_list[54]
    endy_byte2 = data_buffer_list[55]

    # ... (Code for Homed, IO_var, temp_error, etc. remains the same) ...

    temp = Split_2_bitfield(int.from_bytes(Homed,"big"))
    for i in range(8):
        Homed_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(IO_var,"big"))
    for i in range(8):
        InOut_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(temp_error,"big"))
    for i in range(8):
        Temperature_error_in[i] = temp[i]

    temp = Split_2_bitfield(int.from_bytes(position_error,"big"))
    for i in range(8):
        Position_error_in[i] = temp[i]

    var = b'\x00' + b'\x00' + b''.join(timing_data)
    Timing_data_in[0] = Fuse_3_bytes(var)
    Timeout_error = int.from_bytes(Timeout_error_var,"big")
    XTR_data = int.from_bytes(xtr2,"big")

    # --- Gripper Data Unpacking ---
    Gripper_data_in[0] = int.from_bytes(device_ID,"big")

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_position)
    Gripper_data_in[1] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_speed)
    Gripper_data_in[2] = Fuse_2_bytes(var)

    var =  b'\x00'+ b'\x00' + b''.join(Gripper_current)
    Gripper_data_in[3] = Fuse_2_bytes(var)

    # --- Start of Corrected Logic ---
    # This section now mirrors the working logic from GUI_PAROL_latest.py
    
    # 1. Store the raw status byte (from index 51)
    status_byte = int.from_bytes(Status,"big")
    Gripper_data_in[4] = status_byte

    # 2. Split the status byte into a list of 8 individual bits
    status_bits = Split_2_bitfield(status_byte)
    
    # 3. Combine the 3rd and 4th bits (at indices 2 and 3) to get the true object detection status
    # This creates a 2-bit number (0-3) which represents the full state.
    object_detection_status = (status_bits[2] << 1) | status_bits[3]
    Gripper_data_in[5] = object_detection_status
    # --- End of Corrected Logic ---

def Pack_data(Position_out,Speed_out,Command_out,Affected_joint_out,InOut_out,Timeout_out,Gripper_data_out):

    # Len is defined by all bytes EXCEPT start bytes and len
    # Start bytes = 3
    len = 52 #1
    Position = [Position_out[0],Position_out[1],Position_out[2],Position_out[3],Position_out[4],Position_out[5]]  #18
    Speed = [Speed_out[0], Speed_out[1], Speed_out[2], Speed_out[3], Speed_out[4], Speed_out[5],] #18
    Command = Command_out#1
    Affected_joint = Affected_joint_out
    InOut = InOut_out #1
    Timeout = Timeout_out #1
    Gripper_data = Gripper_data_out #9
    CRC_byte = 228 #1
    # End bytes = 2


    test_list = []
    #print(test_list)

    #x = bytes(start_bytes)
    test_list.append((start_bytes))
    
    test_list.append(bytes([len]))


    # Position data
    for i in range(6):
        position_split = Split_2_3_bytes(Position[i])
        test_list.append(position_split[1:4])

    # Speed data
    for i in range(6):
        speed_split = Split_2_3_bytes(Speed[i])
        test_list.append(speed_split[1:4])

    # Command data
    test_list.append(bytes([Command]))

    # Affected joint data
    Affected_list = Fuse_bitfield_2_bytearray(Affected_joint[:])
    test_list.append(Affected_list)

    # Inputs outputs data
    InOut_list = Fuse_bitfield_2_bytearray(InOut[:])
    test_list.append(InOut_list)

    # Timeout data
    test_list.append(bytes([Timeout]))

    # Gripper position
    Gripper_position = Split_2_3_bytes(Gripper_data[0])
    test_list.append(Gripper_position[2:4])

    # Gripper speed
    Gripper_speed = Split_2_3_bytes(Gripper_data[1])
    test_list.append(Gripper_speed[2:4])

    # Gripper current
    Gripper_current = Split_2_3_bytes(Gripper_data[2])
    test_list.append(Gripper_current[2:4])  

    # Gripper command
    test_list.append(bytes([Gripper_data[3]]))
    # Gripper mode
    test_list.append(bytes([Gripper_data[4]]))
    
    # ==========================================================
    # === FIX: Make sure calibrate is a one-shot command      ====
    # ==========================================================
    # If the mode was set to calibrate (1) or clear_error (2), reset it
    # back to normal (0) for the next cycle. This prevents an endless loop.
    if Gripper_data_out[4] == 1 or Gripper_data_out[4] == 2:
        Gripper_data_out[4] = 0
    # ==========================================================
    
    # Gripper ID
    test_list.append(bytes([Gripper_data[5]]))
 
    # CRC byte
    test_list.append(bytes([CRC_byte]))

    # END bytes
    test_list.append((end_bytes))
    
    #print(test_list)
    return test_list

def Get_data(Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
         XTR_data,Gripper_data_in):
    global input_byte 

    global start_cond1_byte 
    global start_cond2_byte 
    global start_cond3_byte 

    global end_cond1_byte 
    global end_cond2_byte 

    global start_cond1 
    global start_cond2 
    global start_cond3 

    global good_start 
    global data_len 

    global data_buffer 
    global data_counter

    while (ser.inWaiting() > 0):
        input_byte = ser.read()

        #UNCOMMENT THIS TO GET ALL DATA FROM THE ROBOT PRINTED
        #print(input_byte) 

        # When data len is received start is good and after that put all data in receive buffer
        # Data len is ALL data after it; that includes input buffer, end bytes and CRC
        if (good_start != 1):
            # All start bytes are good and next byte is data len
            if (start_cond1 == 1 and start_cond2 == 1 and start_cond3 == 1):
                good_start = 1
                data_len = input_byte
                data_len = struct.unpack('B', data_len)[0]
                logging.debug("data len we got from robot packet= ")
                logging.debug(input_byte)
                logging.debug("good start for DATA that we received at PC")
            # Third start byte is good
            if (input_byte == start_cond3_byte and start_cond2 == 1 and start_cond1 == 1):
                start_cond3 = 1
                #print("good cond 3 PC")
            #Third start byte is bad, reset all flags
            elif (start_cond2 == 1 and start_cond1 == 1):
                #print("bad cond 3 PC")
                start_cond1 = 0
                start_cond2 = 0
            # Second start byte is good
            if (input_byte == start_cond2_byte and start_cond1 == 1):
                start_cond2 = 1
                #print("good cond 2 PC ")
            #Second start byte is bad, reset all flags   
            elif (start_cond1 == 1):
                #print("Bad cond 2 PC")
                start_cond1 = 0
            # First start byte is good
            if (input_byte == start_cond1_byte):
                start_cond1 = 1
                #print("good cond 1 PC")
        else:
            # Here data goes after good  start
            data_buffer[data_counter] = input_byte
            if (data_counter == data_len - 1):

                logging.debug("Data len PC")
                logging.debug(data_len)
                logging.debug("End bytes are:")
                logging.debug(data_buffer[data_len -1])
                logging.debug(data_buffer[data_len -2])

                # Here if last 2 bytes are end condition bytes we process the data 
                if (data_buffer[data_len -1] == end_cond2_byte and data_buffer[data_len - 2] == end_cond1_byte):

                    logging.debug("GOOD END CONDITION PC")
                    logging.debug("I UNPACKED RAW DATA RECEIVED FROM THE ROBOT")
                    Unpack_data(data_buffer, Position_in,Speed_in,Homed_in,InOut_in,Temperature_error_in,Position_error_in,Timeout_error,Timing_data_in,
                    XTR_data,Gripper_data_in)
                    logging.debug("DATA UNPACK FINISHED")
                    # ako su dobri izračunaj crc
                    # if crc dobar raspakiraj podatke
                    # ako je dobar paket je dobar i spremi ga u nove variable!
                
                # Print every byte
                #print("podaci u data bufferu su:")
                #for i in range(data_len):
                    #print(data_buffer[i])

                good_start = 0
                start_cond1 = 0
                start_cond3 = 0
                start_cond2 = 0
                data_len = 0
                data_counter = 0
            else:
                data_counter = data_counter + 1

# Split data to 3 bytes 
def Split_2_3_bytes(var_in):
    y = int_to_3_bytes(var_in & 0xFFFFFF) # converts my int value to bytes array
    return y

# Splits byte to bitfield list
def Split_2_bitfield(var_in):
    #return [var_in >> i & 1 for i in range(7,-1,-1)] 
    return [(var_in >> i) & 1 for i in range(7, -1, -1)]

# Fuses 3 bytes to 1 signed int
def Fuse_3_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<23:
        value -= 1<<24

    return value

# Fuses 2 bytes to 1 signed int
def Fuse_2_bytes(var_in):
    value = struct.unpack(">I", bytearray(var_in))[0] # converts bytes array to int

    # convert to negative number if it is negative
    if value >= 1<<15:
        value -= 1<<16

    return value

# Fuse bitfield list to byte
def Fuse_bitfield_2_bytearray(var_in):
    number = 0
    for b in var_in:
        number = (2 * number) + b
    return bytes([number])

# Check if there is element 1 in the list. 
# If yes return its index, if no element is 1 return -1
def check_elements(lst):
    for i, element in enumerate(lst):
        if element == 1:
            return i
    return -1  # Return -1 if no element is 1

def quintic_scaling(s: float) -> float:
    """
    Calculates a smooth 0-to-1 scaling factor for progress 's'
    using a quintic polynomial, ensuring smooth start/end accelerations.
    """
    return 6 * (s**5) - 15 * (s**4) + 10 * (s**3)

#########################################################################
# Robot Commands Start Here
#########################################################################

class HomeCommand:
    """
    A non-blocking command that tells the robot to perform its internal homing sequence.
    This version uses a state machine to allow re-homing even if the robot is already homed.
    """
    def __init__(self):
        self.is_valid = True
        self.is_finished = False
        # State machine: START -> WAIT_FOR_UNHOMED -> WAIT_FOR_HOMED -> FINISHED
        self.state = "START"
        # Counter to send the home command for multiple cycles
        self.start_cmd_counter = 10  # Send command 100 for 10 cycles (0.1s)
        # Safety timeout (20 seconds at 0.01s interval)
        self.timeout_counter = 2000
        print("Initializing Home command...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Manages the homing command and monitors for completion using a state machine.
        """
        if self.is_finished:
            return True

        # --- State: START ---
        # On the first few executions, continuously send the 'home' (100) command.
        if self.state == "START":
            print(f"  -> Sending home signal (100)... Countdown: {self.start_cmd_counter}")
            Command_out.value = 100
            self.start_cmd_counter -= 1
            if self.start_cmd_counter <= 0:
                # Once sent for enough cycles, move to the next state
                self.state = "WAITING_FOR_UNHOMED"
            return False

        # --- State: WAITING_FOR_UNHOMED ---
        # The robot's firmware should reset the homed status. We wait to see that happen.
        # During this time, we send 'idle' (255) to let the robot's controller take over.
        if self.state == "WAITING_FOR_UNHOMED":
            Command_out.value = 255
            # Check if at least one joint has started homing (is no longer homed)
            if any(h == 0 for h in Homed_in[:6]):
                print("  -> Homing sequence initiated by robot.")
                self.state = "WAITING_FOR_HOMED"
            # Check for timeout
            self.timeout_counter -= 1
            if self.timeout_counter <= 0:
                print("  -> ERROR: Timeout waiting for robot to start homing sequence.")
                self.is_finished = True
            return self.is_finished

        # --- State: WAITING_FOR_HOMED ---
        # Now we wait for all joints to report that they are homed (all flags are 1).
        if self.state == "WAITING_FOR_HOMED":
            Command_out.value = 255
            # Check if all joints have finished homing
            if all(h == 1 for h in Homed_in[:6]):
                print("Homing sequence complete. All joints reported home.")
                self.is_finished = True
                Speed_out[:] = [0] * 6 # Ensure robot is stopped

        return self.is_finished

class JogCommand:
    """
    A non-blocking command to jog a joint for a specific duration or distance.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joint, speed_percentage=None, duration=None, distance_deg=None):
        """
        Initializes and validates the jog command. This is the SETUP phase.
        """
        self.is_valid = False
        self.is_finished = False
        self.mode = None
        self.command_step = 0

        # --- 1. Parameter Validation and Mode Selection ---
        if duration and distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Distance {distance_deg} deg, Duration {duration}s.")
        elif duration:
            self.mode = 'time'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Duration {duration}s.")
        elif distance_deg:
            self.mode = 'distance'
            print(f"Initializing Jog: Joint {joint}, Speed {speed_percentage}%, Distance {distance_deg} deg.")
        else:
            print("Error: JogCommand requires either 'duration', 'distance_deg', or both.")
            return

        # --- 2. Store parameters for deferred calculation ---
        self.joint = joint
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.distance_deg = distance_deg

        # --- These will be calculated later ---
        self.direction = 1
        self.joint_index = 0
        self.speed_out = 0
        self.command_len = 0
        self.target_position = 0

        self.is_valid = True # Mark as valid for now; preparation step will confirm.


    def prepare_for_execution(self, current_position_in):
        """Pre-computes speeds and target positions using live data."""
        print(f"  -> Preparing for Jog command...")

        # Determine direction and joint index
        self.direction = 1 if 0 <= self.joint <= 5 else -1
        self.joint_index = self.joint if self.direction == 1 else self.joint - 6
        
        distance_steps = 0
        if self.distance_deg:
            distance_steps = int(PAROL6_ROBOT.DEG2STEPS(abs(self.distance_deg), self.joint_index))
            # --- MOVED LOGIC: Calculate target using the LIVE position ---
            self.target_position = current_position_in[self.joint_index] + (distance_steps * self.direction)
            
            min_limit, max_limit = PAROL6_ROBOT.Joint_limits_steps[self.joint_index]
            if not (min_limit <= self.target_position <= max_limit):
                print(f"  -> VALIDATION FAILED: Target position {self.target_position} is out of joint limits ({min_limit}, {max_limit}).")
                self.is_valid = False
                return

        # Calculate speed and duration
        speed_steps_per_sec = 0
        if self.mode == 'distance' and self.duration:
            speed_steps_per_sec = int(distance_steps / self.duration) if self.duration > 0 else 0
            max_joint_speed = PAROL6_ROBOT.Joint_max_speed[self.joint_index]
            if speed_steps_per_sec > max_joint_speed:
                print(f"  -> VALIDATION FAILED: Required speed ({speed_steps_per_sec} steps/s) exceeds joint's max speed ({max_joint_speed} steps/s).")
                self.is_valid = False
                return
        else:
            if self.speed_percentage is None:
                print("Error: 'speed_percentage' must be provided if not calculating automatically.")
                self.is_valid = False
                return
            speed_steps_per_sec = int(np.interp(abs(self.speed_percentage), [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[self.joint_index] * 2]))

        self.speed_out = speed_steps_per_sec * self.direction
        self.command_len = int(self.duration / INTERVAL_S) if self.duration else float('inf')
        print("  -> Jog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        stop_reason = None
        current_pos = Position_in[self.joint_index]

        if self.mode == 'time':
            if self.command_step >= self.command_len:
                stop_reason = "Timed jog finished."
        elif self.mode == 'distance':
            if (self.direction == 1 and current_pos >= self.target_position) or \
               (self.direction == -1 and current_pos <= self.target_position):
                stop_reason = "Distance jog finished."
        
        if not stop_reason:
            if (self.direction == 1 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][1]) or \
               (self.direction == -1 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[self.joint_index][0]):
                stop_reason = f"Limit reached on joint {self.joint_index + 1}."

        if stop_reason:
            print(stop_reason)
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            Speed_out[:] = [0] * 6
            Speed_out[self.joint_index] = self.speed_out
            Command_out.value = 123
            self.command_step += 1
            return False
        
class MultiJogCommand:
    """
    A non-blocking command to jog multiple joints simultaneously for a specific duration.
    It performs all safety and validity checks upon initialization.
    """
    def __init__(self, joints, speed_percentages, duration):
        """
        Initializes and validates the multi-jog command.
        """
        self.is_valid = False
        self.is_finished = False
        self.command_step = 0

        # --- 1. Parameter Validation ---
        if not isinstance(joints, list) or not isinstance(speed_percentages, list):
            print("Error: MultiJogCommand requires 'joints' and 'speed_percentages' to be lists.")
            return

        if len(joints) != len(speed_percentages):
            print("Error: The number of joints must match the number of speed percentages.")
            return

        if not duration or duration <= 0:
            print("Error: MultiJogCommand requires a positive 'duration'.")
            return

        # ==========================================================
        # === NEW: Check for conflicting joint commands          ===
        # ==========================================================
        base_joints = set()
        for joint in joints:
            # Normalize the joint index to its base (0-5)
            base_joint = joint % 6
            # If the base joint is already in our set, it's a conflict.
            if base_joint in base_joints:
                print(f"  -> VALIDATION FAILED: Conflicting commands for Joint {base_joint + 1} (e.g., J1+ and J1-).")
                self.is_valid = False
                return
            base_joints.add(base_joint)
        # ==========================================================

        print(f"Initializing MultiJog for joints {joints} with speeds {speed_percentages}% for {duration}s.")

        # --- 2. Store parameters ---
        self.joints = joints
        self.speed_percentages = speed_percentages
        self.duration = duration
        self.command_len = int(self.duration / INTERVAL_S)

        # --- This will be calculated in the prepare step ---
        self.speeds_out = [0] * 6

        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Pre-computes the speeds for each joint."""
        print(f"  -> Preparing for MultiJog command...")

        for i, joint in enumerate(self.joints):
            # Determine direction and joint index (0-5 for positive, 6-11 for negative)
            direction = 1 if 0 <= joint <= 5 else -1
            joint_index = joint if direction == 1 else joint - 6
            speed_percentage = self.speed_percentages[i]

            # Check for joint index validity
            if not (0 <= joint_index < 6):
                print(f"  -> VALIDATION FAILED: Invalid joint index {joint_index}.")
                self.is_valid = False
                return

            # Calculate speed in steps/sec
            speed_steps_per_sec = int(np.interp(speed_percentage, [0, 100], [0, PAROL6_ROBOT.Joint_max_speed[joint_index]]))
            self.speeds_out[joint_index] = speed_steps_per_sec * direction

        print("  -> MultiJog command is ready.")


    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """This is the EXECUTION phase. It runs on every loop cycle."""
        if self.is_finished or not self.is_valid:
            return True

        # Stop if the duration has elapsed
        if self.command_step >= self.command_len:
            print("Timed multi-jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        else:
            # Continuously check for joint limits during the jog
            for i in range(6):
                if self.speeds_out[i] != 0:
                    current_pos = Position_in[i]
                    # Hitting positive limit while moving positively
                    if self.speeds_out[i] > 0 and current_pos >= PAROL6_ROBOT.Joint_limits_steps[i][1]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True
                    # Hitting negative limit while moving negatively
                    elif self.speeds_out[i] < 0 and current_pos <= PAROL6_ROBOT.Joint_limits_steps[i][0]:
                         print(f"Limit reached on joint {i + 1}. Stopping jog.")
                         self.is_finished = True
                         Speed_out[:] = [0] * 6
                         Command_out.value = 255
                         return True

            # If no limits are hit, apply the speeds
            Speed_out[:] = self.speeds_out
            Command_out.value = 123 # Jog command
            self.command_step += 1
            return False # Command is still running
        
# This dictionary maps descriptive axis names to movement vectors, which is cleaner.
# Format: ([x, y, z], [rx, ry, rz])
AXIS_MAP = {
    'X+': ([1, 0, 0], [0, 0, 0]), 'X-': ([-1, 0, 0], [0, 0, 0]),
    'Y+': ([0, 1, 0], [0, 0, 0]), 'Y-': ([0, -1, 0], [0, 0, 0]),
    'Z+': ([0, 0, 1], [0, 0, 0]), 'Z-': ([0, 0, -1], [0, 0, 0]),
    'RX+': ([0, 0, 0], [1, 0, 0]), 'RX-': ([0, 0, 0], [-1, 0, 0]),
    'RY+': ([0, 0, 0], [0, 1, 0]), 'RY-': ([0, 0, 0], [0, -1, 0]),
    'RZ+': ([0, 0, 0], [0, 0, 1]), 'RZ-': ([0, 0, 0], [0, 0, -1]),
}

class CartesianJogCommand:
    """
    A non-blocking command to jog the robot's end-effector in Cartesian space.
    This is the final, refactored version using clean, standard spatial math
    operations now that the core unit bug has been fixed.
    """
    def __init__(self, frame, axis, speed_percentage=50, duration=1.5, **kwargs):
        """
        Initializes and validates the Cartesian jog command.
        """
        self.is_valid = False
        self.is_finished = False
        print(f"Initializing CartesianJog: Frame {frame}, Axis {axis}...")

        if axis not in AXIS_MAP:
            print(f"  -> VALIDATION FAILED: Invalid axis '{axis}'.")
            return
        
        # Store all necessary parameters for use in execute_step
        self.frame = frame
        self.axis_vectors = AXIS_MAP[axis]
        self.is_rotation = any(self.axis_vectors[1])
        self.speed_percentage = speed_percentage
        self.duration = duration
        self.end_time = time.time() + self.duration
        
        self.is_valid = True
        print("  -> Command is valid and ready.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Check for completion ---
        if time.time() >= self.end_time:
            print("Cartesian jog finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- B. Calculate Target Pose using clean vector math ---
        Command_out.value = 123 # Set jog command
        
        q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        T_current = PAROL6_ROBOT.robot.fkine(q_current)

        if not isinstance(T_current, SE3):
            return False # Wait for valid pose data

        # Calculate speed and displacement for this cycle
        linear_speed_ms = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min_JOG, PAROL6_ROBOT.Cartesian_linear_velocity_max_JOG]))
        angular_speed_degs = float(np.interp(self.speed_percentage, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max]))

        delta_linear = linear_speed_ms * INTERVAL_S
        delta_angular_rad = np.deg2rad(angular_speed_degs * INTERVAL_S)

        # Create the small incremental transformation (delta_pose)
        trans_vec = np.array(self.axis_vectors[0]) * delta_linear
        rot_vec = np.array(self.axis_vectors[1]) * delta_angular_rad
        delta_pose = SE3.Rt(SE3.Eul(rot_vec).R, trans_vec)

        # Apply the transformation in the correct reference frame
        if self.frame == 'WRF':
            # Pre-multiply to apply the change in the World Reference Frame
            target_pose = delta_pose * T_current
        else: # TRF
            # Post-multiply to apply the change in the Tool Reference Frame
            target_pose = T_current * delta_pose
        
        # --- C. Solve IK and Calculate Velocities ---
        var = solve_ik_with_adaptive_tol_subdivision(PAROL6_ROBOT.robot, target_pose, q_current, jogging=True)

        if var.success:
            q_velocities = (var.q - q_current) / INTERVAL_S
            for i in range(6):
                Speed_out[i] = int(PAROL6_ROBOT.SPEED_RAD2STEP(q_velocities[i], i))
        else:
            print("IK Warning: Could not find solution for jog step. Stopping.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        # --- D. Speed Scaling ---
        max_scale_factor = 1.0
        for i in range(6):
            if abs(Speed_out[i]) > PAROL6_ROBOT.Joint_max_speed[i]:
                scale = abs(Speed_out[i]) / PAROL6_ROBOT.Joint_max_speed[i]
                if scale > max_scale_factor:
                    max_scale_factor = scale
        
        if max_scale_factor > 1.0:
            for i in range(6):
                Speed_out[i] = int(Speed_out[i] / max_scale_factor)

        return False # Command is still running

class MovePoseCommand:
    """
    A non-blocking command to move the robot to a specific Cartesian pose.
    The movement itself is a joint-space interpolation.
    """
    def __init__(self, pose, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = True  # Assume valid; preparation step will confirm.
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MovePose to {pose}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.pose = pose
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

    """
        Initializes, validates, and pre-computes the trajectory for a move-to-pose command.

        Args:
            pose (list): A list of 6 values [x, y, z, r, p, y] for the target pose.
                         Positions are in mm, rotations are in degrees.
            duration (float, optional): The total time for the movement in seconds.
            velocity_percent (float, optional): The target velocity as a percentage (0-100).
            accel_percent (float, optional): The target acceleration as a percentage (0-100).
            trajectory_type (str, optional): The type of trajectory ('poly' or 'trap').
        """
    
    def prepare_for_execution(self, current_position_in):
        """Calculates the full trajectory just-in-time before execution."""
        print(f"  -> Preparing trajectory for MovePose to {self.pose}...")

        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pose = SE3(self.pose[0] / 1000.0, self.pose[1] / 1000.0, self.pose[2] / 1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')
        
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_pose, initial_pos_rad, ilimit=100)

        if not ik_solution.success:
            print("  -> VALIDATION FAILED: Inverse kinematics failed at execution time.")
            self.is_valid = False
            return

        target_pos_rad = ik_solution.q

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])

                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue
                    
                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)
            
                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                self.is_valid = False
                return

        else:
            print("  -> Using conservative values for MovePose.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveJointCommand:
    """
    A non-blocking command to move the robot's joints to a specific configuration.
    It pre-calculates the entire trajectory upon initialization.
    """
    def __init__(self, target_angles, duration=None, velocity_percent=None, accel_percent=50, trajectory_type='poly'):
        self.is_valid = False  # Will be set to True after basic validation
        self.is_finished = False
        self.command_step = 0
        self.trajectory_steps = []

        print(f"Initializing MoveJoint to {target_angles}...")

        # --- MODIFICATION: Store parameters for deferred planning ---
        self.target_angles = target_angles
        self.duration = duration
        self.velocity_percent = velocity_percent
        self.accel_percent = accel_percent
        self.trajectory_type = trajectory_type

        # --- Perform only state-independent validation ---
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])
        for i in range(6):
            min_rad, max_rad = PAROL6_ROBOT.Joint_limits_radian[i]
            if not (min_rad <= target_pos_rad[i] <= max_rad):
                print(f"  -> VALIDATION FAILED: Target for Joint {i+1} ({self.target_angles[i]} deg) is out of range.")
                return
        
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Calculates the trajectory just before execution begins."""
        print(f"  -> Preparing trajectory for MoveJoint to {self.target_angles}...")
        
        initial_pos_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        target_pos_rad = np.array([np.deg2rad(angle) for angle in self.target_angles])

        if self.duration and self.duration > 0:
            if self.velocity_percent is not None:
                print("  -> INFO: Both duration and velocity were provided. Using duration.")
            command_len = int(self.duration / INTERVAL_S)
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))

        elif self.velocity_percent is not None:
            try:
                accel_percent = self.accel_percent if self.accel_percent is not None else 50
                initial_pos_steps = np.array(current_position_in)
                target_pos_steps = np.array([int(PAROL6_ROBOT.RAD2STEPS(rad, i)) for i, rad in enumerate(target_pos_rad)])
                
                all_joint_times = []
                for i in range(6):
                    path_to_travel = abs(target_pos_steps[i] - initial_pos_steps[i])
                    if path_to_travel == 0:
                        all_joint_times.append(0)
                        continue

                    v_max_joint = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Joint_min_speed[i], PAROL6_ROBOT.Joint_max_speed[i]])
                    a_max_rad = np.interp(accel_percent, [0, 100], [PAROL6_ROBOT.Joint_min_acc, PAROL6_ROBOT.Joint_max_acc])
                    a_max_steps = PAROL6_ROBOT.SPEED_RAD2STEP(a_max_rad, i)

                    if v_max_joint <= 0 or a_max_steps <= 0:
                        raise ValueError(f"Invalid speed/acceleration for joint {i+1}. Must be positive.")

                    t_accel = v_max_joint / a_max_steps
                    if path_to_travel < v_max_joint * t_accel:
                        t_accel = np.sqrt(path_to_travel / a_max_steps)
                        joint_time = 2 * t_accel
                    else:
                        joint_time = path_to_travel / v_max_joint + t_accel
                    all_joint_times.append(joint_time)

                total_time = max(all_joint_times)

                if total_time <= 0:
                    self.is_finished = True
                    return

                if total_time < (2 * INTERVAL_S):
                    total_time = 2 * INTERVAL_S

                execution_time = np.arange(0, total_time, INTERVAL_S)
                
                all_q, all_qd = [], []
                for i in range(6):
                    if abs(target_pos_steps[i] - initial_pos_steps[i]) == 0:
                        all_q.append(np.full(len(execution_time), initial_pos_steps[i]))
                        all_qd.append(np.zeros(len(execution_time)))
                    else:
                        joint_traj = rp.trapezoidal(initial_pos_steps[i], target_pos_steps[i], execution_time)
                        all_q.append(joint_traj.q)
                        all_qd.append(joint_traj.qd)

                self.trajectory_steps = list(zip(np.array(all_q).T.astype(int), np.array(all_qd).T.astype(int)))
                print(f"  -> Command is valid (duration calculated from speed: {total_time:.2f}s).")

            except Exception as e:
                print(f"  -> VALIDATION FAILED: Could not calculate velocity-based trajectory. Error: {e}")
                print(f"  -> Please check Joint_min/max_speed and Joint_min/max_acc values in PAROL6_ROBOT.py.")
                self.is_valid = False
                return
        
        else:
            print("  -> Using conservative values for MoveJoint.")
            command_len = 200
            traj_generator = rp.tools.trajectory.jtraj(initial_pos_rad, target_pos_rad, command_len)
            for i in range(len(traj_generator.q)):
                pos_step = [int(PAROL6_ROBOT.RAD2STEPS(p, j)) for j, p in enumerate(traj_generator.q[i])]
                self.trajectory_steps.append((pos_step, None))
        
        if not self.trajectory_steps:
             print(" -> Trajectory calculation resulted in no steps. Command is invalid.")
             self.is_valid = False
        else:
             print(f" -> Trajectory prepared with {len(self.trajectory_steps)} steps.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        # This method remains unchanged.
        if self.is_finished or not self.is_valid:
            return True

        if self.command_step >= len(self.trajectory_steps):
            print(f"{type(self).__name__} finished.")
            self.is_finished = True
            Position_out[:] = Position_in[:]
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            return True
        else:
            pos_step, _ = self.trajectory_steps[self.command_step]
            Position_out[:] = pos_step
            Speed_out[:] = [0] * 6
            Command_out.value = 156
            self.command_step += 1
            return False
        
class MoveCartCommand:
    """
    A non-blocking command to move the robot's end-effector in a straight line
    in Cartesian space, completing the move in an exact duration.

    It works by:
    1. Pre-validating the final target pose.
    2. Interpolating the pose in Cartesian space in real-time.
    3. Solving Inverse Kinematics for each intermediate step to ensure path validity.
    """
    def __init__(self, pose, duration=None, velocity_percent=None):
        self.is_valid = False
        self.is_finished = False

        # --- MODIFICATION: Validate that at least one timing parameter is given ---
        if duration is None and velocity_percent is None:
            print("  -> VALIDATION FAILED: MoveCartCommand requires either 'duration' or 'velocity_percent'.")
            return
        if duration is not None and velocity_percent is not None:
            print("  -> INFO: Both duration and velocity_percent provided. Using duration.")
            self.velocity_percent = None # Prioritize duration
        else:
            self.velocity_percent = velocity_percent

        # --- Store parameters and set placeholders ---
        self.duration = duration
        self.pose = pose
        self.start_time = None
        self.initial_pose = None
        self.target_pose = None
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Captures the initial state and validates the path just before execution."""
        print(f"  -> Preparing for MoveCart to {self.pose}...")
        
        # --- MOVED LOGIC: Capture initial state from live data ---
        initial_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(current_position_in)])
        self.initial_pose = PAROL6_ROBOT.robot.fkine(initial_q_rad)
        self.target_pose = SE3(self.pose[0]/1000.0, self.pose[1]/1000.0, self.pose[2]/1000.0) * SE3.RPY(self.pose[3:6], unit='deg', order='xyz')

        print("  -> Pre-validating final target pose...")
        ik_check = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, self.target_pose, initial_q_rad
        )

        if not ik_check.success:
            print("  -> VALIDATION FAILED: The final target pose is unreachable.")
            if ik_check.violations:
                print(f"     Reason: Solution violates joint limits: {ik_check.violations}")
            self.is_valid = False # Mark as invalid if path fails
            return

        # --- NEW BLOCK: Calculate duration from velocity if needed ---
        if self.velocity_percent is not None:
            print(f"  -> Calculating duration for {self.velocity_percent}% speed...")
            # Calculate the total distance for translation and rotation
            linear_distance = np.linalg.norm(self.target_pose.t - self.initial_pose.t)
            angular_distance_rad = self.initial_pose.angdist(self.target_pose)

            # Interpolate the target speeds from percentages, assuming constants exist in PAROL6_ROBOT
            target_linear_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_linear_velocity_min, PAROL6_ROBOT.Cartesian_linear_velocity_max])
            target_angular_speed = np.interp(self.velocity_percent, [0, 100], [PAROL6_ROBOT.Cartesian_angular_velocity_min, PAROL6_ROBOT.Cartesian_angular_velocity_max])
            target_angular_speed_rad = np.deg2rad(target_angular_speed)

            # Calculate time required for each component of the movement
            time_linear = linear_distance / target_linear_speed if target_linear_speed > 0 else 0
            time_angular = angular_distance_rad / target_angular_speed_rad if target_angular_speed_rad > 0 else 0

            # The total duration is the longer of the two times to ensure synchronization
            calculated_duration = max(time_linear, time_angular)

            if calculated_duration <= 0:
                print("  -> INFO: MoveCart has zero duration. Marking as finished.")
                self.is_finished = True
                self.is_valid = True # It's valid, just already done.
                return

            self.duration = calculated_duration
            print(f"  -> Calculated MoveCart duration: {self.duration:.2f}s")

        print("  -> Command is valid and ready for execution.")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        if self.start_time is None:
            self.start_time = time.time()

        elapsed_time = time.time() - self.start_time
        s = min(elapsed_time / self.duration, 1.0)
        s_scaled = quintic_scaling(s)

        current_target_pose = self.initial_pose.interp(self.target_pose, s_scaled)

        current_q_rad = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
        ik_solution = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, current_target_pose, current_q_rad
        )

        if not ik_solution.success:
            print("  -> ERROR: MoveCart failed. An intermediate point on the path is unreachable.")
            if ik_solution.violations:
                 print(f"     Reason: Path violates joint limits: {ik_solution.violations}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True

        current_pos_rad = ik_solution.q

        # --- MODIFIED BLOCK ---
        # Send only the target position and let the firmware's P-controller handle speed.
        Position_out[:] = [int(PAROL6_ROBOT.RAD2STEPS(p, i)) for i, p in enumerate(current_pos_rad)]
        Speed_out[:] = [0] * 6 # Set feed-forward velocity to zero for smooth P-control.
        Command_out.value = 156
        # --- END MODIFIED BLOCK ---

        if s >= 1.0:
            print(f"MoveCart finished in ~{elapsed_time:.2f}s.")
            self.is_finished = True
            # The main loop will handle holding the final position.

        return self.is_finished
        
class GripperCommand:
    """
    A single, unified, non-blocking command to control all gripper functions.
    It internally selects the correct logic (position-based waiting, timed delay,
    or instantaneous) based on the specified action.
    """
    def __init__(self, gripper_type, action=None, position=100, speed=100, current=500, output_port=1):
        """
        Initializes the Gripper command and configures its internal state machine
        based on the requested action.
        """
        self.is_valid = True
        self.is_finished = False
        self.gripper_type = gripper_type.lower()
        self.action = action.lower() if action else 'move'
        self.state = "START"
        self.timeout_counter = 1000 # 10-second safety timeout for all waiting states

        # --- Configure based on Gripper Type and Action ---
        if self.gripper_type == 'electric':
            if self.action == 'move':
                self.target_position = position
                self.speed = speed
                self.current = current
                if not (0 <= position <= 255 and 0 <= speed <= 255 and 100 <= current <= 1000):
                    self.is_valid = False
            elif self.action == 'calibrate':
                self.wait_counter = 200 # 2-second fixed delay for calibration
            else:
                self.is_valid = False # Invalid action

        elif self.gripper_type == 'pneumatic':
            if self.action not in ['open', 'close']:
                self.is_valid = False
            self.state_to_set = 1 if self.action == 'open' else 0
            self.port_index = 2 if output_port == 1 else 3
        else:
            self.is_valid = False

        if not self.is_valid:
            print(f"  -> VALIDATION FAILED for GripperCommand with action: '{self.action}'")

    def execute_step(self, Gripper_data_out, InOut_out, Gripper_data_in, InOut_in, **kwargs):
        if self.is_finished or not self.is_valid:
            return True

        self.timeout_counter -= 1
        if self.timeout_counter <= 0:
            print(f"  -> ERROR: Gripper command timed out in state {self.state}.")
            self.is_finished = True
            return True

        # --- Pneumatic Logic (Instantaneous) ---
        if self.gripper_type == 'pneumatic':
            InOut_out[self.port_index] = self.state_to_set
            print("  -> Pneumatic gripper command sent.")
            self.is_finished = True
            return True

        # --- Electric Gripper Logic ---
        if self.gripper_type == 'electric':
            # On the first run, transition to the correct state for the action
            if self.state == "START":
                if self.action == 'calibrate':
                    self.state = "SEND_CALIBRATE"
                else: # 'move'
                    self.state = "WAIT_FOR_POSITION"
            
            # --- Calibrate Logic (Timed Delay) ---
            if self.state == "SEND_CALIBRATE":
                print("  -> Sending one-shot calibrate command...")
                Gripper_data_out[4] = 1 # Set mode to calibrate
                self.state = "WAITING_CALIBRATION"
                return False

            if self.state == "WAITING_CALIBRATION":
                self.wait_counter -= 1
                if self.wait_counter <= 0:
                    print("  -> Calibration delay finished.")
                    Gripper_data_out[4] = 0 # Reset to operation mode
                    self.is_finished = True
                    return True
                return False

            # --- Move Logic (Position-Based) ---
            if self.state == "WAIT_FOR_POSITION":
                # Persistently send the move command
                Gripper_data_out[0], Gripper_data_out[1], Gripper_data_out[2] = self.target_position, self.speed, self.current
                Gripper_data_out[4] = 0 # Operation mode
                bitfield = [1, 1, not InOut_in[4], 1, 0, 0, 0, 0]
                fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                Gripper_data_out[3] = int(fused.hex(), 16)

                # Check for completion
                current_position = Gripper_data_in[1]
                if abs(current_position - self.target_position) <= 5:
                    print(f"  -> Gripper move complete.")
                    self.is_finished = True
                    # Set command back to idle
                    bitfield = [1, 0, not InOut_in[4], 1, 0, 0, 0, 0]
                    fused = PAROL6_ROBOT.fuse_bitfield_2_bytearray(bitfield)
                    Gripper_data_out[3] = int(fused.hex(), 16)
                    return True
                return False
        
        return self.is_finished

class DelayCommand:
    """
    A non-blocking command that pauses execution for a specified duration.
    During the delay, it ensures the robot remains idle by sending the
    appropriate commands.
    """
    def __init__(self, duration):
        """
        Initializes and validates the Delay command.

        Args:
            duration (float): The delay time in seconds.
        """
        self.is_valid = False
        self.is_finished = False

        # --- 1. Parameter Validation ---
        if not isinstance(duration, (int, float)) or duration <= 0:
            print(f"  -> VALIDATION FAILED: Delay duration must be a positive number, but got {duration}.")
            return

        print(f"Initializing Delay for {duration} seconds...")
        
        self.duration = duration
        self.end_time = None  # Will be set in prepare_for_execution
        self.is_valid = True

    def prepare_for_execution(self, current_position_in):
        """Set the end time when the command actually starts."""
        self.end_time = time.time() + self.duration
        print(f"  -> Delay starting for {self.duration} seconds...")

    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """
        Checks if the delay duration has passed and keeps the robot idle.
        This method is called on every loop cycle (~0.01s).
        """
        if self.is_finished or not self.is_valid:
            return True

        # --- A. Keep the robot idle during the delay ---
        Command_out.value = 255  # Set command to idle
        Speed_out[:] = [0] * 6   # Set all speeds to zero

        # --- B. Check for completion ---
        if self.end_time and time.time() >= self.end_time:
            print(f"Delay finished after {self.duration} seconds.")
            self.is_finished = True
        
        return self.is_finished
    
#########################################################################
# Smooth Motion Commands Start Here
#########################################################################
    
class BaseSmoothMotionCommand:
    """
    Base class for all smooth motion commands with proper error tracking.
    """
    
    def __init__(self, description="smooth motion"):
        self.description = description
        self.trajectory = None
        self.trajectory_command = None
        self.transition_command = None
        self.is_valid = True
        self.is_finished = False
        self.specified_start_pose = None
        self.transition_complete = False
        self.trajectory_prepared = False
        self.error_state = False
        self.error_message = ""
        self.trajectory_generated = False  # NEW: Track if trajectory is generated
        
    def create_transition_command(self, current_pose, target_pose):
        """Create a MovePose command for smooth transition to start position."""
        pos_error = np.linalg.norm(
            np.array(target_pose[:3]) - np.array(current_pose[:3])
        )
        
        # Lower threshold to 2mm for more aggressive transition generation
        if pos_error < 2.0:  # Changed from 5.0mm to 2.0mm
            print(f"  -> Already near start position (error: {pos_error:.1f}mm)")
            return None
        
        print(f"  -> Creating smooth transition to start ({pos_error:.1f}mm away)")
        
        # Calculate transition speed based on distance
        # Slower for short distances, faster for long distances
        if pos_error < 10:
            transition_speed = 20.0  # mm/s for short distances
        elif pos_error < 30:
            transition_speed = 30.0  # mm/s for medium distances
        else:
            transition_speed = 40.0  # mm/s for long distances
        
        transition_duration = max(pos_error / transition_speed, 0.5)  # Minimum 0.5s
        
        transition_cmd = MovePoseCommand(
            pose=target_pose,
            duration=transition_duration
        )
        
        return transition_cmd
    
    def get_current_pose_from_position(self, position_in):
        """Convert current position to pose [x,y,z,rx,ry,rz]"""
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(position_in)])
        current_pose_se3 = PAROL6_ROBOT.robot.fkine(current_q)
        
        current_xyz = current_pose_se3.t * 1000  # Convert to mm
        current_rpy = current_pose_se3.rpy(unit='deg', order='xyz')
        return np.concatenate([current_xyz, current_rpy]).tolist()
        
    def prepare_for_execution(self, current_position_in):
        """Minimal preparation - just check if we need a transition."""
        print(f"  -> Preparing {self.description}...")
        
        # If there's a specified start pose, prepare transition
        if self.specified_start_pose:
            actual_current_pose = self.get_current_pose_from_position(current_position_in)
            self.transition_command = self.create_transition_command(
                actual_current_pose, self.specified_start_pose
            )
            
            if self.transition_command:
                self.transition_command.prepare_for_execution(current_position_in)
                if not self.transition_command.is_valid:
                    print(f"  -> ERROR: Cannot reach specified start position")
                    self.is_valid = False
                    self.error_state = True
                    self.error_message = "Cannot reach specified start position"
                    return
        else:
            self.transition_command = None
            
        # DON'T generate trajectory yet - wait until execution
        self.trajectory_generated = False
        self.trajectory_prepared = False
        print(f"  -> {self.description} preparation complete (trajectory will be generated at execution)")
            
    def generate_main_trajectory(self, effective_start_pose):
        """Override this in subclasses to generate the specific motion trajectory."""
        raise NotImplementedError("Subclasses must implement generate_main_trajectory")
        
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, **kwargs):
        """Execute transition first if needed, then generate and execute trajectory."""
        if self.is_finished or not self.is_valid:
            return True
        
        # Execute transition first if needed
        if self.transition_command and not self.transition_complete:
            is_done = self.transition_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            if is_done:
                print(f"  -> Transition complete")
                self.transition_complete = True
            return False
        
        # Generate trajectory on first execution step (not during preparation!)
        if not self.trajectory_generated:
            # Get ACTUAL current position NOW
            actual_current_pose = self.get_current_pose_from_position(Position_in)
            print(f"  -> Generating {self.description} from ACTUAL position: {[round(p, 1) for p in actual_current_pose[:3]]}")
            
            # Generate trajectory from where we ACTUALLY are
            self.trajectory = self.generate_main_trajectory(actual_current_pose)
            self.trajectory_command = SmoothTrajectoryCommand(
                self.trajectory, self.description
            )
            
            # Quick validation of first point only
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(Position_in)])
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
            )
            
            if not ik_result.success:
                print(f"  -> ERROR: Cannot reach first trajectory point")
                self.is_finished = True
                self.error_state = True
                self.error_message = "Cannot reach trajectory start"
                Speed_out[:] = [0] * 6
                Command_out.value = 255
                return True
                
            self.trajectory_generated = True
            self.trajectory_prepared = True
            
            # Verify first point is close to current
            distance = np.linalg.norm(first_pose[:3] - np.array(actual_current_pose[:3]))
            if distance > 5.0:
                print(f"  -> WARNING: First trajectory point {distance:.1f}mm from current!")
        
        # Execute main trajectory
        if self.trajectory_command and self.trajectory_prepared:
            is_done = self.trajectory_command.execute_step(
                Position_in, Homed_in, Speed_out, Command_out, **kwargs
            )
            
            # Check for errors in trajectory execution
            if hasattr(self.trajectory_command, 'error_state') and self.trajectory_command.error_state:
                self.error_state = True
                self.error_message = self.trajectory_command.error_message
            
            if is_done:
                self.is_finished = True
            
            return is_done
        else:
            self.is_finished = True
            return True

class SmoothTrajectoryCommand:
    """Command class for executing pre-generated smooth trajectories."""
    
    def __init__(self, trajectory, description="smooth motion"):
        self.trajectory = np.array(trajectory)
        self.description = description
        self.trajectory_index = 0
        self.is_valid = True
        self.is_finished = False
        self.first_step = True
        self.error_state = False
        self.error_message = ""
        
        print(f"Initializing smooth {description} with {len(trajectory)} points")
    
    def prepare_for_execution(self, current_position_in):
        """Skip validation - trajectory is already generated from correct position"""
        # No validation needed since trajectory was just generated from current position
        self.is_valid = True
        return
    
    def execute_step(self, Position_in, Homed_in, Speed_out, Command_out, Position_out=None, **kwargs):
        """Execute one step of the smooth trajectory"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Get Position_out from kwargs if not provided
        if Position_out is None:
            Position_out = kwargs.get('Position_out', Position_in)
        
        if self.trajectory_index >= len(self.trajectory):
            print(f"Smooth {self.description} finished.")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get target pose for this step
        target_pose = self.trajectory[self.trajectory_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                            for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=50, jogging=False
        )
        
        if not ik_result.success:
            print(f"  -> IK failed at trajectory point {self.trajectory_index}")
            self.is_finished = True
            self.error_state = True
            self.error_message = f"IK failed at point {self.trajectory_index}/{len(self.trajectory)}"
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                    for i, q in enumerate(ik_result.q)]
        
        # ADD VELOCITY LIMITING - This prevents violent movements
        if self.trajectory_index > 0:
            for i in range(6):
                step_diff = abs(target_steps[i] - Position_in[i])
                max_step_diff = PAROL6_ROBOT.Joint_max_speed[i] * 0.01  # Max steps in 10ms
                
                # Use 1.2x safety margin (not 2x as before)
                if step_diff > max_step_diff * 1.2:
                    #print(f"  -> WARNING: Joint {i+1} velocity limit exceeded at point {self.trajectory_index}")
                    #print(f"     Step difference: {step_diff}, Max allowed: {max_step_diff * 1.2:.1f}")
                    
                    # Clamp the motion
                    sign = 1 if target_steps[i] > Position_in[i] else -1
                    target_steps[i] = Position_in[i] + sign * int(max_step_diff)
        
        # Send position command
        Position_out[:] = target_steps
        Speed_out[:] = [0] * 6
        Command_out.value = 156
        
        # Advance to next point
        self.trajectory_index += 1
        
        return False

class SmoothCircleCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, plane, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"circle (r={radius}mm, {frame})")
        self.center = center
        self.radius = radius
        self.plane = plane
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame  # Store reference frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None  # Store for TRF transformation
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        # Store current position for potential use in generate_main_trajectory
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'center': self.center,
                'plane': self.plane
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_CIRCLE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Circle: center {self.center[:3]} (WRF), normal {self.normal_vector}")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_CIRCLE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        # Now do normal preparation with transformed parameters
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate circle starting from the actual start position."""
        motion_gen = CircularMotion()
        
        # Use transformed normal for TRF, or standard for WRF
        if self.normal_vector is not None:
            # TRF - use the transformed normal vector
            normal = np.array(self.normal_vector)
            print(f"    Using transformed normal: {normal.round(3)}")
        else:
            # WRF - use standard plane definition
            plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
            normal = np.array(plane_normals.get(self.plane, [0, 0, 1]))  # Convert to numpy array
            print(f"    Using WRF plane {self.plane} with normal: {normal}")
        
        print(f"    Generating circle from position: {[round(p, 1) for p in effective_start_pose[:3]]}")
        print(f"    Circle center: {[round(c, 1) for c in self.center]}")
        
        # Add geometry validation
        center_np = np.array(self.center)
        start_np = np.array(effective_start_pose[:3])
        
        # Project start point onto circle plane to check distance
        to_start = start_np - center_np
        to_start_plane = to_start - np.dot(to_start, normal) * normal
        distance_to_center = np.linalg.norm(to_start_plane)
        
        if abs(distance_to_center - self.radius) > self.radius * 0.3:
            print(f"    WARNING: Robot is {distance_to_center:.1f}mm from center, but radius is {self.radius:.1f}mm")
            print(f"    Circle geometry will be auto-corrected")
        
        # Generate circle that starts at effective_start_pose
        trajectory = motion_gen.generate_circle_3d(
            self.center, 
            self.radius, 
            normal,  # This normal now correctly represents the plane
            start_point=effective_start_pose[:3],
            duration=self.duration
        )
        
        if self.clockwise:
            trajectory = trajectory[::-1]
        
        # Update orientations to match start pose
        for i in range(len(trajectory)):
            trajectory[i][3:] = effective_start_pose[3:]
        
        return trajectory
    
class SmoothArcCenterCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, center, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"arc (center-based, {frame})")
        self.end_pose = end_pose
        self.center = center
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {
                'end_pose': self.end_pose,
                'center': self.center
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
            )
            self.end_pose = transformed['end_pose']
            self.center = transformed['center']
            self.normal_vector = transformed.get('normal_vector')
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_CENTER', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc from actual start to end."""
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, self.center,
            normal=self.normal_vector,  # Use transformed normal if TRF
            clockwise=self.clockwise, duration=self.duration
        )
    
class SmoothArcParamCommand(BaseSmoothMotionCommand):
    def __init__(self, end_pose, radius, arc_angle, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"parametric arc (r={radius}mm, θ={arc_angle}°, {frame})")
        self.end_pose = end_pose
        self.radius = radius
        self.arc_angle = arc_angle
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.normal_vector = None  # Will be set if TRF
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform parameters to WRF
            params = {
                'end_pose': self.end_pose,
                'plane': 'XY'  # Default plane for parametric arc
            }
            transformed = transform_command_params_to_wrf(
                'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.end_pose = transformed['end_pose']
            self.normal_vector = transformed.get('normal_vector')
            
            print(f"  -> TRF Parametric Arc: end {self.end_pose[:3]} (WRF)")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_ARC_PARAM', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate arc based on radius and angle from actual start."""
        # Get start and end positions
        start_xyz = np.array(effective_start_pose[:3])
        end_xyz = np.array(self.end_pose[:3])
        
        # If we have a transformed normal (TRF), use it to define the arc plane
        if self.normal_vector is not None:
            normal = np.array(self.normal_vector)
            
            # Project start and end onto the plane perpendicular to normal
            # This ensures the arc stays in the correct plane for TRF
            
            # Find center of arc using radius and angle
            chord_vec = end_xyz - start_xyz
            chord_length = np.linalg.norm(chord_vec)
            
            if chord_length > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({chord_length:.1f}mm) for radius {self.radius}mm")
                self.radius = chord_length / 2 + 1
            
            # Calculate center position using the normal vector
            chord_mid = (start_xyz + end_xyz) / 2
            
            # Height from chord midpoint to arc center
            if chord_length > 0:
                h = np.sqrt(max(0, self.radius**2 - (chord_length/2)**2))
                
                # Find perpendicular in the plane defined by normal
                chord_dir = chord_vec / chord_length
                perp_in_plane = np.cross(normal, chord_dir)
                if np.linalg.norm(perp_in_plane) > 0.001:
                    perp_in_plane = perp_in_plane / np.linalg.norm(perp_in_plane)
                else:
                    # Chord is parallel to normal (shouldn't happen)
                    perp_in_plane = np.array([1, 0, 0])
                
                # Arc center
                if self.clockwise:
                    center_3d = chord_mid - h * perp_in_plane
                else:
                    center_3d = chord_mid + h * perp_in_plane
            else:
                center_3d = start_xyz
            
        else:
            # WRF - use XY plane (standard behavior)
            normal = np.array([0, 0, 1])
            
            # Calculate arc center in XY plane
            start_xy = start_xyz[:2]
            end_xy = end_xyz[:2]
            
            # Midpoint
            mid = (start_xy + end_xy) / 2
            
            # Distance between points
            d = np.linalg.norm(end_xy - start_xy)
            
            if d > 2 * self.radius:
                print(f"  -> Warning: Points too far apart ({d:.1f}mm) for radius {self.radius}mm")
                self.radius = d / 2 + 1
            
            # Height of arc center from midpoint
            h = np.sqrt(max(0, self.radius**2 - (d/2)**2))
            
            # Perpendicular direction
            if d > 0:
                perp = np.array([-(end_xy[1] - start_xy[1]), end_xy[0] - start_xy[0]])
                perp = perp / np.linalg.norm(perp)
            else:
                perp = np.array([1, 0])
            
            # Arc center (choose based on clockwise)
            if self.clockwise:
                center_2d = mid - h * perp
            else:
                center_2d = mid + h * perp
            
            # Use average Z for center
            center_3d = [center_2d[0], center_2d[1], (start_xyz[2] + end_xyz[2]) / 2]
        
        # Generate arc trajectory from actual start
        motion_gen = CircularMotion()
        return motion_gen.generate_arc_3d(
            effective_start_pose, self.end_pose, center_3d.tolist(),
            normal=normal if self.normal_vector is not None else None,
            clockwise=self.clockwise, duration=self.duration
        )

class SmoothHelixCommand(BaseSmoothMotionCommand):
    def __init__(self, center, radius, pitch, height, duration, clockwise, frame='WRF', start_pose=None):
        super().__init__(f"helix (h={height}mm, {frame})")
        self.center = center
        self.radius = radius
        self.pitch = pitch
        self.height = height
        self.duration = duration
        self.clockwise = clockwise
        self.frame = frame
        self.specified_start_pose = start_pose
        self.helix_axis = None
        self.up_vector = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF."""
        if self.frame == 'TRF':
            params = {'center': self.center}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_HELIX', params, 'TRF', current_position_in
            )
            self.center = transformed['center']
            self.helix_axis = transformed.get('helix_axis', [0, 0, 1])
            self.up_vector = transformed.get('up_vector', [0, 1, 0])
            
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_HELIX', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate helix with proper axis orientation."""
        num_revolutions = self.height / self.pitch if self.pitch > 0 else 1
        num_points = int(self.duration * 100)  # 100Hz
        
        # Get helix axis (default Z for WRF, transformed for TRF)
        if self.helix_axis is not None:
            axis = np.array(self.helix_axis)
        else:
            axis = np.array([0, 0, 1])  # Default vertical
        
        # Create orthonormal basis for helix
        if self.up_vector is not None:
            up = np.array(self.up_vector)
        else:
            # Find perpendicular to axis
            if abs(axis[2]) < 0.9:
                up = np.array([0, 0, 1])
            else:
                up = np.array([1, 0, 0])
        
        # Ensure up is perpendicular to axis
        up = up - np.dot(up, axis) * axis
        up = up / np.linalg.norm(up)
        
        # Create right vector
        right = np.cross(axis, up)
        
        # Calculate starting angle based on actual start position
        to_start = np.array(effective_start_pose[:3]) - np.array(self.center)
        # Project onto plane perpendicular to axis
        to_start_plane = to_start - np.dot(to_start, axis) * axis
        
        if np.linalg.norm(to_start_plane) > 0.001:
            to_start_normalized = to_start_plane / np.linalg.norm(to_start_plane)
            start_angle = np.arctan2(np.dot(to_start_normalized, up), 
                                    np.dot(to_start_normalized, right))
        else:
            start_angle = 0
        
        trajectory = []
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            
            angle = start_angle + 2 * np.pi * num_revolutions * t
            if self.clockwise:
                angle = start_angle - 2 * np.pi * num_revolutions * t
            
            # Position on helix
            pos = np.array(self.center) + \
                  self.radius * (np.cos(angle) * right + np.sin(angle) * up) + \
                  self.height * t * axis
            
            # Use orientation from effective start
            trajectory.append(np.concatenate([pos, effective_start_pose[3:]]))
        
        return np.array(trajectory)

class SmoothSplineCommand(BaseSmoothMotionCommand):
    def __init__(self, waypoints, duration, frame='WRF', start_pose=None):
        super().__init__(f"spline ({len(waypoints)} points, {frame})")
        self.waypoints = waypoints
        self.duration = duration
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform waypoints to WRF
            params = {'waypoints': self.waypoints}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_SPLINE', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.waypoints = transformed['waypoints']
            
            print(f"  -> TRF Spline: transformed {len(self.waypoints)} waypoints to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_SPLINE', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate spline starting from actual position."""
        motion_gen = SplineMotion()
        
        # Always start from the effective start pose
        first_wp_error = np.linalg.norm(
            np.array(self.waypoints[0][:3]) - np.array(effective_start_pose[:3])
        )
        
        if first_wp_error > 5.0:
            # First waypoint is far, prepend the start position
            modified_waypoints = [effective_start_pose] + self.waypoints
            print(f"    Added start position as first waypoint (distance: {first_wp_error:.1f}mm)")
        else:
            # Replace first waypoint with actual start to ensure continuity
            modified_waypoints = [effective_start_pose] + self.waypoints[1:]
            print(f"    Replaced first waypoint with actual start position")
        
        timestamps = np.linspace(0, self.duration, len(modified_waypoints))
        
        # Generate the spline trajectory
        trajectory = motion_gen.generate_cubic_spline(modified_waypoints, timestamps)
        
        print(f"    Generated spline with {len(trajectory)} points")
        
        return trajectory

class SmoothBlendCommand(BaseSmoothMotionCommand):
    def __init__(self, segment_definitions, blend_time, frame='WRF', start_pose=None):
        super().__init__(f"blended ({len(segment_definitions)} segments, {frame})")
        self.segment_definitions = segment_definitions
        self.blend_time = blend_time
        self.frame = frame
        self.specified_start_pose = start_pose
        self.current_position_in = None
        
    def prepare_for_execution(self, current_position_in):
        """Transform parameters if in TRF, then prepare normally."""
        self.current_position_in = current_position_in
        
        if self.frame == 'TRF':
            # Transform all segment definitions to WRF
            params = {'segments': self.segment_definitions}
            transformed = transform_command_params_to_wrf(
                'SMOOTH_BLEND', params, 'TRF', current_position_in
            )
            
            # Update with transformed values
            self.segment_definitions = transformed['segments']
            
            print(f"  -> TRF Blend: transformed {len(self.segment_definitions)} segments to WRF")
            
            # Also transform start_pose if specified
            if self.specified_start_pose:
                params = {'start_pose': self.specified_start_pose}
                transformed = transform_command_params_to_wrf(
                    'SMOOTH_BLEND', params, 'TRF', current_position_in
                )
                self.specified_start_pose = transformed.get('start_pose')
        
        return super().prepare_for_execution(current_position_in)
        
    def generate_main_trajectory(self, effective_start_pose):
        """Generate blended trajectory starting from actual position."""
        trajectories = []
        motion_gen_circle = CircularMotion()
        motion_gen_spline = SplineMotion()
        
        # Always start from effective start pose
        last_end_pose = effective_start_pose
        
        for i, seg_def in enumerate(self.segment_definitions):
            seg_type = seg_def['type']
            
            # First segment always starts from effective_start_pose
            segment_start = effective_start_pose if i == 0 else last_end_pose
            
            if seg_type == 'LINE':
                end = seg_def['end']
                duration = seg_def['duration']
                
                # Generate line segment from actual position
                num_points = int(duration * 100)
                timestamps = np.linspace(0, duration, num_points)
                
                traj = []
                for t in timestamps:
                    s = t / duration if duration > 0 else 1
                    # Interpolate position
                    pos = [
                        segment_start[j] * (1-s) + end[j] * s
                        for j in range(3)
                    ]
                    # Interpolate orientation
                    orient = [
                        segment_start[j+3] * (1-s) + end[j+3] * s
                        for j in range(3)
                    ]
                    traj.append(pos + orient)
                
                trajectories.append(np.array(traj))
                last_end_pose = end
                
            elif seg_type == 'ARC':
                end = seg_def['end']
                center = seg_def['center']
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Check if we have a transformed normal (from TRF)
                normal = seg_def.get('normal_vector', None)
                
                traj = motion_gen_circle.generate_arc_3d(
                    segment_start, end, center, 
                    normal=normal,  # Use transformed normal if available
                    clockwise=clockwise, duration=duration
                )
                trajectories.append(traj)
                last_end_pose = end
                
            elif seg_type == 'CIRCLE':
                center = seg_def['center']
                radius = seg_def['radius']
                plane = seg_def.get('plane', 'XY')
                duration = seg_def['duration']
                clockwise = seg_def['clockwise']
                
                # Use transformed normal if available (from TRF)
                if 'normal_vector' in seg_def:
                    normal = seg_def['normal_vector']
                else:
                    plane_normals = {'XY': [0, 0, 1], 'XZ': [0, 1, 0], 'YZ': [1, 0, 0]}
                    normal = plane_normals.get(plane, [0, 0, 1])
                
                traj = motion_gen_circle.generate_circle_3d(
                    center, radius, normal, 
                    start_point=segment_start[:3],
                    duration=duration
                )
                
                if clockwise:
                    traj = traj[::-1]
                    
                # Update orientations
                for j in range(len(traj)):
                    traj[j][3:] = segment_start[3:]
                    
                trajectories.append(traj)
                # Circle returns to start, so last pose is last point of trajectory
                last_end_pose = traj[-1].tolist()
                
            elif seg_type == 'SPLINE':
                waypoints = seg_def['waypoints']
                duration = seg_def['duration']
                
                # Check if first waypoint is close to segment start
                wp_error = np.linalg.norm(
                    np.array(waypoints[0][:3]) - np.array(segment_start[:3])
                )
                
                if wp_error > 5.0:
                    full_waypoints = [segment_start] + waypoints
                else:
                    full_waypoints = [segment_start] + waypoints[1:]
                
                timestamps = np.linspace(0, duration, len(full_waypoints))
                traj = motion_gen_spline.generate_cubic_spline(full_waypoints, timestamps)
                trajectories.append(traj)
                last_end_pose = waypoints[-1]
        
        # Blend all trajectories
        if len(trajectories) > 1:
            blender = MotionBlender(self.blend_time)
            blended = trajectories[0]
            blend_samples = int(self.blend_time * 100)
            
            for i in range(1, len(trajectories)):
                blended = blender.blend_trajectories(blended, trajectories[i], blend_samples)
            
            print(f"    Blended {len(trajectories)} segments into {len(blended)} points")
            return blended
        elif trajectories:
            return trajectories[0]
        else:
            raise ValueError("No trajectories generated in blend")
        
def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
    """
    Calculate duration based on trajectory length and speed percentage.
    
    Args:
        trajectory_length: Total path length in mm
        speed_percentage: Speed as percentage (1-100)
        
    Returns:
        Duration in seconds
    """
    # Map speed percentage to mm/s (adjustable based on robot capabilities)
    # For example: 100% = 100mm/s, 50% = 50mm/s
    speed_mm_s = np.interp(speed_percentage, [0, 100], 
                          [PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000,
                           PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000])
    
    if speed_mm_s > 0:
        return trajectory_length / speed_mm_s
    else:
        return 5.0  # Default fallback
    
def parse_smooth_motion_commands(parts):
    """
    Parse smooth motion commands received via UDP and create appropriate command objects.
    All commands support:
    - Reference frame selection (WRF or TRF)
    - Optional start position (CURRENT or specified pose)
    - Both DURATION and SPEED timing modes
    
    Args:
        parts: List of command parts split by '|'
        
    Returns:
        Command object or None if parsing fails
    """
    command_type = parts[0]
    
    # Helper function for parsing optional start pose
    def parse_start_pose(start_str):
        """Parse start pose - returns None for CURRENT, or list of floats for specified pose."""
        if start_str == 'CURRENT' or start_str == 'NONE':
            return None
        else:
            try:
                return list(map(float, start_str.split(',')))
            except:
                print(f"Warning: Invalid start pose format: {start_str}")
                return None
    
    # Helper function for calculating duration from speed
    def calculate_duration_from_speed(trajectory_length: float, speed_percentage: float) -> float:
        """Calculate duration based on trajectory length and speed percentage."""
        # Map speed percentage to mm/s
        min_speed = PAROL6_ROBOT.Cartesian_linear_velocity_min * 1000  # Convert to mm/s
        max_speed = PAROL6_ROBOT.Cartesian_linear_velocity_max * 1000  # Convert to mm/s
        speed_mm_s = np.interp(speed_percentage, [0, 100], [min_speed, max_speed])
        
        if speed_mm_s > 0:
            return trajectory_length / speed_mm_s
        else:
            return 5.0  # Default fallback
    
    try:
        if command_type == 'SMOOTH_CIRCLE':
            # Format: SMOOTH_CIRCLE|center_x,center_y,center_z|radius|plane|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            plane = parts[3]
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Circle circumference
                path_length = 2 * np.pi * radius
                duration = calculate_duration_from_speed(path_length, timing_value)
            
            print(f"  -> Parsed circle: r={radius}mm, plane={plane}, frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command object with frame parameter
            return SmoothCircleCommand(center, radius, plane, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_CENTER':
            # Format: SMOOTH_ARC_CENTER|end_pose|center|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            center = list(map(float, parts[2].split(',')))
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[6])
            clockwise = parts[7] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Estimate arc length (will be more accurate when we have actual positions)
                # Use a conservative estimate based on radius
                radius_estimate = np.linalg.norm(np.array(center) - np.array(end_pose[:3]))
                estimated_arc_angle = np.pi / 2  # 90 degrees estimate
                arc_length = radius_estimate * estimated_arc_angle
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (center): frame={frame}, {timing_type}={timing_value}, duration={duration:.2f}s")
            
            # Return command with frame
            return SmoothArcCenterCommand(end_pose, center, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_ARC_PARAM':
            # Format: SMOOTH_ARC_PARAM|end_pose|radius|angle|frame|start_pose|timing_type|timing_value|clockwise
            end_pose = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            arc_angle = float(parts[3])
            frame = parts[4]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[5])
            timing_type = parts[6]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[7])
            clockwise = parts[8] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Arc length = radius * angle (in radians)
                arc_length = radius * np.deg2rad(arc_angle)
                duration = calculate_duration_from_speed(arc_length, timing_value)
            
            print(f"  -> Parsed arc (param): r={radius}mm, θ={arc_angle}°, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothArcParamCommand(end_pose, radius, arc_angle, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_SPLINE':
            # Format: SMOOTH_SPLINE|num_waypoints|frame|start_pose|timing_type|timing_value|waypoint1|waypoint2|...
            num_waypoints = int(parts[1])
            frame = parts[2]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[3])
            timing_type = parts[4]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[5])
            
            # Parse waypoints
            waypoints = []
            idx = 6
            for i in range(num_waypoints):
                wp = []
                for j in range(6):  # Each waypoint has 6 values (x,y,z,rx,ry,rz)
                    wp.append(float(parts[idx]))
                    idx += 1
                waypoints.append(wp)
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate total path length
                total_dist = 0
                for i in range(1, len(waypoints)):
                    dist = np.linalg.norm(np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3]))
                    total_dist += dist
                
                duration = calculate_duration_from_speed(total_dist, timing_value)
            
            print(f"  -> Parsed spline: {num_waypoints} points, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothSplineCommand(waypoints, duration, frame, start_pose)
            
        elif command_type == 'SMOOTH_HELIX':
            # Format: SMOOTH_HELIX|center|radius|pitch|height|frame|start_pose|timing_type|timing_value|clockwise
            center = list(map(float, parts[1].split(',')))
            radius = float(parts[2])
            pitch = float(parts[3])
            height = float(parts[4])
            frame = parts[5]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[6])
            timing_type = parts[7]  # 'DURATION' or 'SPEED'
            timing_value = float(parts[8])
            clockwise = parts[9] == '1'
            
            # Calculate duration
            if timing_type == 'DURATION':
                duration = timing_value
            else:  # SPEED
                # Calculate helix path length
                num_revolutions = height / pitch if pitch > 0 else 1
                horizontal_length = 2 * np.pi * radius * num_revolutions
                helix_length = np.sqrt(horizontal_length**2 + height**2)
                duration = calculate_duration_from_speed(helix_length, timing_value)
            
            print(f"  -> Parsed helix: h={height}mm, pitch={pitch}mm, frame={frame}, duration={duration:.2f}s")
            
            # Return command object with frame
            return SmoothHelixCommand(center, radius, pitch, height, duration, clockwise, frame, start_pose)
            
        elif command_type == 'SMOOTH_BLEND':
            # Format: SMOOTH_BLEND|num_segments|blend_time|frame|start_pose|timing_type|timing_value|segment1||segment2||...
            num_segments = int(parts[1])
            blend_time = float(parts[2])
            frame = parts[3]  # 'WRF' or 'TRF'
            start_pose = parse_start_pose(parts[4])
            timing_type = parts[5]  # 'DEFAULT', 'DURATION', or 'SPEED'
            
            # Parse overall timing
            if timing_type == 'DEFAULT':
                # Use individual segment durations as-is
                overall_duration = None
                overall_speed = None
                segments_start_idx = 6
            else:
                timing_value = float(parts[6])
                if timing_type == 'DURATION':
                    overall_duration = timing_value
                    overall_speed = None
                else:  # SPEED
                    overall_speed = timing_value
                    overall_duration = None
                segments_start_idx = 7
            
            # Parse segments (separated by ||)
            segments_data = '|'.join(parts[segments_start_idx:])
            segment_strs = segments_data.split('||')
            
            # Parse segment definitions
            segment_definitions = []
            total_original_duration = 0
            total_estimated_length = 0
            
            for seg_str in segment_strs:
                if not seg_str:  # Skip empty segments
                    continue
                    
                seg_parts = seg_str.split('|')
                seg_type = seg_parts[0]
                
                if seg_type == 'LINE':
                    # Format: LINE|end_x,end_y,end_z,end_rx,end_ry,end_rz|duration
                    end = list(map(float, seg_parts[1].split(',')))
                    segment_duration = float(seg_parts[2])
                    total_original_duration += segment_duration
                    
                    # Estimate length (will be refined when we have actual start)
                    estimated_length = 100  # mm, conservative estimate
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'LINE',
                        'end': end,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
                    
                elif seg_type == 'CIRCLE':
                    # Format: CIRCLE|center_x,center_y,center_z|radius|plane|duration|clockwise
                    center = list(map(float, seg_parts[1].split(',')))
                    radius = float(seg_parts[2])
                    plane = seg_parts[3]
                    segment_duration = float(seg_parts[4])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[5] == '1'
                    
                    # Circle circumference
                    estimated_length = 2 * np.pi * radius
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'CIRCLE',
                        'center': center,
                        'radius': radius,
                        'plane': plane,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'ARC':
                    # Format: ARC|end_x,end_y,end_z,end_rx,end_ry,end_rz|center_x,center_y,center_z|duration|clockwise
                    end = list(map(float, seg_parts[1].split(',')))
                    center = list(map(float, seg_parts[2].split(',')))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    clockwise = seg_parts[4] == '1'
                    
                    # Estimate arc length
                    estimated_radius = 50  # mm
                    estimated_arc_angle = np.pi / 2  # 90 degrees
                    estimated_length = estimated_radius * estimated_arc_angle
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'ARC',
                        'end': end,
                        'center': center,
                        'duration': segment_duration,
                        'original_duration': segment_duration,
                        'clockwise': clockwise
                    })
                    
                elif seg_type == 'SPLINE':
                    # Format: SPLINE|num_points|waypoint1;waypoint2;...|duration
                    num_points = int(seg_parts[1])
                    waypoints = []
                    wp_strs = seg_parts[2].split(';')
                    for wp_str in wp_strs:
                        waypoints.append(list(map(float, wp_str.split(','))))
                    segment_duration = float(seg_parts[3])
                    total_original_duration += segment_duration
                    
                    # Estimate spline length
                    estimated_length = 0
                    for i in range(1, len(waypoints)):
                        estimated_length += np.linalg.norm(
                            np.array(waypoints[i][:3]) - np.array(waypoints[i-1][:3])
                        )
                    total_estimated_length += estimated_length
                    
                    segment_definitions.append({
                        'type': 'SPLINE',
                        'waypoints': waypoints,
                        'duration': segment_duration,
                        'original_duration': segment_duration
                    })
            
            # Adjust segment durations if overall timing is specified
            if overall_duration is not None:
                # Scale all segment durations proportionally
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Scaled blend segments to total duration: {overall_duration:.2f}s")
                        
            elif overall_speed is not None:
                # Calculate duration from speed and estimated path length
                overall_duration = calculate_duration_from_speed(total_estimated_length, overall_speed)
                if total_original_duration > 0:
                    scale_factor = overall_duration / total_original_duration
                    for seg in segment_definitions:
                        seg['duration'] = seg['original_duration'] * scale_factor
                print(f"  -> Calculated blend duration from speed: {overall_duration:.2f}s")
            else:
                print(f"  -> Using original segment durations (total: {total_original_duration:.2f}s)")
            
            print(f"  -> Parsed blend: {num_segments} segments, frame={frame}, blend_time={blend_time}s")
            
            # Return command with frame
            return SmoothBlendCommand(segment_definitions, blend_time, frame, start_pose)
            
    except Exception as e:
        print(f"Error parsing smooth motion command: {e}")
        print(f"Command parts: {parts}")
        import traceback
        traceback.print_exc()
        return None
    
    print(f"Warning: Unknown smooth motion command type: {command_type}")
    return None

def transform_command_params_to_wrf(command_type: str, params: dict, frame: str, current_position_in) -> dict:
    """
    Transform command parameters from TRF to WRF.
    Handles position, orientation, and directional vectors correctly.
    """
    if frame == 'WRF':
        return params
    
    # Get current tool pose
    current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                         for i, p in enumerate(current_position_in)])
    tool_pose = PAROL6_ROBOT.robot.fkine(current_q)
    
    transformed = params.copy()
    
    # SMOOTH_CIRCLE - Transform center and plane normal
    if command_type == 'SMOOTH_CIRCLE':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'plane' in params:
            plane_normals_trf = {
                'XY': [0, 0, 1],   # Tool's Z-axis
                'XZ': [0, 1, 0],   # Tool's Y-axis  
                'YZ': [1, 0, 0]    # Tool's X-axis
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
            print(f"  -> TRF circle plane {params['plane']} transformed to WRF")
    
    # SMOOTH_ARC_CENTER - Transform center, end_pose, and implied plane
    elif command_type == 'SMOOTH_ARC_CENTER':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # Arc plane is determined by start, end, and center points
        # But we should transform any specified plane normal
        if 'plane' in params:
            # Similar to circle plane transformation
            plane_normals_trf = {
                'XY': [0, 0, 1],
                'XZ': [0, 1, 0],
                'YZ': [1, 0, 0]
            }
            normal_trf = np.array(plane_normals_trf[params['plane']])
            normal_wrf = tool_pose.R @ normal_trf
            transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_ARC_PARAM - Transform end_pose and arc plane
    elif command_type == 'SMOOTH_ARC_PARAM':
        if 'end_pose' in params:
            end_trf = SE3(params['end_pose'][0]/1000, 
                         params['end_pose'][1]/1000, 
                         params['end_pose'][2]/1000) * \
                      SE3.RPY(params['end_pose'][3:], unit='deg', order='xyz')
            end_wrf = tool_pose * end_trf
            transformed['end_pose'] = np.concatenate([
                end_wrf.t * 1000,
                end_wrf.rpy(unit='deg', order='xyz')
            ]).tolist()
        
        # For parametric arc, the plane is usually XY of the tool
        # Transform the assumed plane normal
        if 'plane' not in params:
            params['plane'] = 'XY'  # Default to XY plane
        
        plane_normals_trf = {
            'XY': [0, 0, 1],
            'XZ': [0, 1, 0],
            'YZ': [1, 0, 0]
        }
        normal_trf = np.array(plane_normals_trf[params.get('plane', 'XY')])
        normal_wrf = tool_pose.R @ normal_trf
        transformed['normal_vector'] = normal_wrf.tolist()
    
    # SMOOTH_HELIX - Transform center and helix axis
    elif command_type == 'SMOOTH_HELIX':
        if 'center' in params:
            center_trf = SE3(params['center'][0]/1000, 
                           params['center'][1]/1000, 
                           params['center'][2]/1000)
            center_wrf = tool_pose * center_trf
            transformed['center'] = (center_wrf.t * 1000).tolist()
        
        # Helix axis - default is Z-axis (vertical in TRF)
        # In TRF, helix rises along tool's Z-axis
        helix_axis_trf = np.array([0, 0, 1])  # Tool's Z-axis
        helix_axis_wrf = tool_pose.R @ helix_axis_trf
        transformed['helix_axis'] = helix_axis_wrf.tolist()
        
        # Also need to transform the "up" direction for proper orientation
        up_vector_trf = np.array([0, 1, 0])  # Tool's Y-axis
        up_vector_wrf = tool_pose.R @ up_vector_trf
        transformed['up_vector'] = up_vector_wrf.tolist()
    
    # SMOOTH_SPLINE - Transform all waypoints
    elif command_type == 'SMOOTH_SPLINE':
        if 'waypoints' in params:
            transformed_waypoints = []
            for wp in params['waypoints']:
                wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                         SE3.RPY(wp[3:], unit='deg', order='xyz')
                wp_wrf = tool_pose * wp_trf
                wp_transformed = np.concatenate([
                    wp_wrf.t * 1000,
                    wp_wrf.rpy(unit='deg', order='xyz')
                ]).tolist()
                transformed_waypoints.append(wp_transformed)
            transformed['waypoints'] = transformed_waypoints
    
    # SMOOTH_BLEND - Transform all segments recursively
    elif command_type == 'SMOOTH_BLEND':
        if 'segments' in params:
            transformed_segments = []
            for seg in params['segments']:
                seg_copy = seg.copy()
                seg_type = seg['type']
                
                if seg_type == 'LINE':
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'CIRCLE':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'plane' in seg:
                        plane_normals_trf = {
                            'XY': [0, 0, 1],
                            'XZ': [0, 1, 0],
                            'YZ': [1, 0, 0]
                        }
                        normal_trf = np.array(plane_normals_trf[seg['plane']])
                        normal_wrf = tool_pose.R @ normal_trf
                        seg_copy['normal_vector'] = normal_wrf.tolist()
                
                elif seg_type == 'ARC':
                    if 'center' in seg:
                        center_trf = SE3(seg['center'][0]/1000, 
                                       seg['center'][1]/1000, 
                                       seg['center'][2]/1000)
                        center_wrf = tool_pose * center_trf
                        seg_copy['center'] = (center_wrf.t * 1000).tolist()
                    
                    if 'end' in seg:
                        end_trf = SE3(seg['end'][0]/1000, 
                                    seg['end'][1]/1000, 
                                    seg['end'][2]/1000) * \
                                  SE3.RPY(seg['end'][3:], unit='deg', order='xyz')
                        end_wrf = tool_pose * end_trf
                        seg_copy['end'] = np.concatenate([
                            end_wrf.t * 1000,
                            end_wrf.rpy(unit='deg', order='xyz')
                        ]).tolist()
                
                elif seg_type == 'SPLINE':
                    if 'waypoints' in seg:
                        transformed_waypoints = []
                        for wp in seg['waypoints']:
                            wp_trf = SE3(wp[0]/1000, wp[1]/1000, wp[2]/1000) * \
                                     SE3.RPY(wp[3:], unit='deg', order='xyz')
                            wp_wrf = tool_pose * wp_trf
                            wp_transformed = np.concatenate([
                                wp_wrf.t * 1000,
                                wp_wrf.rpy(unit='deg', order='xyz')
                            ]).tolist()
                            transformed_waypoints.append(wp_transformed)
                        seg_copy['waypoints'] = transformed_waypoints
                
                transformed_segments.append(seg_copy)
            transformed['segments'] = transformed_segments
    
    # Transform start_pose if specified (common to all commands)
    if 'start_pose' in params and params['start_pose'] is not None:
        start_trf = SE3(params['start_pose'][0]/1000, 
                       params['start_pose'][1]/1000, 
                       params['start_pose'][2]/1000) * \
                    SE3.RPY(params['start_pose'][3:], unit='deg', order='xyz')
        start_wrf = tool_pose * start_trf
        transformed['start_pose'] = np.concatenate([
            start_wrf.t * 1000,
            start_wrf.rpy(unit='deg', order='xyz')
        ]).tolist()
    
    return transformed

#########################################################################
# Smooth Motion Commands and Robot Commands End Here
#########################################################################

# Acknowledgment system configuration
CLIENT_ACK_PORT = 5002  # Port where clients listen for acknowledgments
ack_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Command tracking
active_command_id = None
command_id_map = {}  # Maps command objects to their IDs

def send_acknowledgment(cmd_id: str, status: str, details: str = "", addr=None):
    """Send acknowledgment back to client"""
    if not cmd_id:
        return
        
    ack_message = f"ACK|{cmd_id}|{status}|{details}"
    
    # Send to the original sender if we have their address
    if addr:
        try:
            ack_socket.sendto(ack_message.encode('utf-8'), (addr[0], CLIENT_ACK_PORT))
        except Exception as e:
            print(f"Failed to send ack to {addr}: {e}")
    
    # Also broadcast to localhost in case the client is local
    try:
        ack_socket.sendto(ack_message.encode('utf-8'), ('127.0.0.1', CLIENT_ACK_PORT))
    except:
        pass

def parse_command_with_id(message: str) -> Tuple[Optional[str], str]:
    """
    Parse command ID if present.
    Format: [cmd_id|]COMMAND|params...
    Returns: (cmd_id or None, command_string)
    """
    # Clean up any logging artifacts
    if "ID:" in message or "):" in message:
        # Extract the actual command after these artifacts
        if "):" in message:
            message = message[message.rindex("):")+2:].strip()
        elif "ID:" in message:
            message = message[message.index("ID:")+3:].strip()
            # Remove any trailing parentheses or colons
            message = message.lstrip('):').strip()
    
    parts = message.split('|', 1)
    
    # Check if first part looks like a valid command ID (8 chars, alphanumeric)
    # IMPORTANT: Command IDs from uuid.uuid4()[:8] will contain lowercase letters/numbers
    # Actual commands are all uppercase, so exclude all-uppercase strings
    if (len(parts) > 1 and 
        len(parts[0]) == 8 and 
        parts[0].replace('-', '').isalnum() and 
        not parts[0].isupper()):  # This prevents "MOVEPOSE" from being treated as an ID
        return parts[0], parts[1]
    else:
        return None, message


# Create a new, empty command queue
command_queue = deque()

# --------------------------------------------------------------------------
# --- Test 1: Homing and Initial Setup
# --------------------------------------------------------------------------

# 1. Start with the mandatory Home command.
command_queue.append(HomeCommand())

# --- State variable for the currently running command ---
active_command = None
e_stop_active = False

# Use deque for an efficient FIFO queue
incoming_command_buffer = deque()
# Timestamp of the last processed network command
last_command_time = 0
# Cooldown period in seconds to prevent command flooding
COMMAND_COOLDOWN_S = 0.1 # 100ms

# Set interval
timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)

# ============================================================================
# MODIFIED MAIN LOOP WITH ACKNOWLEDGMENTS
# ============================================================================

timer = Timer(interval=INTERVAL_S, warnings=False, precise=True)
prev_time = 0

while timer.elapsed_time < 1100000:
    
    # --- Connection Handling ---
    if ser is None or not ser.is_open:
        print("Serial port not open. Attempting to reconnect...")
        try:
            ser = serial.Serial(port=com_port_str, baudrate=3000000, timeout=0)
            if ser.is_open:
                print(f"Successfully reconnected to {com_port_str}")
        except serial.SerialException as e:
            ser = None
            time.sleep(1) 
        continue

    # =======================================================================
    # === NETWORK COMMAND RECEPTION WITH ID PARSING ===
    # =======================================================================
    try:
        while sock in select.select([sock], [], [], 0)[0]:
            data, addr = sock.recvfrom(1024)
            raw_message = data.decode('utf-8').strip()
            if raw_message:
                # Parse command ID if present
                cmd_id, message = parse_command_with_id(raw_message)
                
                parts = message.split('|')
                command_name = parts[0].upper()

                # Handle immediate response commands
                if command_name == 'STOP':
                    print("Received STOP command. Halting all motion and clearing queue.")
                    
                    # Cancel active command
                    if active_command and active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "Stopped by user", addr)
                    active_command = None
                    active_command_id = None
                    
                    # Clear queue and notify about cancelled commands
                    for queued_cmd in command_id_map.keys():
                        if queued_cmd != active_command:
                            if queued_cmd in command_id_map:
                                send_acknowledgment(command_id_map[queued_cmd], 
                                                  "CANCELLED", "Queue cleared by STOP", addr)
                    
                    command_queue.clear()
                    command_id_map.clear()
                    
                    # Stop robot
                    Command_out.value = 255
                    Speed_out[:] = [0] * 6
                    
                    # Send acknowledgment for STOP command itself
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Emergency stop executed", addr)

                elif command_name == 'GET_POSE':
                    q_current = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)])
                    current_pose_matrix = PAROL6_ROBOT.robot.fkine(q_current).A
                    pose_flat = current_pose_matrix.flatten()
                    pose_str = ",".join(map(str, pose_flat))
                    response_message = f"POSE|{pose_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Pose data sent", addr)

                elif command_name == 'GET_ANGLES':
                    angles_rad = [PAROL6_ROBOT.STEPS2RADS(p, i) for i, p in enumerate(Position_in)]
                    angles_deg = np.rad2deg(angles_rad)
                    angles_str = ",".join(map(str, angles_deg))
                    response_message = f"ANGLES|{angles_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Angles data sent", addr)

                elif command_name == 'GET_IO':
                    io_status_str = ",".join(map(str, InOut_in[:5]))
                    response_message = f"IO|{io_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "IO data sent", addr)

                elif command_name == 'GET_GRIPPER':
                    gripper_status_str = ",".join(map(str, Gripper_data_in))
                    response_message = f"GRIPPER|{gripper_status_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Gripper data sent", addr)

                elif command_name == 'GET_SPEEDS':
                    speeds_str = ",".join(map(str, Speed_in))
                    response_message = f"SPEEDS|{speeds_str}"
                    sock.sendto(response_message.encode('utf-8'), addr)
                    
                    if cmd_id:
                        send_acknowledgment(cmd_id, "COMPLETED", "Speed data sent", addr)

                else:
                    # Queue command for processing
                    incoming_command_buffer.append((raw_message, addr))

    except Exception as e:
        print(f"Network receive error: {e}")

    # =======================================================================
    # === PROCESS COMMANDS FROM BUFFER WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    current_time = time.time()
    if incoming_command_buffer and (current_time - last_command_time) > COMMAND_COOLDOWN_S and not e_stop_active:
        raw_message, addr = incoming_command_buffer.popleft()
        last_command_time = current_time
        
        # Parse command ID
        cmd_id, message = parse_command_with_id(raw_message)
        print(f"Processing command{' (ID: ' + cmd_id + ')' if cmd_id else ''}: {message[:50]}...")
        
        parts = message.split('|')
        command_name = parts[0].upper()
        
        # Variable to track if command was successfully queued
        command_queued = False
        command_obj = None
        error_details = ""

        # Parse and create command objects
        try:
            if command_name == 'MOVEPOSE' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MovePoseCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
                
            elif command_name == 'MOVEJOINT' and len(parts) == 9:
                joint_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveJointCommand(target_angles=joint_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name in ['SMOOTH_CIRCLE', 'SMOOTH_ARC_CENTER', 'SMOOTH_ARC_PARAM', 
                                 'SMOOTH_SPLINE', 'SMOOTH_HELIX', 'SMOOTH_BLEND']:
                command_obj = parse_smooth_motion_commands(parts)
                if command_obj:
                    command_queued = True
                else:
                    error_details = "Failed to parse smooth motion parameters"
            
            elif command_name == 'MOVECART' and len(parts) == 9:
                pose_vals = [float(p) for p in parts[1:7]]
                duration = None if parts[7].upper() == 'NONE' else float(parts[7])
                speed = None if parts[8].upper() == 'NONE' else float(parts[8])
                command_obj = MoveCartCommand(pose=pose_vals, duration=duration, velocity_percent=speed)
                command_queued = True
            
            elif command_name == 'DELAY' and len(parts) == 2:
                duration = float(parts[1])
                command_obj = DelayCommand(duration=duration)
                command_queued = True
            
            elif command_name == 'HOME':
                command_obj = HomeCommand()
                command_queued = True
                
            elif command_name == 'CARTJOG' and len(parts) == 5:
                frame, axis, speed, duration = parts[1].upper(), parts[2], float(parts[3]), float(parts[4])
                command_obj = CartesianJogCommand(frame=frame, axis=axis, speed_percentage=speed, duration=duration)
                command_queued = True
                
            elif command_name == 'JOG' and len(parts) == 5:
                joint_idx, speed = int(parts[1]), float(parts[2])
                duration = None if parts[3].upper() == 'NONE' else float(parts[3])
                distance = None if parts[4].upper() == 'NONE' else float(parts[4])
                command_obj = JogCommand(joint=joint_idx, speed_percentage=speed, duration=duration, distance_deg=distance)
                command_queued = True
            
            elif command_name == 'MULTIJOG' and len(parts) == 4:
                joint_indices = [int(j) for j in parts[1].split(',')]
                speeds = [float(s) for s in parts[2].split(',')]
                duration = float(parts[3])
                command_obj = MultiJogCommand(joints=joint_indices, speed_percentages=speeds, duration=duration)
                command_queued = True
                
            elif command_name == 'PNEUMATICGRIPPER' and len(parts) == 3:
                action, port = parts[1].lower(), int(parts[2])
                command_obj = GripperCommand(gripper_type='pneumatic', action=action, output_port=port)
                command_queued = True
                
            elif command_name == 'ELECTRICGRIPPER' and len(parts) == 5:
                action = None if parts[1].upper() == 'NONE' or parts[1].upper() == 'MOVE' else parts[1].lower()
                pos, spd, curr = int(parts[2]), int(parts[3]), int(parts[4])
                command_obj = GripperCommand(gripper_type='electric', action=action, position=pos, speed=spd, current=curr)
                command_queued = True
            
            else:
                error_details = f"Unknown or malformed command: {command_name}"
                
        except Exception as e:
            error_details = f"Error parsing command: {str(e)}"
            command_queued = False
        
        # Handle command queueing and acknowledgments
        if command_queued and command_obj:
            # Check if command is initially valid
            if hasattr(command_obj, 'is_valid') and not command_obj.is_valid:
                if cmd_id:
                    send_acknowledgment(cmd_id, "INVALID", 
                                       "Command failed validation", addr)
            else:
                # Add to queue
                command_queue.append(command_obj)
                if cmd_id:
                    command_id_map[command_obj] = (cmd_id, addr)
                    send_acknowledgment(cmd_id, "QUEUED", 
                                       f"Position {len(command_queue)} in queue", addr)
        else:
            # Command was not queued
            if cmd_id:
                send_acknowledgment(cmd_id, "INVALID", error_details, addr)
            print(f"Warning: {error_details}")

    # =======================================================================
    # === MAIN EXECUTION LOGIC WITH ACKNOWLEDGMENTS ===
    # =======================================================================
    try:
        # --- E-Stop Handling ---
        if InOut_in[4] == 0:  # E-Stop pressed
            if not e_stop_active:
                cancelled_command_info = "None"
                if active_command is not None:
                    cancelled_command_info = type(active_command).__name__
                    if active_command_id:
                        send_acknowledgment(active_command_id, "CANCELLED", 
                                          "E-Stop activated")
                
                # Cancel all queued commands
                for cmd_obj in command_queue:
                    if cmd_obj in command_id_map:
                        cmd_id, addr = command_id_map[cmd_obj]
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated", addr)
                
                # Cancel all buffered but unprocessed commands
                for raw_message, addr in incoming_command_buffer:
                    cmd_id, _ = parse_command_with_id(raw_message)
                    if cmd_id:
                        send_acknowledgment(cmd_id, "CANCELLED", "E-Stop activated - command not processed", addr)
                
                print(f"E-STOP TRIGGERED! Active command '{cancelled_command_info}' cancelled.")
                print("Release E-Stop and press 'e' to re-enable.")
                e_stop_active = True
            
            Command_out.value = 102
            Speed_out[:] = [0] * 6
            Gripper_data_out[3] = 0
            active_command = None
            active_command_id = None
            command_queue.clear()
            command_id_map.clear()
            incoming_command_buffer.clear()
            
        elif e_stop_active:
            # Waiting for re-enable
            if keyboard.is_pressed('e'):
                print("Re-enabling robot...")
                Command_out.value = 101
                e_stop_active = False
            else:
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]
                
        else:
            # --- Normal Command Processing ---
            
            # Start new command if none active
            if active_command is None and command_queue:
                new_command = command_queue.popleft()
                
                # Get command ID and address if tracked
                cmd_info = command_id_map.get(new_command, (None, None))
                new_cmd_id, new_addr = cmd_info
                
                # Initial validation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Command was invalid from the start
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "INVALID", 
                                        "Initial validation failed", new_addr)
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                    continue  # Skip to next command
                
                # Prepare command
                if hasattr(new_command, 'prepare_for_execution'):
                    try:
                        new_command.prepare_for_execution(current_position_in=Position_in)
                    except Exception as e:
                        print(f"Command preparation failed: {e}")
                        if hasattr(new_command, 'is_valid'):
                            new_command.is_valid = False
                        if hasattr(new_command, 'error_message'):
                            new_command.error_message = str(e)
                
                # Check if still valid after preparation
                if hasattr(new_command, 'is_valid') and not new_command.is_valid:
                    # Failed during preparation
                    error_msg = "Failed during preparation"
                    if hasattr(new_command, 'error_message'):
                        error_msg = new_command.error_message
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "FAILED", error_msg, new_addr)
                    
                    # Clean up
                    if new_command in command_id_map:
                        del command_id_map[new_command]
                else:
                    # Command is valid, make it active
                    active_command = new_command
                    active_command_id = new_cmd_id
                    
                    if new_cmd_id:
                        send_acknowledgment(new_cmd_id, "EXECUTING", 
                                        f"Starting {type(new_command).__name__}", new_addr)
            
            # Execute active command
            if active_command:
                try:
                    is_done = active_command.execute_step(
                        Position_in=Position_in,
                        Homed_in=Homed_in,
                        Speed_out=Speed_out,
                        Command_out=Command_out,
                        Gripper_data_out=Gripper_data_out,
                        InOut_out=InOut_out,
                        InOut_in=InOut_in,
                        Gripper_data_in=Gripper_data_in,
                        Position_out=Position_out  # Add this if needed
                    )
                    
                    if is_done:
                        # Command completed
                        if active_command_id:
                            # Check for error state in smooth motion commands
                            if hasattr(active_command, 'error_state') and active_command.error_state:
                                error_msg = getattr(active_command, 'error_message', 'Command failed during execution')
                                send_acknowledgment(active_command_id, "FAILED", error_msg)
                            else:
                                send_acknowledgment(active_command_id, "COMPLETED", 
                                                f"{type(active_command).__name__} finished successfully")
                        
                        # Clean up
                        if active_command in command_id_map:
                            del command_id_map[active_command]
                        
                        active_command = None
                        active_command_id = None
                        
                except Exception as e:
                    # Command execution error
                    print(f"Command execution error: {e}")
                    if active_command_id:
                        send_acknowledgment(active_command_id, "FAILED", 
                                          f"Execution error: {str(e)}")
                    
                    # Clean up
                    if active_command in command_id_map:
                        del command_id_map[active_command]
                    
                    active_command = None
                    active_command_id = None
                    
            else:
                # No active command - idle
                Command_out.value = 255
                Speed_out[:] = [0] * 6
                Position_out[:] = Position_in[:]

        # --- Communication with Robot ---
        s = Pack_data(Position_out, Speed_out, Command_out.value, 
                     Affected_joint_out, InOut_out, Timeout_out, Gripper_data_out)
        for chunk in s:
            ser.write(chunk)
            
        Get_data(Position_in, Speed_in, Homed_in, InOut_in, Temperature_error_in, 
                Position_error_in, Timeout_error, Timing_data_in, XTR_data, Gripper_data_in)

    except serial.SerialException as e:
        print(f"Serial communication error: {e}")
        
        # Send failure acknowledgments for active command
        if active_command_id:
            send_acknowledgment(active_command_id, "FAILED", "Serial communication lost")
        
        if ser:
            ser.close()
        ser = None
        active_command = None
        active_command_id = None

    timer.checkpt()
````

## File: safe_home_client.py
````python
# safe_home_client.py
import time
from robot_api import (
    connect, disconnect, is_connected,
    stop_robot, clear_queue, home_robot, get_state
)

def main():
    # 1) 连接（如果 robot_api 需要 IP/端口，替换 connect(host, port) 版本）
    connect()
    assert is_connected(), "连接失败，请检查 headless_commander 是否在运行"

    # 2) 安全：停止并清队列
    try:
        stop_robot()    # 某些实现是软停；若无该函数可忽略
    except Exception:
        pass
    try:
        clear_queue()
    except Exception:
        pass

    # 3) 读取当前状态并打印（确认未在运动）
    try:
        s = get_state()
        print("当前状态：", s)
    except Exception as e:
        print("读取状态失败，不影响 Home：", e)

    # 4) 低速 Home（关键！）
    print("开始低速 Home ...")
    home_robot(speed_percentage=10, wait_for_ack=True, timeout=120)

    # 5) 等待稳定
    time.sleep(1.0)
    print("Home 指令完成。再次读取状态：")
    try:
        s2 = get_state()
        print("状态：", s2)
    except Exception:
        pass

    # 6) 断开
    disconnect()
    print("完成")

if __name__ == "__main__":
    main()
````

## File: smooth_motion.py
````python
"""
Smooth Motion Module for PAROL6 Robotic Arm
============================================
This module provides advanced trajectory generation capabilities including:
- Circular and arc movements
- Cubic spline trajectories
- Motion blending
- Pre-computed and real-time trajectory generation

Compatible with:
- numpy==1.23.4
- scipy==1.11.4
- roboticstoolbox-python==1.0.3
"""

import sys
import warnings
from collections import namedtuple
from roboticstoolbox import DHRobot
from spatialmath.base import trinterp

# Version compatibility check
try:
    import numpy as np
    # Check numpy version
    np_version = tuple(map(int, np.__version__.split('.')[:2]))
    if np_version < (1, 23):
        warnings.warn(f"NumPy version {np.__version__} detected. Recommended: 1.23.4")
    
    from scipy.interpolate import CubicSpline
    from scipy.spatial.transform import Rotation, Slerp
    import scipy
    # Check scipy version
    scipy_version = tuple(map(int, scipy.__version__.split('.')[:2]))
    if scipy_version < (1, 11):
        warnings.warn(f"SciPy version {scipy.__version__} detected. Recommended: 1.11.4")
        
except ImportError as e:
    print(f"Error importing required packages: {e}")
    print("Please install: pip3 install numpy==1.23.4 scipy==1.11.4")
    sys.exit(1)

from spatialmath import SE3
import time
from typing import List, Tuple, Optional, Dict, Union
from collections import deque

# Import PAROL6 specific modules (these should be in your path)
try:
    import GUI.files.PAROL6_ROBOT
except ImportError:
    print("Warning: PAROL6 modules not found. Some functions may not work.")
    PAROL6_ROBOT = None

# Global variable to track previous tolerance for logging changes
_prev_tolerance = None

# IK Result structure
IKResult = namedtuple('IKResult', 'success q iterations residual tolerance_used violations')

def normalize_angle(angle):
    """Normalize angle to [-pi, pi] range to handle angle wrapping"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def unwrap_angles(q_solution, q_current):
    """
    Unwrap angles in the solution to be closest to current position.
    This handles the angle wrapping issue where -179° and 181° are close but appear far.
    """
    q_unwrapped = q_solution.copy()
    
    for i in range(len(q_solution)):
        # Calculate the difference
        diff = q_solution[i] - q_current[i]
        
        # If the difference is more than pi, we need to unwrap
        if diff > np.pi:
            # Solution is too far in positive direction, subtract 2*pi
            q_unwrapped[i] = q_solution[i] - 2 * np.pi
        elif diff < -np.pi:
            # Solution is too far in negative direction, add 2*pi
            q_unwrapped[i] = q_solution[i] + 2 * np.pi
    
    return q_unwrapped

def calculate_adaptive_tolerance(robot, q, strict_tol=1e-10, loose_tol=1e-7):
    """
    Calculate adaptive tolerance based on proximity to singularities.
    Near singularities: looser tolerance for easier convergence.
    Away from singularities: stricter tolerance for precise solutions.
    """
    global _prev_tolerance
    
    q_array = np.array(q, dtype=float)
    
    # Calculate manipulability measure (closer to 0 = closer to singularity)
    manip = robot.manipulability(q_array)
    singularity_threshold = 0.001
    
    sing_normalized = np.clip(manip / singularity_threshold, 0.0, 1.0)
    adaptive_tol = loose_tol + (strict_tol - loose_tol) * sing_normalized
    
    # Log tolerance changes (only log significant changes to avoid spam)
    if _prev_tolerance is None or abs(adaptive_tol - _prev_tolerance) / _prev_tolerance > 0.5:
        tol_category = "LOOSE" if adaptive_tol > 1e-7 else "MODERATE" if adaptive_tol > 5e-10 else "STRICT"
        print(f"Adaptive IK tolerance: {adaptive_tol:.2e} ({tol_category}) - Manipulability: {manip:.8f} (threshold: {singularity_threshold})")
        _prev_tolerance = adaptive_tol
    
    return adaptive_tol

def calculate_configuration_dependent_max_reach(q_seed):
    """
    Calculate maximum reach based on joint configuration, particularly joint 5.
    When joint 5 is at 90 degrees, the effective reach is reduced by approximately 0.045.
    """
    base_max_reach = 0.44  # Base maximum reach from experimentation
    
    j5_angle = q_seed[4] if len(q_seed) > 4 else 0.0
    j5_normalized = normalize_angle(j5_angle)
    angle_90_deg = np.pi / 2
    angle_neg_90_deg = -np.pi / 2
    dist_from_90 = abs(j5_normalized - angle_90_deg)
    dist_from_neg_90 = abs(j5_normalized - angle_neg_90_deg)
    dist_from_90_deg = min(dist_from_90, dist_from_neg_90)
    reduction_range = np.pi / 4  # 45 degrees
    if dist_from_90_deg <= reduction_range:
        # Calculate reduction factor based on proximity to 90°
        proximity_factor = 1.0 - (dist_from_90_deg / reduction_range)
        reach_reduction = 0.045 * proximity_factor
        effective_max_reach = base_max_reach - reach_reduction
        
        return effective_max_reach
    else:
        return base_max_reach

def solve_ik_with_adaptive_tol_subdivision(
        robot: DHRobot,
        target_pose: SE3,
        current_q,
        current_pose: SE3 = None,
        max_depth: int = 4,
        ilimit: int = 100,
        jogging: bool = False
):
    """
    Uses adaptive tolerance based on proximity to singularities.
    If necessary, recursively subdivide the motion until ikine_LM converges
    on every segment. Finally check that solution respects joint limits.
    """
    if current_pose is None:
        current_pose = robot.fkine(current_q)

    # ── inner recursive solver───────────────────
    def _solve(Ta: SE3, Tb: SE3, q_seed, depth, tol):
        """Return (path_list, success_flag, iterations, residual)."""
        # Calculate current and target reach
        current_reach = np.linalg.norm(Ta.t)
        target_reach = np.linalg.norm(Tb.t)
        
        # Check if this is an inward movement (recovery)
        is_recovery = target_reach < current_reach
        
        # Calculate configuration-dependent maximum reach based on joint 5 position
        max_reach_threshold = calculate_configuration_dependent_max_reach(q_seed)
        
        # Determine damping based on reach and movement direction
        if is_recovery:
            # Recovery mode - always use low damping
            damping = 0.0000001
        else:
            # Check if we're near configuration-dependent max reach
            if current_reach >= max_reach_threshold:
                print(f"Reach limit exceeded: {current_reach:.3f} >= {max_reach_threshold:.3f}")
                return [], False, depth, 0
            else:
                damping = 0.0000001  # Normal low damping
        
        res = robot.ikine_LM(Tb, q0=q_seed, ilimit=ilimit, tol=tol)
        if res.success:
            q_good = unwrap_angles(res.q, q_seed)      # << unwrap vs *previous*
            return [q_good], True, res.iterations, res.residual

        if depth >= max_depth:
            return [], False, res.iterations, res.residual
        # split the segment and recurse
        Tc = SE3(trinterp(Ta.A, Tb.A, 0.5))            # mid-pose (screw interp)

        left_path,  ok_L, it_L, r_L = _solve(Ta, Tc, q_seed, depth+1, tol)
        if not ok_L:
            return [], False, it_L, r_L

        q_mid = left_path[-1]                          # last solved joint set
        right_path, ok_R, it_R, r_R = _solve(Tc, Tb, q_mid, depth+1, tol)

        return (
            left_path + right_path,
            ok_R,
            it_L + it_R,
            r_R
        )

    # ── kick-off with adaptive tolerance ──────────────────────────────────
    if jogging:
        adaptive_tol = 1e-10
    else:
        adaptive_tol = calculate_adaptive_tolerance(robot, current_q)
    path, ok, its, resid = _solve(current_pose, target_pose, current_q, 0, adaptive_tol)
    
    # Check if solution respects joint limits
    if PAROL6_ROBOT is not None:
        target_q = path[-1] if len(path) != 0 else None
        solution_valid, violations = PAROL6_ROBOT.check_joint_limits(current_q, target_q)
        if ok and solution_valid:
            return IKResult(True, path[-1], its, resid, adaptive_tol, violations)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, violations)
    else:
        # If PAROL6_ROBOT not available, skip joint limit checking
        if ok and len(path) > 0:
            return IKResult(True, path[-1], its, resid, adaptive_tol, None)
        else:
            return IKResult(False, None, its, resid, adaptive_tol, None)

# ============================================================================
# END OF IK SOLVER FUNCTIONS
# ============================================================================

class TrajectoryGenerator:
    """Base class for trajectory generation with caching support"""
    
    def __init__(self, control_rate: float = 100.0):
        """
        Initialize trajectory generator
        
        Args:
            control_rate: Control loop frequency in Hz (default 100Hz for PAROL6)
        """
        self.control_rate = control_rate
        self.dt = 1.0 / control_rate
        self.trajectory_cache = {}
        
    def generate_timestamps(self, duration: float) -> np.ndarray:
        """Generate evenly spaced timestamps for trajectory"""
        num_points = int(duration * self.control_rate)
        return np.linspace(0, duration, num_points)

class CircularMotion(TrajectoryGenerator):
    """Generate circular and arc trajectories in 3D space"""
    
    def generate_arc_3d(self, 
                       start_pose: List[float], 
                       end_pose: List[float], 
                       center: List[float], 
                       normal: Optional[List[float]] = None,
                       clockwise: bool = True,
                       duration: float = 2.0) -> np.ndarray:
        """
        Generate a 3D circular arc trajectory
        
        Args:
            start_pose: Starting pose [x, y, z, rx, ry, rz] (mm and degrees)
            end_pose: Ending pose [x, y, z, rx, ry, rz] (mm and degrees)
            center: Center point of arc [x, y, z] (mm)
            normal: Normal vector to arc plane (default: z-axis)
            clockwise: Direction of rotation
            duration: Time to complete arc (seconds)
            
        Returns:
            Array of poses along the arc trajectory
        """
        # Convert to numpy arrays
        start_pos = np.array(start_pose[:3])
        end_pos = np.array(end_pose[:3])
        center_pt = np.array(center)
        
        # Calculate radius vectors
        r1 = start_pos - center_pt
        r2 = end_pos - center_pt
        radius = np.linalg.norm(r1)
        
        # Determine arc plane normal if not provided
        if normal is None:
            normal = np.cross(r1, r2)
            if np.linalg.norm(normal) < 1e-6:  # Points are collinear
                normal = np.array([0, 0, 1])  # Default to XY plane
        normal = normal / np.linalg.norm(normal)
        
        # Calculate arc angle
        r1_norm = r1 / np.linalg.norm(r1)
        r2_norm = r2 / np.linalg.norm(r2)
        cos_angle = np.clip(np.dot(r1_norm, r2_norm), -1, 1)
        arc_angle = np.arccos(cos_angle)
        
        # Check direction using cross product
        cross = np.cross(r1_norm, r2_norm)
        if np.dot(cross, normal) < 0:
            arc_angle = 2 * np.pi - arc_angle
            
        if clockwise:
            arc_angle = -arc_angle
            
        # Generate trajectory points
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        for i, t in enumerate(timestamps):
            # Interpolation factor
            s = t / duration
            
            # For first point, use exact start position
            if i == 0:
                current_pos = start_pos
            else:
                # Rotate radius vector
                angle = s * arc_angle
                rot_matrix = self._rotation_matrix_from_axis_angle(normal, angle)
                current_pos = center_pt + rot_matrix @ r1
            
            # Interpolate orientation (SLERP)
            current_orient = self._slerp_orientation(start_pose[3:], end_pose[3:], s)
            
            # Combine position and orientation
            pose = np.concatenate([current_pos, current_orient])
            trajectory.append(pose)
            
        return np.array(trajectory)
    
    def generate_circle_3d(self,
                      center: List[float],
                      radius: float,
                      normal: List[float] = [0, 0, 1],
                      start_angle: float = None,
                      duration: float = 4.0,
                      start_point: List[float] = None) -> np.ndarray:
        """
        Generate a complete circle trajectory that starts at start_point
        """
        timestamps = self.generate_timestamps(duration)
        trajectory = []
        
        # Create orthonormal basis for circle plane
        normal = np.array(normal) / np.linalg.norm(normal)
        u = self._get_perpendicular_vector(normal)
        v = np.cross(normal, u)
        
        center_np = np.array(center)
        
        # CRITICAL FIX: Validate and handle geometry
        if start_point is not None:
            start_pos = np.array(start_point[:3])
            
            # Project start point onto the circle plane
            to_start = start_pos - center_np
            to_start_plane = to_start - np.dot(to_start, normal) * normal
            
            # Get distance from center in the plane
            dist_in_plane = np.linalg.norm(to_start_plane)
            
            if dist_in_plane < 0.001:
                # Start point is at center - can't determine angle
                print(f"    WARNING: Start point is at circle center, using default position")
                start_angle = 0
                actual_start = center_np + radius * u
            else:
                # Calculate the angle of the start point
                to_start_normalized = to_start_plane / dist_in_plane
                u_comp = np.dot(to_start_normalized, u)
                v_comp = np.dot(to_start_normalized, v)
                start_angle = np.arctan2(v_comp, u_comp)
                
                # CHECK FOR INVALID GEOMETRY
                radius_error = abs(dist_in_plane - radius)
                if radius_error > radius * 0.3:  # More than 30% off
                    print(f"    WARNING: Start point is {dist_in_plane:.1f}mm from center,")
                    print(f"             but circle radius is {radius:.1f}mm!")
                    
                    # AUTO-CORRECT: Adjust center to make geometry valid
                    print(f"    AUTO-CORRECTING: Moving center to maintain {radius}mm radius from start")
                    direction = to_start_plane / dist_in_plane
                    center_np = start_pos - direction * radius
                    print(f"    New center: {center_np.round(1)}")
                    
                    # Recalculate with new center
                    to_start = start_pos - center_np
                    to_start_plane = to_start - np.dot(to_start, normal) * normal
                    dist_in_plane = np.linalg.norm(to_start_plane)
                
                actual_start = start_pos
        else:
            start_angle = 0 if start_angle is None else start_angle
            actual_start = None
        
        # Generate the circle 
        for i, t in enumerate(timestamps):
            if i == 0 and actual_start is not None:
                # First point MUST be exactly the start point
                pos = actual_start
            else:
                # Generate circle points
                angle = start_angle + (2 * np.pi * t / duration)
                pos = center_np + radius * (np.cos(angle) * u + np.sin(angle) * v)
            
            # Placeholder orientation (will be overridden)
            orient = [0, 0, 0]
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def _rotation_matrix_from_axis_angle(self, axis: np.ndarray, angle: float) -> np.ndarray:
        """Generate rotation matrix using Rodrigues' formula"""
        axis = axis / np.linalg.norm(axis)
        cos_a = np.cos(angle)
        sin_a = np.sin(angle)
        
        # Cross-product matrix
        K = np.array([[0, -axis[2], axis[1]],
                     [axis[2], 0, -axis[0]],
                     [-axis[1], axis[0], 0]])
        
        # Rodrigues' formula
        R = np.eye(3) + sin_a * K + (1 - cos_a) * K @ K
        return R
    
    def _get_perpendicular_vector(self, v: np.ndarray) -> np.ndarray:
        """Find a vector perpendicular to the given vector"""
        v = np.array(v)  # Ensure it's a numpy array
        if abs(v[0]) < 0.9:
            return np.cross(v, [1, 0, 0]) / np.linalg.norm(np.cross(v, [1, 0, 0]))
        else:
            return np.cross(v, [0, 1, 0]) / np.linalg.norm(np.cross(v, [0, 1, 0]))
    
    def _slerp_orientation(self, start_orient: List[float], 
                          end_orient: List[float], 
                          t: float) -> np.ndarray:
        """Spherical linear interpolation for orientation"""
        # Convert to quaternions
        r1 = Rotation.from_euler('xyz', start_orient, degrees=True)
        r2 = Rotation.from_euler('xyz', end_orient, degrees=True)
        
        # Create slerp object - compatible with scipy 1.11.4
        # Stack rotations into a single Rotation object
        key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
        slerp = Slerp([0, 1], key_rots)
        
        # Interpolate
        interp_rot = slerp(t)
        return interp_rot.as_euler('xyz', degrees=True)

class SplineMotion(TrajectoryGenerator):
    """Generate smooth spline trajectories through waypoints"""
    
    def generate_cubic_spline(self,
                             waypoints: List[List[float]],
                             timestamps: Optional[List[float]] = None,
                             velocity_start: Optional[List[float]] = None,
                             velocity_end: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate cubic spline trajectory through waypoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint (auto-generated if None)
            velocity_start: Initial velocity (zero if None)
            velocity_end: Final velocity (zero if None)
            
        Returns:
            Array of interpolated poses
        """
        waypoints = np.array(waypoints)
        num_waypoints = len(waypoints)
        
        # Auto-generate timestamps if not provided
        if timestamps is None:
            # Estimate based on distance
            total_dist = 0
            for i in range(1, num_waypoints):
                dist = np.linalg.norm(waypoints[i, :3] - waypoints[i-1, :3])
                total_dist += dist
            
            # Assume average speed of 50 mm/s
            total_time = total_dist / 50.0
            timestamps = np.linspace(0, total_time, num_waypoints)
        
        # Create splines for position
        pos_splines = []
        for i in range(3):
            bc_type = 'not-a-knot'  # Default boundary condition
            
            # Apply velocity boundary conditions if specified
            if velocity_start is not None and velocity_end is not None:
                bc_type = ((1, velocity_start[i]), (1, velocity_end[i]))
            
            spline = CubicSpline(timestamps, waypoints[:, i], bc_type=bc_type)
            pos_splines.append(spline)
        
        # Create splines for orientation (convert to quaternions for smooth interpolation)
        rotations = [Rotation.from_euler('xyz', wp[3:], degrees=True) for wp in waypoints]
        # Stack quaternions for scipy 1.11.4 compatibility
        quats = np.array([r.as_quat() for r in rotations])
        key_rots = Rotation.from_quat(quats)
        slerp = Slerp(timestamps, key_rots)
        
        # Generate dense trajectory
        t_eval = self.generate_timestamps(timestamps[-1])
        trajectory = []
        
        for t in t_eval:
            # Evaluate position splines
            pos = [spline(t) for spline in pos_splines]
            
            # Evaluate orientation
            rot = slerp(t)
            orient = rot.as_euler('xyz', degrees=True)
            
            trajectory.append(np.concatenate([pos, orient]))
        
        return np.array(trajectory)
    
    def generate_quintic_spline(self,
                               waypoints: List[List[float]],
                               timestamps: Optional[List[float]] = None) -> np.ndarray:
        """
        Generate quintic (5th order) spline with zero velocity and acceleration at endpoints
        
        Args:
            waypoints: List of poses [x, y, z, rx, ry, rz]
            timestamps: Time for each waypoint
            
        Returns:
            Array of interpolated poses
        """
        # For quintic spline, we need to ensure zero velocity and acceleration
        # at the endpoints for smooth motion
        return self.generate_cubic_spline(
            waypoints, 
            timestamps,
            velocity_start=[0, 0, 0],
            velocity_end=[0, 0, 0]
        )

class MotionBlender:
    """Blend between different motion segments for smooth transitions"""
    
    def __init__(self, blend_time: float = 0.5):
        self.blend_time = blend_time
        
    def blend_trajectories(self, traj1, traj2, blend_samples=50):
        """Blend two trajectory segments with improved velocity continuity"""
        
        if blend_samples < 4:
            return np.vstack([traj1, traj2])
        
        # Use more samples for smoother blending
        blend_samples = max(blend_samples, 20)  # Minimum 20 samples for smooth blend
        
        # Calculate overlap region more carefully
        overlap_start = max(0, len(traj1) - blend_samples // 3)
        overlap_end = min(len(traj2), blend_samples // 3)
        
        # Extract blend region
        blend_start_pose = traj1[overlap_start] if overlap_start < len(traj1) else traj1[-1]
        blend_end_pose = traj2[overlap_end] if overlap_end < len(traj2) else traj2[0]
        
        # Generate smooth transition using S-curve
        blended = []
        for i in range(blend_samples):
            t = i / (blend_samples - 1)
            # Use smoothstep function for smoother acceleration
            s = t * t * (3 - 2 * t)  # Smoothstep
            
            # Blend position
            pos_blend = blend_start_pose * (1 - s) + blend_end_pose * s
            
            # For orientation, use SLERP
            r1 = Rotation.from_euler('xyz', blend_start_pose[3:], degrees=True)
            r2 = Rotation.from_euler('xyz', blend_end_pose[3:], degrees=True)
            key_rots = Rotation.from_quat([r1.as_quat(), r2.as_quat()])
            slerp = Slerp([0, 1], key_rots)
            orient_blend = slerp(s).as_euler('xyz', degrees=True)
            
            pos_blend[3:] = orient_blend
            blended.append(pos_blend)
        
        # Combine with better overlap handling
        result = np.vstack([
            traj1[:overlap_start],
            np.array(blended),
            traj2[overlap_end:]
        ])
        
        return result

class SmoothMotionCommand:
    """Command class for executing smooth motions on PAROL6"""
    
    def __init__(self, trajectory: np.ndarray, speed_factor: float = 1.0):
        """
        Initialize smooth motion command
        
        Args:
            trajectory: Pre-computed trajectory array
            speed_factor: Speed scaling factor (1.0 = normal speed)
        """
        self.trajectory = trajectory
        self.speed_factor = speed_factor
        self.current_index = 0
        self.is_finished = False
        self.is_valid = True
        
    def prepare_for_execution(self, current_position_in):
        """Validate trajectory is reachable from current position"""
        # Check if IK solver is available
        if solve_ik_with_adaptive_tol_subdivision is None:
            print("Warning: IK solver not available, skipping validation")
            self.is_valid = True
            return True
            
        try:
            # Convert current position to radians
            current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                                 for i, p in enumerate(current_position_in)])
            
            # Check first waypoint is reachable
            first_pose = self.trajectory[0]
            target_se3 = SE3(first_pose[0]/1000, first_pose[1]/1000, first_pose[2]/1000) * \
                        SE3.RPY(first_pose[3:], unit='deg', order='xyz')
            
            ik_result = solve_ik_with_adaptive_tol_subdivision(
                PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
            )
            
            if not ik_result.success:
                print(f"Smooth motion validation failed: Cannot reach first waypoint")
                self.is_valid = False
                return False
                
            print(f"Smooth motion prepared with {len(self.trajectory)} waypoints")
            return True
            
        except Exception as e:
            print(f"Smooth motion preparation error: {e}")
            self.is_valid = False
            return False
    
    def execute_step(self, Position_in, Speed_out, Command_out, **kwargs):
        """Execute one step of the smooth motion"""
        if self.is_finished or not self.is_valid:
            return True
        
        # Check if required modules are available
        if PAROL6_ROBOT is None or solve_ik_with_adaptive_tol_subdivision is None:
            print("Error: Required PAROL6 modules not available")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Apply speed scaling
        step_increment = max(1, int(self.speed_factor))
        self.current_index += step_increment
        
        if self.current_index >= len(self.trajectory):
            print("Smooth motion completed")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Get current target pose
        target_pose = self.trajectory[self.current_index]
        
        # Convert to SE3
        target_se3 = SE3(target_pose[0]/1000, target_pose[1]/1000, target_pose[2]/1000) * \
                    SE3.RPY(target_pose[3:], unit='deg', order='xyz')
        
        # Get current joint configuration
        current_q = np.array([PAROL6_ROBOT.STEPS2RADS(p, i) 
                             for i, p in enumerate(Position_in)])
        
        # Solve IK
        ik_result = solve_ik_with_adaptive_tol_subdivision(
            PAROL6_ROBOT.robot, target_se3, current_q, ilimit=20
        )
        
        if not ik_result.success:
            print(f"IK failed at trajectory point {self.current_index}")
            self.is_finished = True
            Speed_out[:] = [0] * 6
            Command_out.value = 255
            return True
        
        # Convert to steps and send
        target_steps = [int(PAROL6_ROBOT.RAD2STEPS(q, i)) 
                       for i, q in enumerate(ik_result.q)]
        
        # Calculate velocities for smooth following
        for i in range(6):
            Speed_out[i] = int((target_steps[i] - Position_in[i]) * 10)  # P-control factor
        
        Command_out.value = 156  # Smooth motion command
        return False

# Helper functions for integration with robot_api.py

def execute_circle(center: List[float], 
                  radius: float, 
                  duration: float = 4.0,
                  normal: List[float] = [0, 0, 1]) -> str:
    """
    Execute a circular motion on PAROL6
    
    Args:
        center: Center point [x, y, z] in mm
        radius: Circle radius in mm
        duration: Time to complete circle
        normal: Normal vector to circle plane
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_circle_3d(center, radius, normal, 0, duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|CIRCLE|{traj_str}"
    
    return command

def execute_arc(start_pose: List[float],
               end_pose: List[float],
               center: List[float],
               clockwise: bool = True,
               duration: float = 2.0) -> str:
    """
    Execute an arc motion on PAROL6
    
    Args:
        start_pose: Starting pose [x, y, z, rx, ry, rz]
        end_pose: Ending pose [x, y, z, rx, ry, rz]
        center: Arc center point [x, y, z]
        clockwise: Direction of rotation
        duration: Time to complete arc
        
    Returns:
        Command string for robot_api
    """
    motion_gen = CircularMotion()
    trajectory = motion_gen.generate_arc_3d(start_pose, end_pose, center, 
                                           clockwise=clockwise, duration=duration)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|ARC|{traj_str}"
    
    return command

def execute_spline(waypoints: List[List[float]], 
                  total_time: Optional[float] = None) -> str:
    """
    Execute a spline motion through waypoints
    
    Args:
        waypoints: List of poses [x, y, z, rx, ry, rz]
        total_time: Total time for motion (auto-calculated if None)
        
    Returns:
        Command string for robot_api
    """
    motion_gen = SplineMotion()
    
    # Generate timestamps if total_time is provided
    timestamps = None
    if total_time:
        timestamps = np.linspace(0, total_time, len(waypoints))
    
    trajectory = motion_gen.generate_cubic_spline(waypoints, timestamps)
    
    # Convert to command string format
    traj_str = "|".join([",".join(map(str, pose)) for pose in trajectory])
    command = f"SMOOTH_MOTION|SPLINE|{traj_str}"
    
    return command

# Example usage
if __name__ == "__main__":
    # Example: Generate a circle trajectory
    circle_gen = CircularMotion()
    circle_traj = circle_gen.generate_circle_3d(
        center=[200, 0, 200],  # mm
        radius=50,  # mm
        duration=4.0  # seconds
    )
    print(f"Generated circle with {len(circle_traj)} points")
    
    # Example: Generate arc trajectory
    arc_traj = circle_gen.generate_arc_3d(
        start_pose=[250, 0, 200, 0, 0, 0],
        end_pose=[200, 50, 200, 0, 0, 90],
        center=[200, 0, 200],
        duration=2.0
    )
    print(f"Generated arc with {len(arc_traj)} points")
    
    # Example: Generate spline through waypoints
    spline_gen = SplineMotion()
    waypoints = [
        [200, 0, 100, 0, 0, 0],
        [250, 50, 150, 0, 15, 45],
        [200, 100, 200, 0, 30, 90],
        [150, 50, 150, 0, 15, 45],
        [200, 0, 100, 0, 0, 0]
    ]
    spline_traj = spline_gen.generate_cubic_spline(waypoints)
    print(f"Generated spline with {len(spline_traj)} points")
````
